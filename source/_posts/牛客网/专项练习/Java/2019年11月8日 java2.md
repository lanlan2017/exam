
# 题目1
Which is the return type of the method main()?
- A int
- B void
- C Boolean
- D static

正确答案: B

## 解析
```java
public static void main(String[] args){
}
```

# 题目2
子类A继承父类B, A a = new A(); 则父类B构造函数、父类B静态代码块、父类B非静态代码块、子类A构造函数、子类A静态代码块、子类A非静态代码块 执行的先后顺序是？
- A 父类Ｂ静态代码块->父类Ｂ构造函数->子类Ａ静态代码块->父类Ｂ非静态代码块->子类Ａ构造函数->子类Ａ非静态代码块
- B 父类Ｂ静态代码块->父类Ｂ构造函数->父类Ｂ非静态代码块->子类Ａ静态代码块->子类Ａ构造函数->子类Ａ非静态代码块
- C 父类Ｂ静态代码块->子类Ａ静态代码块->父类Ｂ非静态代码块->父类Ｂ构造函数->子类Ａ非静态代码块->子类Ａ构造函数
- D 父类Ｂ构造函数->父类Ｂ静态代码块->父类Ｂ非静态代码块->子类Ａ静态代码块->子类Ａ构造函数->子类Ａ非静态代码块

正确答案: C

## 解析
当实例化子类对象时，首先要加载父类的class文件进内存，静态代码块是随着类的创建而执行，所以父类静态代码块最先被执行，子类class文件再被加载，同理静态代码块被先执行；实例化子类对象要先调用父类的构造方法，而调用父类构造方法前会先执行父类的非静态代码块

# 题目3
有如下代码：请写出程序的输出结果。
```java
public class Test
{
    public static void main(String[] args)
    {
        int x = 0;
        int y = 0;
        int k = 0;
        for (int z = 0; z < 5; z++) { 
            if ((++x > 2) && (++y > 2) && (k++ > 2))
            {
                x++;
                ++y;
                k++;
            }
        }
        System.out.println(x + ”” +y + ”” +k);
    }
}
```
- A 432
- B 531
- C 421
- D 523

正确答案: B

## 解析
每次循环z,x,y,k对应数值为：
0,1,0,0
1,2,0,0
2,3,1,0
3,4,2,0
4,5,3,1
执行完这次以后，z++为5，不再进入for循环。



# 题目4
现有如下代码段：
```java
   x = 2;
   while(x<n/2) 
          x = 2*x;
```
假设n>=0，则其时间复杂度应为（   ）
- A O(log2(n))
- B O(nlog2(n))
- C O(n)
- D O(n^2)

正确答案: A

## 解析

x = 2;       ①
	   while(x<n/2)
x = 2*x;    ②
语句①的频度是1，设语句2的频度是f(n)，则2^f(n)<=n/2;f(n)<=log2(n/2)近似等于f(n)<=log2(n)，取最大值f(n)=log2(n),T(n)=O(log2(n))

# 题目5
下面关于垃圾收集的说法正确的是
- A 一旦一个对象成为垃圾，就立刻被收集掉。
- B 对象空间被收集掉之后，会执行该对象的finalize方法
- C finalize方法和C++的析构函数是完全一回事情
- D 一个对象成为垃圾是因为不再有引用指着它，但是线程并非如此

正确答案: D

## 解析
对象空间被收集**之前**执行finalize（）方法，而不是对象空间被收集之后再执行

# 题目6
```java
public void test() {
    int a = 10;
    System.out.println(a++ + a--);
}
```
最后输出什么？
- A 19
- B 20
- C 21
- D 22

正确答案: C

## 解析
- 先取值，后加一
- 先取值，后减一

# 题目7
哪个正确
- A abstract类只能用来派生子类，不能用来创建abstract类的对象。
- B final类不但可以用来派生子类，也可以用来创建final类的对象。
- C abstract不能与final同时修饰一个类。
- D abstract类定义中可以没有abstract方法。

正确答案: ACD

## 解析
1、abstract类不能用来创建abstract类的对象；
2、final类不能用来派生子类，因为用final修饰的类不能被继承；
3、如2所述，final不能与abstract同时修饰一个类，abstract类就是被用来继承的；
4、类中有abstract方法必须用abstract修饰，但abstract类中可以没有抽象方法，接口中也可以有abstract方法。
