---
title: 2019年11月9日 java2
categories: 
  - 牛客网
  - 专项练习
  - Java
---

# 题目1
下列说法正确的有（ ）
- A class中的constructor不可省略
- B constructor必须与class同名，但方法不能与class同名
- C constructor可在一个对象被new时执行
- D 一个class只能定义一个constructor

正确答案: C

## 解析
a. 类中的构造方法可以省略不写的
b. 构造方法必须跟类名相同，普通的类方法能与类同名的，但是要返回一个值。
c. 构造方法都在new 对象的时候调用的
d. 一个类可以定义多个构造方法的

# 题目2
```java
static String str0="0123456789";
static String str1="0123456789";
String str2=str1.substring(5);
String str3=new String(str2);
String str4=new String(str3.toCharArray());
str0=null;
```
假定str0,...,str4后序代码都是只读引用。
Java 7中，以上述代码为基础，在发生过一次FullGC后，上述代码在Heap空间（不包括PermGen）保留的字符数为（）
- A 5
- B 10
- C 15
- D 20

正确答案: C

## 解析

这是一个关于java的垃圾回收机制的题目。垃圾回收主要针对的是堆区的回收，因为栈区的内存是随着线程而释放的。堆区分为三个区：年轻代（Young
Generation）、年老代（Old Generation）、永久代（Permanent Generation，也就是方法区）。
 年轻代：对象被创建时（new）的对象通常被放在Young（除了一些占据内存比较大的对象）,经过一定的Minor
GC（针对年轻代的内存回收）还活着的对象会被移动到年老代（一些具体的移动细节省略）。
年老代：就是上述年轻代移动过来的和一些比较大的对象。Minor GC(FullGC)是针对年老代的回收
永久代：存储的是final常量，static变量，常量池。
str3,str4都是直接new的对象，而substring的源代码其实也是new一个string对象返回，如下图：
经过fullgc之后，年老区的内存回收，则年轻区的占了15个，不算PermGen。所以答案选C

垃圾回收机制这方面了解的比较少，有时间了解一下
# 题目3
运行代码，结果正确的是：
```java
Boolean flag = false;
if(flag = true){
    System.out.println("true");
}else{
    System.out.println("false");
}
```
- A 编译错误
- B TRUE
- C FALSE
- D 什么也没有输出

## 解析
<details markdown='1'><summary>展开/收起</summary>
正确答案: B

注意 if判断条件flag = true是**赋值语句**，返回true 不会执行else里面内容
</details>

# 题目4
从运行层面上来看，从四个选项选出不同的一个。
- A JAVA
- B Python
- C objectC
- D C#

## 解析
<details markdown='1'><summary>展开/收起</summary>
正确答案: B
A，C，D都是类C语言，B不是
Python是解释执行的，其他语言都需要先编译
</details>

# 题目5
有以下一个对象：
public class DataObject implements Serializable{
    private static int i=0;
    private String word=" ";
    public void setWord(String word){
        this.word=word;
    }
    public void setI(int i){
        Data0bject. i=I;
     }
}
创建一个如下方式的DataObject: 
DataObject object=new Data0bject ( );
object. setWord("123");
object. setI(2); 
将此对象序列化为文件，并在另外一个JVM中读取文件，进行反序列化，请问此时读出的Data0bject对象中的word和i的值分别为：
- A "", 0
- B "", 2
- C "123", 2
- D "123", 0

正确答案: D

## 解析
序列化保存的是**对象的状态**，静态变量属于**类的状态**，因此，**序列化并不保存静态变量**。所以i是没有改变的
**Java在序列化时不会实例化static变量和transient修饰的变量**，因为static代表类的成员，transient代表对象的临时数据，被声明这两种类型的数据成员不能被序列化

# 题目6
下面有关java threadlocal说法正确的有？
- A ThreadLocal存放的值是线程封闭，线程间互斥的，主要用于线程内共享一些数据，避免通过参数来传递
- B 线程的角度看，每个线程都保持一个对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收
- C 在Thread类中有一个Map，用于存储每一个线程的变量的副本。
- D 对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式

正确答案: ABCD

## 解析
**ThreadLocal类用来提供线程内部的`局部变量`**。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。
ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。 
可以总结为一句话：**ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度**。

ThreadLocal设计的初衷：提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。

### ThreadLocal的使用场景
数据库连接：在多线程中，如果使用懒汉式的单例模式创建Connection对象，由于该对象是共享的，那么必须要使用同步方法保证线程安全，这样当一个线程在连接数据库时，那么另外一个线程只能等待。这样就造成性能降低。
如果改为哪里要连接数据库就来进行连接，那么就会频繁的对数据库进行连接，性能还是不高。这时使用ThreadLocal就可以既可以保证线程安全又可以让性能不会太低。但是ThreadLocal的缺点时占用了较多的空间。
