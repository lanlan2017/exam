---
title: 2019年12月8日
categories: 
  - 牛客网
  - 专项练习
  - Java
  - 2019年12月
---

# 题目1
给定以下方法声明,调用执行mystery(1234)的输出结果？
```java
//precondition:  x >=0
public void mystery (int x){
    System.out.print(x % 10);
    if ((x / 10) != 0){
        mystery(x / 10);
    }
    System.out.print(x % 10);
}
```
- A 1441
- B 43211234
- C 3443
- D 12344321

## 解析
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

这个题目是考递归，总共调用了4次mystery方法，注意：程序是从上往下执行的，所以当一个方法，调用另一个或本方法时，程序会等调用完毕以后在接着执行
1.第一次调用mystery方法，此时参数（x）为1234,进入第四行，x不变为x=1234，1234%10=4,输出 4
2.接着进入if语句，1234/10=123 !=0,进入if语句，此时x还是1234,接着第二次调用mystery方法（此时第一次调用的方法不会继续执行，会等第二次（本次）调用的方法执行完毕后继续执行），mystery(x/10),传入的参数(x)为123,然后第四行123%10=3,参数还是不变为123，输出 3
3.接着进入if语句，第三次调用mystery()方法（此时第二次调用的方法不会继续执行，会等第三次（本次）调用的方法执行完毕后继续执行），传入参数为123/10=12, x=12,接着第四行12%10=2，传入的参数值不会变，输出 2
4.然后进入if语句12/10!=0,第四次调用mystery()方法（此时第三次调用的方法不会继续执行，会等第四次调用的方法（本次）执行完毕后继续执行），传入的参数（x=1）为1，进入第四行1%10，输出 1
5.然后进入if语句1/10=0不满足if语句x/10 != 0,所以本次不会继续调用mystery方法，然后程序继续执行调用下面的输出参数为1，1%10，输出 1
6.然后第四次调用的方法执行结束然后返回第三次调用的方法继续执行，调用下面的输出，参数为12,x%10=2，输出 2
7.然后第三次调用的方法执行结束然后返回第二次调用的方法继续执行，此时调用下面的输出，参数为123,x%10=3,输出 3
8.最后第二次调用的方法执行结束然后回第一次调用的方法继续执行，此时调用下面的输出，参数为1234,x%10=4,输出 4
9.第一次调用方法结束

# 题目2
HashMap的数据结构是怎样的？
- A 数组
- B 链表
- C 数组+链表
- D 二叉树

## 解析
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

HashMap 由数组+链表组成的，
数组是 HashMap 的主体，
链表则是主要为了解决哈希冲突而存在的
HashMap 底层的数据是数组被称为哈希桶（默认的初始值为 16 ），每个桶存放的是链表，链表中的每个节点，就是 HashMap 中的每个元素。
在 JDK 8 当链表长度大于等于 8 时，就会转成**红黑树**的数据结构，以提升查询和插入的效率。

# 题目3
JDK中提供的java、javac、jar等开发工具也是用Java编写的。
- A 对
- B 错

## 解析
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

`java`只有`jvm`是c语言和汇编写的，其他是`java`写的。

# 题目4
关于下面这段Java程序,哪些描述是正确的:( )
```java
public class ThreadTest extends Thread {
    public void run() {
        System.out.println("In run");
        yield();
        System.out.println("Leaving run");
    }
    public static void main(String []argv) {
        (new ThreadTest()).start();
    }
}
```
- A 程序运行输出只有`In run`
- B 程序运行输出只有`Leaving run`
- C 程序运行输出先有`In run`后有`Leaving run`
- D 程序运行输出先有`Leaving run`后有`In run`
- E 程序没有任何输出就退出了
- F 程序将被挂起,只能强制退出

## 解析
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

`Thread.yield()`方法作用是：暂停当前正在执行的线程对象，并执行其他线程。
`yield()`应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用`yield()`的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证`yield()`达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。
结论：`yield()`从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，`yield()`将导致线程从运行状态转到可运行状态，但有可能没有效果。

# 题目5
关于Java中的数组,下面的一些描述,哪些描述是准确的:(    )
- A 数组是一个对象,不同类型的数组具有不同的类
- B 数组长度是可以动态调整的
- C 数组是一个连续的存储结构
- D 一个固定长度的数组可类似这样定义: `int array[100]`
- E 两个数组用`equals`方法比较时,会逐个便利其中的元素,对每个元素进行比较
- F 可以二维数组,且可以有多维数组,都是在`Java`中合法的

## 解析
<details><summary>显示答案/隐藏答案</summary>正确答案: ACF</details>

- 数组是一种引用数据类型
- 数组继承Object类的所以里面有equals()方法
- 数组没有重写equals()方法， Object类的equals()方法比较的是地址
- 如果要比较两个数组中的内容,那么应该使用Arrays.equals()方法。


# 题目6
以下说法错误的是()
- A 其他选项均不正确
- B `java`线程类优先级相同
- C `Thread`和`Runnable`接口没有区别
- D 如果一个类继承了某个类,只能使用`Runnable`实现线程

## 解析
<details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details>

D选项错误，不是只能使用Runable实现线程实现线程的方式有：
- 继承Thread类，重写run()方法；
- 实现Runable接口，实现run()方法；
- 实现Callable接口，线程结束后有返回值。
