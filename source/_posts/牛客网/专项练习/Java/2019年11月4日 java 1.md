
# 题目1
在面向对象编程里，经常使用is-a来说明对象之间的继承关系，下列对象中不具备继承关系的是？（）
- A 手机与小米手机
- B 企业家与雷军
- C 编程语言与Java
- D 中国与北京

正确答案: D

## 解析
is-a 的关系：
A：小米手机是一个手机，没毛病
B：雷军是一个企业家，没毛病
C：Java是一门编程语言，没毛病
D：北京是不是一个中国

类之间存在以下几种常见的关系
- use-a 是依赖关系
- has-a   一般是组合关系
- is-a   一般是继承关系


# 题目2
下面关于垃圾收集的描述哪个是错误的？
- A 使用垃圾收集的程序不需要明确释放对象
- B 现代垃圾收集能够处理循环引用问题
- C 垃圾收集能提高程序员效率
- D 使用垃圾收集的语言没有内在泄漏问题

正确答案: D

## 解析
### 内存泄露
内存泄露(Memory Leak)是指**一个不再被使用的对象或者变量还在内存中占有存储空间**。
在C/C++语言中，内存泄露出现在开发人员忘记释放已分配的内存就会造成内存泄露。
在java语言中引入垃圾回收机制，有GC负责进行回收不再使用的对象，释放内存。但是还是会存在内存泄露的问题。
### 内存泄露主要有两种情况
1. 在堆中申请的空间没有释放。
2. 对象已不再被使用(注意：这里的不在被使用是指对程序来说没有用处，如数据库连接使用后没有关。但是还是存在着引用)，但是仍然在内存中保留着。GC机制的引入只能解决第一种情况，对于第2种情况无法保证不再使用的对象会被释放。java语言中的内存泄露主要指第2种情况。
### 内存泄露的原因
1. 静态集合类。如HashMap和Vector。这些容器是静态的，生命周期和程序的生命周期一致，那么在容器中对象的生命周期也和其一样，对象在程序结束之前将不能被释放，从而会造成内存泄露。
2. 各种连接，如数据库连接，网络连接，IO连接，不再使用时如果连接不释放容易造成内存泄露。
3. 监听器，释放对象时往往没有相应的删除监听器，可能会导致内存泄露。

### 内存溢出
内存溢出（OOM）是指程序在申请内存时没有足够的内存供使用，进而导致程序崩溃这是结果描述。

内存泄露（Memory Leak）最终会导致内存溢出。

### Java的内存分配策略
Java 程序运行时的内存分配策略有三种,分别是
**静态分配**,**栈式分配**,和**堆式分配**，对应的，
三种存储策略使用的内存空间主要分别是**静态存储区**（也称**方法区**）、**栈区**和**堆区**。

- **静态存储区（方法区）**：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。
- **栈区**：当方法被执行时，方法体内的局部变量（其中包括基础数据类型、对象的引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
- **堆区** ： 又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存，也就是对象的实例（包括该对象其中的所有成员变量）。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。

### Java中的内存管理
Java的内存管理就是对象的分配和释放问题。在 Java 中，程序员需要通过关键字 new 为每个对象申请内存空间 (基本类型除外)，所有的对象都在堆 (Heap)中分配空间。
### 关于提高效率
对象的释放是由 GC 决定和执行的。在 Java 中，内存的分配是由程序完成的，而内存的释放是由 GC 完成的，这种收支两条线的方法确实简化了程序员的工作。但同时，它也加重了JVM的工作。
### 关于消除循环引用
Java使用**有向图**的方式进行内存管理，可以消除引用循环的问题。
例如有三个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的。这种方式的优点是管理内存的精度很高，但是效率较低。
另外一种常用的内存管理技术是使用**计数器**。具体如下：gc清理时的引用计数方式：
当引用连接至新对象时，引用计数+1；
当某个引用离开作用域或被设置为null时，引用计数-1，
GC发现这个计数为0时，就回收其占用的内存。这个开销会在引用程序的整个生命周期发生，并且不能处理循环引用的情况。所以这种方式只是用来说明GC的工作方式，而不会被任何一种Java虚拟机应用。例如COM模型采用计数器方式管理构件，它与有向图相比，精度行低(很难处理循环引用的问题)，但执行效率很高。

### 什么是内存泄漏

在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，
- 首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；
- 其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。

有兴趣看引起内存泄漏的原因的可以参考这篇文章http://www.jb51.net/article/92311.htm

# 题目3
下面的输出结果是什么？
public class Demo {
  public static void main(String args[])
  {
    String str=new String("hello");
    if(str=="hello")
    {
      System.out.println("true");
    }      
    else     {
      System.out.println("false");
    }
  }
}
- A true
- B false

正确答案: B

## 解析
这种题烂大街

# 题目4
类方法中可以直接调用对象变量。（ ）
- A 正确
- B 错误

正确答案: B

## 解析
静态方法中不能调用对象的变量，因为静态方法在类加载时就初始化，对象变量需要在新建对象后才能使用

# 题目5
下列java程序的输出结果为____。
public class Example{
    String str=new String("hello");
    char[]ch={'a','b'};
    public static void main(String args[]){
        Example ex=new Example();
        ex.change(ex.str,ex.ch);
        System.out.print(ex.str+" and ");
        System.out.print(ex.ch);
    }
    public void change(String str,char ch[]){
        str="test ok";
        ch[0]='c';
    }
}
- A hello and ab
- B hello and cb
- C hello and a
- D test ok and ab
- E test ok and cb
- F test ok and c

正确答案: B

## 解析
java中只有值传递，改变形参的地址不影响到实参

# 题目6
类Parent和Child定义如下：
class  Parent{
       public  float  aFun(float a, float b) { }
}
class  Child  extends  Parent{
类Parent和Child定义如下：
```
1．class  Parent{
2 .         public  float  aFun(float a, float b) { }
3 ．}
4 ．class  Child  extends  Parent{
5 ．
6 ．}
```
将以下哪种方法插入行5是不合法的。（    ）
- A float aFun(float a, float b){ }
- B public int aFun(int a, int b) { }
- C public float aFun(float p, float q){ }
- D private int aFun(int a, int b){ }

正确答案: - A }
将以下哪种方法插入行5是不合法的。（    ）
- A float aFun(float a, float b){ }
- B public int aFun(int a, int b) { }
- C public float aFun(float p, float q){ }
- D private int aFun(int a, int b){ }

正确答案: A

## 解析
A.方法重写。子类方法不能缩小父类方法的访问权限，错误。
B.方法重载。参数列表不同，满足重载条件，正确。
C.方法重写。方法声明和父类相同，满足重写条件，正确。
D.方法重载。参数列表不同，满足重载条件，正确。

方法重写要遵循“两同两小一大”规则，
- “两同”即方法名相同、形参列表相同；
- “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；
- “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。
- 并且，覆盖方法和被覆盖方法要么都是类方法，要么都是实例方法，不能一个是类方法一个是实例方法。


# 题目7
下面哪几个函数 public void example(){....} 的重载函数？（）
- A public void example(int m){...}
- B public int example(){..}
- C public void example2(){..}
- D public int example(int m,float f){...}

正确答案: AD

## 解析
两同一不同:同一个类中，方法名相同，形参列表不同
方法重载只用关心两个点：
1.方法名相同
2.参数列表不同（个数不同、顺序不同、类型不同）


# 题目8
在Jdk1.7中，下述说法中抽象类与接口的区别与联系正确的有哪些？
- A 抽象类中可以有普通成员变量，接口中没有普通成员变量。
- B 抽象类和接口中都可以包含静态成员常量。
- C 一个类可以实现多个接口，但只能继承一个抽象类
- D 抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法。

正确答案: ABCD

## 解析

|特点|抽象类|接口|
|:--|:--|:--|
|构造方法|有|无|
|普通成员变量|有|无|
|普通方法|可以有非抽象的|必须是抽象的|
|抽象方法的访问类型|public、protected和默认|只能是public的，默认public abstract|
|静态方法|可以有|无|
|静态成员变量|有|有 public static final的|
|其他类|只能继承一个抽象类|可以实现多个接口|
|应用场景|模块之间通信契约|代码重用|


# 题目9
jdk1.8中，下面有关java 抽象类和接口的区别，说法错误的是？
- A 抽象类可以有构造方法，接口中不能有构造方法
- B 抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法
- C 一个类可以实现多个接口，但只能继承一个抽象类
- D 接口中可以有普通成员变量，抽象类中没有普通成员变量

正确答案: BD

## 解析
B 的后半句是错误的，java8在接口中允许有方法体，不过必须是静态方法；
接口中不能有普通成员变量，所以D错误


# 题目10
以下哪种JAVA得变量声明方式可以避免程序在多线程竞争情况下读到不正确的值(  )
- A volatile
- B static volatile
- C synchronized
- D static

正确答案: AB

## 解析
synchronized不是修饰变量的 它修饰方法或代码块或对象
