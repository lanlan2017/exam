<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/exam/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/exam/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/exam/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/exam/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_Sly-yzHYmALHXzjFpPWsodMrjBSphw7bfRbMUH80Qc">
  <meta name="msvalidate.01" content="B1CFD346B8DEBBFE0C983C2AF8955531">
  <meta name="baidu-site-verification" content="vkMTwK56xr">

<link rel="stylesheet" href="/exam/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lanlan2017.github.io","root":"/exam/","images":"/exam/images","scheme":"Gemini","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/exam/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/exam/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="蓝蓝的站点">
<meta property="og:url" content="https://lanlan2017.github.io/exam/page/4/index.html">
<meta property="og:site_name" content="蓝蓝的站点">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="蓝蓝">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lanlan2017.github.io/exam/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>蓝蓝的站点</title>
  

  <script src="/exam/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?dadeb188eb14ccde0b25a19230c429b5"></script>


<link rel="dns-prefetch" href="https://waline-test-mzjszagu6-lanlan2017.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/exam/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/exam/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">蓝蓝的站点</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">笔试题汇总</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/exam/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-dir"><a href="/exam/dir/" rel="section"><i class="fa fa-sitemap fa-fw"></i>目录</a></li>
        <li class="menu-item menu-item-categories"><a href="/exam/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/exam/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-tags"><a href="/exam/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="蓝蓝"
      src="/exam/images/avatar.png">
  <p class="site-author-name" itemprop="name">蓝蓝</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/exam/archives/">
          <span class="site-state-item-count">148</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/exam/categories/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/todo/" title="todo → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;todo&#x2F;"><i class="fa fa-check-square fa-fw"></i>todo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/links/" title="links → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;links&#x2F;"><i class="fa fa-link fa-fw"></i>links</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/exam/69f24af8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/exam/images/avatar.png">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝的站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/exam/69f24af8/" class="post-title-link" itemprop="url">2021年09月11日 java1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-11 22:06:05" itemprop="dateCreated datePublished" datetime="2021-09-11T22:06:05+08:00">2021-09-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-31 15:27:52" itemprop="dateModified" datetime="2021-12-31T15:27:52+08:00">2021-12-31</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">牛客网</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">专项练习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/Java/2021%E5%B9%B409%E6%9C%88/" itemprop="url" rel="index"><span itemprop="name">2021年09月</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/exam/69f24af8/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/exam/69f24af8/" data-xid="/exam/69f24af8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="考点1-抽象类和接口的区别"><a href="#考点1-抽象类和接口的区别" class="headerlink" title="考点1:抽象类和接口的区别"></a>考点1:抽象类和接口的区别</h1><p>下列对接口的说法，正确的是( )</p>
<ul>
<li>A 接口与抽象类是相同的概念</li>
<li>B 若要实现一个接口为普通类则必须实现接口的所有抽象方法</li>
<li>C 接口之间不能有继承关系</li>
<li>D 一个类只能实现一个接口</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>A 接口与抽象类是不同的概念。抽象类是用于捕捉子类的通用特性，接口是抽象方法的集合；<br>B 实现接口必须实现接口的所有方法；<br>C 接口可以继承一个或多个接口，抽象类只能继承一个类或者实现多个接口；<br>D 一个类只能继承一个类，但是可以实现多个接口。</p>
<p>自jdk8之后,实现类不必实现接口的所有方法!此题需要添加限制条件!!!!!因为jdk8之后为了引入steam(),增加了default关键字!<br>java8之后，对接口进行了增强，新增了default和static方法，这两种是不用子类去实现的</p>
<h1 id="考点2-HashSet"><a href="#考点2-HashSet" class="headerlink" title="考点2:HashSet"></a>考点2:HashSet</h1><p>有这样一段程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123; </span><br><span class="line">        List list=<span class="keyword">new</span> ArrayList(); </span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Set set=<span class="keyword">new</span> HashSet(); </span><br><span class="line">        set.add(<span class="string">&quot;a&quot;</span>); </span><br><span class="line">        set.add(<span class="string">&quot;b&quot;</span>); </span><br><span class="line">        set.add(<span class="string">&quot;a&quot;</span>); </span><br><span class="line">        System.out.println(list.size()+<span class="string">&quot;,&quot;</span>+set.size()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请问运行主要的程序会打印出的是什么（）</p>
<ul>
<li>A 2,2</li>
<li>B 2,3</li>
<li>C 3,2</li>
<li>D 3,3</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>list有序可重复，set无序不可重复</p>
<p>HashSet不能添加重复的元素，当调用add(Object)方法时候，<br>首先会调用Object的hashCode方法判hashCode是否已经存在，如不存在则直接插入元素；<br>如果已存在则调用Object对象的equals方法判断是否返回true， 如果为true则说明元素已经存在，如为false则插入元素</p>
<h1 id="考点3-字符串和整数的连接操作"><a href="#考点3-字符串和整数的连接操作" class="headerlink" title="考点3:字符串和整数的连接操作"></a>考点3:字符串和整数的连接操作</h1><p>下面这三条语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;is &quot;</span>+ <span class="number">100</span> + <span class="number">5</span>)；</span><br><span class="line">System.out.println(<span class="number">100</span> + <span class="number">5</span> +<span class="string">&quot; is&quot;</span>)；</span><br><span class="line">System.out.println(<span class="string">&quot;is &quot;</span>+ (<span class="number">100</span> + <span class="number">5</span>))；</span><br></pre></td></tr></table></figure>
<p>的输出结果分别是？ ( )</p>
<ul>
<li>A <code>is 1005, 1005 is, is 1005</code></li>
<li>B <code>is 105, 105 is, is 105</code></li>
<li>C <code>is 1005, 1005 is, is 105</code></li>
<li>D <code>is 1005, 105 is, is 105</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>1.”is”说明后面的内容都会被强制转换为string，所以是最后结果是拼接起来的<br>2.100+5先得到105，然后与is拼接<br>3.先算括号内的</p>
<p>在java中，“+” 和 “+=” 是经过重载的运算符，而java不允许程序员进行运算符的重载。<br>如果 “+”之前是String，那么此时，“+” 的作用就是连接两个字符串；<br>若此时 “+” 后面是基本数据类型的话，可以直接进行连接，若是引用数据类型的话，则会调用该对象的toString()方法。</p>
<p>关键看顺序<br>String先出现，则其后的int统一当作String来拼接<br>若两个int先出现，则int会先执行运算<br>如果有括号，括优先级高于运算符</p>
<h1 id="考点4-start方法才是启动线程"><a href="#考点4-start方法才是启动线程" class="headerlink" title="考点4:start方法才是启动线程"></a>考点4:start方法才是启动线程</h1><p>下面程序的运行结果是：（    ）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pong();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">t.run();</span><br><span class="line">System.out.print(<span class="string">&quot;ping&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.print(<span class="string">&quot;pong&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A pingpong</li>
<li>B pongping</li>
<li>C pingpong和pongping都有可能</li>
<li>D 都不输出</li>
<li>E pong</li>
<li>F ping</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>t.run是调用的Thead类中的run()方法，t.start才是执行线程，<br>所以这题就是执行普通run()方法，先输出pong，在输出ping。</p>
<h1 id="考点5-等价类-无效等价类"><a href="#考点5-等价类-无效等价类" class="headerlink" title="考点5:等价类 无效等价类"></a>考点5:等价类 无效等价类</h1><p>某程序要求每次输入只能是正整数，并且每次输入的数值要求必须是100的倍数且小于等于500，则下列哪个是正确的无效等价类(        )</p>
<ul>
<li>A （0，100）、（100，200）、（200，300）、（300，400）、（400，500）、（500，+∞）;</li>
<li>B （500，+∞）</li>
<li>C （500，+∞）、任意大于0小于500的非100倍数的整数；</li>
<li>D （-∞，100）、（100，200）、（200，300）、（300，400）、（400，500）、（500，+∞）;</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<p>无效等价类和有效等价类相反，即<strong>不满足程序输入要求或者无效的输入数据构成的集合</strong>。</p>
<h2 id="什么是有效等价类"><a href="#什么是有效等价类" class="headerlink" title="什么是有效等价类"></a>什么是有效等价类</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%97%A0%E6%95%88%E7%AD%89%E4%BB%B7%E7%B1%BB">https://baike.baidu.com/item/%E6%97%A0%E6%95%88%E7%AD%89%E4%BB%B7%E7%B1%BB</a><br>有效等价类指输入完全满足程序输入的规格说明，有效、有意义的输入数据所构成的集合。利用有效等价类可以检验程序是否满足规格说明所规定的功能和性能。 </p>
</blockquote>
<h2 id="什么是无效等价类"><a href="#什么是无效等价类" class="headerlink" title="什么是无效等价类"></a>什么是无效等价类</h2><p>无效等价类和有效等价类相反，即不满足程序输入要求或者无效的输入数据构成的集合。使用无效等价类，可以鉴别程序异常情况的处理。</p>
<p>在程序设计中，不但要保证所有有效地数据输入能产生正确的输出，同时需要保障在输入错误或者空输入的时候能有异常保护，这样的测试才能保证软件的可靠性。</p>
<p>等价类（满足条件的集合）：</p>
<p>$ {100,200,300,400,500}$​</p>
<p>无效等价类：</p>
<p>$(-\infty,100) \bigcup (100,200) \bigcup (200,300) \bigcup (300,400) \bigcup(400,500) \bigcup(500,+\infty)$</p>
<h1 id="考点6-对象流-序列化"><a href="#考点6-对象流-序列化" class="headerlink" title="考点6:对象流 序列化"></a>考点6:对象流 序列化</h1><p>以下关于对象序列化描述正确的是</p>
<ul>
<li>A 使用FileOutputStream可以将对象进行传输</li>
<li>B 使用PrintWriter可以将对象进行传输</li>
<li>C 使用transient修饰的变量不会被序列化</li>
<li>D 对象序列化的所属类需要实现Serializable接口</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: CD</details>

<p>使用ObjectOutputStream和ObjectInputStream可以将对象进行传输.<br>声明为static和transient类型的成员数据不能被串行化。<br>因为static代表类的状态， transient代表对象的临时数据。</p>
<h1 id="考点7-抽象类和接口的区别"><a href="#考点7-抽象类和接口的区别" class="headerlink" title="考点7:抽象类和接口的区别"></a>考点7:抽象类和接口的区别</h1><p>jdk1.8中，下面有关java 抽象类和接口的区别，说法错误的是？</p>
<ul>
<li>A 抽象类可以有构造方法，接口中不能有构造方法</li>
<li>B 抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法</li>
<li>C 一个类可以实现多个接口，但只能继承一个抽象类</li>
<li>D 接口中可以有普通成员变量，抽象类中没有普通成员变量</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: BD</details>

<ol>
<li>接口中不能有构造方法，抽象类中可以有。<ol>
<li>抽象类中构造方法作用：用于初始化抽象类的成员；</li>
<li><strong>抽象类的构造方法不能像普通类那样直接调用</strong>，抽象类的构造方法一般由为继承它的子类使用super调用，或者创建抽象类匿名内部类子类是调用。</li>
</ol>
</li>
<li>接口中方法默认是public abstract（只能是这两个关键字，或其中一个或都省略）</li>
<li>接口中的变量默认是public static final（只能是这三个关键字，或其中两个/一个或都省略）</li>
</ol>
<p>Ps : java中一个类只能继承一个类，但一个接口可以继承多个接口</p>
<h2 id="不能通过调用抽象类的构造器来创建对象"><a href="#不能通过调用抽象类的构造器来创建对象" class="headerlink" title="不能通过调用抽象类的构造器来创建对象"></a>不能通过调用抽象类的构造器来创建对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> base.abstractandinterface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">protected</span> String b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractTest</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractTest</span><span class="params">(<span class="keyword">int</span> a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">AbstractTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类的构造器</span></span><br><span class="line">        <span class="keyword">super</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类的构造器</span></span><br><span class="line">        <span class="keyword">super</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;int Class A ...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a + <span class="string">&quot;,b=&quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractTest abstractTest;</span><br><span class="line">        <span class="comment">// 抽象类不能直接调用构造器进行初始化</span></span><br><span class="line">        abstractTest = <span class="keyword">new</span> AbstractTest();</span><br><span class="line">        <span class="comment">// abstractTest = new AbstractTest(20, &quot;helloworld&quot;);</span></span><br><span class="line">        abstractTest = <span class="keyword">new</span> A(<span class="number">20</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">        abstractTest.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;AbstractTest&#x27; is abstract; cannot be instantiated</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">abstractTest = <span class="keyword">new</span> AbstractTest() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在匿名内部类方式实现的子类中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">abstractTest.show();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在匿名内部类方式实现的子类中</span><br></pre></td></tr></table></figure>

<h2 id="接口没有构造器"><a href="#接口没有构造器" class="headerlink" title="接口没有构造器"></a>接口没有构造器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InterfaceTest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>报错如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Not allowed in interface</span><br></pre></td></tr></table></figure>

<h1 id="考点8-Java基础知识"><a href="#考点8-Java基础知识" class="headerlink" title="考点8:Java基础知识"></a>考点8:Java基础知识</h1><p>下面有关Java的说法正确的是（    ）</p>
<ul>
<li>A 一个类可以实现多个接口</li>
<li>B 抽象类必须有抽象方法</li>
<li>C protected成员在子类可见性可以修改</li>
<li>D 通过super可以调用父类构造函数</li>
<li>E final的成员方法实现中只能读取类的成员变量</li>
<li>F String是不可修改的，且java运行环境中对string对象有一个对象池保存</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ACDF</details>

<p>解释一下c选项，意思是父类中的protected方法子类在重写的时候访问权限可以修改，其实就是重写的要素之一，换了个说法而已<br>抽象类可以不具有抽象方法! 抽象类可以不具有抽象方法! 抽象类可以不具有抽象方法! 重要的事情说三遍</p>
<h1 id="考点9-HttpServletRequest方法"><a href="#考点9-HttpServletRequest方法" class="headerlink" title="考点9:HttpServletRequest方法"></a>考点9:HttpServletRequest方法</h1><p>以下哪些方法可以取到http请求中的cookie值（）?</p>
<ul>
<li>A <code>request.getAttribute</code></li>
<li>B <code>request.getHeader</code></li>
<li>C <code>request.getParameter</code></li>
<li>D <code>request.getCookies</code><br>`<details><summary>显示答案/隐藏答案</summary>正确答案: BD</details></li>
</ul>
<p>下面的方法可用在 Servlet 程序中读取 HTTP 头。这些方法通过 HttpServletRequest 对象可用：</p>
<p> 1）Cookie[] getCookies()<br> 返回一个数组，包含客户端发送该请求的所有的 Cookie 对象。</p>
<p> 2）Object getAttribute(String name)<br> 以对象形式返回已命名属性的值，如果没有给定名称的属性存在，则返回 null。</p>
<p> 3）String getHeader(String name)<br> 以字符串形式返回指定的请求头的值。<strong>Cookie也是头的一种</strong>；</p>
<p> 4）String getParameter(String name)<br> 以字符串形式返回请求参数的值，或者如果参数不存在则返回 null。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/exam/863021c6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/exam/images/avatar.png">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝的站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/exam/863021c6/" class="post-title-link" itemprop="url">2021年09月10日 java1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-10 15:07:51" itemprop="dateCreated datePublished" datetime="2021-09-10T15:07:51+08:00">2021-09-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-26 20:11:41" itemprop="dateModified" datetime="2021-12-26T20:11:41+08:00">2021-12-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">牛客网</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">专项练习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/Java/2021%E5%B9%B409%E6%9C%88/" itemprop="url" rel="index"><span itemprop="name">2021年09月</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/exam/863021c6/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/exam/863021c6/" data-xid="/exam/863021c6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="考点1-HashMap源码"><a href="#考点1-HashMap源码" class="headerlink" title="考点1:HashMap源码"></a>考点1:HashMap源码</h1><p>HashMap的数据结构是怎样的？</p>
<ul>
<li>A 数组</li>
<li>B 链表</li>
<li>C 数组+链表</li>
<li>D 二叉树</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的<br>JDK8及其以后版本，HashMap的数据结构是数组+链表+红黑树</p>
<p>HashMap内部包含了一个默认大小为 16 Entry 类型的数组 table,其中每个Entry 是一个链表，当链表长度大于等于 8 时会将链表转换为红黑树。</p>
<h2 id="JDK1-7中HashMap存储结构"><a href="#JDK1-7中HashMap存储结构" class="headerlink" title="JDK1.7中HashMap存储结构"></a>JDK1.7中HashMap存储结构</h2><p>jdk1.7 中使用个 Entry 数组来存储数据，用key的 hashcode 取模来决定key会被放到数组里的位置，如果 hashcode 相同，或者 hashcode 取模后的结果相同（ hash collision ），那么这些 key 会被定位到 Entry 数组的同一个格子里，这些 key 会形成一个链表。在 hashcode 特别差的情况下，比方说所有key的 hashcode 都相同，这个链表可能会很长，那么 put/get 操作都可能需要遍历这个链表，也就是说时间复杂度在最差情况下会退化到 O(n)</p>
<h2 id="JDK1-8中HashMap存储结构"><a href="#JDK1-8中HashMap存储结构" class="headerlink" title="JDK1.8中HashMap存储结构"></a>JDK1.8中HashMap存储结构</h2><p>jdk1.8 中使用一个 Node 数组来存储数据，但这个 Node 可能是链表结构，也可能是红黑树结构，如果插入的 key 的 hashcode 相同，那么这些key也会被定位到 Node 数组的同个格子里。如果同一个格子里的key不超过8个，使用链表结构存储。如果超过了8个，那么会调用 treeifyBin 函数，将链表转换为红黑树。那么即使 hashcode 完全相同，由于红黑树的特点，查找某个特定元素，也只需要O(log n)的开销也就是说put/get的操作的时间复杂度最差只有 O(log n)，但是真正想要利用 JDK1.8 的好处，有一个限制：key的对象，必须正确的实现了 Compare 接口</p>
<p>HashMap在Node数组中进行哈希查找,<br>使用链接法处理冲突,<br>冲突较少时使用链表,<br>目前版本当冲突的键达到8时,<br>会把链表转换为红黑树.</p>
<p>1、HashMap 底层的数据是数组被成为哈希桶（默认的初始值为 16 ），每个桶存放的是链表，链表中的每个节点，就是 HashMap 中的每个元素。<br>2、在 JDK 8 当链表长度大于等于 8 时，就会转成红黑树的数据结构，以提升查询和插入的效率。</p>
<h1 id="考点2-不用编码的java文件编译命令-javac-encoding"><a href="#考点2-不用编码的java文件编译命令-javac-encoding" class="headerlink" title="考点2:不用编码的java文件编译命令 javac -encoding"></a>考点2:不用编码的java文件编译命令 javac -encoding</h1><p>语句：<code>char foo=&#39;中&#39;</code>，是否正确？（假设源文件以GB2312编码存储，并且以<code>javac -encoding GB2312</code>命令编译）</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> base.ecoding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> foo=<span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">        System.out.println(foo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个应该和系统的编码有关，保存为GB2312时，直接使用<code>javac -d . Test.java</code>可以正常编译，因为我的Windows简体中文系统使用的是GBK编码。<br>所以可以正常编译，但是如果把上面的文件保存为UTF-8编码，再次使用<code>javac -d . Test.java</code>就无法编译，报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PS G:\dev2\idea_workspace\MyJavaTools\RunableTools\src\base\ecoding&gt; javac -d . .\Test.java</span><br><span class="line">.\Test.java:5: 错误: 编码 GBK 的不可映射字符 (0xAD)</span><br><span class="line">        char foo=&#x27;涓?&#x27;;</span><br><span class="line">                   ^</span><br><span class="line">.\Test.java:5: 错误: 未结束的字符文字</span><br><span class="line">        char foo=&#x27;涓?&#x27;;</span><br><span class="line">                 ^</span><br><span class="line">.\Test.java:5: 错误: 未结束的字符文字</span><br><span class="line">        char foo=&#x27;涓?&#x27;;</span><br><span class="line">                    ^</span><br><span class="line">3 个错误</span><br><span class="line">PS G:\dev2\idea_workspace\MyJavaTools\RunableTools\src\base\ecoding&gt;</span><br></pre></td></tr></table></figure>
<p>正确的编译命令为：<code>javac -d . -encoding UTF-8 .\Test.java</code>，运行也是正常的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS G:\dev2\idea_workspace\MyJavaTools\RunableTools\src\base\ecoding&gt; javac -d . -encoding UTF-8 .\Test.java</span><br><span class="line">PS G:\dev2\idea_workspace\MyJavaTools\RunableTools\src\base\ecoding&gt; java base.ecoding.Test</span><br><span class="line">中</span><br><span class="line">PS G:\dev2\idea_workspace\MyJavaTools\RunableTools\src\base\ecoding&gt;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>编译java文件时，如果不指定编码时，javac会使用默认的编码，也就是操作系统的编码，如果操作系统的编码和java文件的编码不一致时，就会编译错误。</p>
<p>所以使用javac编译时，都指定文件的编码，这样就不会失败。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -encoding 文件编码 xxx.java</span><br></pre></td></tr></table></figure>
<p>即使java文件的编码和操作系统的相同，也指定编码。因为这样必然会成功。</p>
<h1 id="考点3-异常处理-运行时异常非运行时异常"><a href="#考点3-异常处理-运行时异常非运行时异常" class="headerlink" title="考点3:异常处理 运行时异常非运行时异常"></a>考点3:异常处理 运行时异常非运行时异常</h1><p>下列关于异常处理的描述中，错误的是()。</p>
<ul>
<li>A 程序运行时异常由<code>Java</code>虚拟机自动进行处理</li>
<li>B 使用<code>try-catch-finally</code>语句捕获异常</li>
<li>C 可使用<code>throw</code>语句抛出异常</li>
<li>D 捕获到的异常只能在当前方法中处理，不能在其他方法中处理</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h2 id="运行时异常不需要显示处理"><a href="#运行时异常不需要显示处理" class="headerlink" title="运行时异常不需要显示处理"></a>运行时异常不需要显示处理</h2><p>运行时异常可以不处理。当出现这样的异常时，总是由虚拟机接管。<br>比如我们从来没有人去处理过NullPointerException异常，它就是运行时异常，并且这种异常还是最常见的异常之一。<br>出现运行时异常后，系统会把异常一直往上层抛，一直遇到处理代码。如果没有处理块，到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。<br>抛出之后，如果是线程，这个线程也就退出了。<br>如果是主程序抛出的异常，整个程序也就退出了。<br>运行时异常是Exception的子类，也有一般异常的特点，是可以被Catch块处理的。只不过往往不对它处理罢了。<br>也就是说，如果不对运行时异常进行处理，那么出现运行时异常之后，要么是线程中止，要么是主程序终止。</p>
<h2 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h2><p>C：throw关键字：语句抛出异常  throws关键字：声明异常（方法抛出一个异常）</p>
<p>1.编译时异常必须显示处理，运行时异常交给虚拟机自行处理。</p>
<h1 id="考点4-HashMap源码"><a href="#考点4-HashMap源码" class="headerlink" title="考点4:HashMap源码"></a>考点4:HashMap源码</h1><p>下面有关java hashmap的说法错误的是？</p>
<ul>
<li>A HashMap的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。</li>
<li>B HashMap的实现不是同步的，意味着它不是线程安全的</li>
<li>C HashMap通过开放地址法解决哈希冲突</li>
<li>D HashMap中的key-value都是存储在Entry数组中的</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h2 id="Java8之前HashMap使用链地址法"><a href="#Java8之前HashMap使用链地址法" class="headerlink" title="Java8之前HashMap使用链地址法"></a>Java8之前HashMap使用链地址法</h2><p>1.在Java 8 之前，HashMap和其他基于map的类都是通过<strong>链地址法解决冲突</strong>，它们使用单向链表来存储相同索引值的元素。在最坏的情况下，这种方式会将HashMap的get方法的性能从O(1)降低到O(n)。</p>
<h2 id="Java8-HashMap"><a href="#Java8-HashMap" class="headerlink" title="Java8 HashMap"></a>Java8 HashMap</h2><p>为了解决在频繁冲突时hashmap性能降低的问题，<strong>Java 8中使用平衡树来替代链表存储冲突的元素</strong>。这意味着我们可以将最坏情况下的性能从O(n)提高到O(logn)。</p>
<p>在Java 8中使用常量TREEIFY_THRESHOLD来控制是否切换到平衡树来存储。HashMap一开始使用链表，并在冲突的元素数量超过TREEIFY_THRESHOLD时用平衡二叉树替换链表。目前，这个常量值是8。</p>
<p>不过这一特性在所有基于hash table的类中并没有，例如Hashtable和WeakHashMap。</p>
<h2 id="1-关于HashMap的一些说法："><a href="#1-关于HashMap的一些说法：" class="headerlink" title="1. 关于HashMap的一些说法："></a>1. 关于HashMap的一些说法：</h2><p>a) HashMap实际上是一个“<strong>链表散列</strong>”的数据结构，即数组和链表的结合体。HashMap的底层结构是一个数组，数组中的每一项是一条链表。<br>b) HashMap的实例有俩个参数影响其性能： “<strong>初始容量</strong>” 和 <strong>装填因子</strong>。<br>c) HashMap实现不同步，<strong>线程不安全</strong>。 HashTable线程安全<br>d) HashMap中的key-value都是存储在<strong>Entry</strong>中的。<br>e) HashMap<strong>可以存</strong>null键和null值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode()方法和equals()方法保证键的唯一性</p>
<h2 id="解决冲突的三种方法"><a href="#解决冲突的三种方法" class="headerlink" title="解决冲突的三种方法"></a>解决冲突的三种方法</h2><p>f) 解决冲突主要有<strong>三种</strong>方法：<strong>定址法，拉链法，再散列法</strong>。<br>HashMap是采用<strong>拉链法</strong>解决哈希冲突的。 注： 链表法是将相同hash值的对象组成一个链表放在hash值对应的槽位；</p>
<h3 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h3><p>用<strong>开放定址法</strong>解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。 沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。</p>
<h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p><strong>拉链法</strong>解决冲突的做法是： 将所有关键字为同义词的结点链接在同一个单链表中 。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。拉链法适合未规定元素的大小。</p>
<h2 id="2-Hashtable和HashMap的区别："><a href="#2-Hashtable和HashMap的区别：" class="headerlink" title="2. Hashtable和HashMap的区别："></a>2. Hashtable和HashMap的区别：</h2><h3 id="a-继承不同"><a href="#a-继承不同" class="headerlink" title="a) 继承不同"></a>a) 继承不同</h3><pre>
    public class Hashtable extends <mark>Dictionary</mark> implements Map
    public class HashMap extends <mark>AbstractMap</mark> implements Map
</pre>

<h3 id="b-线程安全不同"><a href="#b-线程安全不同" class="headerlink" title="b) 线程安全不同"></a>b) 线程安全不同</h3><p>Hashtable中的方法是同步的，<br>而HashMap中的方法在缺省情况下是非同步的。</p>
<p>在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。</p>
<h3 id="c-key和value能有null不同"><a href="#c-key和value能有null不同" class="headerlink" title="c) key和value能有null不同"></a>c) key和value能有null不同</h3><p>Hashtable中，key和value都不允许出现null值。<br>在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示HashMap中没有该键，也可以表示该键所对应的值为null。</p>
<p>因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键，而应该用containsKey()方法来判断。</p>
<h3 id="d-遍历方式不同"><a href="#d-遍历方式不同" class="headerlink" title="d) 遍历方式不同"></a>d) 遍历方式不同</h3><p>两个遍历方式的<strong>内部实现上不同</strong>。Hashtable、HashMap都使用了Iterator。<br>而由于历史原因，Hashtable还使用了Enumeration的方式 。</p>
<h3 id="e-哈希值的使用不同"><a href="#e-哈希值的使用不同" class="headerlink" title="e) 哈希值的使用不同"></a>e) 哈希值的使用不同</h3><p><strong>哈希值的使用不同</strong>，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</p>
<h3 id="f-内部实现方式的数组的初始大小和扩容的方式。"><a href="#f-内部实现方式的数组的初始大小和扩容的方式。" class="headerlink" title="f) 内部实现方式的数组的初始大小和扩容的方式。"></a>f) 内部实现方式的数组的初始大小和扩容的方式。</h3><p>Hashtable中hash数组默认大小是11，<br>增加的方式是old*2+1。</p>
<p>HashMap中hash数组的默认大小是16，而且一定是2的指数。 </p>
<h4 id="HashMap有子类HashSet"><a href="#HashMap有子类HashSet" class="headerlink" title="HashMap有子类HashSet"></a>HashMap有子类HashSet</h4><p>注： HashSet子类依靠hashCode()和equal()方法来区分重复元素。</p>
<p>HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，<strong>这也是HashSet中元素不能重复的原因</strong>。而Map中保存key值的,会去判断当前Map中是否含有该Key对象，内部是先通过key的hashCode,确定有相同的hashCode之后，再通过equals方法判断是否相同。</p>
<h1 id="考点5-HashMap源码"><a href="#考点5-HashMap源码" class="headerlink" title="考点5:HashMap源码"></a>考点5:HashMap源码</h1><p>在Java中，关于HashMap类的描述，以下正确的是 ()</p>
<ul>
<li>A HashMap使用键/值得形式保存数据</li>
<li>B HashMap能够保证其中元素的顺序</li>
<li>C HashMap允许将null用作键</li>
<li>D HashMap允许将null用作值</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details>


<table>
<thead>
<tr>
<th align="left">Map集合类</th>
<th align="left">key</th>
<th align="left">value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HashMap</td>
<td align="left">允许为null</td>
<td align="left">允许为null</td>
</tr>
<tr>
<td align="left">TreeMap</td>
<td align="left">不允许为null</td>
<td align="left">允许为null</td>
</tr>
<tr>
<td align="left">ConcurrentMap</td>
<td align="left">不允许为null</td>
<td align="left">不允许为null</td>
</tr>
<tr>
<td align="left">Hashtable</td>
<td align="left">不允许为null</td>
<td align="left">不允许为null</td>
</tr>
</tbody></table>
<p>HashMap 不按插入顺序排序，按照哈希值排序。所以无序。<br>但是不增删改键的情况下，输出是按照一定顺序不变的</p>
<p>HashMap允许一个key为null，多个value为null，而Hashtable不允许有null值</p>
<p>我们常说的Map是无序的，其实这里的描述是不清楚的，我们所说的无序通常是指HashMap无序，因为TreeMap按自然顺序排序，LinkedHashMap按添加元素顺序排序</p>
<h1 id="考点6-常见final类"><a href="#考点6-常见final类" class="headerlink" title="考点6:常见final类"></a>考点6:常见final类</h1><p>下面哪些类可以被继承？ Java.lang.Thread、java.lang.Number、java.lang.Double、java.lang.Math、 java.lang.ClassLoader</p>
<ul>
<li>A Thread</li>
<li>B Number</li>
<li>C Double</li>
<li>D Math</li>
<li>E ClassLoader</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABE</details>

<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>Thread可以被继承，用于创建新的线程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Thread extends Object implements Runnable</span><br></pre></td></tr></table></figure>

<h2 id="Number是抽象类，可以被继承"><a href="#Number是抽象类，可以被继承" class="headerlink" title="Number是抽象类，可以被继承"></a>Number是抽象类，可以被继承</h2><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Number.html">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Number.html</a></p>
<pre>
public abstract class Numberextends Object implements Serializable
</pre>

<blockquote>
<p>Direct Known Subclasses:<br>AtomicInteger, AtomicLong, BigDecimal, BigInteger, <strong>Byte</strong>, <strong>Double</strong>, DoubleAccumulator, DoubleAdder, <strong>Float</strong>, <strong>Integer</strong>, <strong>Long</strong>, LongAccumulator, LongAdder, Short</p>
</blockquote>
<p>Number类可以被继承，Integer，Float，Double等都继承自Number类</p>
<h2 id="包装类是final修饰的，无法继承"><a href="#包装类是final修饰的，无法继承" class="headerlink" title="包装类是final修饰的，无法继承"></a>包装类是final修饰的，无法继承</h2><pre>
public <mark>final</mark> class Double extends Number implements Comparable&lt;Double&gt;
</pre>

<h2 id="Math类是final类"><a href="#Math类是final类" class="headerlink" title="Math类是final类"></a>Math类是final类</h2><p>Math类的声明为</p>
<pre>
public <mark>final</mark> class Mathextends Object
</pre>

<h2 id="ClassLoader是抽象类"><a href="#ClassLoader是抽象类" class="headerlink" title="ClassLoader是抽象类"></a>ClassLoader是抽象类</h2><p>ClassLoader可以被继承，用户可以自定义类加载器</p>
<pre>
public <mark>abstract</mark> class ClassLoader extends Object
</pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/exam/cd60ef48/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/exam/images/avatar.png">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝的站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/exam/cd60ef48/" class="post-title-link" itemprop="url">2021年09月08日 java2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-08 19:14:58" itemprop="dateCreated datePublished" datetime="2021-09-08T19:14:58+08:00">2021-09-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-26 20:11:41" itemprop="dateModified" datetime="2021-12-26T20:11:41+08:00">2021-12-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">牛客网</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">专项练习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/Java/2021%E5%B9%B409%E6%9C%88/" itemprop="url" rel="index"><span itemprop="name">2021年09月</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/exam/cd60ef48/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/exam/cd60ef48/" data-xid="/exam/cd60ef48/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="考点1-Java标识符"><a href="#考点1-Java标识符" class="headerlink" title="考点1:Java标识符"></a>考点1:Java标识符</h1><p>在JAVA中， 下列标识符合法的是（）</p>
<ul>
<li>A 3kyou</li>
<li>B @163</li>
<li>C name</li>
<li>D while</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h2 id="Java中标识符规则"><a href="#Java中标识符规则" class="headerlink" title="Java中标识符规则"></a>Java中标识符规则</h2><ul>
<li>由<strong>字母</strong>、<strong>数字</strong>、<code>美元符号$</code>、**下划线_**4种组成，</li>
<li>不能以数字开头，</li>
<li>不能是保留字和关键字</li>
<li>不能是true,false,null等引用常量</li>
</ul>
<h2 id="C语言标识符规则"><a href="#C语言标识符规则" class="headerlink" title="C语言标识符规则"></a>C语言标识符规则</h2><ul>
<li>标识符由字母（A-Z，a-z）、数字（0-9）、下划线“_”组成，</li>
<li>首字符不能是数字，但可以是字母或者下划线</li>
<li>不能是保留字和关键字</li>
</ul>
<p>Java标识符字符构成比C语言的多了一个美元符$</p>
<h1 id="考点2-java常识-局部变量-成员变量"><a href="#考点2-java常识-局部变量-成员变量" class="headerlink" title="考点2:java常识 局部变量 成员变量"></a>考点2:java常识 局部变量 成员变量</h1><p>局部变量能否和成员变量重名？</p>
<ul>
<li>A 可以，局部变量可以与成员变量重名，这时可用“this”来指向成员变量</li>
<li>B 可以，这时可用“local”关键字来指向局部变量</li>
<li>C 不能，局部变量不能与成员变量重名</li>
<li>D 不能，在一个类中不能有重名变量，不管是成员变量还是函数中的局部变量</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h2 id="java访问变量采用就近原则"><a href="#java访问变量采用就近原则" class="headerlink" title="java访问变量采用就近原则"></a>java访问变量采用就近原则</h2><p>JAVA访问变量采用就近原则，局部变量与成员变量重名时，局部变量比较近，使用局部变量。</p>
<p>java采用局部优先的思想。局部变量可以和成员变量相同，使用标识符调用时，优先使用局部变量。在实例方法中出现变量名相同时，可以使用this关键字来调用实例变量。</p>
<h1 id="考点3-Java常识"><a href="#考点3-Java常识" class="headerlink" title="考点3:Java常识"></a>考点3:Java常识</h1><p>有以下程序片段且Interesting不是内部类，下列哪个选项不能插入到行1。（    ）</p>
<pre>
1.
2. public class Interesting{
3. // 省略代码
4. }
</pre>

<ul>
<li>A import java.awt.*;</li>
<li>B package mypackage;</li>
<li>C class OtherClass{ }</li>
<li>D public class MyClass{ }</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h2 id="一个-java文件中只能有一个public外部类"><a href="#一个-java文件中只能有一个public外部类" class="headerlink" title="一个.java文件中只能有一个public外部类"></a>一个.java文件中只能有一个public外部类</h2><p>在同一个java原文件中，可以有多个class类，但是只有有一个公共的 public class</p>
<p>一个.java文件中，可以有多个类，包括内部类和外部类。</p>
<p>考虑到内部类的原因，一个.java文件可以中可以有多个public类。</p>
<p><strong>但是对于<code>外部类</code>而言，一个.java文件必须只能有一个public类，同时这个类的类名必须和.java的文件名一致（包括大小写）</strong>。</p>
<h1 id="考点4-内存泄漏"><a href="#考点4-内存泄漏" class="headerlink" title="考点4:内存泄漏"></a>考点4:内存泄漏</h1><p>java程序内存泄露的最直接表现是（ ）</p>
<ul>
<li>A 频繁FullGc</li>
<li>B jvm崩溃</li>
<li>C 程序抛内存控制的Exception</li>
<li>D java进程异常消失</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>java是自动管理内存的，通常情况下程序运行到稳定状态，内存大小也达到一个 基本稳定的值<br>但是内存泄露导致Gc不能回收泄露的垃圾，内存不断变大.<br>最终超出内存界限，抛出OutOfMemoryExpection。</p>
<p>答案 C，依次解释一下相关选项</p>
<h2 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h2><p>首先理解一下内存泄漏的概念，<strong>内存泄漏就是对象引用消失了，对象内存却没有被回收</strong>。</p>
<p>A 答案：FullGC 是老年代内存空间不足的时候，才会触发的，老年代一般是生命周期较长的对象或者大对象，频繁的 FullGC不会可能会影响程序性能（因为内存回收需要消耗CPU等资源），但是并不会直接导致内存泄漏。<br>B 答案：JVM奔溃的可能是内存溢出引起的，也可能是其他操作导致JVM崩溃，例如设置了错误的JVM参数等。<br>C 答案：内存异常，最常见的 就是 StackOverFlow了把，内存溢出，<strong>其实内存泄漏的最终结果就是内存溢出</strong>。所以，基本上C是对的答案。<br>D 答案：Java 进程异常消失，这个明显不对的。</p>
<p>题目有问题:<br>“程序抛内存控制的Exception”<br><strong>java只有OutOfMemoryError</strong>，是Error。<br>java没有OutOfMemoryException。<br>C#倒是有OutOfMemoryException。</p>
<h1 id="考点5-Java关键字-Java非法标识符"><a href="#考点5-Java关键字-Java非法标识符" class="headerlink" title="考点5:Java关键字 Java非法标识符"></a>考点5:Java关键字 Java非法标识符</h1><p>以下为 java 语法保留不能作为类名和方法名使用的是</p>
<ul>
<li>A default</li>
<li>B int</li>
<li>C implements</li>
<li>D throws</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>

<p>Java8关键字default也被使用了，所以正确答案应该全选<br>implements《注意有s结尾》是java实现接口的关键字，而implement则是普通单词，<br>default是保留字，<br>throws是抛出异常的关键字，所以正确答案是ABD</p>
<h1 id="考点6-Java常见数据类型"><a href="#考点6-Java常见数据类型" class="headerlink" title="考点6:Java常见数据类型"></a>考点6:Java常见数据类型</h1><p><code>int，String，*point，union</code>哪些不是 Java 的数据类型？</p>
<ul>
<li>A <code>int</code></li>
<li>B <code>String</code></li>
<li>C <code>*point</code></li>
<li>D <code>union</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: CD</details>

<p>*point是指针，java中没有这种类型<br>union是C系的类型，java中没有</p>
<h1 id="考点7-栈"><a href="#考点7-栈" class="headerlink" title="考点7:栈"></a>考点7:栈</h1><p>如果进栈序列为e1，e2，e3，e4，则可能的出栈序列是()<br>注：一个元素进栈后可以马上出栈，不用等全部进栈</p>
<ul>
<li>A e3，e1，e4，e2</li>
<li>B e2，e4，e3，e1</li>
<li>C e2，e3，e4，e1</li>
<li>D 任意顺序都有可能</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<p>A选项e3先出栈。那么e1,e2,e3进栈，e3出栈，如果e1想要出栈必须要e2先出栈，所以A是不可能的。</p>
<p>B选项<br>    入栈顺序：e1进，e2进去又出来，e3进，e4进<br>    出栈：e2、e4、e3、e1<br>C选项<br>    入栈顺序：e1进，e2进去又出来，e3进去又出来，e4进<br>    出栈：e2、e3、e4、e1</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/exam/5469bef2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/exam/images/avatar.png">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝的站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/exam/5469bef2/" class="post-title-link" itemprop="url">2021年09月08日 java1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-08 09:26:50" itemprop="dateCreated datePublished" datetime="2021-09-08T09:26:50+08:00">2021-09-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-26 20:11:41" itemprop="dateModified" datetime="2021-12-26T20:11:41+08:00">2021-12-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">牛客网</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">专项练习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/Java/2021%E5%B9%B409%E6%9C%88/" itemprop="url" rel="index"><span itemprop="name">2021年09月</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/exam/5469bef2/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/exam/5469bef2/" data-xid="/exam/5469bef2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="考点1-Java常识"><a href="#考点1-Java常识" class="headerlink" title="考点1:Java常识"></a>考点1:Java常识</h1><p>以下关于构造函数的描述错误的是 （ ）</p>
<ul>
<li>A 每个类有且只能有一个构造函数。</li>
<li>B 构造函数是类的一种特殊函数，它的方法名必须与类名相同</li>
<li>C 构造函数的主要作用是完成对类的对象的初始化工作</li>
<li>D 一般在创建新对象时，系统会自动调用构造函数</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h1 id="考点2-异常"><a href="#考点2-异常" class="headerlink" title="考点2:异常"></a>考点2:异常</h1><p>代码<code>String str=”123456a”；int i=Integer.parseInt(str);</code>会报异常的是（）</p>
<ul>
<li>A <code>java.lang.NullPoninterException</code></li>
<li>B <code>java.lang.NumberFormatException</code></li>
<li>C <code>java.lang.RuntimeException</code></li>
<li>D <code>java.lang.ArrayindexOutOfBoundsException</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p><code>java.lang.NullPoninterException</code>：变量未被初始化、对象未赋值、对象为空（俗称的空指针异常）<br><code>java.lang.NumberFormatException</code>：数据格式转换失败（<code>integer</code>的取值范围为：-127-128，超过范围都会访问<code>false</code>）<br><code>java.lang.RuntimeException</code>：运行时异常<br><code>java.lang.ArrayindexOutOfBoundsException</code>：数组下标越界</p>
<h1 id="考点3-常识"><a href="#考点3-常识" class="headerlink" title="考点3:常识"></a>考点3:常识</h1><p>下列关于Java类中方法的定义，正确的是（）</p>
<ul>
<li>A 若代码执行到return语句，则将当前值返回，而且继续执行return语句后面的语句。</li>
<li>B 只需要对使用基本数据类型定义的属性使用getter和setter，体现类的封装性。</li>
<li>C 方法的返回值只能是基本数据类型。</li>
<li>D 在同一个类中定义的方法，允许方法名称相同而形参列表不同。</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p><strong>选D</strong><br><strong>A、一旦执行到return，就不再执行后续的代码。</strong><br><strong>B、类的封装性可不是这么体现的，数据域和方法都可以被封装。数据域可以是基本数据类型也可以是引用类型。</strong><br><strong>C、方法的返回值可以是引用类型。</strong><br><strong>D、这是重载，同一个类中，方法名相同，形参列表不同。</strong></p>
<h2 id="封装是通过访问控制符实现的"><a href="#封装是通过访问控制符实现的" class="headerlink" title="封装是通过访问控制符实现的"></a>封装是通过访问控制符实现的</h2><p><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-encapsulation.html">https://www.runoob.com/java/java-encapsulation.html</a></p>
<p>封装性仅仅有get，set方法是不够的，要是成员变量是public的，那么外界就可以随意访问该成员变量。<br>所以封装要求 成员变量私有，然后提供公有的getter和setter方法来访问成员变量。</p>
<h1 id="考点4-浮点数转整数"><a href="#考点4-浮点数转整数" class="headerlink" title="考点4:浮点数转整数"></a>考点4:浮点数转整数</h1><p>下列语句序列执行后，输出结果是（）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ex</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">13</span>;</span><br><span class="line">        a=a/<span class="number">5</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 1</li>
<li>B 2</li>
<li>C 3</li>
<li>D 4</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>整数相除之后还是整数，会丢失掉小数部分的数值。</p>
<h2 id="浮点数转整数：丢弃小数部分"><a href="#浮点数转整数：丢弃小数部分" class="headerlink" title="浮点数转整数：丢弃小数部分"></a>浮点数转整数：丢弃小数部分</h2><p>a是int类型,13/5得到一个浮点类型,浮点类型转成整数类型的原则是,不四舍五入,只取整数部分，小数部分直接丢弃。.</p>
<figure class="highlight java"><figcaption><span>G:\dev2\idea_workspace\MyJavaTools\RunableTools\src\base\Test.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> i = <span class="number">1.0</span>; i &lt; <span class="number">2.2</span>; i = i + <span class="number">0.1000000000000000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;double(&quot;</span> + i + <span class="string">&quot;) \tto int(&quot;</span> + (<span class="keyword">int</span>) i+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">double(1.0)	to int(1)</span><br><span class="line">double(1.1)	to int(1)</span><br><span class="line">double(1.2000000000000002)	to int(1)</span><br><span class="line">double(1.3000000000000003)	to int(1)</span><br><span class="line">double(1.4000000000000004)	to int(1)</span><br><span class="line">double(1.5000000000000004)	to int(1)</span><br><span class="line">double(1.6000000000000005)	to int(1)</span><br><span class="line">double(1.7000000000000006)	to int(1)</span><br><span class="line">double(1.8000000000000007)	to int(1)</span><br><span class="line">double(1.9000000000000008)	to int(1)</span><br><span class="line">double(2.000000000000001)	to int(2)</span><br><span class="line">double(2.100000000000001)	to int(2)</span><br></pre></td></tr></table></figure>
<p>可以看到，double转int的时候，只保留浮点数中的整数部分，小数部分全部丢弃。</p>
<h1 id="考点5-面向对象的三大特征"><a href="#考点5-面向对象的三大特征" class="headerlink" title="考点5:面向对象的三大特征"></a>考点5:面向对象的三大特征</h1><p>面向对象的基本特征是（）</p>
<ul>
<li>A 封装</li>
<li>B 继承</li>
<li>C 重载</li>
<li>D 多态</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>

<h2 id="三大基本特征：封装、继承、多态"><a href="#三大基本特征：封装、继承、多态" class="headerlink" title="三大基本特征：封装、继承、多态"></a>三大基本特征：封装、继承、多态</h2><p>1、封装<br>2、继承<br>3、多态</p>
<h2 id="五大基本原则"><a href="#五大基本原则" class="headerlink" title="五大基本原则"></a>五大基本原则</h2><p>1、单一职责原则（SRP）<br>2、开放封闭原则（OCP）<br>3、里氏替换原则（LSP）<br>4、依赖倒置原则（DIP）<br>5、接口隔离原则（ISP）</p>
<h3 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1.单一职责原则"></a>1.单一职责原则</h3><p>就一个类而言，应该仅有一个引起它变化的原因。</p>
<h3 id="2-开放-封闭原则"><a href="#2-开放-封闭原则" class="headerlink" title="2.开放-封闭原则"></a>2.开放-封闭原则</h3><p>一个软件实体应当对扩展开放，对修改关闭</p>
<h3 id="3-里氏代换原则"><a href="#3-里氏代换原则" class="headerlink" title="3.里氏代换原则"></a>3.里氏代换原则</h3><p>子类型(subtype)必须能够替换它们的基（父）类型</p>
<h3 id="4-依赖倒转（置）原则"><a href="#4-依赖倒转（置）原则" class="headerlink" title="4.依赖倒转（置）原则"></a>4.依赖倒转（置）原则</h3><p>要依赖于抽象，不要依赖于具体</p>
<h3 id="5-接口隔离原则"><a href="#5-接口隔离原则" class="headerlink" title="5.接口隔离原则"></a>5.接口隔离原则</h3><p>使用多个专门的接口比使用单一的总接口总要好</p>
<h1 id="考点6-标识符规则"><a href="#考点6-标识符规则" class="headerlink" title="考点6:标识符规则"></a>考点6:标识符规则</h1><p>下面哪些标识符是正确的？</p>
<ul>
<li>A <code>MyWorld</code></li>
<li>B <code>parseXML</code></li>
<li>C <code>–value</code></li>
<li>D <code>&amp;maybe</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: AB</details>

<h2 id="Java中标识符规则"><a href="#Java中标识符规则" class="headerlink" title="Java中标识符规则"></a>Java中标识符规则</h2><ul>
<li>由<strong>字母</strong>、<strong>数字</strong>、<code>美元符号$</code>、**下划线_**4种组成，</li>
<li>不能以数字开头，</li>
<li>不能是保留字和关键字</li>
<li>不能是true,false,null等引用常量</li>
</ul>
<h2 id="C语言标识符规则"><a href="#C语言标识符规则" class="headerlink" title="C语言标识符规则"></a>C语言标识符规则</h2><ul>
<li>标识符由字母（A-Z，a-z）、数字（0-9）、下划线“_”组成，</li>
<li>首字符不能是数字，但可以是字母或者下划线</li>
<li>不能是保留字和关键字</li>
</ul>
<p>Java标识符字符构成比C语言的多了一个美元符$</p>
<h1 id="考点7-java有哪些包装类"><a href="#考点7-java有哪些包装类" class="headerlink" title="考点7:java有哪些包装类"></a>考点7:java有哪些包装类</h1><p>下面属于java包装类的是？</p>
<ul>
<li>A String</li>
<li>B Long</li>
<li>C Character</li>
<li>D Short</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details>

<h2 id="基本数据类型及其包装类对照表"><a href="#基本数据类型及其包装类对照表" class="headerlink" title="基本数据类型及其包装类对照表"></a>基本数据类型及其包装类对照表</h2><table>
<thead>
<tr>
<th align="left">基本数据类型</th>
<th align="left">包装类</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte</td>
<td align="left">Byte</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">Boolean</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">Short</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">Character</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">Integer</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">Long</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">Float</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">Double</td>
</tr>
</tbody></table>
<p>String既不是包装类，也不是基本类型</p>
<h1 id="考点8-反射机制能做什么"><a href="#考点8-反射机制能做什么" class="headerlink" title="考点8:反射机制能做什么"></a>考点8:反射机制能做什么</h1><p>JAVA反射机制主要提供了以下哪些功能？</p>
<ul>
<li>A 在运行时判断一个对象所属的类</li>
<li>B 在运行时构造一个类的对象</li>
<li>C 在运行时判断一个类所具有的成员变量和方法</li>
<li>D 在运行时调用一个对象的方法</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>

<p>A: Class.isInstance();<br>B: Class.newInstance();<br>C: Class.getMethod(); Class.getField();<br>D: Method.invoke();</p>
<h2 id="Class类方法"><a href="#Class类方法" class="headerlink" title="Class类方法"></a>Class类方法</h2><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html#method.summary">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html#method.summary</a><br><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#method.summary">https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#method.summary</a></p>
<p><img data-src="https://gitee.com/XiaoLan223/images/raw/master/Blog/Sum/20210908162524.png" alt="image-20210908162522801"></p>
<h1 id="考点9-常识-面向对象程序设计优点"><a href="#考点9-常识-面向对象程序设计优点" class="headerlink" title="考点9:常识 面向对象程序设计优点"></a>考点9:常识 面向对象程序设计优点</h1><p>面向对象程序设计方法的优点包含：</p>
<ul>
<li>A 可重用性</li>
<li>B 可扩展性</li>
<li>C 易于管理和维护</li>
<li>D 简单易懂</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/exam/a562e57f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/exam/images/avatar.png">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝的站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/exam/a562e57f/" class="post-title-link" itemprop="url">2021年09月07日 java1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-07 14:39:50" itemprop="dateCreated datePublished" datetime="2021-09-07T14:39:50+08:00">2021-09-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-31 15:27:45" itemprop="dateModified" datetime="2021-12-31T15:27:45+08:00">2021-12-31</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">牛客网</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">专项练习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/Java/2021%E5%B9%B409%E6%9C%88/" itemprop="url" rel="index"><span itemprop="name">2021年09月</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/exam/a562e57f/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/exam/a562e57f/" data-xid="/exam/a562e57f/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="考点1-java基础知识-boolean表达式"><a href="#考点1-java基础知识-boolean表达式" class="headerlink" title="考点1:java基础知识 boolean表达式"></a>考点1:java基础知识 boolean表达式</h1><p>设有定义 int a=3 ,b=4,c=5; 则以下的表达式中 , 值为 false 的是 ()</p>
<ul>
<li>A <code>a &lt; b &amp;&amp; b &lt; c</code></li>
<li>B <code>a &lt;= b</code></li>
<li>C <code>a &lt; ( b + c )</code></li>
<li>D <code>! ( a &lt; b )</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<h3 id="拓展：单与和双与的区别"><a href="#拓展：单与和双与的区别" class="headerlink" title="拓展：单与和双与的区别"></a>拓展：单与和双与的区别</h3><ul>
<li><code>&amp;</code>和<code>&amp;&amp;</code>都是<strong>逻辑运算符</strong>，都是判断<strong>两边同时真则为真，否则为假;</strong><ul>
<li>但是<code>&amp;&amp;</code>当第一个条件不成之后，后面的条件都不执行了，而<code>&amp;</code>则还是继续执行，直到整个条件语句执行完为止。</li>
</ul>
</li>
<li><code>||</code>和<code>|</code>都是逻辑<code>或</code>，<strong>只要两个数任意一个为真，条件就为真。</strong><ul>
<li>同上，<code>||</code>也具有短路效果。</li>
</ul>
</li>
</ul>
<p><strong>双与有短路功能，单与可以进行位运算</strong></p>
<h1 id="考点2-java基础知识-Object类"><a href="#考点2-java基础知识-Object类" class="headerlink" title="考点2:java基础知识 Object类"></a>考点2:java基础知识 Object类</h1><p>Java中所有类的父类是( )。</p>
<ul>
<li>A <code>Father</code></li>
<li>B <code>Dang</code></li>
<li>C <code>Exception</code></li>
<li>D <code>Object</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<ul>
<li>java中Object是所有类的父亲,</li>
<li>所有类的对象都是Class的实例。</li>
</ul>
<h1 id="考点3-实现多个接口的正确写法"><a href="#考点3-实现多个接口的正确写法" class="headerlink" title="考点3:实现多个接口的正确写法"></a>考点3:实现多个接口的正确写法</h1><p>在java中,已定义两个接口B和C,要定义一个实现这两个接口的类,以下语句正确的是()</p>
<ul>
<li>A <code>interface A extends B,C</code></li>
<li>B <code>interface A eimplements B,C</code></li>
<li>C <code>class A implements B,C</code></li>
<li>D <code>class A implements B,implements C</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h3 id="实现多个接口时只需要写一个implements"><a href="#实现多个接口时只需要写一个implements" class="headerlink" title="实现多个接口时只需要写一个implements"></a>实现多个接口时只需要写一个implements</h3><p>类实现多个接口的时候，只需要一个implements，多个接口通过逗号进行隔开，</p>
<p>先继承类,再实现接口</p>
<h1 id="考点4-Servlet生命周期"><a href="#考点4-Servlet生命周期" class="headerlink" title="考点4:Servlet生命周期"></a>考点4:Servlet生命周期</h1><p>J2EE中,当把来自客户机的HTTP请求委托给servlet时,会调用HttpServlet的( )方法</p>
<ul>
<li>A <code>service</code></li>
<li>B <code>doget</code></li>
<li>C <code>dopost</code></li>
<li>D <code>init</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h3 id="HttpServlet容器响应Web请求流程"><a href="#HttpServlet容器响应Web请求流程" class="headerlink" title="HttpServlet容器响应Web请求流程"></a>HttpServlet容器响应Web请求流程</h3><p>HttpServlet容器响应Web客户请求流程如下：<br>1）Web客户向Servlet容器发出Http请求；<br>2）Servlet容器解析Web客户的Http请求；<br>3）Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息；<br>4）Servlet容器创建一个HttpResponse对象；<br>5）Servlet容器调用HttpServlet的service方法，这个方法中会根据request的Method来判断具体是执行doGet还是doPost，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象；<br>6）HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息；<br>7）HttpServlet调用HttpResponse的有关方法，生成响应数据；<br>8）Servlet容器把HttpServlet的响应结果传给Web客户。</p>
<p>doGet()<br>或<br>doPost()<br>是创建HttpServlet时需要覆盖的方法.</p>
<h3 id="Servlet生命周期三个阶段"><a href="#Servlet生命周期三个阶段" class="headerlink" title="Servlet生命周期三个阶段"></a>Servlet生命周期三个阶段</h3><p>1.初始化阶段，调用init()方法<br>2.响应客户请求阶段，调用service()方法<br>3.终止阶段，调用destroy()方法</p>
<h1 id="考点5-类的加载顺序-父类静态块-子类静态块-main方法-父类构造块-父类构造器-子类构造块-子类构造器"><a href="#考点5-类的加载顺序-父类静态块-子类静态块-main方法-父类构造块-父类构造器-子类构造块-子类构造器" class="headerlink" title="考点5:类的加载顺序 父类静态块 子类静态块 main方法 父类构造块 父类构造器 子类构造块 子类构造器"></a>考点5:类的加载顺序 父类静态块 子类静态块 main方法 父类构造块 父类构造器 子类构造块 子类构造器</h1><p>关于以下application,说法正确是什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;x+=<span class="number">5</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="comment">//4</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;x=&quot;</span>+x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;x/=<span class="number">3</span>;&#125;;</span><br><span class="line">&#125;<span class="comment">//9</span></span><br></pre></td></tr></table></figure>
<ul>
<li>A 4行与9行不能通过编译,因为缺少方法名和返回类型</li>
<li>B 编译通过,执行结果是:<code>x=5</code></li>
<li>C 编译通过,执行结果是:<code>x=3</code></li>
<li>D 9行不能通过编译,因为只能有一个静态初始化器</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="类的初始化顺序"><a href="#类的初始化顺序" class="headerlink" title="类的初始化顺序"></a>类的初始化顺序</h3><figure class="highlight java"><figcaption><span>G:\dev2\idea_workspace\MyJavaTools\RunableTools\src\base\test\B.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类 静态 代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类 构造 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类 初始化 代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类 静态 代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类 构造 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类 初始化 代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法 执行&quot;</span>);</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main方法 代码块1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> B();</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main方法 代码块2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">父类 静态 代码块</span><br><span class="line">子类 静态 代码块</span><br><span class="line">main方法 执行</span><br><span class="line">main方法 代码块1</span><br><span class="line">父类 初始化 代码块</span><br><span class="line">父类 构造 方法</span><br><span class="line">子类 初始化 代码块</span><br><span class="line">子类 构造 方法</span><br><span class="line">main方法 代码块2</span><br></pre></td></tr></table></figure>

<p><strong>静态代码块先于 主方法执行，静态代码块之间遵从代码顺序执行</strong>。<br>所以：先初始化静态变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=10；//x=10</span><br></pre></td></tr></table></figure>
<p>执行第一个静态代码块，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=x+5; //x=15</span><br></pre></td></tr></table></figure>
<p>执行第二静态代码块 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=x/3; //x=5</span><br></pre></td></tr></table></figure>
<p>执行主方法： 输出x=5</p>
<p>拓展一下，在类中定义的{}之间被称为构造块，构造块相对于构造方法先执行，构造块之间按照代码编译顺序执行</p>
<p>此外还有普通代码块，存在于方法之中。<br>贴出参考文章：<a href="http://www.cnblogs.com/sophine/p/3531282.html" target="_blank">http://www.cnblogs.com/sophine/p/3531282.html</a></p>
<h1 id="考点6-还没了解hibernate"><a href="#考点6-还没了解hibernate" class="headerlink" title="考点6:还没了解hibernate"></a>考点6:还没了解hibernate</h1><p>下面关于hibernate核心接口说明错误的是？</p>
<ul>
<li>A <code>Configuration</code> 接口:配置<code>Hibernate</code>,根据其启动<code>hibernate</code>,创建<code>SessionFactory</code> 对象</li>
<li>B <code>SessionFactory</code> 接口:负责保存、更新、删除、加载和查询对象,是线程不安全的,避免多个线程共享同一个<code>session</code>,是轻量级、一级缓存</li>
<li>C <code>Query</code> 和<code>Criteria</code> 接口:执行数据库的查询</li>
<li>D <code>Transaction</code> 接口:管理事务</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>B选项中应该是Session接口而不是SessionFactory接口<br>1，Configuration接口：配置Hibernate，根据其启动Hibernate，创建SessionFactory对象；<br>2，SessionFactory接口：初始化Hibernate，充当数据存储源的，创建session对象，SessionFactory是线程安全的，意味着它的同一个实例可以被应用的多个线程共享，是重量级二级缓存；<br>3，<strong>session接口：负责保存、更新、删除、加载和查询对象，是一个非线程安全的，避免多个线程共享一个session，是轻量级，一级缓存。</strong><br>4，Transaction接口：管理事务。可以对事务进行提交和回滚；<br>5，Query和Criteria接口：执行数据库的查询。</p>
<h1 id="考点7-堆外内存-off-heap-还没学到"><a href="#考点7-堆外内存-off-heap-还没学到" class="headerlink" title="考点7:堆外内存 off-heap 还没学到"></a>考点7:堆外内存 off-heap 还没学到</h1><p>off-heap是指那种内存()</p>
<ul>
<li>A <code>JVM GC</code>能管理的内存</li>
<li>B <code>JVM</code>进程管理的内存</li>
<li>C 在<code>JVM</code>老年代内存区</li>
<li>D 在<code>JVM</code>新生代内存</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h3><p>off-heap叫做堆外内存，将你的对象从堆中脱离出来序列化，然后存储在一大块内存中，这就像它存储到磁盘上一样，但它仍然在RAM中。对象在这种状态下不能直接使用，它们必须首先反序列化，也不受垃圾收集。<br>序列化和反序列化将会影响部分性能（所以可以考虑使用FST-serialization）使用堆外内存能够降低GC导致的暂停。<br>堆外内存不受垃圾收集器管理，也不属于老年代，新生代。</p>
<h1 id="考点8-Servlet生命周期"><a href="#考点8-Servlet生命周期" class="headerlink" title="考点8:Servlet生命周期"></a>考点8:Servlet生命周期</h1><p>servlet周期包含哪些:</p>
<ul>
<li>A 初始化</li>
<li>B 销毁</li>
<li>C 请求处理</li>
<li>D 开始</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>


<h3 id="Servlet生命周期3个阶段"><a href="#Servlet生命周期3个阶段" class="headerlink" title="Servlet生命周期3个阶段"></a>Servlet生命周期3个阶段</h3><p>1）初始化阶段：调用init方法<br>2）响应客户请求：调用service<br>3）终止：调用destory方法</p>
<h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p>在下列时刻servlet容器装载servlet<br>1 servlet容器启动时，自动装载某些servlet<br>2 在servlet容器启动后，客户首次向servlet发送请求<br>3 servlet类文件被更新之后，重新装载servlet</p>
<p>Servlet被装载之后，servlet容器创建一个servlet对象并调用servlet的init方法，在servlet生命周期内，init方法只能被调用一次。</p>
<h5 id="servlet工作原理"><a href="#servlet工作原理" class="headerlink" title="servlet工作原理"></a>servlet工作原理</h5><p>客户端发起一个请求，servlet调用service方法时请求进行响应，service对请求的方式进行了匹配，选择调用doPost或者doGet等这些方法，然后进入对应方法中调用逻辑层的方法，实现对客户的响应。</p>
<h4 id="响应客户请求"><a href="#响应客户请求" class="headerlink" title="响应客户请求"></a>响应客户请求</h4><p>对于用户到达servlet的请求，servlet容器会创建特定于该请求的ServletRequest和ServletResponse对象，然后调用servlet的service方法，service方法从ServletRequest对象中获取客户请求的信息，处理该请求，并且通过ServletResponse对象向客户端返回响应信息。</p>
<h4 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h4><p>当web应用终止或者servlet容器终止或servlet容器重新装载servlet新实例时，servlet容器会调用servlet对象的destory方法，在destory方法中可以释放servlet占用的资源</p>
<h1 id="考点9-类的加载顺序-静态块-main-构造块-构造器"><a href="#考点9-类的加载顺序-静态块-main-构造块-构造器" class="headerlink" title="考点9:类的加载顺序 静态块 main 构造块 构造器"></a>考点9:类的加载顺序 静态块 main 构造块 构造器</h1><p>关于以下代码的说明,正确的是( )</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticStuff</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123; x+=<span class="number">5</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[ ])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;x=&quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123; x/=<span class="number">3</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 4行与9行不能通过编译,因为缺少方法名和返回类型</li>
<li>B 9行不能通过编译,因为只能有一个静态初始化器</li>
<li>C 编译通过,执行结果为:x=5</li>
<li>D 编译通过,执行结果为:x=3</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p><strong>同上第5题</strong></p>
<h1 id="考点10-JVM相关-还没学到"><a href="#考点10-JVM相关-还没学到" class="headerlink" title="考点10:JVM相关 还没学到"></a>考点10:JVM相关 还没学到</h1><p>关于OutOfMemoryError,下面说法正确的是()？</p>
<ul>
<li>A <code>java.lang.OutOfMemoryError: PermGen space</code> 增加<code>-XX:MaxPermSize</code>这个参数的值的话,这个问题通常会得到解决。</li>
<li>B <code>java.lang.OutOfMemoryError: Requested array size exceeds VM limit</code>当你正准备创建一个超过虚拟机允许的大小的数组时,这条错误将会出现</li>
<li>C <code>java.lang.OutOfMemoryError: Java heap space</code> 一般情况下解决这个问题最快的方法就是通过<code>-Xmx</code>参数来增加堆的大小</li>
<li>D <code>java.lang.OutOfMemoryError: nativeGetNewTLA</code>这个异常只有在<code>jRockit</code>虚拟机时才会碰到</li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<p>关于此题，《深入理解java虚拟机》有关于OOM（OutOfMemory）问题的解释<br>A：属于运行时常量池导致的溢出，设置-XX：MaxPermSize可以解决这个问题，<br>B：属于堆空间不足导致的错误，问题比较少见，解决方式和C相同，<br>C：属于java堆内存问题，一般的手段是通过内存映像分析工具，对Dump出来的堆转储存快照进行分析，重点是确认内存中的对象是否是有必要的，也就是要判断是出现了内存泄漏，还是出现了内存溢出，如果是内存列楼，通过工具检查泄露对象打GC Roots的引用链信息，可以准确的确定出泄露代码的位置，不存在泄露，就应该检查虚拟机的堆参数，如果可以继续调大，可以设置-Xmx解决问题<br>D：java.lang.OutOfMemoryError: nativeGetNewTLA指当虚拟机不能分配新的线程本地空间(Thread Local Area）的时候错误信息，此错误是线程申请一个新的TLA时产生的，这个异常一般只会发生在jRockit虚拟机，只有过于绝对。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/exam/def2879b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/exam/images/avatar.png">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝的站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/exam/def2879b/" class="post-title-link" itemprop="url">2021年09月06日 计算机_编程基础1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-06 15:09:47" itemprop="dateCreated datePublished" datetime="2021-09-06T15:09:47+08:00">2021-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">牛客网</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">专项练习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机-编程基础</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/exam/def2879b/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/exam/def2879b/" data-xid="/exam/def2879b/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="考点1-C语言命名规则"><a href="#考点1-C语言命名规则" class="headerlink" title="考点1:C语言命名规则"></a>考点1:C语言命名规则</h1><p>以下叙述中正确的是()</p>
<ul>
<li>A 语言中的关键字不能作变量名,但可以作为函数名</li>
<li>B 标识符的长度不能任意长,最多只能包含16个字符</li>
<li>C 标识符可以由字母、数字和下划线组成,且第一个字符不得为数字</li>
<li>D 用户自定义的标识符必须”见名知义”,如果随意定义,则会出编译错误</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h3 id="C语言标识符命名规则"><a href="#C语言标识符命名规则" class="headerlink" title="C语言标识符命名规则"></a>C语言标识符命名规则</h3><p>解析：【解析】<br>C语言中的关键字即不能做变量名也不能做用户函数名,所以A错误。</p>
<p>标识符的命名规则,即：</p>
<ol>
<li>由下划线、字母、数字组成,</li>
<li>且不能以数字开头，可以就是必须以下划线或字母开头,</li>
<li>也不能和关键字一致。</li>
</ol>
<p>不同C语言规定标识符的有效长度可能会不同,但没有限制最大长度,所以B错误。</p>
<p>用户定义的标识符只要满足标识符命名规则没有特殊要求,<strong>不必一定”见名知义”</strong>,所以D错误。</p>
<h1 id="考点2-排错法？"><a href="#考点2-排错法？" class="headerlink" title="考点2:排错法？"></a>考点2:排错法？</h1><p>小孙发现某学生成绩管理系统运行后,不能正常处理分数为90分的成绩。于是小孙再次设计了多个成绩数据进行测试,又发现了它对一些特定分数的成绩处理有错。小孙从所有错误结果中归纳征兆,从而确定错误是由于程序对个位数为0的整数成绩处理有误。小孙排错采用的方法是( )。</p>
<ul>
<li>A 归纳排错法</li>
<li>B 演绎排错法</li>
<li>C 回溯排错法</li>
<li>D 穷举排错法</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<h1 id="考点3-源程序转换为可执行程序要经过的步骤"><a href="#考点3-源程序转换为可执行程序要经过的步骤" class="headerlink" title="考点3:源程序转换为可执行程序要经过的步骤"></a>考点3:源程序转换为可执行程序要经过的步骤</h1><p>用高级语言编写的源程序转化为可执行程序,必须经过()。</p>
<ul>
<li>A 汇编和解释</li>
<li>B 编辑和链接</li>
<li>C 编译和链接</li>
<li>D 解释和编译</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>一个计算机程序执行的过程可分为编辑、编译、连接和运行四个过程。用高级语言编写程序的过程称为编辑，之后利用编译程序从源语言编写的源程序产生目标程序的过程称为编译，翻译完的目标程序不能立即被执行，要通过连接将目标程序和有关的系统函数库以及系统提供的其他信息连接起来，形成一个可执行程序。综上所述，用高级语言编写的源程序，将其转化成能在计算机上运行的程序过程是编辑、编译、连接。</p>
<h1 id="考点4-汉字输入码"><a href="#考点4-汉字输入码" class="headerlink" title="考点4:汉字输入码"></a>考点4:汉字输入码</h1><p>在拼音输入法中,输入拼音”zhengchang”,其编码属于( )。</p>
<ul>
<li>A 字形码</li>
<li>B 地址码</li>
<li>C 外码</li>
<li>D 内码</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h3 id="外码-汉字输入码"><a href="#外码-汉字输入码" class="headerlink" title="外码 汉字输入码"></a>外码 汉字输入码</h3><p>汉字输入码是为使用户能够使用西文键盘输入汉字而编制的编码，也叫外码。</p>
<h3 id="汉字输入码分类"><a href="#汉字输入码分类" class="headerlink" title="汉字输入码分类"></a>汉字输入码分类</h3><p>汉字输入码有多种不同的编码方案，大致包括:</p>
<ol>
<li>音码（以汉语拼音字母和数字为汉字编码）、</li>
<li>音形码（以拼音为主，辅以字形字义进行编码）、</li>
<li>形码（根据汉字的字形结构对汉字进行编码）和</li>
<li>数字码（直接用固定位数的数字给汉字编码）4类。</li>
</ol>
<p>故正确答案为C选项。</p>
<h1 id="考点5-C-重载运算符"><a href="#考点5-C-重载运算符" class="headerlink" title="考点5:C++重载运算符"></a>考点5:C++重载运算符</h1><p>在表达式 <code>+y*z</code> 中, + 是作为成员函数重载的运算符, <code>*</code> 是作为非成员函数重载的运算符。则 <code>operator+</code> 有______个参数, <code>operator*</code> 有________参数。 (    )</p>
<ul>
<li>A 2、2</li>
<li>B 2、1</li>
<li>C 1、1</li>
<li>D 1、2</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>运算符可重载为成员函数，也可重载为非成员函数函数。</p>
<ul>
<li>当重载为<strong>成员函数</strong>时，运算符重载函数的<strong>形参个数要比运算符操作数的个数少一个</strong>；</li>
<li>当重载为<strong>非成员函数</strong>时，其<strong>形参个数应与操作数的个数相同</strong>。</li>
</ul>
<h1 id="考点6-位运算"><a href="#考点6-位运算" class="headerlink" title="考点6:位运算"></a>考点6:位运算</h1><p>下面有关位运算的一些结论哪些是正确的 (    )</p>
<ul>
<li>A 十二进制数81的二进制数为: <code>01100001</code></li>
<li>B 十进制数-11的补码为:<code>11110101</code></li>
<li>C 十进制数76和81异或的结果为十进制数28</li>
<li>D 位运算<code>(A|B)&amp;C = (A&amp;C)|(B&amp;C)</code></li>
<li>E 加法运算等同于位或运算,如<code>A+B=A|B</code></li>
<li>F 与二进制数00101101等值的十六进制数是<code>2C</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>

<h3 id="A选项-N进制数转10进制数：按权展开"><a href="#A选项-N进制数转10进制数：按权展开" class="headerlink" title="A选项 N进制数转10进制数：按权展开"></a>A选项 N进制数转10进制数：按权展开</h3><h4 id="十二进制的81转10进制"><a href="#十二进制的81转10进制" class="headerlink" title="十二进制的81转10进制"></a>十二进制的81转10进制</h4><p>$$<br>(81)_{12}=8\times 12^1+1\times 12^0=96+1=97<br>$$</p>
<h4 id="二进制01100001转10进制"><a href="#二进制01100001转10进制" class="headerlink" title="二进制01100001转10进制"></a>二进制01100001转10进制</h4><p>$$<br>(01100001)_{2}=0+1\times 2^6+1\times 2^5+0+0+0+0+1=2^6+2^5+1=64+32+1=96+1=97<br>$$</p>
<p>所以A正确</p>
<h3 id="B选项-原码反码补码"><a href="#B选项-原码反码补码" class="headerlink" title="B选项 原码反码补码"></a>B选项 原码反码补码</h3><p><strong>正数的原码，反码，补码都一样</strong></p>
<h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p>原码是直接将一个数值换算成二进制数。最高位为符号位，正数为0，负数为1</p>
<h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p>正数的反码是就是原码</p>
<p>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p>
<h4 id="补码的计算规则"><a href="#补码的计算规则" class="headerlink" title="补码的计算规则"></a>补码的计算规则</h4><p>计算机以补码的形式保存所有的整数。</p>
<ul>
<li><p>正数的补码和原码完全相同,</p>
</li>
<li><p>负数的补码是其反码加1;</p>
<p>   负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1.(即在反码的基础上+1)</p>
</li>
</ul>
<p>$$<br>(-11)=8+2+1<br>$$</p>
<h4 id="补码转原码"><a href="#补码转原码" class="headerlink" title="补码转原码"></a>补码转原码</h4><p><strong>补码的补码就是原码</strong>，就像负负得正一样</p>
<h4 id="二进制十进制转换表"><a href="#二进制十进制转换表" class="headerlink" title="二进制十进制转换表"></a>二进制十进制转换表</h4><table>
<thead>
<tr>
<th align="left">2^n</th>
<th align="left">2^7</th>
<th align="left">2^6</th>
<th align="left">2^5</th>
<th align="left">2^4</th>
<th align="left">2^3</th>
<th align="left">2^2</th>
<th align="left">2^1</th>
<th align="left">2^0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">值</td>
<td align="left">128</td>
<td align="left">64</td>
<td align="left">32</td>
<td align="left">16</td>
<td align="left">8</td>
<td align="left">4</td>
<td align="left">2</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">-11原码</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">-11反码</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">-11补码</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>所以<br>$$<br>(-11)<em>{原码}=1000 1011 \newline<br>(-11)</em>{反码}=1000 0100 \newline<br>(-11)_{补码}=1111 0101<br>$$</p>
<p>所以B选项正确</p>
<h3 id="C选项-亦或运算"><a href="#C选项-亦或运算" class="headerlink" title="C选项 亦或运算"></a>C选项 亦或运算</h3><p>如果a、b两个值不相同，则异或结果为1。<br>如果a、b两个值相同，异或结果为0。</p>
<p><strong>相同为0，相异为1</strong></p>
<h4 id="亦或真值表"><a href="#亦或真值表" class="headerlink" title="亦或真值表"></a>亦或真值表</h4><table>
<thead>
<tr>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a⊕b</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
</tbody></table>
<h4 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h4><p>76展开：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">76-64=12</span><br><span class="line">12-8=4</span><br><span class="line">4-4=0</span><br></pre></td></tr></table></figure>
<p>81展开：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">81-64=17</span><br><span class="line">17-16=1</span><br><span class="line">1-1=0</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">2^n</th>
<th align="left">2^7</th>
<th align="left">2^6</th>
<th align="left">2^5</th>
<th align="left">2^4</th>
<th align="left">2^3</th>
<th align="left">2^2</th>
<th align="left">2^1</th>
<th align="left">2^0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">值</td>
<td align="left">128</td>
<td align="left">64</td>
<td align="left">32</td>
<td align="left">16</td>
<td align="left">8</td>
<td align="left">4</td>
<td align="left">2</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">+76补码</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">+81补码</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">+76⊕+81补码</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>$$<br>+76⊕81&amp;=&amp;0  0  0  1  1  1  0  1 \newline<br>&amp;=&amp;16+8+4+1 \newline<br>&amp;=&amp;29<br>$$</p>
<p>所以C选项错误</p>
<h3 id="D选项"><a href="#D选项" class="headerlink" title="D选项"></a>D选项</h3><p>位运算(A|B)&amp;C = (A&amp;C)|(B&amp;C)</p>
<h4 id="交换律-结合律-分配律"><a href="#交换律-结合律-分配律" class="headerlink" title="交换律 结合律 分配律"></a>交换律 结合律 分配律</h4><p><a target="_blank" rel="noopener" href="https://www.shuxuele.com/associative-commutative-distributive.html">https://www.shuxuele.com/associative-commutative-distributive.html</a></p>
<h5 id="交换律"><a href="#交换律" class="headerlink" title="交换律"></a>交换律</h5><p>符号相同的时候</p>
<p>$a+b=b+a$</p>
<h5 id="结合律"><a href="#结合律" class="headerlink" title="结合律"></a>结合律</h5><p>符号相同的时候</p>
<p>$(a+b)+c=a+(b+c)$</p>
<p>$(a\times b) \times c=a\times (b \times c)$</p>
<h5 id="分配率"><a href="#分配率" class="headerlink" title="分配率"></a>分配率</h5><p>符号不同的时候</p>
<p>$a\times (b+c)=a\times b+a\times c$</p>
<h4 id="按位或按位与满足分配率"><a href="#按位或按位与满足分配率" class="headerlink" title="按位或按位与满足分配率"></a>按位或按位与满足分配率</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> A=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> B=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> C=<span class="number">3</span>;</span><br><span class="line">        System.out.println(((A | B) &amp; C) == ((A &amp; C) | (B &amp; C)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>

<h3 id="E选项"><a href="#E选项" class="headerlink" title="E选项"></a>E选项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A=-<span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> B=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> C=<span class="number">6</span>;</span><br><span class="line">System.out.println(A+B);</span><br><span class="line">System.out.println(A|B);</span><br><span class="line">System.out.println(C+B);</span><br><span class="line">System.out.println(C|B);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">-3</span><br><span class="line">11</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/exam/8af88738/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/exam/images/avatar.png">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝的站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/exam/8af88738/" class="post-title-link" itemprop="url">2021年09月05日 数据库1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-06 10:41:29" itemprop="dateCreated datePublished" datetime="2021-09-06T10:41:29+08:00">2021-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">牛客网</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">专项练习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/exam/8af88738/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/exam/8af88738/" data-xid="/exam/8af88738/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="考点1-联系-一对一，一对多，多对多"><a href="#考点1-联系-一对一，一对多，多对多" class="headerlink" title="考点1:联系 一对一，一对多，多对多"></a>考点1:联系 一对一，一对多，多对多</h1><p>学校中有多个院系和多名教师,每个教师只能属于一个院系,一个系可以有多名教师,院系和教师之间的关系是( )。</p>
<ul>
<li>A 一对多</li>
<li>B 一对一</li>
<li>C 一对二</li>
<li>D 多对多</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<h1 id="考点2-数据库范式"><a href="#考点2-数据库范式" class="headerlink" title="考点2:数据库范式"></a>考点2:数据库范式</h1><p>在通常情况下,下面的关系中不可以作为关系数据库的关系是()</p>
<ul>
<li>A <code>R1</code>(学生号,学生名,性别)</li>
<li>B <code>R2</code>(学生号,学生名,班级号)</li>
<li>C <code>R3</code>(学生号,学生名,宿舍号)</li>
<li>D <code>R4</code>(学生号,学生名,简历)</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>1NF是第一范式：数据库中的每一项都是不可分割的基本数据项.</p>
<p>而简历中包含学号与姓名,不满足第一范式。</p>
<h3 id="数据库范式1nf-2nf-3nf"><a href="#数据库范式1nf-2nf-3nf" class="headerlink" title="数据库范式1nf,2nf,3nf"></a>数据库范式1nf,2nf,3nf</h3><p>1nf: 每一列原子性，不可再分<br>2nf: 非主键列完全依赖于（联合）主键<br>3nf: 非主键直接依赖于主键</p>
<h1 id="考点3-DML语句"><a href="#考点3-DML语句" class="headerlink" title="考点3:DML语句"></a>考点3:DML语句</h1><p>以下不属于DML的是?</p>
<ul>
<li>A <code>INSERT</code></li>
<li>B <code>DELETE</code></li>
<li>C <code>CREATE</code></li>
<li>D <code>UPDATE</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h3 id="DQL-DML-DDL-DCL"><a href="#DQL-DML-DDL-DCL" class="headerlink" title="DQL DML DDL DCL"></a>DQL DML DDL DCL</h3><p>数据查询语言DQL: 由select字句，from字句，Where字句组成的查询块<br>数据操纵语言DML：insert，update，delete<br>数据定义语言DDL：Create字句，如创建索引。 表 视图等<br>数据控制语言DCL：Grant字句，Commit字句，用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。</p>
<h1 id="考点4-索引"><a href="#考点4-索引" class="headerlink" title="考点4:索引"></a>考点4:索引</h1><p>关于数据库的描述错误的是:</p>
<ul>
<li>A 创建索引一定能提升查询时间</li>
<li>B 主键的数据列要创建索引</li>
<li>C 外键的数据列要建立索引</li>
<li>D 常见数据库索引有 <code>Hash</code> 索引,<code>B-tree</code> 索引</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>首先明白为什么索引会增加速度，DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。<br>如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。</p>
<p>那么在任何时候都应该加索引么？这里有几个反例：<br>1、如果每次都需要取到所有表记录，无论如何都必须进行全表扫描了，那么是否加索引也没有意义了。<br>2、对非唯一的字段，例如“性别”这种大量重复值的字段，增加索引也没有什么意义。<br>3、对于记录比较少的表，增加索引不会带来速度的优化反而浪费了存储空间，因为索引是需要存储空间的，而且有个致命缺点是对于update/insert/delete的每次执行，字段的索引都必须重新计算更新，这就拖慢了速度</p>
<p>常见的数据库索引是B-tree索引，虽然Hash 索引效率很高，但是他有很多弊端，比如</p>
<p>Hash 索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询等，这些弊端导致其不是常见的数据库索引。</p>
<h1 id="考点5-数据模型及其数据结构"><a href="#考点5-数据模型及其数据结构" class="headerlink" title="考点5:数据模型及其数据结构"></a>考点5:数据模型及其数据结构</h1><p>关系数据模型的基本数据结构是(    )</p>
<ul>
<li>A 树</li>
<li>B 图</li>
<li>C 索引</li>
<li>D 关系</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<p><strong>关系数据模型</strong>的逻辑结构是<strong>关系</strong><br><strong>层次数据模型</strong>的逻辑结构是<strong>树</strong><br><strong>网状数据结构</strong>的逻辑结构是<strong>图</strong></p>
<p>关系模型的数据结构是关系，数据的逻辑结构是二维表。</p>
<h1 id="考点6-SQL创建主键-SQL删除主键"><a href="#考点6-SQL创建主键-SQL删除主键" class="headerlink" title="考点6:SQL创建主键 SQL删除主键"></a>考点6:SQL创建主键 SQL删除主键</h1><p>下面Transact-SQL语句中可以用于创建主键的是()</p>
<ul>
<li>A <code>alter table table1 with notcheck add constraint [PK_table1] primary key nonclustered (column1) on primary;</code></li>
<li>B <code>alter table table1 column1 primary key;</code></li>
<li>C <code>alter table table1 column1;</code></li>
<li>D <code>create table table1 (column1 char(13) not null primary,column2 int not) on primary;</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h3 id="删除主键"><a href="#删除主键" class="headerlink" title="删除主键"></a>删除主键</h3><p>表中删除主键为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert <span class="keyword">table</span> table_test <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br></pre></td></tr></table></figure>
<h3 id="添加主键"><a href="#添加主键" class="headerlink" title="添加主键"></a>添加主键</h3><p>表中增加主键为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert <span class="keyword">table</span> table_test <span class="keyword">add</span> <span class="keyword">primary</span> key(id);</span><br></pre></td></tr></table></figure>
<p>注意<strong>add</strong>,B,C,D都没有add关键字，可以排除。</p>
<h1 id="考点7-分布式数据库系统DDBS"><a href="#考点7-分布式数据库系统DDBS" class="headerlink" title="考点7:分布式数据库系统DDBS"></a>考点7:分布式数据库系统DDBS</h1><p>在DDBS中,数据传输量是衡量查询时间的一个主要指标,导致数据传输量大的主要原因是( )。</p>
<ul>
<li>A 场地间距离过大</li>
<li>B 数据库的数据量大</li>
<li>C 不同场地间的联接操作</li>
<li>D 在<code>CPU</code>上处理通信的代价高</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>DDBS：<strong>Distributed DataBase System</strong> 分布式数据库系统</p>
<h1 id="考点8-数据库技术的根本目标"><a href="#考点8-数据库技术的根本目标" class="headerlink" title="考点8:数据库技术的根本目标"></a>考点8:数据库技术的根本目标</h1><p>数据库技术的根本目标是要解决数据的 ( ) 。</p>
<ul>
<li>A 存储问题</li>
<li>B 共享问题</li>
<li>C 安全问题</li>
<li>D 保护问题</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>数据库的直接目标是解决数据存储问题，根本目标是为了不同用户或应用程序之间的数据共享。</p>
<h1 id="考点9-视图可以从哪里导出"><a href="#考点9-视图可以从哪里导出" class="headerlink" title="考点9:视图可以从哪里导出"></a>考点9:视图可以从哪里导出</h1><p>视图是由下面哪两者导出的表()。</p>
<ul>
<li>A 模式、关系</li>
<li>B 基本表、视图</li>
<li>C 基本关系、关系</li>
<li>D 内模式、外模式</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>SQL中，<strong>内模式</strong>、<code>模式</code>、外模式分别对应<strong>存储文件</strong>、<code>基本表</code>、视图</p>
<h1 id="考点10-MySQL-SQL注入"><a href="#考点10-MySQL-SQL注入" class="headerlink" title="考点10:MySQL SQL注入"></a>考点10:MySQL SQL注入</h1><p>Mysql sql注入中使用延时注入时常用的语句是()</p>
<ul>
<li>A <code>wait for delay &#39;0:0:10</code></li>
<li>B <code>sleep(5)</code></li>
<li>C <code>benchmark(100000000,md5(1))</code></li>
<li>D <code>union select</code></li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<h3 id="函数注入"><a href="#函数注入" class="headerlink" title="函数注入"></a>函数注入</h3><table>
<thead>
<tr>
<th align="left">MySQL</th>
<th align="left">benchmark(100000,md5(1))或者sleep(5)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PostgreSQL</td>
<td align="left">PG_SLEEP(5)或者 GENERATE_SERIES(1,100000)</td>
</tr>
<tr>
<td align="left">MS SQL server</td>
<td align="left">WAITFOR DELAY ‘0:05’</td>
</tr>
</tbody></table>
<p><img data-src="https://uploadfiles.nowcoder.com/images/20180827/283950953_1535337015759_51B3875ECF358403950EB543513B2F00" alt="这里有一张图片"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/exam/4f99546e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/exam/images/avatar.png">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝的站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/exam/4f99546e/" class="post-title-link" itemprop="url">2021年09月05日 java3</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-05 16:09:22" itemprop="dateCreated datePublished" datetime="2021-09-05T16:09:22+08:00">2021-09-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-31 15:27:42" itemprop="dateModified" datetime="2021-12-31T15:27:42+08:00">2021-12-31</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">牛客网</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">专项练习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/Java/2021%E5%B9%B409%E6%9C%88/" itemprop="url" rel="index"><span itemprop="name">2021年09月</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/exam/4f99546e/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/exam/4f99546e/" data-xid="/exam/4f99546e/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="考点1-Java内存结构图"><a href="#考点1-Java内存结构图" class="headerlink" title="考点1:Java内存结构图"></a>考点1:Java内存结构图</h1><p>定义:<code>String s1 = &quot;uml&quot;; String s2 = &quot;uml&quot;; String s3= new String(&quot;uml&quot;); String s4= new String(&quot;uml&quot;);那么,s1==s2;s3 == s4;s1.equals(s3);</code>判断正确与否</p>
<ul>
<li>A <code>T,F,T</code></li>
<li>B <code>F,T,F</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>该题考察的是<strong>String类创建的对象在JVM中的内存分配</strong>和<strong>“<strong><strong>e</strong></strong>quals”与“==”的区别</strong>。</p>
<ul>
<li><p> “==”比较的是<strong>地址和值</strong>。</p>
</li>
<li><p> “equals”比较的是<strong>值</strong>。</p>
</li>
<li> <img data-src="https://uploadfiles.nowcoder.com/images/20190701/300975041_1561974792932_428A93CE2102F1DFD863C72B9733057F"></li>
<li><p> s1==s2，比较的是比较的是地址和值，由上图得知两个引用指向的是同一个地址，<strong>所以返回true.</strong></p>
</li>
<li><p> s3 == s4，比较的是两个new出来开辟的空间对象地址，所以地址不同，<strong>返回false.</strong></p>
</li>
<li><p> s1.equals(s3)，比较的是内容,<strong>返回true</strong>。</p>
</li>
</ul>
<p>==：比较两个引用的地址和值<br>equals：比较两个引用的值<br>1、s1==s2  true  s1和s2指向字符串常量池中同一个地址<br>2、s3 和 s4 都显示使用了new，是不同的对象，  当然不相等<br>3、s1 和 s3 的值都是 “uml”，当然相等<br><img data-src="https://uploadfiles.nowcoder.com/images/20190701/918861942_1561968854891_59B2900AA03CB2182A51CDB520B535B6"></p>
<h1 id="考点2-Applet"><a href="#考点2-Applet" class="headerlink" title="考点2:Applet"></a>考点2:Applet</h1><p>在 Applet 中,方法执行的顺序是 ?( )</p>
<ul>
<li>A <code>init(), start(), paint(),stop(),destroy().</code></li>
<li>B <code>init(),paint(),start(),stop(),destroy().</code></li>
<li>C <code>paint(),start(),stop(),destroy().</code></li>
<li>D <code>init(), start(),stop(),destroy(),paint().</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<h1 id="考点3-abstract和final矛盾"><a href="#考点3-abstract和final矛盾" class="headerlink" title="考点3:abstract和final矛盾"></a>考点3:abstract和final矛盾</h1><p>abstract和final可以同时作为一个类的修饰符。(  )</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>1、abstract期待子类扩展<br>2、final禁止扩展</p>
<h3 id="abstract和final矛盾"><a href="#abstract和final矛盾" class="headerlink" title="abstract和final矛盾"></a>abstract和final矛盾</h3><p>abstract修饰的类需要被继承，而final修饰的类不可被继承，自相矛盾。<br>拓展：<br>一、抽象类的使用原则如下：<br>（1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public；<br>（2）抽象类不能直接实例化，需要依靠子类采用向上转型的方式处理；<br>（3）抽象类必须有子类，使用extends继承，一个子类只能继承一个抽象类；<br>（4）子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。<br>二、final关键字：<br>（1）修饰变量 ： 变量不可修改；<br>（1）修饰方法 ： 方法不可重写；<br>（1）修饰类 ：类不可继承。</p>
<h1 id="考点4-常识"><a href="#考点4-常识" class="headerlink" title="考点4:常识"></a>考点4:常识</h1><p>Web客户端的编程语言JavaScript源自Java,其功能是Java SE的子集。</p>
<ul>
<li>A 对</li>
<li>B 错</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>


<h1 id="考点5-一切皆对象"><a href="#考点5-一切皆对象" class="headerlink" title="考点5:一切皆对象"></a>考点5:一切皆对象</h1><p>以下说法错误的是()</p>
<ul>
<li>A 数组是一个对象</li>
<li>B 数组不是一种原生类</li>
<li>C 数组的大小可以任意改变</li>
<li>D 在<code>Java</code>中,数组存储在堆中连续内存空间里</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p><strong>Java中数组是对象，不是基本数据类型（原生类），大小不可变且连续存储，因为是对象所以存在堆中。</strong></p>
<ol>
<li><strong>数组的创建使用了new关键字，所以数组是一个对象</strong></li>
<li>java数据类型分为基本数据类型（又叫原生类、内置类）和引用数据类型，数组是后者</li>
<li>数组在new的时候内存空间就已经分配好了，不允许改变</li>
<li>数组是一个对象，对象在内存中如何存放同样适用于数组</li>
</ol>
<p>原生类有8种：int 、double、 boolean 、float 、byte、 short 、long、 char 。数组是引用数据类型，不属于原生类。<br>数组长度在定义数组的时候就确定了，长度不可变，数组扩容需要使用函数ArrayCopy复制一个新数组<br>数组是对象，所以存在堆内存中。</p>
<h1 id="考点6-Hibernate"><a href="#考点6-Hibernate" class="headerlink" title="考点6:Hibernate"></a>考点6:Hibernate</h1><p>下面关于hibernate核心接口说明错误的是？</p>
<ul>
<li>A <code>Configuration</code> 接口:配置<code>Hibernate</code>,根据其启动<code>hibernate</code>,创建<code>SessionFactory</code> 对象</li>
<li>B <code>SessionFactory</code> 接口:负责保存、更新、删除、加载和查询对象,是线程不安全的,避免多个线程共享同一个<code>session</code>,是轻量级、一级缓存</li>
<li>C <code>Query</code> 和<code>Criteria</code> 接口:执行数据库的查询</li>
<li>D <code>Transaction</code> 接口:管理事务</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>B选项中应该是Session接口而不是SessionFactory接口<br>1，Configuration接口：配置Hibernate，根据其启动Hibernate，创建SessionFactory对象；<br>2，SessionFactory接口：初始化Hibernate，充当数据存储源的***，创建session对象，SessionFactory是<br>线程安全的，意味着它的同一个实例可以被应用的多个线程共享，是重量级二级缓存；<br>3，session接口：负责保存、更新、删除、加载和查询对象，是一个非线程安全的，避免多个线程共享一个session，是轻量级，一级缓存。<br>4，Transaction接口：管理事务。可以对事务进行提交和回滚；<br>5，Query和Criteria接口：执行数据库的查询。</p>
<h1 id="考点7-final成员变量不会默认初始化，必须手动初始化"><a href="#考点7-final成员变量不会默认初始化，必须手动初始化" class="headerlink" title="考点7:final成员变量不会默认初始化，必须手动初始化"></a>考点7:final成员变量不会默认初始化，必须手动初始化</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(++j + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>的输出是？</p>
<ul>
<li>A 0</li>
<li>B 1</li>
<li>C 2</li>
<li>D 不能执行,因为编译有错</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h3 id="final成员变量的初始化"><a href="#final成员变量的初始化" class="headerlink" title="final成员变量的初始化"></a>final成员变量的初始化</h3><p>final作为对象成员存在时，必须初始化；<br>1、定义时就初始化<br>2、先定义，后初始化。先定义，然后在构造函数中初始化话，或者在代码块中初始化。</p>
<figure class="highlight java"><figcaption><span>E:\dev2\workspace\NiKeTest\src\finaltest\FinalTest.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> finaltest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// final成员变量，定义的时候就赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 先定义，后赋值。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> num2;</span><br><span class="line">    <span class="comment">// 先定义，后赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> num3;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在代码块中初始化</span></span><br><span class="line">        num3 = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalTest</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在构造函数中初始化</span></span><br><span class="line">        <span class="keyword">this</span>.num2 = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FinalTest f1 = <span class="keyword">new</span> FinalTest(<span class="number">2</span>);</span><br><span class="line">        FinalTest f2 = <span class="keyword">new</span> FinalTest(<span class="number">100</span>);</span><br><span class="line">        System.out.println(f1.num1);</span><br><span class="line">        System.out.println(f1.num2);</span><br><span class="line">        System.out.println(f1.num3);</span><br><span class="line">        System.out.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">        System.out.println(f2.num1);</span><br><span class="line">        System.out.println(f2.num2);</span><br><span class="line">        System.out.println(f2.num3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">============================</span><br><span class="line">1</span><br><span class="line">100</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h4 id="final成员先定义后赋值的优点-不同的对象的final成员可以不一样"><a href="#final成员先定义后赋值的优点-不同的对象的final成员可以不一样" class="headerlink" title="final成员先定义后赋值的优点: 不同的对象的final成员可以不一样"></a>final成员先定义后赋值的优点: 不同的对象的final成员可以不一样</h4><p>从上面的代码中可以看出，定义final成员变量时不初始化，而在构造器中初始化的好处就在于。这个final成员的值是可变的。<br>如果在定义的时候就初始化，或者在代码块中初始化话。<br>所有的对象的这个final成员都是一样的，做不到不同的对象的final变量不一样这样的功能。</p>
<p>如果定义的时候没有赋值，并且没有构造器，则会在变量处显示错误提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The blank final field num2 may not have been initialized</span><br></pre></td></tr></table></figure>
<p>如果定义时，没有赋值，并且有构造器，则会在构造器处显示错误提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The blank final field num4 may not have been initialized</span><br></pre></td></tr></table></figure>


<h1 id="考点8-JDK1-7之前的抽象类和接口特性"><a href="#考点8-JDK1-7之前的抽象类和接口特性" class="headerlink" title="考点8:JDK1.7之前的抽象类和接口特性"></a>考点8:JDK1.7之前的抽象类和接口特性</h1><p>在jdk 1.7中,以下说法正确的是(    )。</p>
<ul>
<li>A <code>Java</code>中所有的非抽象方法都必须在类内定义</li>
<li>B <code>Java</code>中主方法可以不在类内定义,其他方法都必须定义在类内</li>
<li>C <code>Java</code>中主方法必须定义在类内,其他方法可以不必定义在类内</li>
<li>D <code>Java</code>中所有方法都不必在类内定义</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>我想这题纯粹是想考察JDK1.8和1.9的接口新特性（因为其提到JDK1.7）<br>JDK1.8接口可以定义default方法和static方法；<br>JDK1.9接口中可以定义私有方法。<br>因此在JDK1.7中，接口只能定义抽象方法，既Java中所有的非抽象方法都必须在类内定义。</p>
<h1 id="考点9-volatile关键字"><a href="#考点9-volatile关键字" class="headerlink" title="考点9:volatile关键字"></a>考点9:volatile关键字</h1><p>volatile关键字的说法错误的是</p>
<ul>
<li>A 能保证线程安全</li>
<li>B <code>volatile</code>关键字用在多线程同步中,可保证读取的可见性</li>
<li>C <code>JVM</code>保证从主内存加载到线程工作内存的值是最新的</li>
<li>D <code>volatile</code>能禁止进行指令重排序</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>出于运行速率的考虑，java编译器会把经常经常访问的变量放到缓存（严格讲应该是工作内存）中，读取变量则从缓存中读。但是在多线程编程中,内存中的值和缓存中的值可能会出现不一致。<br><strong>volatile用于限定变量只能从内存中读取，保证对所有线程而言，值都是一致的</strong>。<br><strong>但是volatile不能保证原子性，也就不能保证线程安全</strong>。</p>
<h3 id="1-java的内存模型"><a href="#1-java的内存模型" class="headerlink" title="1.java的内存模型"></a>1.java的内存模型</h3><p>java 内存模型规定了所有的变量都存储在主内存中，但是每个线程会有自己的工作内存，线程的工作内存保存了该线程中使用了的变量（从主内存中拷贝的），线程对变量的操作都必须在工作内存中进行，不同线程之间无法直接访问对方工作内存中的变量，线程间变量值从传递都要经过主内存完成</p>
 <img alt="图片说明" data-src="https://uploadfiles.nowcoder.com/images/20180827/9780880_1535335958506_5721C0ED3C89479FA5F09D1F8E722D00" title="图片标题">
 
<h3 id="2-什么是原子性"><a href="#2-什么是原子性" class="headerlink" title="2.什么是原子性"></a>2.什么是原子性</h3><p>一个操作是不可中断的，要么全部执行成功要么全部执行失败，比如银行转账</p>
<h3 id="3-什么是可见性"><a href="#3-什么是可见性" class="headerlink" title="3.什么是可见性"></a>3.什么是可见性</h3><p>当多个线程访问同一变量时，一个线程修改了这个变量的值，其他线程就能够立即看到修改的值</p>
<h3 id="4-什么是有序性"><a href="#4-什么是有序性" class="headerlink" title="4.什么是有序性"></a>4.什么是有序性</h3><p>程序执行的顺序按照代码的先后顺序执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>; <span class="comment">//1</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>; <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>像这2句代码1会比2先执行，但是jvm在正真执行时不一定是1在2之前，</p>
<p>这里涉及一个概念叫做指令重排，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>
<p>比如上面的代码语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。<br>在指令重排时会考虑指令之间的数据依赖性，比如2依赖了1的数值，那么处理器会保证1在2之前执行。</p>
<p>但是在多线程的情况下，指令重排就会有影响了。</p>
<h3 id="5-volatile功能-volatile到底做了什么"><a href="#5-volatile功能-volatile到底做了什么" class="headerlink" title="5.volatile功能 volatile到底做了什么"></a>5.volatile功能 volatile到底做了什么</h3><ul>
<li> 禁止了指令重排</li>
<li> 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量值，这个新值对其他线程是立即可见的</li>
<li> 不保证原子性（线程不安全）</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/exam/a1973542/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/exam/images/avatar.png">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝的站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/exam/a1973542/" class="post-title-link" itemprop="url">2021年09月05日 java1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-05 10:11:35" itemprop="dateCreated datePublished" datetime="2021-09-05T10:11:35+08:00">2021-09-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-31 15:27:40" itemprop="dateModified" datetime="2021-12-31T15:27:40+08:00">2021-12-31</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">牛客网</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">专项练习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/Java/2021%E5%B9%B409%E6%9C%88/" itemprop="url" rel="index"><span itemprop="name">2021年09月</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/exam/a1973542/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/exam/a1973542/" data-xid="/exam/a1973542/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="考点1-子类能访问父类的那些成员"><a href="#考点1-子类能访问父类的那些成员" class="headerlink" title="考点1:子类能访问父类的那些成员"></a>考点1:子类能访问父类的那些成员</h1><p>C#、JAVA)扩展方法能访问被扩展对象的public成员</p>
<ul>
<li>A 能</li>
<li>B 不能</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p><strong>翻译一下，子类方法是否能够访问父类中的public成员。</strong></p>
<h1 id="考点2-构造方法"><a href="#考点2-构造方法" class="headerlink" title="考点2:构造方法"></a>考点2:构造方法</h1><p>以下有关构造方法的说法,正确的是:()</p>
<ul>
<li>A 一个类的构造方法可以有多个</li>
<li>B 构造方法在类定义时被调用</li>
<li>C 构造方法只能由对象中的其他方法调用</li>
<li>D 构造方法可以和类同名,也可以和类名不同</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>A 一个类有多个构造方法便是重载的表现。<strong>重载参数列表不同</strong>。所以A是正确的。<br>B 构造方法是在对象<strong>创建时</strong>就被调用，用于初始化。<br>C 构造方法是给与之对应的对象进行初始化，初始化的动作只执行一次。<br>D 构造方法必须与所在类的名称同名。</p>
<p>B、构造器在对象被实例化的时候调用<br>C、构造方法不能由对象中的其他方法调用。都是new出来或者利用了反射。<br>D、构造方法必须与类同名，且没有返回值（不同于void）。</p>
<h1 id="考点3-线程执行体run-启动线程start"><a href="#考点3-线程执行体run-启动线程start" class="headerlink" title="考点3:线程执行体run() 启动线程start()"></a>考点3:线程执行体run() 启动线程start()</h1><p>以下哪个方法用于定义线程的执行体？</p>
<ul>
<li>A <code>start()</code></li>
<li>B <code>init()</code></li>
<li>C <code>run()</code></li>
<li>D <code>synchronized()</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>run()用于定义线程执行体，<br>start()用于启动线程</p>
<h1 id="考点4-重载"><a href="#考点4-重载" class="headerlink" title="考点4:重载"></a>考点4:重载</h1><p>对于同一类中的两个方法 , 在判断它们是不是重载方法时 , 肯定不考虑( )</p>
<ul>
<li>A 参数个数</li>
<li>B 参数类型</li>
<li>C 返回值类型</li>
<li>D 参数顺序</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>方法重写的注意事项：<br>构造方法不能被重写，不要问为什么？因为构造方法名必须和类名相同<br>private修饰的成员方法不能被重写<br><strong>static修饰的方法不能被重写</strong><br><strong>final修饰的方法不能被重写</strong><br>当子类重写了父类中的方法后，子类对象调用该方法时调用的是子类重写后的方法</p>
<h3 id="子类的实例方法不能重写父类的静态方法"><a href="#子类的实例方法不能重写父类的静态方法" class="headerlink" title="子类的实例方法不能重写父类的静态方法"></a>子类的实例方法不能重写父类的静态方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extendstest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 父类中的static方法</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Static method in parent class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 父类中的非static方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Non static method in parent class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 父类中的final方法</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finalMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Final method in parent class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 子类可以重写父类的protected 非static方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.nonStaticMethod();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 子类无法重写父类的static方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Static method in parent class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finalMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Final method in son class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类的staticMethod方法报错如下:</p>
<pre>
Multiple markers at this line
    - <mark>This instance method cannot override the static method from Father</mark>
    - overrides extendstest.Father.canYouSeeStatic
    - The method canYouSeeStatic() of type Son must override or implement a supertype method
</pre>

<p><strong>意思是子类的实例方法不能重写父类的静态方法</strong></p>
<p>给子类中的staticMethod加上static修饰符：</p>
<pre>
    // 子类无法重写父类的static方法
    @Override
    public <mark>static</mark> void staticMethod() {
        System.out.println("Static method in parent class");
    }
</pre>

<p>还是不可以重写，报错如下：</p>
<pre>
The method staticMethod() of type Son must override or implement a supertype method
</pre>

<p>子类的finalMethod方法报错如下：</p>
<pre>
Multiple markers at this line
    - <mark>Cannot override the final method from Parent</mark>
    - overrides extendstest.Parent.finalMethod
</pre>

<h3 id="可以定义与父类同名的Static方法"><a href="#可以定义与父类同名的Static方法" class="headerlink" title="可以定义与父类同名的Static方法"></a>可以定义与父类同名的Static方法</h3><p>去掉子类的staticMethod()方法上面的<code>@Override</code>，则不会报错。<br>这不是重写，无法实现多态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extendstest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 父类中的static方法</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Static method in parent class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 父类中的非static方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Non static method in parent class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 父类中的final方法</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finalMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Final method in parent class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Parent parent = <span class="keyword">new</span> Son();</span><br><span class="line">		<span class="comment">// 调用的还是父类的静态方法，不能实现多态</span></span><br><span class="line">		parent.staticMethod();</span><br><span class="line">		<span class="comment">// 调用的是子类的方法，多态</span></span><br><span class="line">		parent.nonStaticMethod();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 子类可以重写父类的protected 非static方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Static method in Son class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 子类无法重写父类的static方法</span></span><br><span class="line">	<span class="comment">// @Override</span></span><br><span class="line">	<span class="comment">// 子类可以定义与父类相同的静态方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Static method in Son class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Static method in parent class</span><br><span class="line">Static method in Son class</span><br></pre></td></tr></table></figure>
<h3 id="重写描述的是子类实例方法和父类实例方法的关系"><a href="#重写描述的是子类实例方法和父类实例方法的关系" class="headerlink" title="重写描述的是子类实例方法和父类实例方法的关系"></a>重写描述的是子类实例方法和父类实例方法的关系</h3><p>static定义的方法时类方法，通过类名调用。<br>上面的<code>parent.staticMethod();</code>调用实际上还是<code>类名.staticMethod();</code><br>也就是<code>Parent.staticMethod();</code>.所以不会去调用Son类中的同名方法。<br>如果非要调用子类的同名静态方法的话，需要改成:<code>Son.staticMethod()</code>。</p>
<h3 id="static方法如何实现”多态”"><a href="#static方法如何实现”多态”" class="headerlink" title="static方法如何实现”多态”"></a>static方法如何实现”多态”</h3><p>使用子类来调用覆盖的static方法，如果子类中有该静态方法，则执行子类的静态方法。<br>如果子类没有该静态方法，则去父类中查找静态方法，如果有则执行父类的静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extendstest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 父类中的static方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in parent class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类中的非static方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Non static method in parent class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类中的final方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finalMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Final method in parent class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        Parent parent = son;</span><br><span class="line">        <span class="comment">// 调用的还是父类的静态方法，不能实现多态</span></span><br><span class="line">        parent.staticMethod();</span><br><span class="line">        <span class="comment">// 调用的是子类的方法，多态</span></span><br><span class="line">        parent.nonStaticMethod();</span><br><span class="line">        <span class="comment">// 调用子类的静态方法，如果子类定义了该静态方法，</span></span><br><span class="line">        <span class="comment">// 则调用子类的，如果没有则去父类中查找</span></span><br><span class="line">        <span class="comment">// son.staticMethod();</span></span><br><span class="line">        Son.staticMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子类可以重写父类的protected 非static方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in Son class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类无法重写父类的static方法</span></span><br><span class="line">    <span class="comment">// @Override</span></span><br><span class="line">    <span class="comment">// 子类可以定义与父类相同的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in Son class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Static method in parent class</span><br><span class="line">Static method in Son class</span><br><span class="line">Static method in Son class</span><br></pre></td></tr></table></figure>
<p>此时Son类中重写了父类的静态方法，调用的是重写后的。<br>如果把Son类中的staticMethod方法注释掉。：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extendstest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 父类中的static方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in parent class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类中的非static方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Non static method in parent class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类中的final方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finalMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Final method in parent class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        Parent parent = son;</span><br><span class="line">        <span class="comment">// 调用的还是父类的静态方法，不能实现多态</span></span><br><span class="line">        parent.staticMethod();</span><br><span class="line">        <span class="comment">// 调用的是子类的方法，多态</span></span><br><span class="line">        parent.nonStaticMethod();</span><br><span class="line">        <span class="comment">// 调用子类的静态方法，如果子类定义了该静态方法，</span></span><br><span class="line">        <span class="comment">// 则调用子类的，如果没有则去父类中查找</span></span><br><span class="line">        <span class="comment">// son.staticMethod();</span></span><br><span class="line">        Son.staticMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子类可以重写父类的protected 非static方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in Son class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    // 子类无法重写父类的static方法</span></span><br><span class="line"><span class="comment">//    // @Override</span></span><br><span class="line"><span class="comment">//    // 子类可以定义与父类相同的静态方法</span></span><br><span class="line"><span class="comment">//    public static void staticMethod() &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;Static method in Son class&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Static method in parent class</span><br><span class="line">Static method in Son class</span><br><span class="line">Static method in parent class</span><br></pre></td></tr></table></figure>
<p>可以看到，此时调用了从父类继承得到的静态方法。</p>
<h3 id="static方法可以被继承-可以被覆盖-不能被重写"><a href="#static方法可以被继承-可以被覆盖-不能被重写" class="headerlink" title="static方法可以被继承 可以被覆盖 不能被重写"></a>static方法可以被继承 可以被覆盖 不能被重写</h3><p><strong>重写，说的是根据<code>运行时</code>的对象类型来决定调用哪个方法</strong>，而不是编译时类型。</p>
<p>因为无法使用<code>@Override</code>修饰，所以不是重写。</p>
<p>对于静态方法，我们不应该尝试去重写，而且调用时应该以类进行调用，而不是对象进行调用。</p>
<h3 id="问-static方法可以被重写吗？"><a href="#问-static方法可以被重写吗？" class="headerlink" title="问 static方法可以被重写吗？"></a>问 static方法可以被重写吗？</h3><p>答，static方法可以被子类继承，子类可以覆盖继承到的static方法。但是这不叫重写。<br>因为如果你在同名的static方法上写上@Override注解，编译器会报错。</p>
<p>重写是为了实现多态，多态是<strong>在运行的时候</strong>根据对象的类型来调用方法的。<br>如果使用了静态方法，那么在<strong>编译期间</strong>，就知道调用的是那个静态方法了，这不符合多态的定义。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/df43f5500ea3">https://www.jianshu.com/p/df43f5500ea3</a><br>静态方法从程序开始运行后就已经分配了内存，也就是说已经写死了。所有引用到该方法的对象（父类的对象也好子类的对象也好）所指向的都是同一块内存中的数据，也就是该静态方法。<strong>子类中如果定义了相同名称的静态方法，并不会重写，而应该是在内存中又分配了一块给子类的静态方法，没有重写这一说</strong>。</p>
</blockquote>
<h1 id="考点5-不懂的点：JVM"><a href="#考点5-不懂的点：JVM" class="headerlink" title="考点5:不懂的点：JVM"></a>考点5:不懂的点：JVM</h1><p>off-heap是指那种内存()</p>
<ul>
<li>A <code>JVM GC</code>能管理的内存</li>
<li>B <code>JVM</code>进程管理的内存</li>
<li>C 在<code>JVM</code>老年代内存区</li>
<li>D 在<code>JVM</code>新生代内存</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h3><p>off-heap叫做堆外内存，将你的对象从堆中脱离出来序列化，然后存储在一大块内存中，这就像它存储到磁盘上一样，但它仍然在RAM中。<br>对象在这种状态下不能直接使用，它们必须首先反序列化，也不受垃圾收集。<br>序列化和反序列化将会影响部分性能（所以可以考虑使用FST-serialization）使用堆外内存能够降低GC导致的暂停。<br>堆外内存不受垃圾收集器管理，也不属于老年代，新生代。</p>
<p><strong>堆外内存意味着把内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机）</strong>。<strong>不属于老年代和新生代。</strong></p>
<p><strong>JVM GC回收堆和方法区，排除法选择 B</strong></p>
<p>这样做的结果就是能保持一个较小的堆，以减少垃圾收集对应用的影响。</p>
<p>使用堆外内存能够降低GC导致的暂停。</p>
<p>堆外内存，它和内存池一样，也能缩短垃圾回收时间，但是它适用的对象和内存池完全相反。<br>内存池往往适用于生命期较短的可变对象，而生命期中等或较长的对象，正是堆外内存要解决的。</p>
<h4 id="堆外内存的特点"><a href="#堆外内存的特点" class="headerlink" title="堆外内存的特点"></a>堆外内存的特点</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/universe_ant/article/details/52145450">https://blog.csdn.net/universe_ant/article/details/52145450</a><br>堆外内存有以下特点：</p>
<ul>
<li>对于大内存有良好的伸缩性</li>
<li>对垃圾回收停顿的改善可以明显感觉到</li>
<li>在进程间可以共享，减少虚拟机间的复制</li>
</ul>
<p>当然堆外内存也有它自己的问题，</p>
<ul>
<li>最大的问题就是你的数据结构变得不那么直观，如果数据结构比较复杂，就要对它进行串行化（serialization），而串行化本身也会影响性能。</li>
<li>另一个问题是由于你可以使用更大的内存，你可能开始担心虚拟内存（即硬盘）的速度对你的影响了。</li>
</ul>
<h3 id="1）程序计数器"><a href="#1）程序计数器" class="headerlink" title="1）程序计数器"></a>1）程序计数器</h3><p>几乎不占有内存。用于取下一条执行的指令。</p>
<h3 id="2）堆"><a href="#2）堆" class="headerlink" title="2）堆"></a>2）堆</h3><p>所有通过new创建的对象的内存都在堆中分配，其大小可以通过-Xmx和-Xms来控制。<br>堆被划分为新生代和旧生代，<br>新生代又被进一步划分为Eden和Survivor区，最后Survivor由FromSpace和ToSpace组成，结构图如下所示：</p>
<p>新生代。新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中，新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例旧生代。用于存放新生代中经过多次垃圾回收仍然存活的对象。</p>
<img data-src="https://uploadfiles.nowcoder.com/images/20191224/337184788_1577191659133_DB86032511CDC329D42FB2BB8831615C">

<h3 id="3）栈"><a href="#3）栈" class="headerlink" title="3）栈"></a>3）栈</h3><p>每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果。</p>
<h3 id="4）本地方法栈"><a href="#4）本地方法栈" class="headerlink" title="4）本地方法栈"></a>4）本地方法栈</h3><p>用于支持native方法的执行，存储了每个native方法调用的状态</p>
<h3 id="5）方法区"><a href="#5）方法区" class="headerlink" title="5）方法区"></a>5）方法区</h3><p>存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。<br>JVM用永久代（PermanetGeneration）来存放方法区，（在JDK的HotSpot虚拟机中，可以认为方法区就是永久代，但是在其他类型的虚拟机中，没有永久代的概念，有关信息可以看周志明的书）可通过-XX:PermSize和-XX:MaxPermSize来指定最小值和最大值。</p>
<h1 id="考点6-异常处理机制"><a href="#考点6-异常处理机制" class="headerlink" title="考点6:异常处理机制"></a>考点6:异常处理机制</h1><p>java关于异常处理机制的叙述哪些正确</p>
<ul>
<li>A <code>catch</code>部分捕捉到异常情况时,才会执行<code>finally</code>部分</li>
<li>B 当<code>try</code>区段的程序发生异常时,才会执行<code>catch</code>区段的程序</li>
<li>C 在<code>try</code>区段不论程序是否发生异常及捕获到异常,都会执行<code>finally</code>部分</li>
<li>D 以上都是</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<h3 id="finally不执行情况"><a href="#finally不执行情况" class="headerlink" title="finally不执行情况"></a>finally不执行情况</h3><p>try块执行时，finally表示总是执行。但是</p>
<ol>
<li>在try中调用System.exit(0)，强制退出了程序，finally块不执行。</li>
<li>在进入try块前，出现了异常，此时try没有执行，finally块不执行。</li>
</ol>
<h1 id="考点7-面向对象三大特性"><a href="#考点7-面向对象三大特性" class="headerlink" title="考点7:面向对象三大特性"></a>考点7:面向对象三大特性</h1><p>面向对象的程序设计语言具有()等共同特性。</p>
<ul>
<li>A 封装性</li>
<li>B 多态性</li>
<li>C 简单性</li>
<li>D 复杂性</li>
<li>E 继承性</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABE</details>

<h3 id="面向对象OOP三大特性："><a href="#面向对象OOP三大特性：" class="headerlink" title="面向对象OOP三大特性："></a>面向对象OOP三大特性：</h3><ul>
<li>继承</li>
<li>封装</li>
<li>多态</li>
</ul>
<p>准确来说，基于对象和面向对象是有区别的。<br><strong>基于对象是封装和继承</strong>。<br><strong>面向对象是封装、继承和多态</strong>。<br>详见 <a href="https://blog.csdn.net/jiaruitao777/article/details/99098027" target="_blank">https://blog.csdn.net/jiaruitao777/article/details/99098027</a></p>
<h1 id="考点8-IO流-字符流字节流"><a href="#考点8-IO流-字符流字节流" class="headerlink" title="考点8:IO流 字符流字节流"></a>考点8:IO流 字符流字节流</h1><p>下面哪个流类不属于面向字符的流()</p>
<ul>
<li>A <code>BufferedWriter</code></li>
<li>B <code>FileInputStream</code></li>
<li>C <code>ObjectInputStream</code></li>
<li>D <code>InputStreamReader</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<p>既然是字符流，那么一般是reader和writer结尾。<br>Stream结尾的是字节，Reader结尾的是字符</p>
<p>面向字符的输入流类都是Reader的子类，<img data-src="https://uploadfiles.nowcoder.com/images/20190603/652334996_1559537222061_12B6233B6EA3C9956865918F5E9B7240"></p>
<p>面向字符的输出流都是类 Writer 的子类<img data-src="https://uploadfiles.nowcoder.com/images/20190603/652334996_1559537178275_256EC3581646F19915DBB5C9F4D80330"></p>
<img data-src="https://uploadfiles.nowcoder.com/images/20200805/643412545_1596634989327_DEF638F8839D3C558612E08DC0A11BFF">



<h1 id="考点9-堆存放对象-栈存放程序"><a href="#考点9-堆存放对象-栈存放程序" class="headerlink" title="考点9:堆存放对象 栈存放程序"></a>考点9:堆存放对象 栈存放程序</h1><p>程序中常采用变量表示数据,变量具有名、地址、值、作用域、生存期等属性。关于变量的叙述,()是正确的。</p>
<ul>
<li>A 根据作用域规则,在函数中定义的变量只能在函数中引用</li>
<li>B 在函数中定义的变量,其生存期为整个程序执行期间</li>
<li>C 在函数中定义的变量不能与其所在函数的形参同名</li>
<li>D 在函数中定义的变量,其存储单元在内存的栈区</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details>

<p>这里主要说明D为什么是对的</p>
<p>首先说明栈内存和堆内存里存放的是什么</p>
<ul>
<li> 栈内存中存放函数中定义的一些基本类型的变量和对象的引用变量；</li>
<li> <strong>堆内存中存放new创建的</strong>对象和数组。</li>
</ul>
<p>简单的来说，<strong>堆主要是用来存放对象的，栈主要是用来执行程序的</strong></p>
<p>这么做是因为</p>
<ul>
<li> 栈的存取速度快，栈数据可以共享，但是栈中的数据大小和生存期必须确定，缺乏灵活性中存放一些基本类型的对象和对象句柄</li>
<li> 堆是操作系统分配给自己内存，由于从操作系统管理的内存分配，所以再分配和销毁时都需要占用时间，因此用堆的效率非常低，但是优点在于编译器不需要指导从堆里分配多少存储控件，也不需要知道存储的数据要再堆里停留多长事件，因此用堆保存数据时会得到更大的灵活性 </li>
</ul>
<p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wangbo1998/article/details/80379016">https://blog.csdn.net/wangbo1998/article/details/80379016</a></p>
<p>D选项不太严谨，如果定义的是引用类型变量，且没有通过逃逸分析，则可能会被分配到堆中，逃逸分析是jdk1.8默认开启的</p>
<p>D选项我给大家说明一下，我觉得题出的不严谨，如果方法中有引用类型的变量，那么存储是在堆中，引用在栈中</p>
<h1 id="考点10-身份证号的正则表达式"><a href="#考点10-身份证号的正则表达式" class="headerlink" title="考点10:身份证号的正则表达式"></a>考点10:身份证号的正则表达式</h1><p><strong>多选题</strong><br>关于身份证号,以下正确的正则表达式为(      )</p>
<ul>
<li>A <code>isIDCard=/^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$/;</code></li>
<li>B <code>isIDCard=/^[1-9]\d&#123;7&#125;((9\d)|(1[0-2]))(([0|1|2]\d)|3[9-1])\d&#123;3&#125;$/;</code></li>
<li>C <code>isIDCard=/^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;4&#125;$/;</code></li>
<li>D <code>isIDCard=/^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((9\d)|(1[9-2]))(([0|1|2]\d)|3[9-1])\d&#123;4&#125;$/;</code></li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

<h3 id="身份证构成"><a href="#身份证构成" class="headerlink" title="身份证构成"></a>身份证构成</h3><p>15位身份证的构成：六位出生地区码+六位出身日期码+三位顺序码<br>18位身份证的构成：六位出生地区码+八位出生日期码+三位顺序码+一位校验码</p>
<p>A选项<br><strong>^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$</strong></p>
<ul>
<li><code>[1-9]\d&#123;7&#125;</code>，有8位，其中前六位是地址码，后两位是年份，00~99年。</li>
<li><code>((0\d)|(1[0-2]))</code>,有两位，表示月份，第一个括号范围位00<del>09，第二个括号的范围位10</del>12，综合得到00~12，符合月份的定义。</li>
<li><code>(([0|1|2]\d)|3[0-1])</code>,有两位，表示日期，第一个括号的范围位00<del>09或者10</del>19或者20<del>29，第2个括号的范围位30</del>31，综合得到00~31，符合月份的定义。这个其实也不严谨，例如2月份，只有28天，或29天。</li>
<li><code>\d&#123;3&#125;</code>有三位，表示顺序码</li>
</ul>
<p>B选项<br><strong>^[1-9]\d{7}((9\d)|(1[0-2]))(([0|1|2]\d)|3[9-1])\d{3}$</strong></p>
<ul>
<li><code>[1-9]\d&#123;7&#125;</code>，有8位，其中前六位是地址码，后两位是年份，00~99年。</li>
<li><code>((9\d)|(1[0-2]))</code>，有两位，表示月份，第一个括号的范围位90~99，一年只有12个月份，没有90月份，更没有99月份，B选项排除。</li>
</ul>
<p>C选项的<br><strong>^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$</strong></p>
<ul>
<li><code>[1-9]\d&#123;5&#125;</code>这六位，表示六位出生地码，<ul>
<li><strong>^<mark>[1-9]\d{5}</mark>[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$</strong></li>
</ul>
</li>
<li><code>[1-9]\d&#123;3&#125;</code>这四位，表示年<ul>
<li><strong>^[1-9]\d{5}<mark>[1-9]\d{3}</mark>((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$</strong></li>
</ul>
</li>
<li><code>((0\d)|(1[0-2]))</code>这两位表示，月份，从第一个括号匹配<code>00~09</code>。第二个括号匹配<code>10~12</code>。<ul>
<li><strong>^[1-9]\d{5}[1-9]\d{3}<mark>((0\d)|(1[0-2]))</mark>(([0|1|2]\d)|3[0-1])\d{4}$</strong></li>
<li>所以月份共计匹配范围：<code>00~12</code>符合月份00~12的定义。</li>
</ul>
</li>
<li><code>(([0|1|2]\d)|3[0-1])</code>这两位表示日期，第一个括号匹配00<del>09,10</del>19,20<del>29。第二个括号匹配30</del>31。<ul>
<li><strong>^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))<mark>(([0|1|2]\d)|3[0-1])</mark>\d{4}$</strong></li>
<li>所以日期总计匹配范围：00~31,符合日期的定义。</li>
</ul>
</li>
<li><code>\d&#123;4&#125;</code>,表示匹配三位顺序吗+一位校验码。校验码有字母，这里显然不能完全匹配，勉强认为校验码都是数字吧。<ul>
<li><strong>^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])<mark>\d{4}</mark>$</strong></li>
</ul>
</li>
</ul>
<p>D选项<br><strong>^[1-9]\d{5}[1-9]\d{3}((9\d)|(1[9-2]))(([0|1|2]\d)|3[9-1])\d{4}$</strong></p>
<ul>
<li><code>[1-9]\d&#123;5&#125;</code>,六位地址码</li>
<li><code>[1-9]\d&#123;3&#125;</code>,四位年，1000~9999</li>
<li><code>((9\d)|(1[9-2]))</code>,表示月份，<code>9\d</code>的范围位<code>90~99</code>,一年最多有12个月，没有90个月，更没有99个月。所以D选项错误。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/exam/5eb758f5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/exam/images/avatar.png">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝的站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/exam/5eb758f5/" class="post-title-link" itemprop="url">2021年09月04日 java</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-04 20:32:30" itemprop="dateCreated datePublished" datetime="2021-09-04T20:32:30+08:00">2021-09-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-26 20:11:41" itemprop="dateModified" datetime="2021-12-26T20:11:41+08:00">2021-12-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">牛客网</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">专项练习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/Java/2021%E5%B9%B409%E6%9C%88/" itemprop="url" rel="index"><span itemprop="name">2021年09月</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/exam/5eb758f5/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/exam/5eb758f5/" data-xid="/exam/5eb758f5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="考点1-访问控制权限修饰符"><a href="#考点1-访问控制权限修饰符" class="headerlink" title="考点1:访问控制权限修饰符"></a>考点1:访问控制权限修饰符</h1><p>下列修饰符中与访问控制权限无关的是？( )</p>
<ul>
<li>A <code>private</code></li>
<li>B <code>public</code></li>
<li>C <code>protected</code></li>
<li>D <code>final</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h3 id="java常见修饰符"><a href="#java常见修饰符" class="headerlink" title="java常见修饰符"></a>java常见修饰符</h3><h4 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h4><p>private: 修饰私有变量<br>默认修饰符default（不用把default写出来）： 比private限制更少，但比protected限制更多<br>protected: 修饰受保护变量<br>public: 修饰公有变量 </p>
<h4 id="状态修饰符"><a href="#状态修饰符" class="headerlink" title="状态修饰符"></a>状态修饰符</h4><p>final 最终变量（final修饰类，该类不能被继承，final修饰方法，该方法不能被重写，final修饰变量，该变量不能被重新赋值（相当于常量））<br>static 静态变量（随着类的加载而加载，优先于对象存在，被所有对象所共享，可以通过类名调用）</p>
<h4 id="抽象修饰符"><a href="#抽象修饰符" class="headerlink" title="抽象修饰符"></a>抽象修饰符</h4><p>abstract 抽象类&amp;抽象方法（抽象类不能被实例化，抽象类中不一定有抽象方法，但有抽象方法的类必须定义为抽象类）</p>
<h1 id="考点2-main方法"><a href="#考点2-main方法" class="headerlink" title="考点2:main方法"></a>考点2:main方法</h1><p>Java Application 中的主类需包含main方法,以下哪项是main方法的正确形参？(    )</p>
<ul>
<li>A <code>String args</code></li>
<li>B <code>String[] args</code></li>
<li>C <code>Char arg</code></li>
<li>D <code>StringBuffer[] args</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>


<h1 id="考点3-重载"><a href="#考点3-重载" class="headerlink" title="考点3:重载"></a>考点3:重载</h1><p>类 ABC 定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABC</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将以下哪个方法插入行 3 是不合法的。()</p>
<ul>
<li>A <code>public float max(float a, float b, float c)&#123; &#125;</code></li>
<li>B <code>public double max (double c, double d)&#123; &#125;</code></li>
<li>C <code>public float max(float a, float b)&#123; &#125;</code></li>
<li>D <code>private int max(int a, int b, int c)&#123; &#125;</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="重载要求：两同一不同"><a href="#重载要求：两同一不同" class="headerlink" title="重载要求：两同一不同"></a>重载要求：两同一不同</h3><p><strong>重载要求方法的参数列表需要不一样</strong>（个数，或者参数类型），修改参数名或者修改返回值以及访问权限并没有用</p>
<h1 id="考点4-异常try-catch-finally执行流程"><a href="#考点4-异常try-catch-finally执行流程" class="headerlink" title="考点4:异常try-catch-finally执行流程"></a>考点4:异常try-catch-finally执行流程</h1><p>AccessViolationException异常触发后,下列程序的输出结果为(      )</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(string[] args)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">try</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AccessViolationException();  </span><br><span class="line">        Console.WriteLine(<span class="string">&quot;error1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">catch</span> (Exception e)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Console.WriteLine(<span class="string">&quot;error2&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;error3&quot;</span>);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>A <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error2</span><br><span class="line">error3</span><br></pre></td></tr></table></figure></li>
<li>B <code>error3</code></li>
<li>C <code>error2</code></li>
<li>D <code>error1</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h1 id="考点5-集合HashMap的key和value可以为null-放入时如果key相同-则新value覆盖旧的value"><a href="#考点5-集合HashMap的key和value可以为null-放入时如果key相同-则新value覆盖旧的value" class="headerlink" title="考点5:集合HashMap的key和value可以为null,放入时如果key相同,则新value覆盖旧的value"></a>考点5:集合HashMap的key和value可以为null,放入时如果key相同,则新value覆盖旧的value</h1><p>以下java程序代码,执行后的结果是()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.HashMap map=<span class="keyword">new</span> java.util.HashMap();</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">System.out.println(map.size());</span><br></pre></td></tr></table></figure>
<ul>
<li>A 0</li>
<li>B <code>null</code></li>
<li>C 1</li>
<li>D 2</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<ul>
<li>HashMap可以插入null的key或value。</li>
<li>插入的时候，检查是否已经存在相同的key，<ul>
<li>如果不存在，则直接插入，</li>
<li>如果存在，则用新的value替换旧的value。<br>在本题中，第一条put语句，会将key/value对插入HashMap，而第二条put，因为已经存在一个key为name的项，所以会用新的value替换旧的value，<br>因此，两条put之后，HashMap中只有一个key/value键值对。那就是（name，jack）。所以，size为1.</li>
</ul>
</li>
</ul>
<h1 id="考点6-boolean变量只能和boolean变量比较"><a href="#考点6-boolean变量只能和boolean变量比较" class="headerlink" title="考点6:boolean变量只能和boolean变量比较"></a>考点6:boolean变量只能和boolean变量比较</h1><p>已知<code>boolean result = false</code>,则下面哪个选项是合法的:</p>
<ul>
<li>A <code>result=1</code></li>
<li>B <code>result=true;</code></li>
<li>C <code>if(result!=0) &#123;//so something…&#125;</code></li>
<li>D <code>if(result) &#123;//do something…&#125;</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BD</details>


<p>1、boolean类型只有两个直接量值:true和false.<br>2、除成员变量会有默认初始值外，其他变量必须在第一次使用之前初始化</p>
<p>boolean类型的默认值是false;</p>
<h3 id="基本数据类型的默认值（成员变量）"><a href="#基本数据类型的默认值（成员变量）" class="headerlink" title="基本数据类型的默认值（成员变量）"></a>基本数据类型的默认值（成员变量）</h3><p>其余的7种基本类型默认值：<br>byte是 (byte)0；<br>short是 (short)0；<br>int是 0；<br>long是 0L；<br>float 是0.0f；<br>double 是0.0d；<br>char是 \u0000.<br>String是null.</p>
<h1 id="考点7-java关键字和常量"><a href="#考点7-java关键字和常量" class="headerlink" title="考点7:java关键字和常量"></a>考点7:java关键字和常量</h1><p>下列不是 Java 关键字的是 ( )</p>
<ul>
<li>A <code>abstract</code></li>
<li>B <code>false</code></li>
<li>C <code>native</code></li>
<li>D <code>sizeof</code></li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BD</details>


<h3 id="Java中的关键字有哪些"><a href="#Java中的关键字有哪些" class="headerlink" title="Java中的关键字有哪些"></a>Java中的关键字有哪些</h3><p>答：1）48个关键字：<code>abstract</code>、<code>assert</code>、<code>boolean</code>、<code>break</code>、<code>byte</code>、<code>case</code>、<code>catch</code>、<code>char</code>、<code>class</code>、<code>continue</code>、<code>default</code>、<code>do</code>、<code>double</code>、<code>else</code>、<code>enum</code>、<code>extends</code>、<code>final</code>、<code>finally</code>、<code>float</code>、<code>for</code>、<code>if</code>、<code>implements</code>、<code>import</code>、<code>int</code>、<code>interface</code>、<code>instanceof</code>、<code>long</code>、<code>native</code>、<code>new</code>、<code>package</code>、<code>private</code>、<code>protected</code>、<code>public</code>、<code>return</code>、<code>short</code>、<code>static</code>、<code>strictfp</code>、<code>super</code>、<code>switch</code>、<code>synchronized</code>、<code>this</code>、<code>throw</code>、<code>throws</code>、<code>transient</code>、<code>try</code>、<code>void</code>、<code>volatile</code>、<code>while</code>。 </p>
<h3 id="Java保留字"><a href="#Java保留字" class="headerlink" title="Java保留字"></a>Java保留字</h3><p>2）2个保留字（现在没用以后可能用到作为关键字）：<code>goto</code>、<code>const</code>。</p>
<h3 id="Java特殊直接量-Java常量"><a href="#Java特殊直接量-Java常量" class="headerlink" title="Java特殊直接量 Java常量"></a>Java特殊直接量 Java常量</h3><p>3）3个特殊直接量：<code>true</code>、<code>false</code>、<code>null</code>。</p>
<h1 id="考点8-暂时不懂：Jvm垃圾回收"><a href="#考点8-暂时不懂：Jvm垃圾回收" class="headerlink" title="考点8:暂时不懂：Jvm垃圾回收"></a>考点8:暂时不懂：Jvm垃圾回收</h1><p>以下哪些jvm的垃圾回收方式采用的是复制算法回收</p>
<ul>
<li>A 新生代串行收集器</li>
<li>B 老年代串行收集器</li>
<li>C 并行收集器</li>
<li>D 新生代并行回收收集器</li>
<li>E 老年代并行回收收集器</li>
<li>F <code>cms</code>收集器</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details>



<p>答案AD<br>新生代串行收集/并行回收器：复制算法；<br>老年代串行收集/并行回收器：标记-压缩算法；<br>并行收集器：将串行收集器多线程化，回收策略和串行收集器一致，因此该收集器是新生代为复制算法，老年代为标记-压缩算法。<br>CMS收集器：Concurrent Mark Sweep,从名字就能知道使用的是多线程的标记-清除算法。</p>
<p>在垃圾的分代回收机制中<br>新生代一般采用“复制”算法：因为新生代每次都有大批量对象死去，就以少量对象的复制成本完成收集<br>老年代一般采用“标记-整理/清除”算法：因为对象存活率高，且没有额外内存，故采用“标记-整理”或者“标记-清除”</p>
<h3 id="两个最基本的java回收算法：复制算法和标记清理算法"><a href="#两个最基本的java回收算法：复制算法和标记清理算法" class="headerlink" title="两个最基本的java回收算法：复制算法和标记清理算法"></a>两个最基本的java回收算法：复制算法和标记清理算法</h3><p>复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为<strong>新生代最常用的算法</strong><br>标记清理：一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出 标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象</p>
<h3 id="两个概念：新生代和年老代"><a href="#两个概念：新生代和年老代" class="headerlink" title="两个概念：新生代和年老代"></a>两个概念：新生代和年老代</h3><p>新生代：初始对象，生命周期短的<br>永久代：长时间存在的对象</p>
<p>整个java的垃圾回收是新生代和年老代的协作，这种叫做<strong>分代回收</strong>。<br>P.S：Serial New收集器是针对新生代的收集器，采用的是复制算法<br>Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理<br>Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法<br>Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理<br>Parallel Old（并行）收集器，针对老年代，标记整理 CMS收集器，基于标记清理<br>G1收集器：整体上是基于标记 整理 ，局部采用复制</p>
<p><strong>综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理</strong>。</p>
<h1 id="考点9-int赋值给Integer时自动装箱-Integer自动装箱时-128-127范围内使用缓存数组中的值-Integer和int比较时自动拆箱然后比较值"><a href="#考点9-int赋值给Integer时自动装箱-Integer自动装箱时-128-127范围内使用缓存数组中的值-Integer和int比较时自动拆箱然后比较值" class="headerlink" title="考点9:int赋值给Integer时自动装箱 Integer自动装箱时-128~+127范围内使用缓存数组中的值 Integer和int比较时自动拆箱然后比较值"></a>考点9:int赋值给Integer时自动装箱 Integer自动装箱时-128~+127范围内使用缓存数组中的值 Integer和int比较时自动拆箱然后比较值</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer a1=<span class="number">17</span>,b2=<span class="number">17</span>;</span><br><span class="line">Integer b1=<span class="number">2017</span>,b2=<span class="number">2017</span>;</span><br><span class="line">Integer c1=<span class="keyword">new</span> Integer(<span class="number">17</span>);</span><br><span class="line">Integer c2=<span class="keyword">new</span> Integer(<span class="number">17</span>);</span><br><span class="line">Integer d1=<span class="keyword">new</span> Integer(<span class="number">2017</span>);</span><br><span class="line"><span class="keyword">int</span> d2=<span class="number">2017</span>;</span><br></pre></td></tr></table></figure>
<p>以下语句返回值为 true 的2是()</p>
<ul>
<li>A <code>a1==a2</code></li>
<li>B <code>d1==d2</code></li>
<li>C <code>b1==b2</code></li>
<li>D <code>c1==c2</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AB</details>

<h3 id="Integer缓存-128到-127"><a href="#Integer缓存-128到-127" class="headerlink" title="Integer缓存-128到+127"></a>Integer缓存-128到+127</h3><p>选<strong>A,B</strong>. Integer a1 = 17; 语句执行的是valueOf()方法</p>
<figure class="highlight java"><figcaption><span>G:\java\java8\jdk-8u221\src.zip!\java\lang\Integer.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p><strong>对于-128到127之间的数, Integer直接从数组中取</strong>, 故a1, a2指向的是同一个对象, A正确. </p>
<p>其余都是new出来的对象, 显然地址都不相同.</p>
<h3 id="int与Integer比较时-只比较值"><a href="#int与Integer比较时-只比较值" class="headerlink" title="int与Integer比较时 只比较值"></a>int与Integer比较时 只比较值</h3><p>int类型与Integer类型比较时, 先将Integer拆箱, 再比较值, 故B正确.</p>
<h1 id="考点10-正则表达式身份证号"><a href="#考点10-正则表达式身份证号" class="headerlink" title="考点10:正则表达式身份证号"></a>考点10:正则表达式身份证号</h1><p>关于身份证号,以下正确的正则表达式为(      )</p>
<ul>
<li>A <code>isIDCard=/^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$/;</code></li>
<li>B <code>isIDCard=/^[1-9]\d&#123;7&#125;((9\d)|(1[0-2]))(([0|1|2]\d)|3[9-1])\d&#123;3&#125;$/;</code></li>
<li>C <code>isIDCard=/^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;4&#125;$/;</code></li>
<li>D <code>isIDCard=/^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((9\d)|(1[9-2]))(([0|1|2]\d)|3[9-1])\d&#123;4&#125;$/;</code></li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

<p>正确选项<br>A选项：<code>isIDCard=/^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$/</code><br>C选项：<code>isIDCard=/^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;4&#125;$/</code></p>
<h3 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h3><p><code>^</code>：起始符号，<code>^x</code>表示以x开头<br><code>$</code>：结束符号，<code>x$</code>表示以x结尾<br><code>[n-m]</code>：表示从n到m的数字<br><code>\d</code>：表示数字，等同于<code>[0-9]</code><br><code>X&#123;m&#125;</code>：表示由m个X字符构成，<code>\d&#123;4&#125;</code>表示4位数字</p>
<h3 id="身份证构成-15位-18位"><a href="#身份证构成-15位-18位" class="headerlink" title="身份证构成 15位 18位"></a>身份证构成 15位 18位</h3><p>15位身份证的构成：六位出生地区码+六位出身日期码+三位顺序码<br>18位身份证的构成：六位出生地区码+八位出生日期码+三位顺序码+一位校验码</p>
<p>C选项的构成：<br><code>[1-9]\d&#123;5&#125;</code>：六位出生地区码，出生地区码没有以0开头，因此第一位为<code>[1-9]</code>。<br><code>[1-9]\d&#123;3</code>}：八位出生日期码的四位年份，同样年份没有以0开头。<br><code>((0\d)|(1[0-2]))</code>：八位出生日期码的两位月份，<code>|</code> 表示或者，月份的形式为<code>0\d</code>或者是<code>10</code>、<code>11</code>、<code>12</code>。<br><code>(([0|1|2]\d)|3[0-1])</code>：八位出生日期码的两位日期，日期由01至31。<br><code>\d&#123;4&#125;</code>：三位顺序码+一位校验码，共四位。</p>
<p>A选项的构成：<br><code>[1-9]\d&#123;7&#125;</code>：六位出生地区码+两位出生日期码的年份，这里的年份指后两位，因此没有第一位不能为0的限制，所以合并了。<br>后面的与C选项类似了。<br>好吧其实我也是第一次知道身份证还有15位的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/exam/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/exam/">1</a><span class="space">&hellip;</span><a class="page-number" href="/exam/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/exam/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/exam/page/15/">15</a><a class="extend next" rel="next" href="/exam/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蓝蓝</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">507k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">7:41</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/exam/js/comments.js"></script><script src="/exam/js/utils.js"></script><script src="/exam/js/motion.js"></script><script src="/exam/js/next-boot.js"></script><script src="/exam/js/bookmark.js"></script><script src="/exam/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/exam/js/third-party/search/local-search.js"></script>



  <script src="/exam/js/third-party/fancybox.js"></script>

  <script src="/exam/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/exam/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://lanlan2017.github.io/exam/page/4/"}</script>
  <script src="/exam/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":null,"enable":true,"serverURL":"https://waline-test-mzjszagu6-lanlan2017.vercel.app","placeholder":"Just go go","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/exam/page/4/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
</body>
</html>
