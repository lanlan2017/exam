<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《第一周单元测验》(一)</title>
    <url>/exam//5cba7af/</url>
    <content><![CDATA[<h2 id="1单选-3分"><a href="#1单选-3分" class="headerlink" title="1单选(3分)"></a>1单选(3分)</h2><p>C语言编写的应用程序，通过printf打印一个换行符\n，但在终端上执行的是回车加换行\r\n，把换行符替换为回车换行是由下面哪个软件模块完成的？<br>A. C语言实现printf功能的动态链接库<br>B. Linux的串口驱动程序<br>C. 应用程序中的C语言函数库<br>D. Linux内核中的行律模块</p>
<p>正确答案：D你选对了</p>
<h2 id="2单选-3分"><a href="#2单选-3分" class="headerlink" title="2单选(3分)"></a>2单选(3分)</h2><p>Linux超级用户的用户名为：<br>A. supervisor<br>B. admin<br>C. administrator<br>D. root</p>
<p>正确答案：D你选对了</p>
<h2 id="3单选-3分"><a href="#3单选-3分" class="headerlink" title="3单选(3分)"></a>3单选(3分)</h2><p>下面哪个命令可以获得某进程占用的逻辑内存大小？<br>A. uptime<br>B. vmstat<br>C. free<br>D. ps</p>
<p>正确答案：D你错选为B</p>
<h2 id="4单选-3分"><a href="#4单选-3分" class="headerlink" title="4单选(3分)"></a>4单选(3分)</h2><p>下面哪个命令可以了解目前系统CPU的空闲情况？</p>
<p>A. who<br>B. free<br>C. ps<br>D. uptime</p>
<p>3.00&#x2F;3.00<br>正确答案：D你选对了</p>
<h2 id="5判断-2分"><a href="#5判断-2分" class="headerlink" title="5判断(2分)"></a>5判断(2分)</h2><p>终端仅仅是Linux主机的一个外部设备，不分担存储和计算工作。<br>A. 对<br>B. 错</p>
<p>正确答案：A你选对了</p>
<h2 id="6判断-2分"><a href="#6判断-2分" class="headerlink" title="6判断(2分)"></a>6判断(2分)</h2><p>传统的终端与Linux主机之间传输的是字节流。<br>A. 错<br>B. 对</p>
<p>正确答案：B你选对了</p>
<h2 id="7判断-2分"><a href="#7判断-2分" class="headerlink" title="7判断(2分)"></a>7判断(2分)</h2><p>终端转义序列的意义在于终端收到某一特定字符序列后执行一些约定好的控制功能，而不是把这些字符显示在显示器上。<br>A. 对<br>B. 错</p>
<p>正确答案：A你选对了</p>
<h2 id="8判断-2分"><a href="#8判断-2分" class="headerlink" title="8判断(2分)"></a>8判断(2分)</h2><p>直接执行bc命令，后面不带任何选项，除法计算时保留小数点后20个有效数字。<br>A. 对<br>B. 错</p>
<p>正确答案：B你选对了</p>
<h2 id="9判断-2分"><a href="#9判断-2分" class="headerlink" title="9判断(2分)"></a>9判断(2分)</h2><p>Linux中超级用户的权限很大，可以读取普通用户的口令值。</p>
<p>A. 错<br>B. 对<br>正确答案：A你选对了</p>
<h2 id="10判断-2分"><a href="#10判断-2分" class="headerlink" title="10判断(2分)"></a>10判断(2分)</h2><p>ps命令显示进程占用内存的大小SZ，这表示该进程占用了多少物理内存。<br>A. 对<br>B. 错</p>
<p>正确答案：B你没选择任何选项</p>
<!-- https://www.icourse163.org/learn/BUPT-1003557006?tid=1450758476#/learn/quizscore?id=1223003561&aid=2303013359 -->]]></content>
      <categories>
        <category>网课习题</category>
      </categories>
  </entry>
  <entry>
    <title>《第一周单元测验》(二）</title>
    <url>/exam//59d45d43/</url>
    <content><![CDATA[<h1 id="《第一周单元测验》-二）"><a href="#《第一周单元测验》-二）" class="headerlink" title="《第一周单元测验》(二）"></a>《第一周单元测验》(二）</h1><h2 id="1单选-3分"><a href="#1单选-3分" class="headerlink" title="1单选(3分)"></a>1单选(3分)</h2><p>使用more命令逐屏显示文本文件时，使得显示内容上滚一行而不是滚动一屏，应按下哪个键？</p>
<ul>
<li>A. 向下的箭头键</li>
<li>B. 空格</li>
<li>C. 回车 </li>
<li>D. Esc键</li>
</ul>
<p>正确答案：C你选对了</p>
<h2 id="2单选"><a href="#2单选" class="headerlink" title="2单选"></a>2单选</h2><p>使用less命令逐屏显示文本文件时，使得显示内容上滚一行而不是滚动一屏，应按下哪个键？</p>
<ul>
<li>A. 回车</li>
<li>B. 空格键</li>
<li>C. Ctrl-L</li>
<li>D.  Esc键</li>
</ul>
<p>正确答案：A你选对了</p>
<h2 id="3单选"><a href="#3单选" class="headerlink" title="3单选"></a>3单选</h2><p>Linux中用来实现计数功能，比如：统计系统有多少个登录用户，实现计数功能的命令是：</p>
<ul>
<li>A. sort -n</li>
<li>B. wc -l</li>
<li>C. cnt -s</li>
<li>D. uniq -c</li>
</ul>
<p>正确答案：B你选对了</p>
<h2 id="4判断"><a href="#4判断" class="headerlink" title="4判断"></a>4判断</h2><p>uniq命令可以通过它的选项，选择打印所有只出现一次的行，或者打印出现不只一次的行，或者两种都选。但无论哪种情况，重复出现的行最多只能打印一次。</p>
<ul>
<li>A. 对</li>
<li>B. 错</li>
</ul>
<p>正确答案：A你错选为B</p>
<h2 id="5判断"><a href="#5判断" class="headerlink" title="5判断"></a>5判断</h2><p>一个应用程序的C语言源程序通过printf语句在标准输出输出信息，运行时只要使用输出重定向机制，不需要修改原先的程序加入文件操作的代码，就可以把输出结果存入指定名字的文件。</p>
<ul>
<li>A. 错</li>
<li>B. 对</li>
</ul>
<p>正确答案：B你选对了</p>
<h2 id="6判断"><a href="#6判断" class="headerlink" title="6判断"></a>6判断</h2><p>less命令时more命令的一个简化版本，精简后功能比more弱，但更节约内存和CPU</p>
<ul>
<li>A. 错</li>
<li>B. 对</li>
</ul>
<p>正确答案：A你选对了</p>
<h2 id="7判断"><a href="#7判断" class="headerlink" title="7判断"></a>7判断</h2><p>od命令可以实现用16进制方式逐字节打印一个文件内容的功能，但要求文件的每个字节必须是可打印字符。</p>
<ul>
<li>A. 错</li>
<li>B. 对</li>
</ul>
<p>正确答案：A你选对了</p>
<h2 id="8判断"><a href="#8判断" class="headerlink" title="8判断"></a>8判断</h2><p>信息由一个个字节组成，tr命令处理这些信息时，可以将256种字节值中的255种取值“翻译”为另一个字节值，唯有字节值为0时无法转译，因为一个字节的8个比特全为零被用作字符串结尾。</p>
<ul>
<li>A. 错</li>
<li>B. 对</li>
</ul>
<p>正确答案：A你没选择任何选项</p>
<h2 id="9判断"><a href="#9判断" class="headerlink" title="9判断"></a>9判断</h2><p>不带任何选项的uniq命令消除数据中重复的行。一旦某一行出现过，uniq会记录下来，以后无论这一行在以后什么地方再次出现，输出时都会被忽略，保证数据的唯一行。</p>
<ul>
<li>A. 错</li>
<li>B. 对</li>
</ul>
<p>正确答案：A你选对了</p>
<h2 id="10判断"><a href="#10判断" class="headerlink" title="10判断"></a>10判断</h2><p>信息由一个个字节组成，tr命令处理这些信息时，可以将256种字节值中的任何一种取值“翻译”为另一个字节值，并且不限于可打印字符之间的转译，比如把换行符替换为斜线。</p>
<ul>
<li>A. 对</li>
<li>B. 错</li>
</ul>
<p>正确答案：A你选对了</p>
<!-- https://www.icourse163.org/learn/BUPT-1003557006?tid=1450758476#/learn/quizscore?id=1223003562&aid=2303098948 -->]]></content>
      <categories>
        <category>网课习题</category>
      </categories>
  </entry>
  <entry>
    <title>《第二周单元测验》</title>
    <url>/exam//675812a8/</url>
    <content><![CDATA[<h1 id="《第二周单元测验》"><a href="#《第二周单元测验》" class="headerlink" title="《第二周单元测验》"></a>《第二周单元测验》</h1><h2 id="1单选-3分"><a href="#1单选-3分" class="headerlink" title="1单选(3分)"></a>1单选(3分)</h2><p>下列哪个不是单字符正则表达式？</p>
<ul>
<li>A. <code>.</code> </li>
<li>B. <code>[i-k]</code></li>
<li>C. <code>@</code></li>
<li>D. <code>$</code><br>正确答案：D你错选为C</li>
</ul>
<h2 id="2单选-3分"><a href="#2单选-3分" class="headerlink" title="2单选(3分)"></a>2单选(3分)</h2><p>可以与正则表达式<code>A[i-k]*b[i]*c</code>匹配的最短字符串长度为：</p>
<ul>
<li>A. 6</li>
<li>B. 4</li>
<li>C. 3</li>
<li>D. 5<br>正确答案：C你选对了</li>
</ul>
<h2 id="3单选-3分"><a href="#3单选-3分" class="headerlink" title="3单选(3分)"></a>3单选(3分)</h2><p>能与正则表达式<code>a.x[i-j]*b[i-j]</code>匹配的字符串为：</p>
<ul>
<li>A. <code>a.x[i-j]*b[i-j]</code></li>
<li>B. <code>a*xbj</code></li>
<li>C. <code>a-x[i]*b[j]</code></li>
<li>D. <code>axibj</code><br>正确答案：B你选对了</li>
</ul>
<h2 id="4单选-3分"><a href="#4单选-3分" class="headerlink" title="4单选(3分)"></a>4单选(3分)</h2><p>与字符串<code>A1234</code>不匹配的正则表达式有：</p>
<ul>
<li>A. <code>A.*</code></li>
<li>B. <code>A12345*</code></li>
<li>C. <code>[A-Z][0-9]*</code></li>
<li>D. <code> A*4</code><br>正确答案：D你选对了</li>
</ul>
<h2 id="5判断-2分"><a href="#5判断-2分" class="headerlink" title="5判断(2分)"></a>5判断(2分)</h2><p>grep和fgrep都可以从一个文本文件中搜索出指定的字符串。<br>A. 错<br>B. 对<br>正确答案：B你选对了</p>
<h2 id="6判断-2分"><a href="#6判断-2分" class="headerlink" title="6判断(2分)"></a>6判断(2分)</h2><p>fgrep，grep，egrep三个命令在指定待查找字符串的模式方面，依次越来越灵活，后面的命令可以覆盖前面命令的功能，并且模式描述的语法也是完全兼容的。<br>A. 对<br>B. 错<br>正确答案：B你错选为A</p>
<h2 id="7判断-2分"><a href="#7判断-2分" class="headerlink" title="7判断(2分)"></a>7判断(2分)</h2><p>命令<code>cat pm.txt | sed &#39;s/\[[^][]*]//g&#39;</code>可以把pm.txt中所有用方括号括起来的内容（包括方括号自身）类似“ [参考文献23] ”这样的字符串片段删除。<br>A. 错<br>B. 对<br>正确答案：B你选对了</p>
<h2 id="8判断-2分"><a href="#8判断-2分" class="headerlink" title="8判断(2分)"></a>8判断(2分)</h2><p>grep可以筛选出包括某些特定模式的文本行，awk不仅可以筛出指定模式的行，还可以筛掉文本型表格中的部分列。<br>A. 对<br>B. 错<br>正确答案：A你选对了</p>
<h2 id="9判断-2分"><a href="#9判断-2分" class="headerlink" title="9判断(2分)"></a>9判断(2分)</h2><p>正则表达式<code>&lt;[^&lt;&gt;]*&gt;</code>可以匹配一个HTML格式数据中的诸如<code>&lt;span class=&quot;src-time&quot;&gt;</code>这样的用尖括号包裹起来的标签信息。<br>A. 对<br>B. 错<br>正确答案：A你没选择任何选项</p>
<h2 id="10判断-2分-awk描述"><a href="#10判断-2分-awk描述" class="headerlink" title="10判断(2分) awk描述"></a>10判断(2分) awk描述</h2><p>awk是一门小型的文本数据处理语言，有类似C语言一样的语法，可以使用自定义的变量，变量之间可以进行算术运算、关系运算和逻辑运算，还可以进行正则表达式匹配运算，支持条件、循环等流程控制。<br>A. 对<br>B. 错<br>正确答案：A你选对了</p>
]]></content>
      <categories>
        <category>网课习题</category>
      </categories>
  </entry>
  <entry>
    <title>在校生如何面向面试地学习Java</title>
    <url>/exam//46ec7757/</url>
    <content><![CDATA[<h1 id="在校生的困境"><a href="#在校生的困境" class="headerlink" title="在校生的困境"></a>在校生的困境</h1><p>对于那些已经工作的同学，哪怕才工作不久，毕竟也能<strong>从项目实践里总结和探索<code>java</code>的学习途径和相关方法</strong>。但在校生同学由于没机会接触实际项目，在学习内容、进阶途径和学成标准这些方面都是两眼一抹黑，而大学里的内容可能偏重于理论，讲述的技术往往也和软件公司里常用的技术不匹配。<br>这就导致了很多上心的在校生，虽然很努力，但到毕业时，才发现自己起早贪黑学成的技能并不能帮他们找到工作。在本文里，就将结合我面试实习生和毕业生的标准，专门给在校生这个群体一些学习<code>Java</code>方面的建议。</p>
<h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><h2 id="1-明确目标，先说下公司面试应届生的标准"><a href="#1-明确目标，先说下公司面试应届生的标准" class="headerlink" title="1. 明确目标，先说下公司面试应届生的标准"></a>1. 明确目标，先说下公司面试应届生的标准</h2><p>我最近可能都在大公司，到毕业季，会到一些学校去校招，校招的标准描述起来很简单：<code>Java</code>方面能干活，或者能经短期帮带后能干活，具体标准如下。</p>
<ol>
<li><code>Web</code>框架方面，需要以全栈的形式，了解<code>SSM</code>，或<code>Spring Boot</code>或<code>Spring Cloud</code>从前端到后端的基本语法，<strong>至少能在项目经理短期帮助下，能照着别人的例子写代码</strong>。应届生候选人只要能讲清楚相关框架的语法点和流程即可，最多再附带说明下<code>mybatis</code>等组件的用法，至于<code>redis</code>，<code>dubbo</code>，根本没要求。</li>
<li>数据库方面，能会基本的增删改查即可，外带一些基本概念，比如事务怎么处理，<code>JDBC</code>里批处理怎么处理。</li>
<li><code>Java</code>语法（也就是核心方面），其实如果能讲清楚<code>SSM</code>等<code>Web</code>框架技能，这块只要刷题就能过，比如就问些<code>ArrayList</code>和<code>LinkedList</code>的差别，以及多线程等的概念。</li>
<li>人看上去听话，想法少，学习能力强，责任心强，不是刺头，这块其实大多数人都可以达标。</li>
</ol>
<p>以上不要求有商业项目经验，当然如果有，绝对是加分项，而且这还是大公司的面试应届生的标准。<strong>至于一些小公司，或者是一些外包公司，有时候能招到人就阿弥陀佛了</strong>（至于有些能力比较强的一本的应届生愿不愿意去还难说）。有些在招收应届生的时候，不少<strong>小公司</strong>甚至在“项目经验”方面没要求，哪怕没学习项目经验也不要紧，<strong>只会问些网上比较大路的面试题，能说上来即可</strong>。</p>
<h2 id="2-面试中大多数应届生的实际表现"><a href="#2-面试中大多数应届生的实际表现" class="headerlink" title="2. 面试中大多数应届生的实际表现"></a>2. 面试中大多数应届生的实际表现</h2><p>从面试官角度来看，<strong>招收应届生的标准其实是很低的</strong>，对应的，在招初级开发时，多少都需要有商业项目经验。从这个角度来看，<strong>应届生最好在校期间就找到工作</strong>，毕业后两三个月找不到工作问题还不怎么大，但如果半年后再找不到工作，那么到时候被面试的标准就高于“应届生”的标准了。<br>这里我无意贬低应届生的水平，毕竟我们都是从这个阶段过来的，但从面试情况来看，至少有将近一半的应届生达不到标准。</p>
<h3 id="达不到标准的具体表现"><a href="#达不到标准的具体表现" class="headerlink" title="达不到标准的具体表现"></a>达不到标准的具体表现</h3><ol>
<li>没有框架开发的经验，这里最低要求是能自行搭建个<code>SSM</code>项目，但不少同学根本没有。</li>
<li>数据库方面，就知道理论上的增删改查，甚至不会在<code>MySQL, Oracle</code>和<code>SQL Server</code>平台上运行过<code>SQL</code>语句。</li>
<li><code>Java</code>核心方面，掌握了一大堆项目里一定不会用的，比如<code>Swing</code>之类的界面编程技术，但<strong>该掌握的多线程集合</strong>等，一些常用的概念也不清楚。</li>
<li>论动手能力，有些同学甚至没有在<code>Eclipse</code>等<code>IDE</code>上运行通<code>Java</code>代码，或者出了基本的语法错误不知道如何自行解决，至于没有**<code>debug</code>调试经验**的，就更加见怪不怪了，而在代码里需要加必要的<code>try...catch</code>异常处理语句，这就更加凤毛麟角了。</li>
</ol>
<p>在一些一本大学里，理论和实际操作能力较差的同学虽然不多，但也有，就更别提其它大学和大专了。我也和一些大学老师打过交道，也看过一些大学里用的Java和数据库等编程方面的教材，再结合诸多应届生在面试时的表现，我的感受是，或许<strong>大学阶段更会培养学生的理论素养</strong>，但大学生朋友在读大学阶段，一定要提升实际的编程能力，<strong>包含但不限于（SSM）框架的编程能力，数据库实际操作能力和Java核心部分代码的开发和调试能力</strong> 。</p>
<h2 id="3-哪些大学里学到的知识点面试大概率不问（根本不用太费精力看的技术有哪些）"><a href="#3-哪些大学里学到的知识点面试大概率不问（根本不用太费精力看的技术有哪些）" class="headerlink" title="3. 哪些大学里学到的知识点面试大概率不问（根本不用太费精力看的技术有哪些）"></a>3. 哪些大学里学到的知识点面试大概率不问（根本不用太费精力看的技术有哪些）</h2><p>这里就将结合具体的知识点，列出面试时需要掌握的最低技能标准，除此之外,大概率不会问的</p>
<h3 id="面试时需要掌握的最低技能标准"><a href="#面试时需要掌握的最低技能标准" class="headerlink" title="面试时需要掌握的最低技能标准"></a>面试时需要掌握的最低技能标准</h3><h4 id="Java核心常问"><a href="#Java核心常问" class="headerlink" title="Java核心常问:"></a><code>Java</code>核心常问:</h4><ul>
<li>集合，</li>
<li>多线程，</li>
<li>异常处理，</li>
<li><code>IO</code>，</li>
<li><code>JDBC</code>，</li>
<li>面向对象技能，</li>
</ul>
<p>这些大概率会问到</p>
<h4 id="java核心不常问"><a href="#java核心不常问" class="headerlink" title="java核心不常问"></a>java核心不常问</h4><ul>
<li>图形化界面，</li>
<li><code>NIO</code>，</li>
<li><code>Socket</code>网络编程，</li>
<li>甚至<code>Applet</code>之类的</li>
</ul>
<h4 id="数据库方面"><a href="#数据库方面" class="headerlink" title="数据库方面"></a>数据库方面</h4><ul>
<li>会写增删改查的<code>SQL</code>语句，</li>
<li>知道存储过程之类的概念，</li>
<li>会通过索引优化查询条件，</li>
<li>会建表，</li>
<li>会些诸如子查询,<code>group by,having</code>，</li>
<li>表关联查询等基本<code>SQL</code>技能，</li>
<li><strong>至少得用过一种商业化数据库</strong>。</li>
</ul>
<h4 id="框架方面"><a href="#框架方面" class="headerlink" title="框架方面"></a>框架方面</h4><p>需要有Spring+Spring MVC+mybatis框架的实际操作能力（不是商业项目开发能力），<br>至于有Spring Boot或Spring Cloud，那更好了。</p>
<h4 id="综合技能方面"><a href="#综合技能方面" class="headerlink" title="综合技能方面"></a>综合技能方面</h4><ul>
<li>能知道基本的数据结构知识（线性表外带排序外带一些树的技能），</li>
<li>基本的操作系统知识（一般仅限于线程进程概念），</li>
<li>基本网络通讯知识（一般仅限于网络通讯模型和tcp udp协议），</li>
</ul>
<p>这些要求是“需要知道”而已。</p>
<h2 id="看招聘要求查缺补漏"><a href="#看招聘要求查缺补漏" class="headerlink" title="看招聘要求查缺补漏"></a>看招聘要求查缺补漏</h2><p>大家其实也可以通过看各种职位描述和招聘需求，看下哪些技能实际上是不会问的，对于这些知识，就不用学，从而把精力用到学实际Java相关技能上。</p>
<h2 id="大学许多知识后面才用到"><a href="#大学许多知识后面才用到" class="headerlink" title="大学许多知识后面才用到"></a>大学许多知识后面才用到</h2><p>这里需要说明，在大学阶段学的很多知识，不能说没用。比如网络通讯里的tcp底层通讯细节，这些技能或者要等到工作5年后升级到高级开发或架构师的时候才会用到，而且以高级开发视角观察需要掌握的通讯协议细节知识，绝对要比大学阶段要复杂。</p>
<p>换句话说，很多技能，在大学阶段也就“需要了解有这事”，以在大学阶段的经历，再多用时间学，估计也无法达到“实际项目的需求”，而且等到有实际项目经验时，再学这类技能也就是一两周的事情。两厢一对比，结论就很明确了：在<strong>校阶段应该更多积累实际开发能力</strong>，因为更得靠这个找工作。</p>
<h2 id="4-用一个月的时间了解Java核心部分的内容"><a href="#4-用一个月的时间了解Java核心部分的内容" class="headerlink" title="4. 用一个月的时间了解Java核心部分的内容"></a>4. 用一个月的时间了解Java核心部分的内容</h2><ul>
<li>着重观察<strong>集合</strong>，<strong>面向对象</strong>，<strong>多线程</strong>，<strong>IO处理</strong>，<strong>JDBC</strong>，<strong>异常处理</strong>相关章节，这个阶段，是<strong>以掌握API用法</strong>为主，在这基本上再看下诸如接口，抽象类，异常处理流程，垃圾回收之类的高级知识点。</li>
<li>在上述基础上，如果可以通过资料的帮助，</li>
<li><strong>用Java实现堆栈，链表，队列，散列表，树等的数据结构</strong>，</li>
<li><strong>同时操练各种排序算法</strong>，这对找工作也有些帮助</li>
</ul>
<h2 id="5-用半个月的时间，以MySQL为例，了解数据库的大致操作"><a href="#5-用半个月的时间，以MySQL为例，了解数据库的大致操作" class="headerlink" title="5. 用半个月的时间，以MySQL为例，了解数据库的大致操作"></a>5. 用半个月的时间，以MySQL为例，了解数据库的大致操作</h2><p>在数据库方面，最好也去找本书，同时在<code>MYSQL</code>上实践。为什么选<code>MYSQL</code>,因为这比较轻，相比<code>Oracle</code>而言，好安装，当然如果有条件装<code>SQL Server</code>之类的，那就更好了。<br>1、在<code>MySQL</code>数据库上，实践各种增删改查的<code>SQL</code>语句，实践建表，建索引能技巧，同时实践一下诸如子查询，<code>with as</code>等等复杂的<code>SQL</code>语句。<br>2、用<code>JDBC</code>连同<code>MYSQL</code>，在<code>Java</code>代码里做各种<strong>增删改查</strong>的操作。<br>3、在此基础上，了解诸如索引，范式和锁等概念，这时候虽然认识也会很肤浅，但至少不会一头雾水了。</p>
<p>这样，在数据库方面，好歹有实际操作经验了，这为之后的项目实践，能打下很好的基础。</p>
<h2 id="6、用一个月的时间，了解基于Spring的web框架"><a href="#6、用一个月的时间，了解基于Spring的web框架" class="headerlink" title="6、用一个月的时间，了解基于Spring的web框架"></a>6、用一个月的时间，了解基于Spring的web框架</h2><p>面试时更看重的是框架经验，这块学习的建议如下。<br>1、先通过运行代码，了解<code>Spring</code>里<code>IOC, AOP</code>，这时应该注意各种配置。<br>2、熟悉<code>Spring</code>的基本概念后，可以尝试跑一个<code>SSM</code>的小例子，这个例子可以非常简答，就一个页面也行，但要包含<code>Spring MVC</code>和<code>Mybatis</code>诸多要素，这样大家好歹能知道框架的构成，在这个基础上，可以继续扩展，加些必要的业务，从而进一步了解这个框架。<br>在这个阶段，还是最好看书上的例子，因为书上的例子一定能通，而且还会带部署和运行的步骤，还是不建议自己敲代码，因为<code>SSM</code>框架相对复杂，在这个阶段如果自己敲，很有可能会因为问题太多而放弃。<br>3、在自己机器上跑通<code>SSM</code>框架的案例后，可以网上找个带业务的系统，比如<strong>图书管理系统</strong>等，从中看些前端和后端交互数据的流程，同时，结合业务看<code>Mybatis</code>里的<code>ORM</code>过程，以及**<code>Spring</code>里的常用注解**。</p>
<h2 id="8、有学习项目经验后，争取找些商业项目的实践机会"><a href="#8、有学习项目经验后，争取找些商业项目的实践机会" class="headerlink" title="8、有学习项目经验后，争取找些商业项目的实践机会"></a>8、有学习项目经验后，争取找些商业项目的实践机会</h2><p>拥有最基本的SSM以及其它Java和数据库相关技能后，要做的绝不是继续积累学习项目经验，而是尽可能去找实习的机会，以积累商业项目的经验。在找实习经验方面，大家可以参照如下的建议。<br>1、在我之前的博文里也提到，大三时，<strong>打听计算机学院里哪些老师和外面公司有合作</strong>，一般<strong>硕导</strong>都有这样的项目，然后直接去找老师，刚开始不要钱，只求经验，或许对各位在校生同学而言，这种方式是比较可行的，本人第一个商业项目经验也是由此得到的。<br>2、一般学校里都会安排实习，实习的过程中，一定要重视，这个是实打实的商业项目经验。<br>3、寒暑假，找软件公司，这可能会比较艰辛，因为在校阶段自己非常难找相关实习机会，但要去找。<br>5、如果实在找不到实习的机会，那么尽可能通过各种渠道，去找商业项目经验的案例</p>
<p><strong>哪怕实际只干了三个月的商业项目经验，自己的技能也会很大程度提升</strong>，而且实际的商业项目经验，会让大家掌握书本上根本不会多提但项目里一定会用的技能，比如JVM内存调优或多线程并发。从这意义上来讲，只要有条件，大学生朋友应该挤破头去找商业项目的经验，而不是悠哉游哉地坐在机房里敲代码。只要你有商业项目的经验，哪怕就三个月，找工作时你就有代差优势。</p>
<h2 id="9、毕业生准备简历的要点"><a href="#9、毕业生准备简历的要点" class="headerlink" title="9、毕业生准备简历的要点"></a>9、毕业生准备简历的要点</h2><p>在招聘毕业生时<br>，第一看项目经验，<br>第二看项目里包含的技能，<br>第三再问算法和理论问题，<br>至于逻辑题和情商题，只供参考</p>
<p>毕业生在简历中，一定得突出做过的项目经验，优先挖掘商业项目经验，<br>实在没有学习项目也行。<br>如果没任何项目经验，那么找工作时会吃力很多</p>
<h1 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h1><p><a href="https://mp.weixin.qq.com/s/y_ozO8BnH6YkoFh_Oq8M1w">https://mp.weixin.qq.com/s/y_ozO8BnH6YkoFh_Oq8M1w</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>职场就业面试最常问的50题</title>
    <url>/exam//c17e8611/</url>
    <content><![CDATA[<h1 id="1到10题"><a href="#1到10题" class="headerlink" title="1到10题"></a>1到10题</h1><h2 id="Q1请自我介绍一下"><a href="#Q1请自我介绍一下" class="headerlink" title="Q1请自我介绍一下"></a>Q1请自我介绍一下</h2><p>不要只是简单读简历,企业最希望通过这个问题了解你是否能胜任工作,要介绍自己最强的技能、最深入硏究的领域、个性中最积极的部分等,简短但要能突出自己的能力。</p>
<h2 id="Q2你最大的优点和缺点"><a href="#Q2你最大的优点和缺点" class="headerlink" title="Q2你最大的优点和缺点"></a>Q2你最大的优点和缺点</h2><p>优点可以答沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和幽默感、乐观和友爱等;从自己的优点说起,中间加一些小缺点,最后再把问题转回到优点上,突出优点的部分。</p>
<h2 id="Q3你是否能够接受加班"><a href="#Q3你是否能够接受加班" class="headerlink" title="Q3你是否能够接受加班?"></a>Q3你是否能够接受加班?</h2><p>你可以回答:“我愿额接受挑战在自己责任范围内的工作,不能算是加班。”<br>但是也要强调,会努力提高工作效率,因为能力低、完成工作慢造成的加班,并不是一件好事。</p>
<h2 id="Q4你对薪资的要求"><a href="#Q4你对薪资的要求" class="headerlink" title="Q4你对薪资的要求"></a>Q4你对薪资的要求</h2><p>如果你要求太低,那显然贬低自己的能力;<br>如果要求太高,又会显得公司受用不起。<br>HR第一次提出的价钱往往是他们所能给予的最高价钱,他们问你只不过想证实一下这笔钱是否足以引起你对该职位的兴趣。</p>
<h2 id="Q5在五年的时间内-你的职业规划"><a href="#Q5在五年的时间内-你的职业规划" class="headerlink" title="Q5在五年的时间内,你的职业规划"></a>Q5在五年的时间内,你的职业规划</h2><p>最普通的回答是“我准备在技术领域有所作为”或“我希望能按公司的管理思路发展”,也可以说出一些你感兴趣的职位。HR总是喜欢有进取心的应聘者。</p>
<h2 id="Q6我们为什么要聘用你"><a href="#Q6我们为什么要聘用你" class="headerlink" title="Q6我们为什么要聘用你"></a>Q6我们为什么要聘用你</h2><p>测试你的沉着与自信。可以根据自己的实际情况和优势加以说明,而一个简短、有礼貌但非常笃定的收尾也很重要.<br>比如,“我能做好我要做的事情”,“我相信自己”。</p>
<h2 id="Q7你对于我们公司了解多少"><a href="#Q7你对于我们公司了解多少" class="headerlink" title="Q7你对于我们公司了解多少"></a>Q7你对于我们公司了解多少</h2><p>面试之前,一定要做好功课,可以在网上查一下该公司<strong>主营业务</strong>,<strong>发展方向</strong>、<strong>近期重大战略调整</strong>等。</p>
<h2 id="Q8你为什么愿意到我们公司来工作"><a href="#Q8你为什么愿意到我们公司来工作" class="headerlink" title="Q8你为什么愿意到我们公司来工作"></a>Q8你为什么愿意到我们公司来工作</h2><p>可以回答一些详细的原因,像“贵公司的高技术开发环境很吸引我”、<br>“贵公司在近几年来在市场上很有竞争力”、<br>“贵公司能够给我提供一个与众不同的发展道路”。<br>这都显示出你已经做了一些调查,也说明你有较为具体的职业规划。</p>
<h2 id="Q9就你申请的这个职位-你认为自己欠缺什么"><a href="#Q9就你申请的这个职位-你认为自己欠缺什么" class="headerlink" title="Q9就你申请的这个职位,你认为自己欠缺什么"></a>Q9就你申请的这个职位,你认为自己欠缺什么</h2><p>你可以重新强调自己的优势,然后说“对于这个职位和我的能力来说,我相信自己是可以胜任的,只是缺乏经验。我的学习能力很强,我相信可以很快融入公司的企业文化,进入工作状态。”</p>
<h2 id="Q10在完成某项顶工作时-你觉得领导的指示不对-你会怎么做"><a href="#Q10在完成某项顶工作时-你觉得领导的指示不对-你会怎么做" class="headerlink" title="Q10在完成某项顶工作时,你觉得领导的指示不对,你会怎么做?"></a>Q10在完成某项顶工作时,你觉得领导的指示不对,你会怎么做?</h2><p>原则上我会尊重和服从领导的工作安排,私底下以请教的口吻表达自己的想法。如果领导没有采纳我的建议,我同样会按要求认真完成工作,但如果领导要求的方式违背原则,我会提出反对意见。</p>
<h1 id="11到20题"><a href="#11到20题" class="headerlink" title="11到20题"></a>11到20题</h1><h2 id="Q11你缺乏工作经验-如何能胜任这项工作"><a href="#Q11你缺乏工作经验-如何能胜任这项工作" class="headerlink" title="Q11你缺乏工作经验,如何能胜任这项工作?"></a>Q11你缺乏工作经验,如何能胜任这项工作?</h2><p>要体现出诚思、机智、果敢及敬业。如“作为应届毕业生,在工作经验方面的确会有所欠缺,因此在读书期间我一直利用各种机会在这个行业里做兼职和实习。实际工作远比书本复杂,但我有较强的责任心、适应能力和学习能力,而且很勤奋,所以是一个优秀的实习生,也积累了一些经验。请放心,学校所学及兼职的工作经验使我一定能胜任这个职位。”</p>
<h2 id="Q12如果我们没有录取你-你下步有什么打算"><a href="#Q12如果我们没有录取你-你下步有什么打算" class="headerlink" title="Q12如果我们没有录取你,你下步有什么打算?"></a>Q12如果我们没有录取你,你下步有什么打算?</h2><p>可以表示会认直总结这次面试的经验,找原因,找差距,但也不会就此气馁,会把这次的不成功当作历练积累</p>
<h2 id="Q13如果你的工作出现失误-给公司造成损失-你认为该怎么办"><a href="#Q13如果你的工作出现失误-给公司造成损失-你认为该怎么办" class="headerlink" title="Q13如果你的工作出现失误,给公司造成损失,你认为该怎么办?"></a>Q13如果你的工作出现失误,给公司造成损失,你认为该怎么办?</h2><p>首先强调,本意是为公司努力工作,如果造成经济损失,首要的是想方设法弥补或挽回。如果确实是工作失误所致,愿意承担责任。同时应该补充,之后会总结经验教训。</p>
<h2 id="Q14如果你的工作成绩很突出-得到领导肯定-但却发现同事们因此孤立你-你如何处理"><a href="#Q14如果你的工作成绩很突出-得到领导肯定-但却发现同事们因此孤立你-你如何处理" class="headerlink" title="Q14如果你的工作成绩很突出;得到领导肯定,但却发现同事们因此孤立你,你如何处理?"></a>Q14如果你的工作成绩很突出;得到领导肯定,但却发现同事们因此孤立你,你如何处理?</h2><p>以后会更加努力;<br>检讨自己是不是忽略了与同事的交往,或者有什么事情做得不妥当,产生了误会;<br>会更注意工作方法,多换位思考。</p>
<h2 id="Q15工作中如果难以和同事、上司相处-你该怎么办"><a href="#Q15工作中如果难以和同事、上司相处-你该怎么办" class="headerlink" title="Q15工作中如果难以和同事、上司相处,你该怎么办?"></a>Q15工作中如果难以和同事、上司相处,你该怎么办?</h2><p>会服从领号指挥,配合同事的工作如果发生问题,<br>首先从自身找原因,努力改正;<br>如果难以发现原因,会积极和他们沟通,请他们指出我的不足;<br>即使在一段时间内,领导和同事对我不理解,也会做好本职工作,以诚待人。</p>
<h2 id="Q16你何时可以入职"><a href="#Q16你何时可以入职" class="headerlink" title="Q16你何时可以入职?"></a>Q16你何时可以入职?</h2><p>最好回答“如果被录用的话,到职日可按公司要求的时间入职”。如果做不到,可以告知用人单位,但需要表明愿意在能力所及范围内尽快到岗。</p>
<h2 id="Q17你选离职的原因是什么"><a href="#Q17你选离职的原因是什么" class="headerlink" title="Q17你选离职的原因是什么?"></a>Q17你选离职的原因是什么?</h2><p>不能表现出对上一份工作的怨言,最好从自身发展来表明离职原因,比如,遭遇职业的天花板,或前份工作与自己的长期职业生涯规划不合等,也可以表明应聘的新职位对自己是很好的机会。</p>
<h2 id="Q18你并排毕业于名牌学校"><a href="#Q18你并排毕业于名牌学校" class="headerlink" title="Q18你并排毕业于名牌学校?"></a>Q18你并排毕业于名牌学校?</h2><p>不卑不亢地回应,比如,我认为是否毕业于名牌院校并不是最重要的,重要的是我目前掌握的技能完全可以胜任工作。而且我的经历让我比一些名牌院校毕业生的动手能力更强,我想我更适合这个职位</p>
<h2 id="Q19我怎样相信你是这个职位最好的人选呢"><a href="#Q19我怎样相信你是这个职位最好的人选呢" class="headerlink" title="Q19我怎样相信你是这个职位最好的人选呢?"></a>Q19我怎样相信你是这个职位最好的人选呢?</h2><p>根据要求,说出自己应聘的优势。比如,“根据这个职位的性质和我们刚才的谈话,我推断您需要的是工作积极、能够设定目标,不惧怕挑战的人,我就具有这些品质”。然后再介绍一些经历来说明。</p>
<h2 id="Q20为什么你还没有找到工作"><a href="#Q20为什么你还没有找到工作" class="headerlink" title="Q20为什么你还没有找到工作?"></a>Q20为什么你还没有找到工作?</h2><p>没有找到工作并不是因为能力不行,而是在寻找更好的机会。比如,“我正在谨慎选择我的工作,也有一些工作可以选择,但并不是非常满意</p>
<h1 id="21到30题"><a href="#21到30题" class="headerlink" title="21到30题"></a>21到30题</h1><h2 id="Q21你认为你在学校属于好学生吗"><a href="#Q21你认为你在学校属于好学生吗" class="headerlink" title="Q21你认为你在学校属于好学生吗?"></a>Q21你认为你在学校属于好学生吗?</h2><p>如果成绩好,可以说:“是的,但判断一个学生是不是好学生有很多标准,还包括思想道德、实践经验、团队精神、沟通能力等我是一个全面发展的学生。”<br>如果成绩不尽理想可以说:“我认为好学生的标准是多元化的我的学习成绩还可以,在其他方面我的表现也很突出,比如我去很多地方实习过,我在学生会组织过许多活动,有比较强的团队合作精神和组织能力。”</p>
<h2 id="Q22你在大学里的学习成绩、不敢恭维-你如何解释呢"><a href="#Q22你在大学里的学习成绩、不敢恭维-你如何解释呢" class="headerlink" title="Q22你在大学里的学习成绩、不敢恭维,你如何解释呢?"></a>Q22你在大学里的学习成绩、不敢恭维,你如何解释呢?</h2><p>这类问题往往是一种“压追法”的面试技巧,提到的弱点不是问题关键所在,HR是为了看你在压力下如何反应,所以应沉着应付,想办法扭转劣势,表现出自己的急才与修养。</p>
<h2 id="Q23假如我们聘用你-但有时需要做些倒茶端水的杂务-你会反对吗"><a href="#Q23假如我们聘用你-但有时需要做些倒茶端水的杂务-你会反对吗" class="headerlink" title="Q23假如我们聘用你,但有时需要做些倒茶端水的杂务,你会反对吗?"></a>Q23假如我们聘用你,但有时需要做些倒茶端水的杂务,你会反对吗?</h2><p>这是一个试探性问题,目的是判断你对工作的态度。可以回答:“如果需要,我不会斤斤计较,这些杂务只是我的工作内容的小部分而已</p>
<h2 id="Q24假如你流落荒岛-可以拥有一本书-你会选择哪一本-为什么"><a href="#Q24假如你流落荒岛-可以拥有一本书-你会选择哪一本-为什么" class="headerlink" title="Q24假如你流落荒岛,可以拥有一本书,你会选择哪一本?为什么?"></a>Q24假如你流落荒岛,可以拥有一本书,你会选择哪一本?为什么?</h2><p>这是假设性问题,来测试应试者的想象力、解决问题的能力,目的看你有没有急才,思想有没有条理,说清理由即可。</p>
<h2 id="Q25你有哪些兴趣爱好"><a href="#Q25你有哪些兴趣爱好" class="headerlink" title="Q25你有哪些兴趣爱好?"></a>Q25你有哪些兴趣爱好?</h2><p>回答的兴趣爱好可以体现自己积极主动的性格、团队合作的精神、深入学习的意愿等。</p>
<h2 id="Q26你人生中最令你受挫的事情是什么"><a href="#Q26你人生中最令你受挫的事情是什么" class="headerlink" title="Q26你人生中最令你受挫的事情是什么?"></a>Q26你人生中最令你受挫的事情是什么?</h2><p>这个问题是为了解你对挫折的容忍度及调节方式。可以说让你受挫的经历,但更重要的是你如何处理、克服或改变。</p>
<h2 id="Q27你朋友对你的评价"><a href="#Q27你朋友对你的评价" class="headerlink" title="Q27你朋友对你的评价?"></a>Q27你朋友对你的评价?</h2><p>“我的朋友都说我是一个可以信赖的人。因为我一旦答应别人的事情,就一定会做到。如果我做不到,我就不会轻易许诺&quot;;或“我的朋友都说我是一个比较随和的人,与不同的人都可以友好相处,我总是能站在别人的角度考虑问题。</p>
<h2 id="Q28谈谈你过去做过的成功案例"><a href="#Q28谈谈你过去做过的成功案例" class="headerlink" title="Q28谈谈你过去做过的成功案例?"></a>Q28谈谈你过去做过的成功案例?</h2><p>举一个你最有把握的例子,把来龙去脉说清楚。切忌夸大其词,把别人的功劳说成自己的。</p>
<h2 id="Q29如果你做的一顶工作受到上级领导的表扬-但你主管领导却说是他做的-你该怎样"><a href="#Q29如果你做的一顶工作受到上级领导的表扬-但你主管领导却说是他做的-你该怎样" class="headerlink" title="Q29如果你做的一顶工作受到上级领导的表扬,但你主管领导却说是他做的,你该怎样?"></a>Q29如果你做的一顶工作受到上级领导的表扬,但你主管领导却说是他做的,你该怎样?</h2><p>首先,理性地看待这个事情,不能因为这件事影响工作态度。而且平时工作中,领导确实帮助过我,这项工作理应有领导的功劳。但我还是会在适当的时候找领导委婉表达态度,相信领导会明事理。</p>
<h2 id="Q30你能为我们公司带来什么呢"><a href="#Q30你能为我们公司带来什么呢" class="headerlink" title="Q30你能为我们公司带来什么呢?"></a>Q30你能为我们公司带来什么呢?</h2><p>应再次重复自己的优势,然后说:“就我的能力,我可以给组织带来高效率和更多的收益”。</p>
<h1 id="31到40题"><a href="#31到40题" class="headerlink" title="31到40题"></a>31到40题</h1><h2 id="Q31喜欢这份工作的哪点"><a href="#Q31喜欢这份工作的哪点" class="headerlink" title="Q31喜欢这份工作的哪点?"></a>Q31喜欢这份工作的哪点?</h2><p>不要太直接地把自己的心里话说出来,如果能仔细思考这份工作的与众不同之处,会大大加分。</p>
<h2 id="Q32说你对行业、技术发展趋势的看法"><a href="#Q32说你对行业、技术发展趋势的看法" class="headerlink" title="Q32说你对行业、技术发展趋势的看法?"></a>Q32说你对行业、技术发展趋势的看法?</h2><p>面试前可以在网上查找该<strong>行业</strong>、该<strong>企业</strong>的相关信息,做足功课,包括<strong>公司各个部门发展情况</strong>。企业欢迎的是“知己”,而不是“盲人</p>
<h2 id="Q33说说你的家庭"><a href="#Q33说说你的家庭" class="headerlink" title="Q33说说你的家庭?"></a>Q33说说你的家庭?</h2><p>可以回答:虽然我的父母亲都是普通人,但是从小我就看到父亲起早贪黑,工作认真负责,我母亲为人善良,特别乐于助人,父母的一言一行一直在教导我做人做事的道理。</p>
<h2 id="Q34谈你对别槽的看法"><a href="#Q34谈你对别槽的看法" class="headerlink" title="Q34谈你对别槽的看法?"></a>Q34谈你对别槽的看法?</h2><p>正常的跳槽能促进人才合理流动应该支持;<br>频繁的跳槽对单位和个人双方都不利,应该反对。</p>
<h2 id="Q35你工作的期望与目标"><a href="#Q35你工作的期望与目标" class="headerlink" title="Q35你工作的期望与目标?"></a>Q35你工作的期望与目标?</h2><p>回答最好有<strong>针对性</strong>,如应聘业务员,“我的目标是成为一个超级业务员,将公司的产品广泛推销出去,达到最好的业绩成效。”</p>
<h2 id="Q36如果你被录用了-但工作一段你发现你并不适合这个职位-你怎么办"><a href="#Q36如果你被录用了-但工作一段你发现你并不适合这个职位-你怎么办" class="headerlink" title="Q36如果你被录用了,但工作一段你发现你并不适合这个职位,你怎么办?"></a>Q36如果你被录用了,但工作一段你发现你并不适合这个职位,你怎么办?</h2><p>首先强调,申请这个职位是你经过了<strong>深思熟虑和全面了解</strong>的决定,所谓的不适应可能是业务不熟练导致的。而后表明态度,如果发现短时间内能力与职位有差距,你会不断学习,虚心向领导和同事请教经验,力争减少差距。</p>
<h2 id="Q37你和别人发生过争执吗-你是怎样解决的"><a href="#Q37你和别人发生过争执吗-你是怎样解决的" class="headerlink" title="Q37你和别人发生过争执吗?你是怎样解决的?"></a>Q37你和别人发生过争执吗?你是怎样解决的?</h2><p>千万不要说任何人的过错,成功解决矛盾是一个协作团体中成员所必备的能力,HR希望看到你<strong>成熟且乐于奉献</strong>。在没有外界干涉的情况下,通过妥协的方式来解决,是较好的答案。</p>
<h2 id="Q38你会如何处理别人的批评"><a href="#Q38你会如何处理别人的批评" class="headerlink" title="Q38你会如何处理别人的批评?"></a>Q38你会如何处理别人的批评?</h2><p>沉默是金,不必说什么,否则情况更糟,我会等大家冷静下来再讨论,也会接受建设性的批评。</p>
<h2 id="Q39你很努力-但客户始终不满意并投诉-你怎么做"><a href="#Q39你很努力-但客户始终不满意并投诉-你怎么做" class="headerlink" title="Q39你很努力,但客户始终不满意并投诉,你怎么做?"></a>Q39你很努力,但客户始终不满意并投诉,你怎么做?</h2><p>首先,我会保持冷静,积极应对;<br>其次,我会反思原因,一是看自己在解决问题上是否有考虑不周之处,二是看客户是否不了解情况,三是看客户是否故意刁难;<br>再次如果自己确有不周,按照规定作出合理安排;<br>如果是客户不了解情况,我会做解释;<br>如果是客户的要求不符合规定,我会明确指出;<br>把处理情况向领导汇报,不会因客户投诉而丧失工作热情。</p>
<h2 id="Q40对这项工作-你有哪些可预见的困难"><a href="#Q40对这项工作-你有哪些可预见的困难" class="headerlink" title="Q40对这项工作,你有哪些可预见的困难?"></a>Q40对这项工作,你有哪些可预见的困难?</h2><p>不宜直接说出具体困难,否则可能令HR怀疑你能力。可尝试迂回战术,说出对困难所持有的态度:</p>
<ul>
<li>工作中出现一些困难是难免的,但是只要有坚忍不拔的毅力、良好的作精神以及周密而充分的准备,任何困难都可以克服。</li>
</ul>
<h1 id="41到50题"><a href="#41到50题" class="headerlink" title="41到50题"></a>41到50题</h1><h2 id="Q41如果我录用你-你将怎样开展工作"><a href="#Q41如果我录用你-你将怎样开展工作" class="headerlink" title="Q41如果我录用你,你将怎样开展工作?"></a>Q41如果我录用你,你将怎样开展工作?</h2><p>最好不要直接说出具体办法,而是“首先听取领导的要求,然后就有关情况进行了解,接下来制定工作计划并报领导批准,最后根据计划开展工作”</p>
<h2 id="Q42你希望与什么样的上级共事"><a href="#Q42你希望与什么样的上级共事" class="headerlink" title="Q42你希望与什么样的上级共事?"></a>Q42你希望与什么样的上级共事?</h2><p>最好回避对上级具体的希望,多谈对自己的要求。如“作为刚步入社会的新人,我应该多要求自己尽快适应环境,而不应该对环境提要求,只要能发挥能力,做好工作即可<br>或“希望我的上级能够在工作中对我多指导对我工作中的错误能够立即指出。”</p>
<h2 id="Q43怎样看待学历和能力"><a href="#Q43怎样看待学历和能力" class="headerlink" title="Q43怎样看待学历和能力?"></a>Q43怎样看待学历和能力?</h2><p>可以试这样回答“我认为一个人能力的高低,不是看你学了多少知识,而是看你在这个领域上如何发挥。学历只是进入一个企业的敲门砖,工作能力直接决定其职场命运”。</p>
<h2 id="Q44你做的哪件事最自豪"><a href="#Q44你做的哪件事最自豪" class="headerlink" title="Q44你做的哪件事最自豪?"></a>Q44你做的哪件事最自豪?</h2><p>描述一件能体现你潜在能力的事情</p>
<h2 id="Q45假如你要送同学去机场可单位临时有事非你办不可-怎么办"><a href="#Q45假如你要送同学去机场可单位临时有事非你办不可-怎么办" class="headerlink" title="Q45假如你要送同学去机场可单位临时有事非你办不可,怎么办?"></a>Q45假如你要送同学去机场可单位临时有事非你办不可,怎么办?</h2><p>如果时间能错开最好<br>如果工作不是很紧急,跟领导打声招呼,先去机场然后回来加班;<br>如果工作很紧急,试试能否请其他同事帮忙,实在无法平衡,就打电话给朋友解释一下。</p>
<h2 id="Q46为什么选择这个职务"><a href="#Q46为什么选择这个职务" class="headerlink" title="Q46为什么选择这个职务?"></a>Q46为什么选择这个职务?</h2><p>表明这一职务一直是自己的兴趣和专长,也累积了一定的经验及人脉,相信自己一定能胜任。<br>可以适时举出过去取得的成绩,但避免过于夸张或流于炫耀。</p>
<h2 id="Q47对这个职务的期许"><a href="#Q47对这个职务的期许" class="headerlink" title="Q47对这个职务的期许?"></a>Q47对这个职务的期许?</h2><p>说明自己希望能借此发挥所学及专长同时也吸收公司在这方面的经验。</p>
<h2 id="Q48谈谈如何适应新环境"><a href="#Q48谈谈如何适应新环境" class="headerlink" title="Q48谈谈如何适应新环境?"></a>Q48谈谈如何适应新环境?</h2><p>遵守规章制度,不迟到不早退,不擅自离岗;<br>根据领导指示和工作安排,制定工作计划,提前预备,并按计划完成;<br>多请示并及时汇报,遇到不明白的要虚心请教;<br>多学习,努力提高自己的业务水平。</p>
<h2 id="Q49除了本公司外-还应聘了哪些公司"><a href="#Q49除了本公司外-还应聘了哪些公司" class="headerlink" title="Q49除了本公司外,还应聘了哪些公司?"></a>Q49除了本公司外,还应聘了哪些公司?</h2><p>就算不便说出公司名称,也应回答“销售同种产品的公司”,如果应聘的其他公司是不同<strong>业界</strong>,容易让HR觉得你求职意向不明确。</p>
<h2 id="Q50请问你还有问题要问吗"><a href="#Q50请问你还有问题要问吗" class="headerlink" title="Q50请问你还有问题要问吗?"></a>Q50请问你还有问题要问吗?</h2><p>不要说没有问题,<br>可以将没有机会提的问题提出来,<br>可以强调你没有机会谈到的个人优势,<br>可以询问何时能得到面试结果,也可以借机表达“我很想得到这份工作,我完全能够胜任,请给我这个机会”。<br>最后,记得跟HR握手致谢。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://m.weibo.cn/detail/4448391272434927">https://m.weibo.cn/detail/4448391272434927</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>面试攻略</title>
    <url>/exam//767b4928/</url>
    <content><![CDATA[<h1 id="自我介绍篇"><a href="#自我介绍篇" class="headerlink" title="自我介绍篇"></a>自我介绍篇</h1><p>可包含如下信息:</p>
<h2 id="我是谁"><a href="#我是谁" class="headerlink" title="我是谁"></a>我是谁</h2><p>例如我是小明,毕业于xxxx大学xxxx专业,今天面试的岗位为xxxxx.</p>
<h2 id="职业相关经历介绍"><a href="#职业相关经历介绍" class="headerlink" title="职业相关经历介绍"></a>职业相关经历介绍</h2><p>提示<br>举出几个<strong>与面试职位相关的经历</strong>,结合具体事例,善用数字。<br>例如“在实习的两个月内先后帮助同事完成了xxxx,xxx和xxx三个项目&#x2F;报告,为公司带来xx利润。<br>“我被破例允许以实习生的身份在毎天的晨会上做宏观经济简报</p>
<h2 id="我为什么想要这份工作"><a href="#我为什么想要这份工作" class="headerlink" title="我为什么想要这份工作"></a>我为什么想要这份工作</h2><p>提示结合工作要求,谈谈你为什么能胜任这个工作。<br>例如xxx是我的强项,这份工作和我一直以来所做的以及职业生涯的发展非常匹配。</p>
<h2 id="个人其他值得一提的经历"><a href="#个人其他值得一提的经历" class="headerlink" title="个人其他值得一提的经历"></a>个人其他值得一提的经历</h2><p>提示<br>能够给面试官留下深刻印象的个人经历。<br>例如<br>我曾经做过义工,我曾经骑行去过西藏。</p>
<h1 id="自我评价篇"><a href="#自我评价篇" class="headerlink" title="自我评价篇"></a>自我评价篇</h1><p>可包含如下信息:</p>
<h2 id="你最大的缺点是什么"><a href="#你最大的缺点是什么" class="headerlink" title="你最大的缺点是什么?"></a>你最大的缺点是什么?</h2><p>提示<br>说出自己的缺点及改正它的过程。<br>例如<br>工作经验较少,需要学习和掌握的知识很多,所以有些不够自信,但是一定会加倍努力。</p>
<h2 id="你的优点是什么"><a href="#你的优点是什么" class="headerlink" title="你的优点是什么?"></a>你的优点是什么?</h2><p>提示<br>自己觉得还不错且和工作有关的的优点。<br>例如<br>处事能力类——沉着冷静、条理清矬;<br>优秀品质类—一不怕困难、喜欢挑战;<br>团队精神类乐于助人、关心他人。</p>
<h2 id="最能概括你的三个词是什么"><a href="#最能概括你的三个词是什么" class="headerlink" title="最能概括你的三个词是什么?"></a>最能概括你的三个词是什么?</h2><p>提示<br>不仅给出关键词,还应举出具体例子说明。<br>例如“我的适应能力强,有责任心和做事有始终”,并结合具体例子解释</p>
<h2 id="谈谈你某次失败的经历"><a href="#谈谈你某次失败的经历" class="headerlink" title="谈谈你某次失败的经历"></a>谈谈你某次失败的经历</h2><p>提示<br>应表达出曾做过的努力,并介绍从失败中总结出的经验,及如何处理、克服和改变。<br>例如<br>虽然方杗没有通过,但是拢到了存在的问题,并以更饱满的热情面对之后的工作。</p>
<h1 id="求职意愿篇"><a href="#求职意愿篇" class="headerlink" title="求职意愿篇"></a>求职意愿篇</h1><p>可包含如下信息:</p>
<h2 id="你为什么想来这里工作"><a href="#你为什么想来这里工作" class="headerlink" title="你为什么想来这里工作?"></a>你为什么想来这里工作?</h2><p>提示<br>可以从<strong>行业</strong>、<strong>平台</strong>和<strong>岗位</strong>这三个角度来回答。<br>例如<br>依据行业大环境与局部小环境的具体了解详细回答,充分表达自对于用人单位的向往和长期的职业规划等,突出自己与这份工作的契合点。</p>
<h2 id="你如何评价这份工作"><a href="#你如何评价这份工作" class="headerlink" title="你如何评价这份工作?"></a>你如何评价这份工作?</h2><p>提示<br>可以回答对工作环境很向往,对工作内容很感兴趣。<br>例如<br>之前受到从事过类似工作的前辈对自己产生的积极影晌,加上自己亲身的学习与实践体会,觉得这份工作的确有与众不同之处。</p>
<h2 id="你觉得你有什么优势"><a href="#你觉得你有什么优势" class="headerlink" title="你觉得你有什么优势?"></a>你觉得你有什么优势?</h2><p>提示充分了解招聘单位期待这个职位所能发挥的作用,根据自己的实际情况和优势,站在招聘单位的角度表明“我能做什么语句尽量简短有力,语气自信笃定。</p>
<h2 id="你能接受加班吗"><a href="#你能接受加班吗" class="headerlink" title="你能接受加班吗?"></a>你能接受加班吗?</h2><p>提示面试官提出这样的问题,通常是想看你愿不愿意为单位付出、奉献<br>例如<br>根据实际情况作答。或者表达出“我会提高效率,减少不必要的卩班类的意思。</p>
<h1 id="职业规划篇"><a href="#职业规划篇" class="headerlink" title="职业规划篇"></a>职业规划篇</h1><p>可包含如下信息:</p>
<h2 id="说说你对行业内热点事件-x2F-热门现象的看法"><a href="#说说你对行业内热点事件-x2F-热门现象的看法" class="headerlink" title="说说你对行业内热点事件&#x2F;热门现象的看法?"></a>说说你对行业内热点事件&#x2F;热门现象的看法?</h2><p>提示热点事件与热门现象往往众说纷纭,所以不必过度纠结持哪种见解。<br>回答问题时,理由要支撑观点,井依循一定的要点,有逻辑、有条理、有节奏地说出自己的想法。</p>
<h2 id="说说你对行业、技术发展趋势的看法"><a href="#说说你对行业、技术发展趋势的看法" class="headerlink" title="说说你对行业、技术发展趋势的看法?"></a>说说你对行业、技术发展趋势的看法?</h2><p>提示在面试前充分了解你所在行业的新近热点与发屐趋势,并在思考后整理出相对独特的见解。<br>聪明的求职者往往对所要涉足的领域预先了解很多,用人单位更青睐“知己”,而不是盲人</p>
<h2 id="你的职业规划是怎样的"><a href="#你的职业规划是怎样的" class="headerlink" title="你的职业规划是怎样的?"></a>你的职业规划是怎样的?</h2><p>提示这个问题涉及个人定位,回答时可以多侧重对于<strong>进步的渴望</strong>。未来规划是否是空想,是否能清楚地意识到风险的存在等,都会在规划中得到体现。因此要慎重考虑回答。</p>
<h2 id="就你所申请的这个职位-你认为你还欠缺什么"><a href="#就你所申请的这个职位-你认为你还欠缺什么" class="headerlink" title="就你所申请的这个职位,你认为你还欠缺什么?"></a>就你所申请的这个职位,你认为你还欠缺什么?</h2><p>可以通过个人经历的不足之处,以<strong>自省</strong>为角度回答问题可以表达“我相信自己可以胜任这份工作,目前只是缺验,我可以进入公司后以最短的解决,我的学习能力很强,相信可以很快融入单位,进入工作状态。</p>
<h1 id="临场压力篇"><a href="#临场压力篇" class="headerlink" title="临场压力篇"></a>临场压力篇</h1><p>可包含如下信息</p>
<h2 id="你并非毕业于名校"><a href="#你并非毕业于名校" class="headerlink" title="你并非毕业于名校?"></a>你并非毕业于名校?</h2><p>提示<br>没必要被这类问题激怒,要强调比学历更重要的是能力,并举列说明自己的优势。而且要强调你目前所掌握的技能可以匹配招聘需求。</p>
<h2 id="从简历上看-你的学习成绩似乎并不突出"><a href="#从简历上看-你的学习成绩似乎并不突出" class="headerlink" title="从简历上看,你的学习成绩似乎并不突出?"></a>从简历上看,你的学习成绩似乎并不突出?</h2><p>提示<br>突出与应聘岗位相关的高分课程;突出实习、兼职或社囫经历通过实践证明面试者的综合素质和能力;突出自己在大学长期坚持的某项爱好及取得的成绩。</p>
<h2 id="你还有什么问题要问吗"><a href="#你还有什么问题要问吗" class="headerlink" title="你还有什么问题要问吗?"></a>你还有什么问题要问吗?</h2><p>提示<br>根据个人情况作答,可以适当体现自己的个性,也可以表达自己的学习热情及上进心。<br>例如“贵单位对新入职的员工么培训项目?”“贵单位的xxx部门或产品)是怎样运生的?</p>
<h2 id="当你遇到真的无法回答的问题时"><a href="#当你遇到真的无法回答的问题时" class="headerlink" title="当你遇到真的无法回答的问题时"></a>当你遇到真的无法回答的问题时</h2><p>提示<br>不要着急回答,先要做认真思考,以示自己的认真态度与这个问题的难度诚恳向对方表明自己在这个问题上只知道皮毛,从来不知道深意;适时将问题抛给对方,表示出愿意聆听教导的诚意。</p>
<h1 id="群面篇"><a href="#群面篇" class="headerlink" title="群面篇"></a>群面篇</h1><p>提示<br>无论扮演的角色是什么,群面考察的本质上都是<strong>个人的气度礼仪、表达能力、沟通能力及合作能力</strong>等。<br>1提前熟悉队友:<br>群面是一次团队合作,沟通非常重要。在面试前与队友简单交流、相互熟悉,讨论的氛围会变得更加融洽;<br>2.善于倾听他人:<br>注意聆听别人的发言,一方面可以结合自己的思考推陈出新,另一方面可以通过总结让自己的发言更加全面;<br>3.逻辑清晰:<br>发言务必要有逻辑、有要点,力争让人能够及时理解你的观点、你的理由,提前列出框架会对你更有帮助;<br>4.学会及时应变:<br>在规定时间内达成共识,是群面中重要的考核点。适当妥协,勇于受更加合理的建议在群面中也是加分项。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://m.weibo.cn/detail/4448389053509435">https://m.weibo.cn/detail/4448389053509435</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode刷题 [9] 回文数</title>
    <url>/exam//2877c0a6/</url>
    <content><![CDATA[<h1 id="LeetCode刷题-9-回文数"><a href="#LeetCode刷题-9-回文数" class="headerlink" title="LeetCode刷题 [9] 回文数"></a>LeetCode刷题 [9] 回文数</h1><p><strong>思路:逆序这个整数,然后和该整数比较</strong></p>
<h2 id="解法2-使用StringBuilder的reverse方法逆序"><a href="#解法2-使用StringBuilder的reverse方法逆序" class="headerlink" title="解法2: 使用StringBuilder的reverse方法逆序"></a>解法2: 使用StringBuilder的reverse方法逆序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode1_10;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> francis</span></span><br><span class="line"><span class="comment"> * create at 2019/9/17-19:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeetCode9_2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 转成字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">xStr</span> <span class="operator">=</span> String.valueOf(x);</span><br><span class="line">        <span class="comment">// 逆序字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">reverseStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(String.valueOf(x)).reverse().toString();</span><br><span class="line">        <span class="keyword">return</span> xStr.equals(reverseStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] testArr = &#123;<span class="number">123</span>, <span class="number">121</span>, <span class="number">111</span>, <span class="number">1000</span>, <span class="number">12321</span>, <span class="number">2332</span>&#125;;</span><br><span class="line">        LeetCode9_2 leetCode9_2=<span class="keyword">new</span> <span class="title class_">LeetCode9_2</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testArr.length; i++) &#123;</span><br><span class="line">            System.out.println(testArr[i]+<span class="string">&quot; 是回文数:&quot;</span>+leetCode9_2.isPalindrome(testArr[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点:代码量少</strong></p>
<h2 id="解法3-通过数学运算逆序"><a href="#解法3-通过数学运算逆序" class="headerlink" title="解法3: 通过数学运算逆序"></a>解法3: 通过数学运算逆序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=9 lang=java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [9] 回文数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否是回文数.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 一个整数.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是小数,则不是回文数</span></span><br><span class="line">        <span class="comment">// 如果是10的倍数,也不是回文数</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; (x % <span class="number">10</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逆序这个正整数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">reverse</span> <span class="operator">=</span> getReverse(x);</span><br><span class="line">        <span class="comment">// 如果逆序后还和原来的数相等的话就是回文数</span></span><br><span class="line">        <span class="type">return</span> <span class="variable">reverse</span> <span class="operator">=</span>= x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 逆序正整数.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> positiveInteger 正整数.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该正整数逆序后的结果.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getReverse</span><span class="params">(<span class="type">int</span> positiveInteger)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">reverseInteger</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (positiveInteger &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将当前数字左移一位,然后加上个位数</span></span><br><span class="line">            reverseInteger = reverseInteger * <span class="number">10</span> + positiveInteger % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 右移删除掉当前的个位数</span></span><br><span class="line">            positiveInteger = positiveInteger / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverseInteger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>简单</category>
      </categories>
  </entry>
  <entry>
    <title>华为OD</title>
    <url>/exam//2b2bcc2e/</url>
    <content><![CDATA[<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211006141340.png" alt="image-20211006140957644"></p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211006141608.png" alt="image-20211006141607964"></p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>笔试题</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月11日 HTML CSS</title>
    <url>/exam//6acef549/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下列定义的 css 中,哪个权重是最低的？</p>
<ul>
<li>A #game .name</li>
<li>B #game .name span</li>
<li>C #game div</li>
<li>D #game div.name</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<table>
<thead>
<tr>
<th align="left">style</th>
<th align="left">权重</th>
</tr>
</thead>
<tbody><tr>
<td align="left">行内样式</td>
<td align="left">1000</td>
</tr>
<tr>
<td align="left">id</td>
<td align="left">100</td>
</tr>
<tr>
<td align="left">class</td>
<td align="left">10</td>
</tr>
<tr>
<td align="left">element</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>权重越大，优先级越高<br>CSS选择器优先级是指“基础选择器”的优先级：<br>ID &gt; CLASS &gt; ELEMENT &gt; *</p>
<p>a：100 + 10 &#x3D; 110<br>b：100 + 10 + 1 &#x3D; 111<br>c：100 + 1 &#x3D; 101<br>d：100 + 1 + 10 &#x3D; 111</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>对于li这个节点,下列哪个CSS选择器的优先级最高？</p>
<ul>
<li>A li#app</li>
<li>B li.cnt</li>
<li>C li.cnt:hover</li>
<li>D #app.cnt</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<table>
<thead>
<tr>
<th align="left">style</th>
<th align="left">权重</th>
</tr>
</thead>
<tbody><tr>
<td align="left">行内样式</td>
<td align="left">1000</td>
</tr>
<tr>
<td align="left">id</td>
<td align="left">100</td>
</tr>
<tr>
<td align="left">class</td>
<td align="left">10</td>
</tr>
<tr>
<td align="left">element</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>第一等:代表内联样式,如: style&#x3D;””，权值为1000。<br>第二等：代表ID选择器，如：#content，权值为0100。<br>第三等：代表类，伪类和属性选择器，如.content，权值为0010。<br>第四等：代表类型选择器和伪元素选择器，如div<br>p，权值为0001。<br>通配符、子选择器、相邻选择器等的。如<br>、&gt;、+,权值为0000。</p>
<p>权重:<br>①内联样式1000,如style&#x3D;””;<br>②ID100，如#content；<br>③类、属性10，如.content；<br>④标签1，如div。<br>A.li#app:标签+ID&#x3D;1+100&#x3D;101；<br>B.li.cnt：标签+类&#x3D;1+10&#x3D;11；<br>C.li.cnt:hover：标签+类&#x3D;11；<br>D.#app.cnt：ID+类&#x3D;100+10&#x3D;110。<br>(D)权重最大，优先级最高。</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>下列哪个不属于id与class之间的区别</p>
<ul>
<li>A id在文档中只能使用一次,而class可以多次使用</li>
<li>B id比class具有更高的样式优先级</li>
<li>C 一个元素只能有一个id属性值，却可以拥有多个class属性值</li>
<li>D 在class中可以定义:hover伪类，在id中不能定义</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>伪类选择符E:hover设置元素在其鼠标悬停时的样式。<br><code>E元素</code>可以通过其他选择器进行选择，比如使用<code>类选择符</code>、<code>id选择符</code>、<code>类型选择符</code>等等。</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>下面关于表单的说法中,错误的是 (      )</p>
<ul>
<li>A 可以给 input 添加 multiple 属性使它可以输入多行文字</li>
<li>B placeholder 属性可以用来提示用户输入什么内容</li>
<li>C 用户无法直接修改包含 disabled 属性的文本框的内容</li>
<li>D maxlength 属性可以限制文本框内最多输入多少个字符</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>multiple 属性是一个布尔属性。<br>multiple 属性规定允许用户输入到 <code>&lt;input&gt; </code>元素的多个值。<br>注意：multiple 属性适用于以下 input 类型：email 和 file。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;demo-form.php&quot;</span>&gt;</span></span><br><span class="line">  选择图片: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;img&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>有一个元素,需要在pc端显示而在手机端隐藏，需要使用的方法是？</p>
<ul>
<li>A visible-xs-8 hidden-md</li>
<li>B visible-md-8 hidden-xs</li>
<li>C visible-md-8 hidden-sm</li>
<li>D visible-sm-8 hidden-md</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>手机端屏幕是小于768px的，bootstrap col-xs代表屏幕小于768px，所以在手机端隐藏是hidden-xs。</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p><code>&lt;i&gt;</code>，<code>&lt;em&gt;</code>标签语义分别表示斜体和加粗,是否正确？</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<ul>
<li><code>&lt;i&gt;</code>标签只是单纯的样式标签，表现斜体的样式，但是语义上与普通文本无异；</li>
<li><code>&lt;em&gt;</code>标签在样式上表示为斜体，同时在语义上也表示为强调</li>
</ul>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>以下不属于把CSS样式表与HTML网页关联的方法的是()</p>
<ul>
<li>A 在HTML文档的<code>&lt;!--…--&gt;</code>标签内定义CSS样式</li>
<li>B 用<code>&lt;link&gt;</code>标签链接网上可访问的CSS样式表文件</li>
<li>C 在HTML文档的<head>标签内定义CSS样式</li>
<li>D 用<code>@import</code>引入样式表文件</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>关于标签,下列说法错误的是</p>
<ul>
<li>A <code>&lt;video&gt;</code>标签中controls属性决定是否向用户显示控件</li>
<li>B <code>&lt;audio&gt;</code>与<code>&lt;/audio&gt;</code>之间插入的内容是用来解释控件的</li>
<li>C <code>&lt;datalist&gt;</code>标签可以和input标签配合进行使用，来显示列表</li>
<li>D <code>&lt;progress&gt;</code>标签不填写max和value会自动滑动</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p><code>&lt;audio&gt; </code>与<code>&lt;/audio&gt;</code> 之间插入的内容是供不支持audio 元素的浏览器显示的</p>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>以下选项正确的是</p>
<ul>
<li>A <code>&lt;p /&gt;</code></li>
<li>B <code>&lt;br /&gt;</code></li>
<li>C <code>&lt;hr /&gt;</code></li>
<li>D <code>&lt;img /&gt;</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details>

<p>HTML中的标签分为<code>闭合标签</code>和<code>自闭合标签</code>。 自闭合标签有</p>
<ul>
<li><code>&lt;input/&gt;</code></li>
<li><code>&lt;img/&gt;</code></li>
<li><code>&lt;br/&gt;</code></li>
<li><code>&lt;link/&gt;</code></li>
<li><code>&lt;hr/&gt;</code></li>
</ul>
<p>等</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>HTML CSS</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月12日 HTML CSS1</title>
    <url>/exam//f0d7fdad/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下列哪个样式定义后,内联(非块状)元素可以定义宽度和高度</p>
<ul>
<li>A display:inline</li>
<li>B display:block</li>
<li>C display:none</li>
<li>D display:inherit</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<ul>
<li>block:将行级别元素转为块级别元素</li>
<li>inline:将块级别元素转为行级别元素</li>
<li>inline-block:不能自动换行,但是可以设置宽高</li>
</ul>
<p>内联元素加上display：block后被块级化，块级元素一般是其他元素的容器，可容纳其他内联元素和其他块状元素。块状元素排斥和其他元素一行，高度和宽度起作用，因此可以定义宽高。</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>css属性font-style用于设置字体的粗细。请判断这句话的正确与否。</p>
<ul>
<li>A T</li>
<li>B F</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="font-style属性定义字体的风格"><a href="#font-style属性定义字体的风格" class="headerlink" title="font-style属性定义字体的风格"></a>font-style属性定义字体的风格</h3><p>注意：该属性设置使用斜体、倾斜或正常字体。<br>语法: font-style: normal | italic | oblique | inherit;</p>
<ul>
<li>normal:默认正常情况;</li>
<li>italic:显示文字为斜体(该字体有斜体样式时使用)</li>
<li>oblique:显示文字为斜体(该字体没有斜体样式时使用,文字斜体显示)</li>
<li>inherit:从父亲那继承一个样式字体;</li>
</ul>
<h3 id="font-weight属性设置文本的粗细"><a href="#font-weight属性设置文本的粗细" class="headerlink" title="font-weight属性设置文本的粗细"></a>font-weight属性设置文本的粗细</h3><p>注意：该属性用于设置显示元素的文本中所用的字体加粗。</p>
<p>语法: font-weight: normal | bold | bolder | lighter | 100-900 | inherit;</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>表示有序列表的是</p>
<ul>
<li>A ul</li>
<li>B dl</li>
<li>C li</li>
<li>D ol</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<ul>
<li>ul 无序列表</li>
<li>ol 有序列表</li>
<li>li 定义列表项目</li>
<li>dl 定义列表</li>
</ul>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>请选出结构正确的选项</p>
<ul>
<li>A <code>&lt;a href=www.nowcoder.com&gt;牛客网&lt;/a&gt;</code></li>
<li>B <code>&lt;a href=&quot;www.nowcoder.com&quot;&gt;牛客网&lt;/a&gt;</code></li>
<li>C <code>&lt;a href=&quot;http://www.nowcoder.com/&quot;&gt;牛客网&lt;/a&gt;</code></li>
<li>D <code>&lt;a href=&quot;http://www.nowcoder.com/&quot;&gt;牛客网</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>href属性值是URL，而URL里包含协议，但不一定是http协议。如果没协议就会解析为相对路径。在浏览器地址栏中不输入协议名也行是因为浏览器发现这个相对路径没东西之后自动帮你加的协议。</p>
<ul>
<li>属性值要写在引号里面，A错误</li>
<li>URL中要有协议,B错误</li>
<li>a标签为双标签故应为<code>&lt;a&gt;&lt;/a&gt;</code>，所以D错误</li>
</ul>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>从四个选项选出不同的一个。</p>
<ul>
<li>A <code>&lt;nav&gt;</code></li>
<li>B <code>&lt;footer&gt;</code></li>
<li>C <code>&lt;meta&gt;</code></li>
<li>D <code>&lt;canvas&gt;</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<ul>
<li>A选项<code>&lt;nav&gt;&lt;/nav&gt;</code>，位于<code>&lt;body&gt;&lt;/body&gt;</code>中。标签定义导航链接；</li>
<li>B选项<code>&lt;footer&gt;&lt;/footer&gt;</code>,位于<code>&lt;body&gt;&lt;/body&gt;</code>中。标签定义文档或节的页脚；</li>
<li>C选项<code>&lt;meta&gt;</code>,<code>&lt;meta&gt;</code> 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。</li>
<li><code>&lt;meta&gt;</code>标签位于文档的头部（<code>&lt;head&gt;&lt;/head&gt;</code>），不包含任何内容。<code>&lt;meta&gt;</code> 标签的属性定义了与文档相关联的名称&#x2F;值对。</li>
<li>D选项<code>&lt;canvas&gt;</code>。<code>&lt;canvas&gt;</code>位于<code>&lt;body&gt;&lt;/body&gt;</code>中， 标签定义图形，比如图表和其他图像。</li>
</ul>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p><code>HTML</code> 语言中,设置表格中文字与边框距离的标签是(      )</p>
<ul>
<li>A <code>&lt;table boder=&quot;&quot;&gt;</code></li>
<li>B <code>&lt;table cellspacing=&quot;&quot;&gt;</code></li>
<li>C <code>&lt;table cellpadding=&quot;&quot;&gt;</code></li>
<li>D <code>&lt;table width=&quot;&quot;&gt;</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>cellpadding</code></td>
<td align="left">单元格<strong>边距</strong>，就是文字与边框之间的距离</td>
</tr>
<tr>
<td align="left"><code>cellspacing</code></td>
<td align="left">单元格之间的间距</td>
</tr>
</tbody></table>
<h3 id="表格标记的常用属性有9个"><a href="#表格标记的常用属性有9个" class="headerlink" title="表格标记的常用属性有9个"></a>表格标记的常用属性有9个</h3><ul>
<li><code>cellpadding</code>:单元格边沿与其内容之间的空白 <code>cellspacing</code>:单元格之间的空白</li>
<li><code>border</code>:表格边框的宽度(也可以理解我边框的粗细程度) </li>
<li><code>height</code>:表格高度</li>
<li><code>width</code>:表格的宽度</li>
<li><code>bgcolor</code>:表格背景颜色 </li>
<li><code>align</code>:表格相对周围元素的对齐方式(也可以理解为表格中的文字内容的对齐方式) </li>
<li><code>frame</code>:规定外侧边框哪些部分是可见的</li>
<li><code>rules</code>:规定内侧边框哪些部分是可见的</li>
</ul>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>以下说法,错误的是</p>
<ul>
<li>A <code>mark</code>用于显示变粗的文字</li>
<li>B <code>&lt;del&gt;</code>用于显示删除的文本</li>
<li>C <code>&lt;ins&gt;</code>的文字会带下划线</li>
<li>D <code>&lt;strong&gt;</code>用于强调文本</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<ul>
<li><code>&lt;mark&gt;</code> 标签定义带有记号的文本。请在需要突出显示文本时使用 <code>&lt;m&gt;</code> 标签。</li>
<li><code>&lt;del&gt;</code>定义文档中已被删除的文本。 </li>
<li><code>&lt;ins&gt;</code> 标签定义已经被插入文档中的文本。 </li>
<li><code>&lt;strong&gt;</code> 标签和<code>&lt;em&gt;</code> 标签一样，用于强调文本，但<code>&lt;strong&gt;</code> 强调的程度更强一些。</li>
</ul>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>以下哪个<code>CSS</code>属性是继承属性(<code>inherited)</code>？</p>
<ul>
<li>A <code>vertical-align</code></li>
<li>B <code>background-color</code></li>
<li>C <code>text-indent</code></li>
<li>D <code>justify-content</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h3 id="什么是CSS中的继承"><a href="#什么是CSS中的继承" class="headerlink" title="什么是CSS中的继承"></a>什么是CSS中的继承</h3><p><strong>继承就是指<code>子节点</code>默认使用<code>父节点</code>的样式属性</strong>。 </p>
<h3 id="那些属性可以继承"><a href="#那些属性可以继承" class="headerlink" title="那些属性可以继承"></a>那些属性可以继承</h3><p>不可继承的属性太多了不要背，记住可以继承的属性有哪些就行了。<br>可以继承的属性很少，只有<code>颜色</code>，<code>文字</code>，<code>字体间距</code>，<code>行高</code>，<code>对齐方式</code>，和<code>列表的样式</code>可以继承。 </p>
<ul>
<li>所有元素可继承：<code>visibility</code>和<code>cursor</code>。</li>
<li>内联元素可继承：<code>letter-spacing</code>、<code>word-spacing</code>、<code>white-space</code>、<code>line-height</code>、<code>color</code>、<code>font</code>、<code>font-family</code>、<code>font-size</code>、<code>font-style</code>、<code>font-variant</code>、<code>font-weight</code>、<code>text-decoration</code>、<code>text-transform</code>、<code>direction</code>。 </li>
<li>终端块状元素可继承：<code>text-indent</code>和<code>text-align</code>。 </li>
<li>列表元素可继承：<code>list-style</code>、<code>list-style-type</code>、<code>list-style-position</code>、<code>list-style-image</code>。</li>
</ul>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>关于<code>web</code>表单登录中用到的图形验证码的实现,以下做法不正确的有</p>
<ul>
<li>A 返回给浏览器的<code>html</code>代码中包含图形验证码和文本字符串,登录前客户端判断输入内容和页面中保存的内容是否一致</li>
<li>B 服务器端在返回的图片和<code>cookie</code>中同时包含图形验证码,登录前客户端判断输入内容和<code>cookie</code>保存的内容是否一致</li>
<li>C 服务器端生成验证码后一方面通过图片将验证码返回给客户端,同时在服务器端保存文本的验证码,由服务器端验证输入内容是否正确</li>
<li>D 浏览器通过识别图形验证码中的内容和用户输入的内容判断是否一致</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: `ABD`</details>

<p>放浏览器判断太不安全啦，当然要给服务器来判断啦</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>HTML CSS</category>
      </categories>
  </entry>
  <entry>
    <title>2021年03月22日 HTML1</title>
    <url>/exam//8c8ce85/</url>
    <content><![CDATA[<h1 id="考点1-HTML清除浮动"><a href="#考点1-HTML清除浮动" class="headerlink" title="考点1:HTML清除浮动"></a>考点1:HTML清除浮动</h1><p>浮动会导致页面的非正常显示,以下几种清除浮动的方法,哪个是不推荐使用的？</p>
<ul>
<li>A 在浮动元素末尾添加一个空的标签例如 <code>&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</code></li>
<li>B 通过设置父元素<code>overflow</code>值为<code>hidden;</code></li>
<li>C 父元素也设置浮动</li>
<li>D 给父元素添加<code>clearfix</code>类</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>完美的解答: <a href="https://segmentfault.com/a/1190000004865198">https://segmentfault.com/a/1190000004865198</a></p>
<h1 id="考点2-jQuery的text，html，val，attr方法"><a href="#考点2-jQuery的text，html，val，attr方法" class="headerlink" title="考点2:jQuery的text，html，val，attr方法"></a>考点2:jQuery的text，html，val，attr方法</h1><p>jQuery通过哪个方法可以设置或返回表单字段的值:</p>
<ul>
<li>A $(&amp;<code>quot;</code>#<code>test</code>&amp;<code>quot;</code>).<code>text()</code></li>
<li>B $(&amp;<code>quot;</code>#<code>test</code>&amp;<code>quot;</code>).<code>html()</code></li>
<li>C $(&amp;<code>quot;</code>#<code>test</code>&amp;<code>quot;</code>).<code>val()</code></li>
<li>D $(&amp;<code>quot;</code>#<code>test</code>&amp;<code>quot;</code>).<code>attr()</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>.value()  用在表单元素上，用来设置获取 input 或 select 的值<br>.html()  设置或返回的是源代码<br>.text()  设置或返回的是纯文本内容<br>.attr()  设置或返回被选元素的属性值</p>
<h1 id="考点3-HTTP协议"><a href="#考点3-HTTP协议" class="headerlink" title="考点3:HTTP协议"></a>考点3:HTTP协议</h1><p>下列关于HTTP协议的描述中,错误的是()</p>
<ul>
<li>A <code>HTTP</code>协议是应用层协议,它的底层基于<code>UDP</code>连接</li>
<li>B <code>HTTP</code>协议规定了浏览器与服务器通信的四个步骤,依次是:建立连接、发送请求、接收响应、关闭连接</li>
<li>C <code>HTTP</code>请求报文中,包含请求方式、请求路径、协议版本、消息头等内容</li>
<li>D <code>HTTP</code>响应报文中,包含状态码、状态名、协议版本、消息头等内容</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>http是一个简单的请求-响应协议，它通常运行在TCP之上，其底层基于TCP。</p>
<h1 id="考点4-HTML5组合标题元素"><a href="#考点4-HTML5组合标题元素" class="headerlink" title="考点4:HTML5组合标题元素"></a>考点4:HTML5组合标题元素</h1><p>在 HTML5 中,哪个元素用于组合标题元素？()</p>
<ul>
<li>A <code>&lt;group&gt;</code></li>
<li>B <code>&lt;header&gt;</code></li>
<li>C <code>&lt;headings&gt;</code></li>
<li>D <code>&lt;hgroup&gt;</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p><a href="https://m.runoob.com/tags/tag-hgroup.html">https://m.runoob.com/tags/tag-hgroup.html</a></p>
<h1 id="考点5-HTML滑块控件"><a href="#考点5-HTML滑块控件" class="headerlink" title="考点5:HTML滑块控件"></a>考点5:HTML滑块控件</h1><p>哪种输入类型定义滑块控件？</p>
<ul>
<li>A <code>search</code></li>
<li>B <code>controls</code></li>
<li>C <code>slider</code></li>
<li>D <code>range</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>input type  为 range</p>
<table>
<thead>
<tr>
<th align="left">input type属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">button</td>
<td align="left">定义可点击的按钮（大多与 JavaScript 使用来启动脚本）</td>
</tr>
<tr>
<td align="left">checkbox</td>
<td align="left">定义复选框。</td>
</tr>
<tr>
<td align="left">color</td>
<td align="left">定义拾色器。</td>
</tr>
<tr>
<td align="left">date</td>
<td align="left">定义日期字段（带有 calendar 控件）</td>
</tr>
<tr>
<td align="left">datetime</td>
<td align="left">定义日期字段（带有 calendar 和 time 控件）</td>
</tr>
<tr>
<td align="left">datetime-local</td>
<td align="left">定义日期字段（带有 calendar 和 time 控件）</td>
</tr>
<tr>
<td align="left">month</td>
<td align="left">定义日期字段的月（带有 calendar 控件）</td>
</tr>
<tr>
<td align="left">week</td>
<td align="left">定义日期字段的周（带有 calendar 控件）</td>
</tr>
<tr>
<td align="left">time</td>
<td align="left">定义日期字段的时、分、秒（带有 time 控件）</td>
</tr>
<tr>
<td align="left">email</td>
<td align="left">定义用于 e-mail 地址的文本字段</td>
</tr>
<tr>
<td align="left">file</td>
<td align="left">定义输入字段和 “浏览…” 按钮，供文件上传</td>
</tr>
<tr>
<td align="left">hidden</td>
<td align="left">定义隐藏输入字段</td>
</tr>
<tr>
<td align="left">image</td>
<td align="left">定义图像作为提交按钮</td>
</tr>
<tr>
<td align="left">number</td>
<td align="left">定义带有 spinner 控件的数字字段</td>
</tr>
<tr>
<td align="left">password</td>
<td align="left">定义密码字段。字段中的字符会被遮蔽。</td>
</tr>
<tr>
<td align="left">radio</td>
<td align="left">定义单选按钮。</td>
</tr>
<tr>
<td align="left">range</td>
<td align="left">定义带有 slider 控件的数字字段。</td>
</tr>
<tr>
<td align="left">reset</td>
<td align="left">定义重置按钮。重置按钮会将所有表单字段重置为初始值。</td>
</tr>
<tr>
<td align="left">search</td>
<td align="left">定义用于搜索的文本字段。</td>
</tr>
<tr>
<td align="left">submit</td>
<td align="left">定义提交按钮。提交按钮向服务器发送数据。</td>
</tr>
<tr>
<td align="left">tel</td>
<td align="left">定义用于电话号码的文本字段。</td>
</tr>
<tr>
<td align="left">text</td>
<td align="left">默认。定义单行输入字段，用户可在其中输入文本。默认是 20 个字符。</td>
</tr>
<tr>
<td align="left">url</td>
<td align="left">定义用于 URL 的文本字段。</td>
</tr>
</tbody></table>
<h1 id="考点6-HTML5相关框架或者类库"><a href="#考点6-HTML5相关框架或者类库" class="headerlink" title="考点6:HTML5相关框架或者类库"></a>考点6:HTML5相关框架或者类库</h1><p>下列哪些是HTML5相关的框架或类库:(         )</p>
<ul>
<li>A <code>spring-core</code></li>
<li>B <code>RactiveJS</code></li>
<li>C <code>Dubbo</code></li>
<li>D <code>Bootstrap</code></li>
<li>E <code>AngularJS</code></li>
<li>F <code>Hibernate</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BDE</details>

<p>Bootstrap、AngularJS这三个。<br>查了一下：<br>Spring框架是一个开放源代码的J2EE应用程序框架<br>Dubbo是一款高性能、轻量级的开源Java RPC框架<br>Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架</p>
<h1 id="考点7-HTML5"><a href="#考点7-HTML5" class="headerlink" title="考点7:HTML5"></a>考点7:HTML5</h1><p>下列属于HTML5新元素的是？()</p>
<ul>
<li>A <code>header</code></li>
<li>B <code>nav</code></li>
<li>C <code>section</code></li>
<li>D <code>viewport</code></li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<p>Viewport是属性<br>HTML5中常用的新特性：<br>canvas元素：用于定义图形（图表等），只是图形容器，必须使用脚本来绘制图形。<br>audio：用于音频播放。<br>video：用于视频播放。<br>article：规定独立的自包含内容。<br>header：定义文档的页眉，介绍相关信息。<br>section：定义文档中的节。<br>footer：定义文档的页脚，通常有文档的作者、版权信息、联系方式等。<br>nav：定义导航链接。<br>表单控件：<br>calender<br>date<br>time<br>email<br>url<br>search<br><a href="https://zhuanlan.zhihu.com/p/25445181">https://zhuanlan.zhihu.com/p/25445181</a></p>
<h1 id="考点8-HTML5新增元素"><a href="#考点8-HTML5新增元素" class="headerlink" title="考点8:HTML5新增元素"></a>考点8:HTML5新增元素</h1><p>下列选项中哪些标签是HTML5新增的？</p>
<ul>
<li>A <code>footer</code></li>
<li>B <code>content</code></li>
<li>C <code>section</code></li>
<li>D <code>header</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details>


<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9:"></a>考点9:</h1><p>以下哪些HTML标签属于行内元素:</p>
<ul>
<li>A p</li>
<li>B span</li>
<li>C canvas</li>
<li>D label</li>
<li>E img</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BDE</details>

<p>p 、canvas –&gt; 块状元素<br>span 、img 、label –&gt; 内联元素（行内）</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>HTML CSS</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月15日 js1</title>
    <url>/exam//5e5d21bc/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>以下哪一个不是JavaScript的数据类型:</p>
<ul>
<li>A <code>String</code></li>
<li>B <code>Boolean</code></li>
<li>C <code>Integer</code></li>
<li>D <code>Undefined</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h3 id="JavaScript中的数据类"><a href="#JavaScript中的数据类" class="headerlink" title="JavaScript中的数据类"></a>JavaScript中的数据类</h3><ul>
<li>基本类型:Undefined,Null,Boolean,Number.</li>
<li>引用类型:Object, Array, Function</li>
</ul>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>以下代码执行的结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 0,1,2</li>
<li>B 1,2,3</li>
<li>C 3,3,3</li>
<li>D 0,0,0</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>每次for循环的时候setTimeout都会执行，因为setTimeout是<strong>异步函数</strong>，里面的function则不会立即执行，而是会被放入任务队列，因此放了3次；<br>任务队列中的函数会在for循环结束之后执行。<br>for循环的3次执行完之后,i变为3，也就是每次循环，i都会被后一个i值覆盖。所以就是输出3个3。</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>请问在javascript程序中,alert(undefined&#x3D;&#x3D;null)的输出结果是</p>
<ul>
<li>A <code>null</code></li>
<li>B <code>undefined</code></li>
<li>C <code>true</code></li>
<li>D <code>false</code></li>
<li>E 以上答案都不正确</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>&#x3D;&#x3D;仅判断<code>值</code>是否相同，undefined值和null是相同的，故true<br>&#x3D;&#x3D;&#x3D;在判断值是否相同的同时<strong>还判断类型是否相同</strong>，</p>
<ul>
<li>undefined类型为undefined，</li>
<li>null类型为object，</li>
<li>因此为false</li>
</ul>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>var str1&#x3D;new RegExp(“e”);<br>document.write(str1.exec(“hello”));<br>以上代码输出结果为(      )</p>
<ul>
<li>A e</li>
<li>B <code>null</code></li>
<li>C 1</li>
<li>D 其他几项都不对</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h3 id="正则表达式方法-exec-方法"><a href="#正则表达式方法-exec-方法" class="headerlink" title="正则表达式方法 exec()方法"></a>正则表达式方法 exec()方法</h3><p>exec()方法用于检索字符串中的匹配正则表达式的子串<br>该函数返回一个数组，其中存放匹配的子串。如果未找到匹配，则返回值为 null。</p>
<p>JavaScript高级程序设计<br>有空了解一下</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下列关于 JavaScript 的说法中正确的是()</p>
<ul>
<li>A 所有变量在使用之前必须做声明</li>
<li>B <code>JavaScript</code>是面向对象的程序设计语言</li>
<li>C <code>JavaScript</code>是解释性语言</li>
<li>D <code>JavaScript</code>前身是<code>Oak</code>语言</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>
### 解释性语言和编译型语音
**解释性语言**是相对于**编译型语言**存在的，
**编译型语言**源代码直接翻译成`机器语言`，
解释性语言源代码先翻译成中间代码，再由解释器对中间代码进行解释运行。
比如Python/JavaScript / Perl /Shell等都是解释型语言。
### JavaScript局部变量可以不声明
A如果是局部变量无需声明，也可以使用，如下所示。所以A错误。
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 没有 var i</span></span></span><br><span class="line"><span class="language-javascript">    &#125;      <span class="keyword">return</span> i;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">writeln</span>(<span class="title function_">a</span>());</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br></pre></td></tr></table></figure>
### javascript不是面向对象语言
javascript没有继承性，所以B错误。

<p>D选项中JAVA的前身才是Oak，而不是JavaScript。所以D错误。</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下面有关JavaScript中 call和apply的描述,错误的是？</p>
<ul>
<li>A <code>call</code>与<code>apply</code>都属于<code>Function.prototype</code>的一个方法,所以每个<code>function</code>实例都有<code>call</code>、<code>apply</code>属性</li>
<li>B 两者传递的参数不同,<code>call</code>函数第一个参数都是要传入给当前对象的对象,<code>apply</code>不是</li>
<li>C <code>apply</code>传入的是一个参数数组,也就是将多个参数组合成为一个数组传入</li>
<li>D <code>call</code>传入的则是直接的参数列表。<code>call</code> 方法可将一个函数的对象上下文从初始的上下文改变为由 <code>thisObj</code> 指定的新对象。</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>有空了解一下</p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>typeof Date.now() 的值是:</p>
<ul>
<li>A date</li>
<li>B object</li>
<li>C number</li>
<li>D error</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>Date.now() 方法返回自1970年1月1日 00:00:00 UTC到当前时间的<strong>毫秒数</strong>。<br>故该题为number</p>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>0xff ^ 33 的结果是:</p>
<ul>
<li>A 220</li>
<li>B 221</li>
<li>C 222</li>
<li>D 223</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xff＝1111 1111(255)</span><br><span class="line"></span><br><span class="line">1111 1111(255)</span><br><span class="line">0010 0001(33)</span><br><span class="line">异或操作     </span><br><span class="line">1101 1110(222)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>2021年03月23日Linux专项练习4</title>
    <url>/exam//3a8d0894/</url>
    <content><![CDATA[<h1 id="考点1-如何修改文件权限"><a href="#考点1-如何修改文件权限" class="headerlink" title="考点1:如何修改文件权限"></a>考点1:如何修改文件权限</h1><p>怎样更改一个文件的权限设置？</p>
<ul>
<li>A <code>chmod</code></li>
<li>B <code>file</code></li>
<li>C <code>attrib</code></li>
<li>D <code>change</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>chmod 是change &amp;nbsp;mode of file 的缩写，改变文件的的读写权限。</p>
<h1 id="考点2-hardware-filename-fixed-address-server-name命令"><a href="#考点2-hardware-filename-fixed-address-server-name命令" class="headerlink" title="考点2:hardware filename fixed-address server-name命令"></a>考点2:hardware filename fixed-address server-name命令</h1><p>在dhcpd.conf中用于向某个客户主机分配固定IP地址的参数是 (   )</p>
<ul>
<li>A <code>server-name</code></li>
<li>B <code>fixed-address</code></li>
<li>C <code>filename</code></li>
<li>D <code>hardware</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="hardware语句"><a href="#hardware语句" class="headerlink" title="hardware语句"></a>hardware语句</h3><p>语法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hardware hardware-type hardware-address; </span><br></pre></td></tr></table></figure>
<p>指明物理硬件接口类型和硬件地址。硬件地址由6个8位组构成，每个8位组以“：”隔开。如00：00：E8：1B：54：97</p>
<h3 id="server-name-语句"><a href="#server-name-语句" class="headerlink" title="server-name 语句"></a>server-name 语句</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server-name <span class="string">&quot;name&quot;</span>; </span><br></pre></td></tr></table></figure>
<p>用于告诉客户服务器的名字。</p>
<h3 id="fixed-address-语句"><a href="#fixed-address-语句" class="headerlink" title="fixed-address 语句"></a>fixed-address 语句</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fixed-address address [, address ... ]; </span><br></pre></td></tr></table></figure>
<p>fixed-address 语句用于指定一个或多个IP地址给一个DHCP客户。只能出现在host声明里。</p>
<h1 id="考点3-ls-df-du-fine命令"><a href="#考点3-ls-df-du-fine命令" class="headerlink" title="考点3:ls df du fine命令"></a>考点3:ls df du fine命令</h1><p>下列哪个命令可以看到文件的大小？(不添加参数的情况下)</p>
<ul>
<li>A <code>ls</code></li>
<li>B <code>df</code></li>
<li>C <code>du</code></li>
<li>D <code>find</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>A：ls是list的缩写，用来显示当前目录下面文件的信息；如果要查看文件的大小则需要加上-al参数<br>B：df是disk free的缩写，用来显示文件系统中不同磁盘的使用情况；<br>C：du是disk usage的缩写，显示当前目录或者当前文件的占用的块大小；<br>D：find命令作用在目录下，用来查找指定目录或者当前目录下的文件。</p>
<h2 id="ls-l查看文件大小"><a href="#ls-l查看文件大小" class="headerlink" title="ls -l查看文件大小"></a>ls -l查看文件大小</h2><p>参考资料：<a href="https://www.cnblogs.com/sparkdev/p/7476005.html">https://www.cnblogs.com/sparkdev/p/7476005.html</a><br>ls -al命令输出的第5列就是该文件或目录的大小（以字节为单位显示的文件大小）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ls -l exam/</span><br><span class="line">总用量 3640</span><br><span class="line">-rw-r--r--.   1 root root    3093 3月  19 21:12 _config.yml</span><br><span class="line">-rw-r--r--.   1 root root 3498022 3月  22 20:29 db.json</span><br><span class="line">-rw-r--r--.   1 root root     158 3月  19 21:12 FM.properties</span><br><span class="line">-rw-r--r--.   1 root root     576 3月  19 21:12 HexoD.bat</span><br><span class="line">-rw-r--r--.   1 root root     431 3月  22 20:52 HexoS.bat</span><br><span class="line">-rwxr--r--.   1 root root     174 3月  19 21:16 hexos.sh</span><br><span class="line">-rw-r--r--.   1 root root     376 3月  19 21:12 HexoSTest.bat</span><br><span class="line">drwxr-xr-x. 308 root root    8192 3月  19 21:19 node_modules</span><br><span class="line">-rw-r--r--.   1 root root     817 3月  19 21:12 package.json</span><br><span class="line">-rw-r--r--.   1 root root  170424 3月  19 21:19 package-lock.json</span><br><span class="line">drwxr-xr-x.   2 root root    4096 3月  19 21:12 scaffolds</span><br><span class="line">drwxr-xr-x.   9 root root    4096 3月  19 21:12 source</span><br><span class="line">-rw-r--r--.   1 root root     422 3月  19 21:12 StartWriting.bat</span><br><span class="line">drwxr-xr-x.   3 root root    4096 3月  19 21:12 themes</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>
<h3 id="ls-lh"><a href="#ls-lh" class="headerlink" title="ls -lh"></a>ls -lh</h3><p>在 Linux 命令中，涉及到文件大小的地方，一般默认是以字节为单位显示的。这样可读性就不是很好。所以有了 -h 选项！这个选项的全称是 –human-readable(给人读的)。也就是以 K, M, G 等单位来显示文件的大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ls -lh exam/</span><br><span class="line">总用量 3.6M</span><br><span class="line">-rw-r--r--.   1 root root 3.1K 3月  19 21:12 _config.yml</span><br><span class="line">-rw-r--r--.   1 root root 3.4M 3月  22 20:29 db.json</span><br><span class="line">-rw-r--r--.   1 root root  158 3月  19 21:12 FM.properties</span><br><span class="line">-rw-r--r--.   1 root root  576 3月  19 21:12 HexoD.bat</span><br><span class="line">-rw-r--r--.   1 root root  431 3月  22 20:52 HexoS.bat</span><br><span class="line">-rwxr--r--.   1 root root  174 3月  19 21:16 hexos.sh</span><br><span class="line">-rw-r--r--.   1 root root  376 3月  19 21:12 HexoSTest.bat</span><br><span class="line">drwxr-xr-x. 308 root root 8.0K 3月  19 21:19 node_modules</span><br><span class="line">-rw-r--r--.   1 root root  817 3月  19 21:12 package.json</span><br><span class="line">-rw-r--r--.   1 root root 167K 3月  19 21:19 package-lock.json</span><br><span class="line">drwxr-xr-x.   2 root root 4.0K 3月  19 21:12 scaffolds</span><br><span class="line">drwxr-xr-x.   9 root root 4.0K 3月  19 21:12 source</span><br><span class="line">-rw-r--r--.   1 root root  422 3月  19 21:12 StartWriting.bat</span><br><span class="line">drwxr-xr-x.   3 root root 4.0K 3月  19 21:12 themes</span><br><span class="line">[root@localhost ~]# </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="考点4-Linux命令返回值"><a href="#考点4-Linux命令返回值" class="headerlink" title="考点4:Linux命令返回值"></a>考点4:Linux命令返回值</h1><p>linux命令执行成功后会返回</p>
<ul>
<li>A 0</li>
<li>B 1</li>
<li>C 2</li>
<li>D -1</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h3 id="Linux命令返回值"><a href="#Linux命令返回值" class="headerlink" title="Linux命令返回值"></a>Linux命令返回值</h3><p>参考资料：<br><a href="https://blog.csdn.net/cy413026/article/details/104172448">https://blog.csdn.net/cy413026/article/details/104172448</a><br>Linux错误代码及其含义：<a href="https://blog.csdn.net/u013457167/article/details/79196306">https://blog.csdn.net/u013457167/article/details/79196306</a></p>
<p>在shell终端中，你所输入的一切命令其实都有返回值，而这个返回值默认保存在变量<code>$?</code>中，举例看一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line"> </span><br><span class="line">grup_pwd=`cat /etc/grub.conf | grep -v ^# | grep password 2&gt; /dev/null`</span><br><span class="line"> </span><br><span class="line">if [ $? -eq 0 ];then</span><br><span class="line">   echo &quot;  [ √ ] 已设置grub密码,符合要求&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;  [ X ] 没有设置grub密码，不符合要求,建议设置grub密码&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h3 id="Linux错误码含义"><a href="#Linux错误码含义" class="headerlink" title="Linux错误码含义"></a>Linux错误码含义</h3><p>Linux错误代码及其含义：<a href="https://blog.csdn.net/u013457167/article/details/79196306">https://blog.csdn.net/u013457167/article/details/79196306</a></p>
<h1 id="考点5-查看文件命令cat-more-tail"><a href="#考点5-查看文件命令cat-more-tail" class="headerlink" title="考点5:查看文件命令cat more tail"></a>考点5:查看文件命令cat more tail</h1><p>为了查看不断更新的日志文件,可以使用的指令是()</p>
<ul>
<li>A <code>cat -n</code></li>
<li>B <code>vi</code></li>
<li>C <code>more</code></li>
<li>D <code>tail -f</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>linux 下tail用于查看档案的结尾，-f 参数是follow的意思，当文件增长时，输出后续添加的数据。所以使用使用tail命令的-f选项可以方便的查阅正在改变的日志文件。<br>Linux tail 命令：<a href="https://www.runoob.com/linux/linux-comm-tail.html">https://www.runoob.com/linux/linux-comm-tail.html</a></p>
<h1 id="考点5-vi编辑器的三种模式"><a href="#考点5-vi编辑器的三种模式" class="headerlink" title="考点5:vi编辑器的三种模式"></a>考点5:vi编辑器的三种模式</h1><p>在RHEL5系统中,在vi编辑器环境中的任意时刻,选择”ESC”键后,编辑器将进入(  )模式</p>
<ul>
<li>A 命令</li>
<li>B 输入</li>
<li>C 末行</li>
<li>D 文本</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>
  
<p>vim编辑器可以分为三种模式：<br>1.命令模式：控制屏幕光标的移动，进行文本的删除，复制等文字编辑工作，不使用【del】和【backspace】键，以及进入插入模式或者回到底行模式；<br>2.插入模式：只有在插入模式下，才可以输入文字，按【esc】可以回到命令模式，vim编辑器一打开是不可以输入的，因为刚打开时候处于命令模式;<br>3.底行模式：保存文件或者退出vim，也可以设置编辑环境和一些编译工作。<br><img data-src="https://uploadfiles.nowcoder.com/images/20180619/3431580_1529372993152_25A1FCC1486B869925E23FECFEBADC61"></p>
<h1 id="考点6-useradd命令"><a href="#考点6-useradd命令" class="headerlink" title="考点6:useradd命令"></a>考点6:useradd命令</h1><p>创建用户时不指定用户主目录的参数(      )</p>
<ul>
<li>A <code>useradd -o</code></li>
<li>B <code>useradd -m</code></li>
<li>C <code>useradd -M</code></li>
<li>D <code>useradd -d</code></li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<table>
<thead>
<tr>
<th align="left">useradd参数</th>
<th align="left">全称</th>
<th align="left">释义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-b</td>
<td align="left">base-dir BASE_DIR</td>
<td align="left">新账户的主目录的基目录</td>
</tr>
<tr>
<td align="left">-c</td>
<td align="left">comment COMMENT</td>
<td align="left">新账户的 GECOS 字段</td>
</tr>
<tr>
<td align="left">-d</td>
<td align="left">home-dir HOME_DIR</td>
<td align="left">新账户的主目录</td>
</tr>
<tr>
<td align="left">-D</td>
<td align="left">defaults</td>
<td align="left">显示或更改默认的 useradd 配置</td>
</tr>
<tr>
<td align="left">-e</td>
<td align="left">expiredate EXPIRE_DATE</td>
<td align="left">新账户的过期日期</td>
</tr>
<tr>
<td align="left">-f</td>
<td align="left">inactive INACTIVE</td>
<td align="left">新账户的密码不活动期</td>
</tr>
<tr>
<td align="left">-g</td>
<td align="left">gid GROUP</td>
<td align="left">新账户主组的名称或 ID</td>
</tr>
<tr>
<td align="left">-G</td>
<td align="left">groups GROUPS</td>
<td align="left">新账户的附加组列表</td>
</tr>
<tr>
<td align="left">-h</td>
<td align="left">help</td>
<td align="left">显示此帮助信息并推出</td>
</tr>
<tr>
<td align="left">-k</td>
<td align="left">skel SKEL_DIR</td>
<td align="left">使用此目录作为骨架目录</td>
</tr>
<tr>
<td align="left">-K</td>
<td align="left">key KEY&#x3D;VALUE</td>
<td align="left">不使用 &#x2F;etc&#x2F;login.defs 中的默认值</td>
</tr>
<tr>
<td align="left">-l</td>
<td align="left">no-log-init</td>
<td align="left">不要将此用户添加到最近登录和登录失败数据库</td>
</tr>
<tr>
<td align="left">-m</td>
<td align="left">create-home</td>
<td align="left">创建用户的主目录</td>
</tr>
<tr>
<td align="left">-M</td>
<td align="left">no-create-home</td>
<td align="left">不创建用户的主目录</td>
</tr>
<tr>
<td align="left">-N</td>
<td align="left">no-user-group</td>
<td align="left">不创建同名的组</td>
</tr>
<tr>
<td align="left">-o</td>
<td align="left">non-unique</td>
<td align="left">允许使用重复的 UID 创建用户</td>
</tr>
<tr>
<td align="left">-p</td>
<td align="left">password PASSWORD</td>
<td align="left">加密后的新账户密码</td>
</tr>
<tr>
<td align="left">-r</td>
<td align="left">system</td>
<td align="left">创建一个系统账户</td>
</tr>
<tr>
<td align="left">-s</td>
<td align="left">shell SHELL</td>
<td align="left">新账户的登录 shell</td>
</tr>
<tr>
<td align="left">-u</td>
<td align="left">uid UID</td>
<td align="left">新账户的用户 ID</td>
</tr>
<tr>
<td align="left">-U</td>
<td align="left">user-group</td>
<td align="left">创建与用户同名的组</td>
</tr>
<tr>
<td align="left">-Z</td>
<td align="left">selinux-user SEUSER</td>
<td align="left">为 SELinux 用户映射使用指定 SEUSER</td>
</tr>
</tbody></table>
<h1 id="考点7-多进程同时操作一个文件"><a href="#考点7-多进程同时操作一个文件" class="headerlink" title="考点7:多进程同时操作一个文件"></a>考点7:多进程同时操作一个文件</h1><p>Linux下两个进程可以同时打开同一个文件,这时如下描述错误的是:</p>
<ul>
<li>A 两个进程中分别产生生成两个独立的<code>fd</code></li>
<li>B 两个进程可以任意对文件进行读写操作,操作系统并不保证写的原子性</li>
<li>C 进程可以通过系统调用对文件加锁,从而实现对文件内容的保护</li>
<li>D 任何一个进程删除该文件时,另外一个进程会立即出现读写失败</li>
<li>E 两个进程可以分别读取文件的不同部分而不会相互影响</li>
<li>F 一个进程对文件长度和内容的修改另外一个进程可以立即感知</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>一般删除都是文件索引，如果两个文件同时打开同一个文件，一个线程执行删除操作，只要另一个线程不退出，就可以继续对该文件进行操作，一旦退出才找不到该文件的索引节点而报错。</p>
<p>内核中，对应于每个进程都有一个文件描述符表，表示这个进程打开的所有文件。文件描述表中每一项都是一个指针，指向一个用于描述打开的文件的数据块———file对象，file对象中描述了文件的打开模式，读写位置等重要信息，当进程打开一个文件时，内核就会创建一个新的file对象。需要注意的是，file对象不是专属于某个进程的，不同进程的文件描述符表中的指针可以指向相同的file对象，从而共享这个打开的文件。file对象有引用计数，记录了引用这个对象的文件描述符个数，只有当引用计数为0时，内核才销毁file对象，因此某个进程关闭文件，不影响与之共享同一个file对象的进程.<br><a href="http://www.cnblogs.com/zhaoyl/archive/2012/05/15/2502010.html">http://www.cnblogs.com/zhaoyl/archive/2012/05/15/2502010.html</a><br><a href="http://blog.chinaunix.net/uid-26548237-id-3046664.html">http://blog.chinaunix.net/uid-26548237-id-3046664.html</a></p>
<h1 id="考点8-TCP握手-分手"><a href="#考点8-TCP握手-分手" class="headerlink" title="考点8:TCP握手 分手"></a>考点8:TCP握手 分手</h1><p>TCP的握手与分手,可能出现的情形有()。</p>
<ul>
<li>A 握手需要3次通信</li>
<li>B 分手需要进行4次通信</li>
<li>C <code>FIN</code>和<code>ACK</code> 在同一包里</li>
<li>D <code>ACK</code> 和<code>SYN</code> 在同一包里</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>

<p>知识盲区：后续再解析<br><a href="https://m.nowcoder.com/questions?tagId=42507626&type=1&source=intelli&pos=6">https://m.nowcoder.com/questions?tagId=42507626&type=1&source=intelli&pos=6</a></p>
<h1 id="考点9-Linux日志文件"><a href="#考点9-Linux日志文件" class="headerlink" title="考点9:Linux日志文件"></a>考点9:Linux日志文件</h1><p>以下说法正确的是()</p>
<ul>
<li>A <code>linux</code>系统中的<code>/var/log/lastlog</code>日志记录了所有用户最后登录的记录,可以用<code>lastlog</code>命令查看</li>
<li>B <code>linux</code>系统中的<code>/var/log/last</code>日志可以用<code>last</code>命令查看</li>
<li>C <code>/var/log/wtmp</code>日志记录了登录过本系统的用户信息,可以用<code>tail -f</code>命令查看</li>
<li>D <code>/var/run/utmp</code>日志记录了正在登录本系统中的用户信息,可以用<code>last -f</code>命令查看</li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details>

<p>B. 执行last指令时，它会读取位于&#x2F;var&#x2F;log&#x2F;wtmp的文件，并把该给文件的内容记录的登录系统的用户名单全部显示出来。<br>C. wtmp是二进制文件，他们不能被诸如tail命令剪贴或合并，需要使用who、w、users、last和ac来使用这两个文件包含的信息。</p>
<p><strong>&#x2F;var&#x2F;log&#x2F;lastlog</strong>:记录系统中所有用户最后一次的登录时间的曰志。这个文件也是二进制文件.不能直接用Vi 查看。而要使用lastlog命令查看<br><strong>&#x2F;var&#x2F;log&#x2F;wtmp</strong> :永久记录所有用户的登陆、注销信息，同时记录系统的后动、重启、关机事件。同样，这个文件也是二进制文件.不能直接用Vi查看，而要使用<strong>last命令</strong>查看.<br><strong>&#x2F;var&#x2F;log&#x2F;utmp</strong>:记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息。同样，这个文件不能直接用Vi查看，而要使用w、who、users等命令查看 </p>
<p><strong>&#x2F;var&#x2F;log&#x2F;wtmp</strong>是一个二进制文件，记录每个用户的登录次数和持续时间等信息，使用”last -f”查看，如”last -f &#x2F;var&#x2F;log&#x2F;wtmp”;<br><strong>&#x2F;var&#x2F;run&#x2F;utmp</strong>是一个二进制文件，保存当前在本系统中的用户信息，使用”last -f”查看，如”last -f &#x2F;var&#x2F;run&#x2F;utmp”;<br>  </p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://linux.cn/article-10096-1.html">https://linux.cn/article-10096-1.html</a></p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Test</category>
      </categories>
  </entry>
  <entry>
    <title>2021年03月31日Linux专项练习1</title>
    <url>/exam//bf531909/</url>
    <content><![CDATA[<h1 id="考点1-Linux修改权限命令-chmod命令"><a href="#考点1-Linux修改权限命令-chmod命令" class="headerlink" title="考点1:Linux修改权限命令_chmod命令"></a>考点1:Linux修改权限命令_chmod命令</h1><p>Linux下,为某个脚本赋予可执行权限()</p>
<ul>
<li>A <code>chmod +x filename.sh</code></li>
<li>B <code>chown +x filename.sh</code></li>
<li>C <code>chmod +r filename.sh</code></li>
<li>D <code>chown +r filename.sh</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>chmod命令修改权限 +x表示增加执行权限，+r表示增加读取权限，+w表示增加写权限  chown将指定文件的拥有者改为指定的用户或组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">total 3766</span><br><span class="line">-rwxr-xr-x 1 lan 197609     183  3月 19 21:32 hexos.sh*</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rwx</span><br><span class="line">111</span><br><span class="line">421</span><br></pre></td></tr></table></figure>

<h1 id="考点2-UNIX目录结构"><a href="#考点2-UNIX目录结构" class="headerlink" title="考点2:UNIX目录结构"></a>考点2:UNIX目录结构</h1><p>在UNIX系统中,目录结构采用( )</p>
<ul>
<li>A 单级目录结构</li>
<li>B 二级目录结构</li>
<li>C 单纯树形目录结构</li>
<li>D 带链接树形目录结构</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>带链接树形目录结构又称非循环图目录结构,它是指访问一文件(或目录)可以有多条路径。一般常说UNIX的文件系统是树形结构，其实是指带链接的树形结构，而不是纯树形目录结构。 </p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3:"></a>考点3:</h1><p>一个文件名字为rr.Z,可以用来解压缩的命令是？</p>
<ul>
<li>A <code>tar</code></li>
<li>B <code>gzip</code></li>
<li>C <code>compress</code></li>
<li>D <code>uncompress</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<ul>
<li><code>tar</code>: 操作.<code>tar</code>的命令</li>
<li><code>gzip</code>: 压缩.<code>gz</code>压缩包的命令</li>
<li><code>compress</code>：压缩.Z文件</li>
<li><code>uncompress</code>：解压缩.Z文件</li>
</ul>
<h1 id="考点4-记录已经加载的文件系统的文件"><a href="#考点4-记录已经加载的文件系统的文件" class="headerlink" title="考点4:记录已经加载的文件系统的文件"></a>考点4:记录已经加载的文件系统的文件</h1><p>系统当前已经加载的所有文件系统在_________文件中得到反映。</p>
<ul>
<li>A <code>/usr/sbin/cfdisk</code></li>
<li>B <code>/sbin/fdisk</code></li>
<li>C <code>/etc/mtab</code></li>
<li>D <code>/etc/fstab</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<p> <strong>&#x2F;etc&#x2F;mtab文件的作用</strong>：记载的是现在系统已经装载的文件系统，包括操作系统建立的虚拟文件等；而&#x2F;etc&#x2F;fstab是系统准备装载的<br> <strong>etc&#x2F;fstab文件的作用</strong>：记录了计算机上硬盘分区的相关信息，启动 Linux 的时候，检查分区的<br> fsck 命令，和挂载分区的 mount 命令，都需要 fstab 中的信息，来正确的检查和挂载硬盘。</p>
<h1 id="考点5-Linux列举当前目录"><a href="#考点5-Linux列举当前目录" class="headerlink" title="考点5:Linux列举当前目录"></a>考点5:Linux列举当前目录</h1><p>在linux中,列举当前目录下文件的是哪个命令______。</p>
<ul>
<li>A <code>ps</code></li>
<li>B <code>cd</code></li>
<li>C <code>mv</code></li>
<li>D <code>ls</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<ul>
<li>ps 查看运行中的进程</li>
<li>cd 进入某个目录</li>
<li>mv 移动文件或者文件夹</li>
<li>ls list的缩写，列出某个目录下的文件或者文件夹</li>
</ul>
<h1 id="考点6-Linux查看文件命令"><a href="#考点6-Linux查看文件命令" class="headerlink" title="考点6:Linux查看文件命令"></a>考点6:Linux查看文件命令</h1><p>在Linux下查看文件有多种方法,若希望在查看文件内容过程中,可以按空格实现翻页,应使用(      )命令</p>
<ul>
<li>A <code>cat</code></li>
<li>B <code>more</code></li>
<li>C <code>less</code></li>
<li>D <code>head</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<ul>
<li>cat：由第一行开始显示文件所有内容； </li>
<li>tac：从最后一行开始显示文件的所有内容，<ul>
<li>注意 tac 与cat 写法正好相反；</li>
</ul>
</li>
<li>more：一页一页的显示文件内容，只能向后翻页； </li>
<li>less：也是一页一页显示文件内容，但是可以通过键盘上的【pagedown】，【pageup】控制向后，向前翻页； </li>
<li>head：显示一个文件的前几行； </li>
<li>tail：显示一个文件的后几行；</li>
</ul>
<h1 id="考点7-Linux查看CPU-Swap分区-硬盘信息命令"><a href="#考点7-Linux查看CPU-Swap分区-硬盘信息命令" class="headerlink" title="考点7:Linux查看CPU Swap分区 硬盘信息命令"></a>考点7:Linux查看CPU Swap分区 硬盘信息命令</h1><p>如何在命令行查看一台linux机器的CPU、SWAP分区信息、硬盘信息?</p>
<ul>
<li>A <code>cat /proc/cpuinfo</code></li>
<li>B <code>du</code></li>
<li>C <code>cat /proc/swaps</code></li>
<li>D <code>df -lh</code></li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details>

<p>-<code>cat /proc/cpuinfo</code>：查看一台<code>linux</code>机器的<code>CPU</code>信息<br>-<code>du</code>：查看该目录占用文件系统数据块的情况<br>-<code>cat /proc/swaps</code>：查看<code>SWAP</code>分区信息<br>-<code>df -lh</code>：查看硬盘信息</p>
<h1 id="考点8-日志文件系统有哪些"><a href="#考点8-日志文件系统有哪些" class="headerlink" title="考点8:日志文件系统有哪些"></a>考点8:日志文件系统有哪些</h1><p>以下哪个是日志文件系统()</p>
<ul>
<li>A <code>ext2</code></li>
<li>B <code>fat32</code></li>
<li>C <code>ntfs</code></li>
<li>D <code>ext3</code></li>
<li>E <code>ext4</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: CDE</details>

<p>日志文件系统（英语：Journaling file system）是一种文件系统。在发生变化时，它先把相关的信息写入一个被称为日志的区域，然后再把变化写入主文件系统。在文件系统发生故障（如内核崩溃或突然停电）时，日志文件系统更容易保持一致性，并且可以较快恢复。</p>
<h3 id="常见的日志文件系统"><a href="#常见的日志文件系统" class="headerlink" title="常见的日志文件系统"></a>常见的日志文件系统</h3><p>JFS：IBM的 Journaled File System, 最早的日志文件系统。<br>Ext4&#x2F;Ext3文件系统：由Ext2文件系统演化而成的日志文件系统，广泛用于Linux系统。<br>XFS文件系统：广泛用于Linux系统，取代了Ext4。<br>ReiserFS：用B+树作为数据结构的日志文件系统，在处理小文件时有较好的性能。<br>Btrfs：用B树作为数据结构，被认为是下一代Linux文件系统。<br>NTFS：微软的NTFS也是日志文件系统，也是Windows下最常用的文件系统。<br>HFS+：苹果公司发展的OS X操作系统下主要使用的文件系统。</p>
<h1 id="考点9-系统调用"><a href="#考点9-系统调用" class="headerlink" title="考点9:系统调用"></a>考点9:系统调用</h1><p>Linux执行ls,会引起哪些系统调用()</p>
<ul>
<li>A <code>nmap</code></li>
<li>B <code>read</code></li>
<li>C <code>execve</code></li>
<li>D <code>fork</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details>

<ul>
<li>任何shell都会执行 exec 和 fork</li>
<li>而ls会执行read</li>
<li>三个加起来就是read,execve,fork</li>
</ul>
<h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10:"></a>考点10:</h1><p>linux 2.6.* 内核默认支持的文件系统有哪些？</p>
<ul>
<li>A <code>ext3</code></li>
<li>B <code>ext2</code></li>
<li>C <code>ext4</code></li>
<li>D <code>xfs</code></li>
<li>E <code>ufs</code></li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>

<p>背答案算了</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Test</category>
      </categories>
  </entry>
  <entry>
    <title>2021年03月31日Linux专项联系2</title>
    <url>/exam//e8640a22/</url>
    <content><![CDATA[<h1 id="考点1-输入输出重定向"><a href="#考点1-输入输出重定向" class="headerlink" title="考点1:输入输出重定向"></a>考点1:输入输出重定向</h1><p>在RHEL5系统中,小王希望将他执行的ls命令的输出结果保存在当前目录下文件output.ls中,以供日后进行分析和使用,但要求不覆盖原文件的内容,他应该使用的命令是(  )</p>
<ul>
<li>A <code>ls&gt;output.ls</code></li>
<li>B <code>ls&gt;&gt;output.ls</code></li>
<li>C <code>ls&lt;&lt;output.ls</code></li>
<li>D <code>ls—output.ls</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>&gt;  输出重定向到一个文件或设备 <strong>覆盖原来的文件</strong><br>&gt;!  输出重定向到一个文件或设备 <strong>强制覆盖原来的文件</strong><br>&gt;&gt;  输出重定向到一个文件或设备 <strong>追加原来的文件</strong><br>&lt;  输入重定向到一个程序 </p>
<ul> <li>command &gt; file:将输出重定向到 file。 </li><li>command &lt; file:将输入重定向到 file。 </li><li>command &gt;&gt; file:将输出以追加的方式重定向到 file。 </li><li>n &gt; file:将文件描述符为 n 的文件重定向到 file。 </li><li>n &gt;&gt; file:将文件描述符为 n 的文件以追加的方式重定向到 file。 </li><li>n &gt;&amp; m:将输出文件 m 和 n 合并。 </li><li>n &lt;&amp; m:将输入文件 m 和 n 合并。 </li><li>&lt;&lt; tag:将开始标记 tag 和结束标记 tag 之间的内容作为输入。 </li></ul>

<h1 id="考点2-Linux目录结构"><a href="#考点2-Linux目录结构" class="headerlink" title="考点2:Linux目录结构"></a>考点2:Linux目录结构</h1><p>Linux文件系统的文件都按其作用分门别类地放在相关的目录中,对于外部设备文件,一般应将其放在()目录中</p>
<ul>
<li>A <code>/bin</code></li>
<li>B <code>/etc</code></li>
<li>C <code>/dev</code></li>
<li>D <code>/lib</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p> &#x2F;bin  二进制执行文件，也就是命令文件<br> &#x2F;etc 下存放的是配置文件<br> &#x2F;dev 存放是时外部设备文件，硬盘，usb等<br> &#x2F;lib 存放的是库文件 </p>
<p>&#x2F;bin 二进制可执行命令<br>&#x2F;dev 设备特殊文件<br>&#x2F;etc 系统管理和配置文件<br>&#x2F;etc&#x2F;rc.d 启动的配置文件和脚本<br>&#x2F;home 用户主目录的基点，比如用户user的主目录就是&#x2F;home&#x2F;user，可以用~user表示<br>&#x2F;lib 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件<br>&#x2F;sbin 超级管理命令，这里存放的是系统管理员使用的管理程序<br>&#x2F;tmp 公共的临时文件存储点<br>&#x2F;root 系统管理员的主目录<br>&#x2F;mnt 系统提供这个目录是让用户临时挂载其他的文件系统<br>&#x2F;lost+found这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）<br>&#x2F;proc 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。<br>&#x2F;var 某些大文件的溢出区，比方说各种服务的日志文件<br>&#x2F;usr 最庞大的目录，要用到的应用程序和文件几乎都在这个目录，其中包含：<br>&#x2F;usr&#x2F;x11R6 存放x window的目录<br>&#x2F;usr&#x2F;bin 众多的应用程序<br>&#x2F;usr&#x2F;sbin 超级用户的一些管理程序<br>&#x2F;usr&#x2F;doc linux文档<br>&#x2F;usr&#x2F;include linux下开发和编译应用程序所需要的头文件<br>&#x2F;usr&#x2F;lib 常用的动态链接库和软件包的配置文件<br>&#x2F;usr&#x2F;man 帮助文档<br>&#x2F;usr&#x2F;src 源代码，linux内核的源代码就放在&#x2F;usr&#x2F;src&#x2F;linux里<br>&#x2F;usr&#x2F;local&#x2F;bin 本地增加的命令</p>
<p>&#x2F;dev   是device的简写，英文原意是device 设备。</p>
<h1 id="考点3-常用端口号-WWW和FTP端口号"><a href="#考点3-常用端口号-WWW和FTP端口号" class="headerlink" title="考点3:常用端口号 WWW和FTP端口号"></a>考点3:常用端口号 WWW和FTP端口号</h1><p>下面对www 和ftp的端口描述正确的是</p>
<ul>
<li>A 20 21</li>
<li>B 80 20</li>
<li>C 80 21</li>
<li>D 80,20 21</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h3 id="FTP端口"><a href="#FTP端口" class="headerlink" title="FTP端口"></a>FTP端口</h3><p>FTP服务器有两个端口，其中<strong>21端口用于连接</strong>，<strong>20端口用于传输数据</strong><br>进行FTP文件传输中，客户端首先连接到FTP服务器的21端口，进行用户的认证，认证成功后，要传输文件时，服务器会开一个端口为20来进行传输数据文件。<br>也就是说，<strong>端口20才是真正传输所用到的端口，端口21只用于FTP的登陆认证</strong>。我们平常下载文件时，会遇到下载到99%时，文件不完成，不能成功的下载。其实是因为文件下载完毕后，还要在21端口再行进行用户认证，而下载文件的时间如果过长，客户机与服务器的21端口的连接会被服务器认为是超时连接而中断掉，就是这个原因。解决方法就是设置21端口的响应时间。</p>
<p>www 80<br>ftp(主动模式20数据端口，用于传输-服务端传输文件  被动模式21控制端口,认证-客户端认证用户)  ftp协议由ftp服务器和ftp客户端构成,是基于tcp的两个端口：20,21<br>tftp协议基于udp端口 tcp传输层协议 ftp应用层协议 </p>
<h3 id="其他常用端口"><a href="#其他常用端口" class="headerlink" title="其他常用端口"></a>其他常用端口</h3><ul>
<li>SSH：22</li>
<li>Telnet：23 </li>
<li>SMTP：25 </li>
<li>POP3：110. S</li>
<li>NMP：161 </li>
<li>DNS服务：53  </li>
<li>HTTP(www)：80(默认端口) </li>
<li>HTTPS：443(在http的基础上ssl加密)</li>
</ul>
<h1 id="考点4-Linux查看磁盘挂载状态命令"><a href="#考点4-Linux查看磁盘挂载状态命令" class="headerlink" title="考点4:Linux查看磁盘挂载状态命令"></a>考点4:Linux查看磁盘挂载状态命令</h1><p>linux下查看磁盘挂载状态的命令式？</p>
<ul>
<li>A <code>rpm</code></li>
<li>B <code>mount</code></li>
<li>C <code>netstat</code></li>
<li>D <code>df</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>安装命令：rpm -ivh<br>卸载命令: rpm -e [package name]<br>查看挂载状态: mount<br>查看磁盘情况: df<br>查看端口:netstat –anlp<br>.tar.gz的安装:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar –zxvf tar.gz </span><br><span class="line">./configure </span><br><span class="line">Make </span><br><span class="line">Make install</span><br></pre></td></tr></table></figure>

<h1 id="考点5-vi强制保存退出参数"><a href="#考点5-vi强制保存退出参数" class="headerlink" title="考点5:vi强制保存退出参数"></a>考点5:vi强制保存退出参数</h1><p>某配置文件针对所有用户的访问权限是只读,vi编辑器强制存盘退出的指令是(      )</p>
<ul>
<li>A <code>:wq</code></li>
<li>B <code>ZZ</code></li>
<li>C <code>:q!</code></li>
<li>D <code>:wq!</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<table>
<thead>
<tr>
<th align="left">vim的退出编辑命令</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">:q</td>
<td align="left">不保存退出</td>
</tr>
<tr>
<td align="left">:q!</td>
<td align="left">不保存强制退出</td>
</tr>
<tr>
<td align="left">:wq</td>
<td align="left">写入文件并退出</td>
</tr>
<tr>
<td align="left">:wq!</td>
<td align="left"><strong>强制写入并退出（只有当操作者是文件所有者才可行）</strong></td>
</tr>
<tr>
<td align="left">:x</td>
<td align="left">文件有变动时等同于 :wq，文件无变动时等同与 :q</td>
</tr>
<tr>
<td align="left">ZZ</td>
<td align="left">等同于:x</td>
</tr>
</tbody></table>
<h1 id="考点7-Linux的ifconfig命令"><a href="#考点7-Linux的ifconfig命令" class="headerlink" title="考点7:Linux的ifconfig命令"></a>考点7:Linux的ifconfig命令</h1><p>下列提法中,不属于ifconfig命令作用范围的是 。</p>
<ul>
<li>A 配置本地回环地址</li>
<li>B 配置网卡的<code>IP</code>地址</li>
<li>C 激活网络适配器</li>
<li>D 加载网卡到内核中</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<h3 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h3><p>1.作用<br>ifconfig用于查看和更改网络接口的地址和参数，包括IP地址、网络掩码、广播地址，使用权限是超级用户。<br>2.格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig -interface [options] address</span><br></pre></td></tr></table></figure>
<p>3.主要参数如下</p>
<ul>
<li>interface：指定的网络接口名，如eth0和eth1。 </li>
<li>options:<ul>
<li>up：激活指定的网络接口卡。</li>
<li>down：关闭指定的网络接口。 </li>
<li>broadcast address：设置接口的广播地址。 </li>
<li>pointopoint：启用点对点方式。 </li>
<li>address：设置指定接口设备的IP地址。 </li>
<li>netmask address：设置接口的子网掩码。</li>
</ul>
</li>
</ul>
<h1 id="考点8-Linux进程-clone和fork的区别"><a href="#考点8-Linux进程-clone和fork的区别" class="headerlink" title="考点8:Linux进程 clone和fork的区别"></a>考点8:Linux进程 clone和fork的区别</h1><p>下列关于 clone 和 fork 的区别描述正确的有？</p>
<ul>
<li>A <code>clone</code>和<code>fork</code>最大不同在于<code>fork</code>不再复制父进程的栈空间,而是自己创建一个新的。</li>
<li>B <code>clone</code>和<code>fork</code>最大不同在于<code>clone</code>不再复制父进程的栈空间,而是自己创建一个新的。</li>
<li>C <code>clone</code>是<code>fork</code>的升级版本,不仅可以创建进程或者线程,还可以指定创建新的命名空间(<code>namespace</code>)、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等</li>
<li>D <code>fork</code>是<code>clone</code>的升级版本,不仅可以创建进程或者线程,还可以指定创建新的命名空间(<code>namespace</code>)、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<p>fork()<br>函数复制时将父进程的所以资源都通过复制数据结构进行了复制，然后传递给子进程，所以fork()函数不带参数；<br>clone()<br>函数则是将部分父进程的资源的数据结构进行复制，复制哪些资源是可选择的，这个可以通过参数设定，所以clone()<br>函数带参数，没有复制的资源可以通过指针共享给子进程</p>
<p>fork()是全部复制<br>vfork()是共享内存<br><strong>clone()是可以将父进程资源有选择地复制给子进程</strong>，而没有复制的数据结构则通过指针的复制让子进程共享，具体要复制哪些资源给子进程，由参数列表中的clone_flags来决定。另外，clone()返回的是子进程的pid。 </p>
<p>fork是复制进程，创建一个新的进程，不带参数<br>clone是可选的复制父进程资源，可以通过参数控制复制的内容 </p>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9:"></a>考点9:</h1><p>在Linux系统中, 哪个文件你可以存储用于创建用户目录的系统用户默认文件？ </p>
<ul>
<li>A <code>/usr/tmp</code></li>
<li>B <code>/etc/default</code></li>
<li>C <code>/etc/skel</code></li>
<li>D <code>/etc/users</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>Linux下的&#x2F;etc&#x2F;skel目录往往不被人注意，其实此目录在新建用户时还是很有用的，灵活运用此目录可以节约一定的配置时间。<br>skel是skeleton的缩写，意为骨骼、框架。故此目录的作用是在建立新用户时，用于初始化用户根目录。系统会将此目录下的所有文件、目录都复制到新建用户的根目录，并且将用户属主与用户组调整为与此根目录相同。所以可将用户配置文件预置到&#x2F;etc&#x2F;skel目录下，比如说.bashrc、.profile与.vimrc等。<br>注：<br>1.如果在新建用户时，没有自动建立用户根目录，则无法调用到此框架目录。<br>2.如果不想以默认的&#x2F;etc&#x2F;skel目录作为框架目录，可以在运行useradd命令时指定新的框架目录。例如：<br>sudo useradd -d &#x2F;home&#x2F;chen -m -k<br> &#x2F;etc&#x2F;my_skel chen<br>上述命令将新建用户chen，设置用户根目录为&#x2F;home&#x2F;chen，并且此目录会自动建立；同时指定框架目录为&#x2F;etc&#x2F;my_skel。<br>3.如果不想在每次新建用户时，都重新指定新的框架目录，可以通过修改&#x2F;etc&#x2F;default&#x2F;useradd配置文件来改变默认的框架目录，方法如下：<br>查找SKEL变量的定义，如果此变量的定义已被注释掉，可以取消注释，然后修改其值：<br>SKEL&#x3D;&#x2F;etc&#x2F;my_skel</p>
<h1 id="考点10-Linux可以查看系统启动时间的命令"><a href="#考点10-Linux可以查看系统启动时间的命令" class="headerlink" title="考点10:Linux可以查看系统启动时间的命令"></a>考点10:Linux可以查看系统启动时间的命令</h1><p>以下哪些命令可以查看当前系统的启动时间()</p>
<ul>
<li>A <code>w</code></li>
<li>B <code>top</code></li>
<li>C <code>ps</code></li>
<li>D <code>uptime</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>


<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ps</td>
<td align="left">查看当前系统中的进程</td>
</tr>
<tr>
<td align="left">who -b</td>
<td align="left">查看当前系统的启动时间</td>
</tr>
<tr>
<td align="left">last reboot</td>
<td align="left">查看当前系统的启动时间</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">查看当前系统的启动时间</td>
</tr>
<tr>
<td align="left">top</td>
<td align="left">查看当前系统的启动时间</td>
</tr>
<tr>
<td align="left">uptime</td>
<td align="left">查看当前系统的启动时间</td>
</tr>
</tbody></table>
<h1 id="考点11"><a href="#考点11" class="headerlink" title="考点11:"></a>考点11:</h1><p>关于Linux系统的负载(Load),以下表述正确的是______。</p>
<ul>
<li>A 通过就绪和运行的进程数来反映</li>
<li>B 可以通过<code>TOP</code>命令查看</li>
<li>C 可以通过<code>uptime</code>查看</li>
<li>D <code>Load:2.5,1.3,1.1</code>表示系统的负载压力在逐渐减少</li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Test</category>
      </categories>
  </entry>
  <entry>
    <title>2019年10月31日 加密和安全 1</title>
    <url>/exam//9403006d/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>以下关于计算机病毒的说法，不正确的是（   ）。</p>
<ul>
<li>A 计算机病毒一般会寄生在其他程序中</li>
<li>B 计算机病毒一般会传染其他文件</li>
<li>C 计算机病毒一般会具有自愈性</li>
<li>D 计算机病毒一般会具有潜伏性</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>计算机病毒实质上是一种特殊的计算机程序，一般具有寄生性、破坏性、传染性、潜伏性和隐蔽性。故正确答案为C选项。</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>计算机安全是指计算机资产安全，即（ ）</p>
<ul>
<li>A 计算机信息系统资源不受自然有害因素的威胁和危害</li>
<li>B 信息资源不受自然和人为有害因素的威胁和危害</li>
<li>C 计算机硬件系统不受人为有害因素的威胁和危害</li>
<li>D 计算机信息系统资源和信息资源不受自然和人为有害因素的威胁和危害</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>我国公安部计算机管理监察司的定义是计算机安全是指计算机资产安全，即<strong>计算机信息系统资源和信息资源不受自然和人为有害因素的威胁和危害</strong>。</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>有一种木马程序，其感染机制与 U 盘病毒的传播机制完全一样，只是感染目标计算机后它会尽量隐藏自己的踪迹，它唯一的动作是扫描系统的文件，发现对其可能有用的敏感文件，就将其悄悄拷贝到 U 盘，一旦这个 U 盘插入到连接互联网的计算机，就会将这些敏感文件自动发送到互联网上指定的计算机中，从而达到窃取的目的。该木马叫做（ ）</p>
<ul>
<li>A 网游木马</li>
<li>B 网银木马</li>
<li>C 代理木马</li>
<li>D 摆渡木马</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><h3 id="摆渡木马"><a href="#摆渡木马" class="headerlink" title="摆渡木马"></a>摆渡木马</h3><p>摆渡木马是一种特殊的木马，其感染机制与U盘病毒的传播机制完全一样，只是感染目标计算机后，它会尽量隐蔽自己的踪迹，不会出现普通U盘病毒感染后的症状，如更改盘符图标、破坏系统数据、在弹出菜单中添加选项等，它唯一的动作就是扫描系统中的文件数据，利用关键字匹配等手段将敏感文件悄悄写回U盘中，一旦这个U盘再插入到连接互联网的计算机上，就会将这些敏感文件自动发送到互联网上指定的计算机中。<br>摆渡木马是一种间谍人员定制的木马，隐蔽性、针对性很强，一般只感染特定的计算机，普通杀毒软件和木马查杀工具难以及时发现。故正确答案为D</p>
<h3 id="代理木马"><a href="#代理木马" class="headerlink" title="代理木马"></a>代理木马</h3><p>“代理木马”（Troj_Agent）具有自动下载木马病毒的功能，病毒可以根据病毒编者指定的网址下载木马病毒或其他恶意软件，还可以通过网络和移动存储介质传播。</p>
<h3 id="网络木马"><a href="#网络木马" class="headerlink" title="网络木马"></a>网络木马</h3><p>网络木马通常采用记录用户键盘输入、Hook游戏进程API函数等方法获取用户的密码和帐号。窃取的信息一般通过发送电子邮件或向远程脚本程序提交的方式发送给木马作者。</p>
<h3 id="网银木马"><a href="#网银木马" class="headerlink" title="网银木马"></a>网银木马</h3><p>网银木马是针对网上交易系统编写的木马病毒，其目的是盗取用户的卡号、密码，甚至安全证书。</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>下列攻击方式中，哪种不是针对客户端的？</p>
<ul>
<li>A cross site script（跨站点脚本）</li>
<li>B cross site request（跨站点请求）</li>
<li>C ActiveX buffer overflow（控件缓冲溢出）</li>
<li>D sql injection（sql注入）</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>SQ LInjection：就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。所以SQL injection不是针对客户端的。<strong>SQL注入是针对服务器数据库的</strong>。</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>以下说法不正确的是()</p>
<ul>
<li>A Hash算法主要被用来做数字签名、数据校验</li>
<li>B SHA-224、SHA-256、SHA-384和SHA-512并称为SHA-2</li>
<li>C 已知明文攻击对 AES算法无效</li>
<li>D 非对称加密算法，就是加密、解密的密钥分为两组，并且可以互相反推</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>非对称加密算法不可逆，不能反推<br>SHA-2可分为<strong>六</strong>个不同的算法标准，包括了：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512&#x2F;224、SHA-512&#x2F;256。</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>流量劫持是网络安全中常见的安全威胁，下列哪些情况可能会造成流量劫持?()</p>
<ul>
<li>A MAC地址欺骗</li>
<li>B DNS劫持</li>
<li>C 伪造的DHCP服务器</li>
<li>D 使用https协议</li>
</ul>
<p>正确答案: ABC</p>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>流量劫持：是利用各种恶意软件修改浏览器、锁定主页或不停弹出新窗口，强制用户访问某些网站，从而<strong>造成用户流量损失的情形</strong>。是一种古老的攻击方式，比如广告弹窗等。<br>常见的有</p>
<ul>
<li>Hub嗅探、</li>
<li>MAC欺骗、</li>
<li>MAC冲刷</li>
<li>ARP攻击、</li>
<li>DHCP钓鱼、</li>
<li>DNS劫持、</li>
<li>CDN入侵、</li>
<li>路由器弱口令、</li>
<li>路由器CSRF、</li>
<li>PPPoE钓鱼、</li>
<li>蜜罐代理、</li>
<li>Wifi弱口令、</li>
<li>伪热点、</li>
<li>强制断线、</li>
<li>WlAN基站钓鱼。</li>
</ul>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>加密和安全</category>
      </categories>
  </entry>
  <entry>
    <title>2019年10月31日 操作系统 1</title>
    <url>/exam//c3120b4d/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>虚拟存储器是利用操作系统产生的一个假想的特大存储器，是逻辑上扩充了内存容量，而物理内存的容量并未增加。</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>根据程序执行的互斥性和局部性两个特点，我们允许作业装入的时候只装入一部分，另一部分放在磁盘上，当需要的时候再装入到主存，这样以来，在一个小的主存空间就可以运行一个比它大的作业。好像计算机系统具有一个容量很大的主存储器，称为“虚拟存储器”。</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>一个进程被唤醒意味着（）</p>
<ul>
<li>A 该进程一定马上占有</li>
<li>B 它的优先权变得最大</li>
<li>C 其PCB移至等待队列队首</li>
<li>D 进程变为就绪状态</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>进程和程序的最根本区别在于（ ）。</p>
<ul>
<li>A 对资源的占有类型和数量</li>
<li>B 进程是动态的，而程序是静态的</li>
<li>C 看它们是否能够并发地在处理机上运行</li>
<li>D 进程规模较小，程序规模较大</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>程序是静态的，进程是动态的，程序相当于一个乐谱，进程相当于一次演奏，程序可以查看，进程不能查看代码，进程可以被创建 运行 撤销</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>对进程和线程的描述，以下正确的是？</p>
<ul>
<li>A 父进程里的所有线程共享相同的地址空间，父进程的所有子进程共享相同的地址空间</li>
<li>B 改变进程里面主线程的状态会影响其他线程的行为，改变父进程的状态不会影响其他子进程</li>
<li>C 多线程会引起死锁，而多进程则不会</li>
<li>D 以上都不对</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><ul>
<li>A错，进程拥有独立的地址空间；</li>
<li>B错，主线程和子线程是并行关系的时候，并没有依赖关系。父进程和子进程中，子进程是父进程的一个副本，创建子进程后，子进程会有自己的空间，然后把父进程的数据拷贝到子进程的空间里。运行时，谁先运行是不确定的，这由系统决定；</li>
<li>C错，多线程和多进程都会引起死锁，一般说的死锁指的是进程间的死锁。</li>
</ul>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>文件系统的主要目的是（  ）</p>
<ul>
<li>A 实现对文件的按名存取</li>
<li>B 实现虚拟存储</li>
<li>C 提高外存的读取速度</li>
<li>D 用于存储系统文件</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>文件系统是操作系统下用来对文件的命名以及逻辑操作的一些系统。在计算机中，文件系统（file system）是命名文件及放置文件的逻辑存储和恢复的系统。</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>在计数器定时查询方式下，若每次计数都从 0 开始，则 （）</p>
<ul>
<li>A 设备号小的设备优先级高</li>
<li>B 设备号大的设备优先级高</li>
<li>C 每个设备的优先级均等</li>
<li>D 每个设备的优先级随机变化</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>两个进程合作完成一个任务。在并发执行中，一个进程要等待其合作伙伴发来消息，或者建立某个条件后再向前执行，这种制约性合作关系被称为进程的（ ）。</p>
<ul>
<li>A 互斥</li>
<li>B 同步</li>
<li>C 调度</li>
<li>D 伙伴</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>同步：进程按照一定规则顺序执行，互斥是同步特例</p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>分层式 OS 结构是把 OS 的功能模块划分为若干层，每层之间的模块只能单向调用，这样的说法正确吗？</p>
<ul>
<li>A 正确</li>
<li>B 不正确</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>所谓的层次结构，就是把操作系统所有的功能模块按照功能调用次序分别排成若干层，<strong>各层之间的模块只有单向调用关系</strong>(例如，只允许上层或外层模块调用下层或内层模块)。<br>分层的优点是：<br> (1)把功能实现的无序性改成有序性，可显著提高设计的准确性。<br> (2)把模块问的复杂依赖关系改为简单的单向依赖关系，即高层软件依赖于低层软件。</p>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>在操作系统的层次结构中，各层之间是（ ）</p>
<ul>
<li>A 互不相关</li>
<li>B 内外层相互依赖</li>
<li>C 内层依赖外层</li>
<li>D 外层依赖内层</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>linux 的索引节点中不包含的内容是（ ）</p>
<ul>
<li>A 文件名</li>
<li>B 文件物理地址</li>
<li>C 文件存取权限</li>
<li>D 文件创建时间</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><p>inode包含文件的元信息，具体来说有以下内容：</p>
<ul>
<li>文件的字节数</li>
<li>文件拥有者的User ID</li>
<li>文件的Group ID</li>
<li>文件的读、写、执行权限</li>
<li>文件的时间戳，共有三个：<ul>
<li>ctime指inode上一次变动的时间，</li>
<li>mtime指文件内容上一次变动的时间，</li>
<li>atime指文件上一次打开的时间。</li>
</ul>
</li>
<li>链接数，即有多少文件名指向这个inode</li>
<li>文件数据block的位置<br>至于为什么没有文件名，<strong>是因为由于inode号码与文件名分离</strong>，这种机制导致了一些Unix&#x2F;Linux系统特有的现象。</li>
</ul>
<ol>
<li>有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。</li>
<li>移动文件或重命名文件，只是改变文件名，不影响inode号码。</li>
<li>打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。</li>
</ol>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>2019年10月16日 数据库刷题笔记</title>
    <url>/exam//e973c4f4/</url>
    <content><![CDATA[<h2 id="数据库系统的独立性是指"><a href="#数据库系统的独立性是指" class="headerlink" title="数据库系统的独立性是指"></a>数据库系统的独立性是指</h2><p>不会因为系统数据存储结构与数据逻辑结构的变化而影响应用程序</p>
<h2 id="数据库恢复的基础是利用转储的冗余数据-这些转储的冗余数据包括"><a href="#数据库恢复的基础是利用转储的冗余数据-这些转储的冗余数据包括" class="headerlink" title="数据库恢复的基础是利用转储的冗余数据 这些转储的冗余数据包括"></a>数据库恢复的基础是利用转储的冗余数据 这些转储的冗余数据包括</h2><p>日志文件、数据库后备副本</p>
<h2 id="问题-下列关于数据库设计的叙述中-正确的是"><a href="#问题-下列关于数据库设计的叙述中-正确的是" class="headerlink" title="问题: 下列关于数据库设计的叙述中 正确的是"></a>问题: 下列关于数据库设计的叙述中 正确的是</h2><p><strong>在需求分析阶段建立数据字典</strong></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>数据字典是在<strong>需求分析阶段建立</strong>，在数据库设计过程中不断修改、充实和完善的。</p>
<h3 id="完整的数据库设计步骤"><a href="#完整的数据库设计步骤" class="headerlink" title="完整的数据库设计步骤"></a>完整的数据库设计步骤</h3><p>按照规范的设计方法，一个完整的数据库设计一般分为以下六个阶段：<br>⑴<strong>需求分析</strong>：分析用户的需求，包括数据、功能和性能需求；<br>⑵<strong>概念结构设计</strong>：主要采用<code>E-R</code>模型进行设计，包括画<code>E-R</code>图；<br>⑶<strong>逻辑结构设计</strong>：通过将<code>E-R</code>图转换成表，实现从<code>E-R</code>模型到关系模型的转换；<br>⑷<strong>数据库物理设计</strong>：主要是为所设计的数据库选择合适的存储结构和存取路径；<br>⑸<strong>数据库的实施</strong>：包括编程、测试和试运行；<br>⑹<strong>数据库运行与维护</strong>：系统的运行与数据库的日常维护。</p>
<h2 id="事务的隔离性是指"><a href="#事务的隔离性是指" class="headerlink" title="事务的隔离性是指"></a>事务的隔离性是指</h2><p>一个事务内部的操作及使用的数据对并发的其他事务是隔离的</p>
<h2 id="对关系模型叙述正确的是"><a href="#对关系模型叙述正确的是" class="headerlink" title="对关系模型叙述正确的是"></a>对关系模型叙述正确的是</h2><ul>
<li>关系模型建立在严格的<code>数学理论</code>、<code>集合论</code>和<code>谓词演算公式</code>的基础之上</li>
<li>微机<code>DBMS</code>绝大部分采取关系数据模型</li>
<li>用二维表表示关系模型是其一大特点</li>
</ul>
<h2 id="全局E-R模型的设计，需要消除属性冲突、命名冲突和"><a href="#全局E-R模型的设计，需要消除属性冲突、命名冲突和" class="headerlink" title="全局E-R模型的设计，需要消除属性冲突、命名冲突和"></a>全局E-R模型的设计，需要消除属性冲突、命名冲突和</h2><p>结构冲突</p>
<h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p> 当将局部的<code>E-R</code>图集成为全局<code>E-R</code>图时，可能存在3类冲突。</p>
<ol>
<li><strong>属性冲突</strong>：包括类型、取值范围、取值单位的冲突；</li>
<li><strong>结构冲突</strong>：例如同一对象在一个局部<code>E-R</code>图中作为实体，而在另一个局部<code>E-R</code>图中作为属性，同一实体在不同的<code>E-R</code>图中的属性个数和类型不同等；</li>
<li><strong>命名冲突</strong>：包括实体类型名、联系类型名之间异名同义，或同名异义等</li>
</ol>
<h2 id="group-by中的all关键字说明"><a href="#group-by中的all关键字说明" class="headerlink" title="group by中的all关键字说明"></a>group by中的all关键字说明</h2><p><code>Transact-SQL</code> 在 <code>group by</code> 子句中提供 <code>all</code> 关键字。</p>
<h3 id="必须有where子句才能在group-by子句中使用all关键字"><a href="#必须有where子句才能在group-by子句中使用all关键字" class="headerlink" title="必须有where子句才能在group by子句中使用all关键字"></a>必须有where子句才能在group by子句中使用all关键字</h3><p>只有在<code>select</code>语句还包括<code>where</code>子句时,<code>all</code> 关键字才有意义。</p>
<h3 id="添加all时where则不起作用"><a href="#添加all时where则不起作用" class="headerlink" title="添加all时where则不起作用"></a>添加all时where则不起作用</h3><p>如果使用<code>all</code>关键字，那么查询结果将包括由<code>group by</code>子句产生的<code>所有组</code>，即使某些组没有符合<code>where</code>的条件</p>
<h3 id="没有all时where起作用"><a href="#没有all时where起作用" class="headerlink" title="没有all时where起作用"></a>没有all时where起作用</h3><p>没有<code>all</code>关键字，包含<code>group by</code>子句的<code>select</code>语句将不显示没有符合条件的行的组。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>2019年10月18日 数据库刷题笔记</title>
    <url>/exam//ecbe9f3/</url>
    <content><![CDATA[<h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a><code>ACID</code></h1><h2 id="原子性Atomicity"><a href="#原子性Atomicity" class="headerlink" title="原子性Atomicity"></a>原子性<code>Atomicity</code></h2><p>事务的原子性是指事务中包括的所有操作<strong>要么都做，要么都不做</strong></p>
<h2 id="一致性Consistency"><a href="#一致性Consistency" class="headerlink" title="一致性Consistency"></a>一致性Consistency</h2><p>事务前后数据的完整性必须保持一致。事务必须是使数据库从一个一致性状态变到另一个一致性状态</p>
<h2 id="隔离性Isolation"><a href="#隔离性Isolation" class="headerlink" title="隔离性Isolation"></a>隔离性Isolation</h2><p>一个事务内部的操作及使用的数据对并发的其他事务是隔离的</p>
<h2 id="持久性Durability"><a href="#持久性Durability" class="headerlink" title="持久性Durability"></a>持久性Durability</h2><p><strong>事务一旦提交,对数据库的改变是永久的</strong>,接下来即使数据库发生故障也不应该对其有任何影响</p>
<h1 id="like模式匹配的通配符"><a href="#like模式匹配的通配符" class="headerlink" title="like模式匹配的通配符"></a>like模式匹配的通配符</h1><ul>
<li>通配符<code>%</code>匹配的是任意字符,也就是<strong>0个或者0个以上的字符</strong></li>
<li>通配符<code>_</code>匹配的是任意<code>一个</code>字符。</li>
</ul>
<h1 id="在关系模型中-起导航数据作用的是"><a href="#在关系模型中-起导航数据作用的是" class="headerlink" title="在关系模型中 起导航数据作用的是"></a>在关系模型中 起导航数据作用的是</h1><p>答案: 关键码</p>
<h1 id="自然连接的条件"><a href="#自然连接的条件" class="headerlink" title="自然连接的条件"></a>自然连接的条件</h1><p>关系R和S进行自然连接时，要求R和S含有一个或多个公共的<strong>属性</strong></p>
<h1 id="DTS-数据转换服务-Data-Transformation-Services-介绍"><a href="#DTS-数据转换服务-Data-Transformation-Services-介绍" class="headerlink" title="DTS 数据转换服务 Data Transformation Services 介绍"></a>DTS 数据转换服务 Data Transformation Services 介绍</h1><p><code>DTS</code> 是一组数据转换工具，您可以用来在一个或多个<code>数据源</code>之间进行不同类型数据的导入、导出和转换。<br>这里的数据源数据库或类似数据库的东西,例如(<code>Microsoft SQL Server</code>,<code>Microsoft Excel</code>,<code>Microsoft Access</code>,<code>MySQL</code>,<code>Oracle</code>).</p>
<h1 id="数据库的数据项之间和记录之间都存在联系"><a href="#数据库的数据项之间和记录之间都存在联系" class="headerlink" title="数据库的数据项之间和记录之间都存在联系"></a>数据库的<code>数据项</code>之间和<code>记录</code>之间都存在联系</h1><h1 id="范式相关的东西我还不知道"><a href="#范式相关的东西我还不知道" class="headerlink" title="范式相关的东西我还不知道"></a>范式相关的东西我还不知道</h1><h1 id="SQL查询中的where子句中不能有聚集函数"><a href="#SQL查询中的where子句中不能有聚集函数" class="headerlink" title="SQL查询中的where子句中不能有聚集函数"></a>SQL查询中的where子句中不能有聚集函数</h1><ul>
<li><code>where</code>子句用于选出满足条件的行.</li>
<li><code>having</code>子句用于选出满足条件的列。</li>
<li><code>聚集函数</code>用于统计结果<code>表中的所有的列</code>上的数据,这要求先要确定表中有多少行,<ul>
<li>也就是聚集函数需要放在<code>where</code>子句之后,聚集函数不能放在<code>where</code>子句之中.</li>
<li>聚集函数可以用在<code>having</code>子句中,也可以放在<code>select</code>子句之中.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>2019年10月26日 数据库刷题笔记</title>
    <url>/exam//c25e9737/</url>
    <content><![CDATA[<h1 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h1><p>在一个关系R中，若每个数据项都是不可再分割的，那么R一定属于<br>答案:<strong>第一范式</strong></p>
<h1 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h1><p>在SQL语言中的视图VIEW是数据库的<br><strong>外模式</strong></p>
<h1 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h1><p>SQL语言的功能有</p>
<ol>
<li>数据定义、</li>
<li>数据操纵、</li>
<li>数据控制</li>
</ol>
<h1 id="问题3-1"><a href="#问题3-1" class="headerlink" title="问题3"></a>问题3</h1><p>设关系R和S的属性个数分别为r和s,则(<code>R×S</code>)操作结果的属性个数是什么<br>答案:<code>x+y</code></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析:"></a>解析:</h2><p>笛卡尔乘积X×Y结果的属性个数等于<code>x+y</code>，结果的元组个数等于<code>x*y</code>.</p>
<h1 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h1><p><code>SQL</code>基本表的创建中是通过哪个子句实现参照完整性规则的</p>
<ul>
<li>主键 实现 实体完整性约束</li>
<li>外键 实现 参照完整性约束</li>
</ul>
<h1 id="题目5"><a href="#题目5" class="headerlink" title="题目5"></a>题目5</h1><p>题目省略<br>答:<code>SQL</code>是非过程化的语言</p>
<h1 id="题目6"><a href="#题目6" class="headerlink" title="题目6"></a>题目6</h1><p><code>SQL</code>语言具有两种使用方式，一个称为交互式<code>SQL</code> ，还有一个是什么<br>答:嵌入式<code>SQL</code></p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><ul>
<li><strong>交互式</strong>是通过命令行或者客户端工具操作数据库的方式。</li>
<li><strong>嵌入式</strong>是高级语言操作数据库的方式，高级语言编程时使用。</li>
</ul>
<h1 id="题目7"><a href="#题目7" class="headerlink" title="题目7"></a>题目7</h1><p>下列回收授权的语句正确的是:</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>回收授权语句格式如下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">revoke</span> 权限 <span class="keyword">on</span> 表 <span class="keyword">from</span> 用户</span><br></pre></td></tr></table></figure>
<p>再结合题意即可得到正确的回收授权语句</p>
<h1 id="题目8"><a href="#题目8" class="headerlink" title="题目8"></a>题目8</h1><p>题目略，</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h2 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h2><ul>
<li><strong>第一范式</strong>，关系模式的所有属性均为简单属性，即<strong>属性不可再分</strong>。</li>
<li><strong>第二范式</strong>，若关系模式属于第一范式，并且每个非主属性都完全依赖于关系模式的码。即**消除<code>非主属性</code>对<code>码</code>的<code>部分依赖</code>**。</li>
<li><strong>第三范式</strong>，若关系模式属于第二范式，并且<strong>每个<code>非主属性</code>都不<code>传递依赖</code>于候选码</strong>。即<strong>消除非主属性对码的传递依赖</strong></li>
</ul>
<h1 id="题目9"><a href="#题目9" class="headerlink" title="题目9"></a>题目9</h1><p>在<code>SQL</code>中，删除视图用什么命令<br>答:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> 视图名;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>2019年10月27日 数据库刷题笔记</title>
    <url>/exam//66d50c96/</url>
    <content><![CDATA[<h1 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h1><p>数据库的基本特点是:</p>
<ol>
<li>数据结构化</li>
<li>数据的共享性高，冗余度低，易扩充</li>
<li>数据独立性高</li>
<li>数据由<code>DBMS</code>统一管理和控制</li>
</ol>
<h1 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h1><p>在课程表中要查找课程名称中包含“计算机”课程，对应“课程名称”字段的正确准则表达式是什么。<br>答:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">like</span> &quot;%计算机%&quot;;</span><br></pre></td></tr></table></figure>
<h1 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h1><p>在<code>E-R</code>图中，联系用什么符号表示<br>答:<strong>菱形</strong></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p><code>E-R</code>图中</p>
<ul>
<li>用<strong>矩形</strong>表示<strong>实体型</strong>；</li>
<li>用<strong>椭圆</strong>表示实体的属性；</li>
<li>用<strong>菱形</strong>表示实体型之间的联系</li>
</ul>
<h1 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h1><p>实体是信息世界中的术语，与之对应的数据库术语是什么<br>答:记录</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><ul>
<li>一个实体对应一条记录，或一个元组；</li>
<li>一个属性对应一个数据项，或一个字段</li>
</ul>
<h1 id="题目5"><a href="#题目5" class="headerlink" title="题目5"></a>题目5</h1><p>当局部<code>E-R</code>图合并成全局<code>E-R</code>图时可能出现那些冲突<br>答:局部E-R图之间的冲突主要有三类：</p>
<ul>
<li>属性冲突、</li>
<li>命名冲突,</li>
<li>结构冲突。</li>
</ul>
<h1 id="题目6"><a href="#题目6" class="headerlink" title="题目6"></a>题目6</h1><p><code>SQL</code> 基本表的创建中是通过哪个子句实现实体完整性规则的<br>答:主键子句</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>实体完整性是对关系中的记录唯一性，准确来说<strong>实体完整性是指关系中的主属性值不能为Null且不能有相同值</strong> 。<br> 定义表中的所有行能唯一的标识,一般用主键子句</p>
<h1 id="题目7"><a href="#题目7" class="headerlink" title="题目7"></a>题目7</h1><p>数据库管理系统(<code>DBMS</code>)是哪一个级别的软件。<br>答:系统软件</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>系统软件是和硬件直接相关联的，没有系统软件，计算机就没有办法正常运行。包括：</p>
<ul>
<li>操作系统、</li>
<li>语言处理程序、</li>
<li>标准库程序、</li>
<li>服务型程序、</li>
<li>数据库管理系统、</li>
<li>计算机网络软件</li>
</ul>
<h1 id="题目8"><a href="#题目8" class="headerlink" title="题目8"></a>题目8</h1><p>从关系中挑选出指定的元组组成新关系的运算叫什么<br>答:”选取”运算</p>
<h1 id="题目9"><a href="#题目9" class="headerlink" title="题目9"></a>题目9</h1><p>省略<br>外键的取值只允许等于所参照关系中某个主键值或者为空</p>
<h1 id="题目10"><a href="#题目10" class="headerlink" title="题目10"></a>题目10</h1><p>授权语句格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant 权限 on 表 to 用户</span><br></pre></td></tr></table></figure>
<h1 id="题目11"><a href="#题目11" class="headerlink" title="题目11"></a>题目11</h1><p>题目略</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p><strong>实体完整性</strong>和<strong>参照完整性</strong>适用于任何关系型数据库系统,它主要是针对关系的主关键字和外部关键字取值必须有效而做出的约束。<br><strong>用户定义完整性</strong> (<code>user defined integrity</code>)则是根据应用环境的要求和实际的需要,对某一具体应用所涉及的数据提出约束性条件。这一约束机制一般不应由应用程序提供,而应有由关系模型提供定义并检验<br><strong>用户定义完整性</strong>主要包括<strong>字段有效性约束</strong>和 <strong>记录有效性</strong> 。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月7日 数据库1</title>
    <url>/exam//f54bdba1/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>实现数据库安全性控制的常用方法和技术有（）</p>
<ul>
<li>A 用户标识与鉴别、存取控制、视图机制、审计、数据加密</li>
<li>B 存取控制、视图机制、审计、数据加密、防火墙</li>
<li>C 用户标识与鉴别、存取控制、视图机制、审计、防火墙</li>
<li>D 存取控制、视图机制、审计、数据加密、数据转储</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="实现数据库安全性控制的常用方法和技术"><a href="#实现数据库安全性控制的常用方法和技术" class="headerlink" title="实现数据库安全性控制的常用方法和技术"></a>实现数据库安全性控制的常用方法和技术</h3><p><strong>用户标识和鉴别</strong>：该方法由系统提供一定的方式让用户标识自己的名字或身份。每次用户要求进入系统时，由系统进行核对，通过鉴定后才能提供系统的使用权<br><strong>存取控制</strong>：通过用户权限定义和合法权检查确保只有合法权限的用户访问数据库，所有未授权的人员无法存取数据<br><strong>视图机制</strong>：为不同的用户定义视图，通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动地对数据提供一定程度的安全保护。<br><strong>审计</strong>：建立审计日志，把用户对数据库的所有操作自动记录下来放入审计日志中，DBA可以利用审计跟踪的信息，重现导致数据库现有状况的一系列事件，找出非法存取数据的人，时间和内容等。<br><strong>数据加密</strong>：对存储和传输的数据进行加密处理，从而使得不知道解密算法的人无法获知数据的内容。</p>
<h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>防火墙指的是一个由软件和硬件设备组合而成、在内部网和外部网之间、专用网与公共网之间的界面上构造的保护屏障。和数据库安全性没关系</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>数据库 DB 、数据库系统 DBS 、数据库管理系统 DBMS 之间的关系是 ( ) 。</p>
<ul>
<li>A DB包括DBS和DBMS</li>
<li>B DBMS包括DB和DBS</li>
<li>C DBS包括DB和DBMS</li>
<li>D 没有任何关系</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>数据库系统DBS包括：数据库DB和数据库管理系统DBMS</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>在SQL语言中，属于DCL的操作命令是?</p>
<ul>
<li>A GRANT</li>
<li>B CREATE</li>
<li>C UPDATE</li>
<li>D DROP</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><h3 id="DML（data-manipulation-language）："><a href="#DML（data-manipulation-language）：" class="headerlink" title="DML（data manipulation language）："></a>DML（data manipulation language）：</h3><p>它们是select、update、insert、delete，<br>就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言</p>
<h3 id="DDL（data-definition-language）："><a href="#DDL（data-definition-language）：" class="headerlink" title="DDL（data definition language）："></a>DDL（data definition language）：</h3><p>DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，<br>DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用</p>
<h3 id="DCL（Data-Control-Language）："><a href="#DCL（Data-Control-Language）：" class="headerlink" title="DCL（Data Control Language）："></a>DCL（Data Control Language）：</h3><p>是数据库控制功能。是用来设置或更改数据库<strong>用户</strong>或<strong>角色权限</strong>的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>在E-R图中，属性用（ ）符号表示。</p>
<ul>
<li>A 椭圆</li>
<li>B 矩形</li>
<li>C 菱形</li>
<li>D 三角形</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><ul>
<li>E-R图 用矩形表示实体型；</li>
<li>用椭圆表示实体的属性；</li>
<li>用菱形表示实体型之间的联系</li>
</ul>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>在数据库设计中， E-R 图产生于（ ）。</p>
<ul>
<li>A 需求分析阶段</li>
<li>B 物理设计阶段</li>
<li>C 逻辑设计阶段</li>
<li>D 概念设计阶段</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><h3 id="数据库设计的六个阶段"><a href="#数据库设计的六个阶段" class="headerlink" title="数据库设计的六个阶段"></a>数据库设计的六个阶段</h3><p>规范的设计方法，一个完整的数据库设计一般分为六个阶段：<br>⑴<strong>需求分析</strong>：分析用户的需求，包括数据、功能和性能需求；<br>⑵<strong>概念结构设计</strong>：主要采用E-R模型进行设计，包括<strong>画E-R图</strong>；<br>⑶<strong>逻辑结构设计</strong>：通过将E-R图转换成表，<strong>实现从E-R模型到关系模型的转换</strong>；<br>⑷<strong>数据库物理设计</strong>：主要是为所设计的数据库选择合适的存储结构和存取路径；<br>⑸<strong>数据库的实施</strong>：包括编程、测试和试运行；<br>⑹<strong>数据库运行与维护</strong>：系统的运行与数据库的日常维护。</p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>对数据库第二范式的理解正确的是()</p>
<ul>
<li>A 数据库表的每一列都是不可分割的原子数据项</li>
<li>B 在1NF基础上,任何非主属性不依赖于其它非主属性</li>
<li>C 在1NF基础上,非码属性必须完全依赖与码</li>
<li>D 以上说法都不正确</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><h3 id="范式说明"><a href="#范式说明" class="headerlink" title="范式说明"></a>范式说明</h3><p>第一范式，原子性<br>第二范式，没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。<br>第三范式，不能存在传递依赖</p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>使用MYSQL进行模糊查询 LIKE ‘_YOU%’,下面哪个是正确结果？</p>
<ul>
<li>A YONYOU</li>
<li>B YYOUYO</li>
<li>C YOUYON</li>
<li>D YYYOUN</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><table>
<thead>
<tr>
<th align="left">通配符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">_</td>
<td align="left">表示任意单个字符</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">表示任意个或多个字符</td>
</tr>
</tbody></table>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>下面那些是非关系型数据库()</p>
<ul>
<li>A Redis</li>
<li>B Mysql</li>
<li>C MongoDb</li>
<li>D SqlServer</li>
</ul>
<p>正确答案: AC</p>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><h3 id="一、关系型数据库"><a href="#一、关系型数据库" class="headerlink" title="一、关系型数据库"></a>一、关系型数据库</h3><p><img data-src="https://uploadfiles.nowcoder.com/files/20190815/345829746_1565884415495_1013528-20170926113945323-238845177.png" alt="图片"><br>关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织<br>优点：<br>1、易于维护：都是使用表结构，格式一致；<br>2、使用方便：SQL语言通用，可用于复杂查询；<br>3、复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。<br>缺点：<br>1、读写性能比较差，尤其是海量数据的高效率读写；<br>2、固定的表结构，灵活度稍欠；<br>3、高并发读写需求，传统关系型数据库来说，硬盘I&#x2F;O是一个很大的瓶颈。</p>
<h3 id="二、非关系型数据库"><a href="#二、非关系型数据库" class="headerlink" title="二、非关系型数据库"></a>二、非关系型数据库</h3><p><img data-src="https://uploadfiles.nowcoder.com/files/20190815/345829746_1565884442185_1013528-20170926114007198-781865994.png" alt="图片"><br>非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合，可以是文档或者键值对等。<br>优点：<br>1、格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。<br>2、速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；<br>3、高扩展性；<br>4、成本低：nosql数据库部署简单，基本都是开源软件。</p>
<p>缺点：<br>1、不提供sql支持，学习和使用成本较高；<br>2、无事务处理；<br>3、数据结构相对复杂，复杂查询方面稍欠。</p>
<p>非关系型数据库的分类和比较：<br>1、文档型<br>2、key-value型<br>3、列式数据库<br>4、图形数据库</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月05日 数据库1</title>
    <url>/exam//8af88738/</url>
    <content><![CDATA[<h1 id="考点1-联系-一对一，一对多，多对多"><a href="#考点1-联系-一对一，一对多，多对多" class="headerlink" title="考点1:联系 一对一，一对多，多对多"></a>考点1:联系 一对一，一对多，多对多</h1><p>学校中有多个院系和多名教师,每个教师只能属于一个院系,一个系可以有多名教师,院系和教师之间的关系是( )。</p>
<ul>
<li>A 一对多</li>
<li>B 一对一</li>
<li>C 一对二</li>
<li>D 多对多</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<h1 id="考点2-数据库范式"><a href="#考点2-数据库范式" class="headerlink" title="考点2:数据库范式"></a>考点2:数据库范式</h1><p>在通常情况下,下面的关系中不可以作为关系数据库的关系是()</p>
<ul>
<li>A <code>R1</code>(学生号,学生名,性别)</li>
<li>B <code>R2</code>(学生号,学生名,班级号)</li>
<li>C <code>R3</code>(学生号,学生名,宿舍号)</li>
<li>D <code>R4</code>(学生号,学生名,简历)</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>1NF是第一范式：数据库中的每一项都是不可分割的基本数据项.</p>
<p>而简历中包含学号与姓名,不满足第一范式。</p>
<h3 id="数据库范式1nf-2nf-3nf"><a href="#数据库范式1nf-2nf-3nf" class="headerlink" title="数据库范式1nf,2nf,3nf"></a>数据库范式1nf,2nf,3nf</h3><p>1nf: 每一列原子性，不可再分<br>2nf: 非主键列完全依赖于（联合）主键<br>3nf: 非主键直接依赖于主键</p>
<h1 id="考点3-DML语句"><a href="#考点3-DML语句" class="headerlink" title="考点3:DML语句"></a>考点3:DML语句</h1><p>以下不属于DML的是?</p>
<ul>
<li>A <code>INSERT</code></li>
<li>B <code>DELETE</code></li>
<li>C <code>CREATE</code></li>
<li>D <code>UPDATE</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h3 id="DQL-DML-DDL-DCL"><a href="#DQL-DML-DDL-DCL" class="headerlink" title="DQL DML DDL DCL"></a>DQL DML DDL DCL</h3><p>数据查询语言DQL: 由select字句，from字句，Where字句组成的查询块<br>数据操纵语言DML：insert，update，delete<br>数据定义语言DDL：Create字句，如创建索引。 表 视图等<br>数据控制语言DCL：Grant字句，Commit字句，用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。</p>
<h1 id="考点4-索引"><a href="#考点4-索引" class="headerlink" title="考点4:索引"></a>考点4:索引</h1><p>关于数据库的描述错误的是:</p>
<ul>
<li>A 创建索引一定能提升查询时间</li>
<li>B 主键的数据列要创建索引</li>
<li>C 外键的数据列要建立索引</li>
<li>D 常见数据库索引有 <code>Hash</code> 索引,<code>B-tree</code> 索引</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>首先明白为什么索引会增加速度，DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。<br>如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。</p>
<p>那么在任何时候都应该加索引么？这里有几个反例：<br>1、如果每次都需要取到所有表记录，无论如何都必须进行全表扫描了，那么是否加索引也没有意义了。<br>2、对非唯一的字段，例如“性别”这种大量重复值的字段，增加索引也没有什么意义。<br>3、对于记录比较少的表，增加索引不会带来速度的优化反而浪费了存储空间，因为索引是需要存储空间的，而且有个致命缺点是对于update&#x2F;insert&#x2F;delete的每次执行，字段的索引都必须重新计算更新，这就拖慢了速度</p>
<p>常见的数据库索引是B-tree索引，虽然Hash 索引效率很高，但是他有很多弊端，比如</p>
<p>Hash 索引仅仅能满足”&#x3D;”,”IN”和”&lt;&#x3D;&gt;”查询，不能使用范围查询等，这些弊端导致其不是常见的数据库索引。</p>
<h1 id="考点5-数据模型及其数据结构"><a href="#考点5-数据模型及其数据结构" class="headerlink" title="考点5:数据模型及其数据结构"></a>考点5:数据模型及其数据结构</h1><p>关系数据模型的基本数据结构是(    )</p>
<ul>
<li>A 树</li>
<li>B 图</li>
<li>C 索引</li>
<li>D 关系</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<p><strong>关系数据模型</strong>的逻辑结构是<strong>关系</strong><br><strong>层次数据模型</strong>的逻辑结构是<strong>树</strong><br><strong>网状数据结构</strong>的逻辑结构是<strong>图</strong></p>
<p>关系模型的数据结构是关系，数据的逻辑结构是二维表。</p>
<h1 id="考点6-SQL创建主键-SQL删除主键"><a href="#考点6-SQL创建主键-SQL删除主键" class="headerlink" title="考点6:SQL创建主键 SQL删除主键"></a>考点6:SQL创建主键 SQL删除主键</h1><p>下面Transact-SQL语句中可以用于创建主键的是()</p>
<ul>
<li>A <code>alter table table1 with notcheck add constraint [PK_table1] primary key nonclustered (column1) on primary;</code></li>
<li>B <code>alter table table1 column1 primary key;</code></li>
<li>C <code>alter table table1 column1;</code></li>
<li>D <code>create table table1 (column1 char(13) not null primary,column2 int not) on primary;</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h3 id="删除主键"><a href="#删除主键" class="headerlink" title="删除主键"></a>删除主键</h3><p>表中删除主键为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">alert <span class="keyword">table</span> table_test <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br></pre></td></tr></table></figure>
<h3 id="添加主键"><a href="#添加主键" class="headerlink" title="添加主键"></a>添加主键</h3><p>表中增加主键为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">alert <span class="keyword">table</span> table_test <span class="keyword">add</span> <span class="keyword">primary</span> key(id);</span><br></pre></td></tr></table></figure>
<p>注意<strong>add</strong>,B,C,D都没有add关键字，可以排除。</p>
<h1 id="考点7-分布式数据库系统DDBS"><a href="#考点7-分布式数据库系统DDBS" class="headerlink" title="考点7:分布式数据库系统DDBS"></a>考点7:分布式数据库系统DDBS</h1><p>在DDBS中,数据传输量是衡量查询时间的一个主要指标,导致数据传输量大的主要原因是( )。</p>
<ul>
<li>A 场地间距离过大</li>
<li>B 数据库的数据量大</li>
<li>C 不同场地间的联接操作</li>
<li>D 在<code>CPU</code>上处理通信的代价高</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>DDBS：<strong>Distributed DataBase System</strong> 分布式数据库系统</p>
<h1 id="考点8-数据库技术的根本目标"><a href="#考点8-数据库技术的根本目标" class="headerlink" title="考点8:数据库技术的根本目标"></a>考点8:数据库技术的根本目标</h1><p>数据库技术的根本目标是要解决数据的 ( ) 。</p>
<ul>
<li>A 存储问题</li>
<li>B 共享问题</li>
<li>C 安全问题</li>
<li>D 保护问题</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>数据库的直接目标是解决数据存储问题，根本目标是为了不同用户或应用程序之间的数据共享。</p>
<h1 id="考点9-视图可以从哪里导出"><a href="#考点9-视图可以从哪里导出" class="headerlink" title="考点9:视图可以从哪里导出"></a>考点9:视图可以从哪里导出</h1><p>视图是由下面哪两者导出的表()。</p>
<ul>
<li>A 模式、关系</li>
<li>B 基本表、视图</li>
<li>C 基本关系、关系</li>
<li>D 内模式、外模式</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>SQL中，<strong>内模式</strong>、<code>模式</code>、外模式分别对应<strong>存储文件</strong>、<code>基本表</code>、视图</p>
<h1 id="考点10-MySQL-SQL注入"><a href="#考点10-MySQL-SQL注入" class="headerlink" title="考点10:MySQL SQL注入"></a>考点10:MySQL SQL注入</h1><p>Mysql sql注入中使用延时注入时常用的语句是()</p>
<ul>
<li>A <code>wait for delay &#39;0:0:10</code></li>
<li>B <code>sleep(5)</code></li>
<li>C <code>benchmark(100000000,md5(1))</code></li>
<li>D <code>union select</code></li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<h3 id="函数注入"><a href="#函数注入" class="headerlink" title="函数注入"></a>函数注入</h3><table>
<thead>
<tr>
<th align="left">MySQL</th>
<th align="left">benchmark(100000,md5(1))或者sleep(5)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PostgreSQL</td>
<td align="left">PG_SLEEP(5)或者 GENERATE_SERIES(1,100000)</td>
</tr>
<tr>
<td align="left">MS SQL server</td>
<td align="left">WAITFOR DELAY ‘0:05’</td>
</tr>
</tbody></table>
<p><img data-src="https://uploadfiles.nowcoder.com/images/20180827/283950953_1535337015759_51B3875ECF358403950EB543513B2F00" alt="这里有一张图片"></p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月23日 SQL专项练习</title>
    <url>/exam//d07385b1/</url>
    <content><![CDATA[<h1 id="考点1-数据操纵语言-SQL语言分类"><a href="#考点1-数据操纵语言-SQL语言分类" class="headerlink" title="考点1:数据操纵语言 SQL语言分类"></a>考点1:数据操纵语言 SQL语言分类</h1><p>SQL语言共分为三大类（亦有说法分为四大类），那么不属于数据操纵语言的有（）</p>
<ul>
<li>A update</li>
<li>B grant</li>
<li>C delete</li>
<li>D insert</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h2 id="数据操纵语言"><a href="#数据操纵语言" class="headerlink" title="数据操纵语言"></a>数据操纵语言</h2><ul>
<li>数据查询语言（<code>DQL</code>）：是由<code>SELECT</code>子句，<code>FROM</code>子句，<code>WHERE</code>子句组成的查询块</li>
<li>数据操纵语言（<code>DML</code>）:<code>SELECT</code>(查询)<code>INSERT</code>(插入)<code>UPDATE</code>(更新)<code>DELETE</code>(删除）</li>
<li>数据定义语言（<code>DDL</code>）：<code>CREATE</code>(创建数据库或表或索引）<code>ALTER</code>(修改表或者数据库）<code>DROP</code>(删除表或索引）</li>
<li>数据控制语言（<code>DCL</code>）：<code>GRANT</code>(赋予用户权限）<code>REVOKE</code>(收回权限）<code>DENY</code>(禁止权限)</li>
<li>事务控制语言（<code>TCL</code>）：<code>SAVEPOINT</code> (设置保存点）<code>ROLLBACK</code> (回滚)<code>COMMIT</code>(提交)</li>
</ul>
<h1 id="考点2-多表联查"><a href="#考点2-多表联查" class="headerlink" title="考点2:多表联查"></a>考点2:多表联查</h1><p>设有图书管理数据库：<br>图书(总编号C(6),分类号C(8),书名C(16),作者C(6),出版单位C(20),单价N(6,2))<br>读者(借书证号C(4),单位C(8),姓名C(6),性别C(2),职称C(6),地址C(20))<br>借阅(借书证号C(4),总编号C(6),借书日期D(8))<br>对于图书管理数据库，查询0001号借书证的读者姓名和所借图书的书名。</p>
<p>SQL语句正确的是______。<br>SELECT 姓名,书名 FROM 借阅,图书,读者 WHERE;<br>借阅.借书证号&#x3D;”0001” AND;</p>
<hr>
<hr>
<ul>
<li>A <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">图书.分类号<span class="operator">=</span>借阅.分类号 <span class="keyword">AND</span>;</span><br><span class="line">读者.借书证号<span class="operator">=</span>借阅.借书证号;</span><br></pre></td></tr></table></figure></li>
<li>B<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">图书.总编号<span class="operator">=</span>借阅.总编号 <span class="keyword">AND</span>;</span><br><span class="line">读者.借书证号<span class="operator">=</span>借阅.借书证号;</span><br></pre></td></tr></table></figure></li>
<li>C <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">读者.总编号<span class="operator">=</span>借阅.总编号 <span class="keyword">AND</span>;</span><br><span class="line">读者.借书证号<span class="operator">=</span>借阅.借书证号;</span><br></pre></td></tr></table></figure></li>
<li>D <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">图书.总编号<span class="operator">=</span>借阅.总编号 <span class="keyword">AND</span>;</span><br><span class="line">读者.书名<span class="operator">=</span>借阅.书名;</span><br></pre></td></tr></table></figure></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h1 id="考点3-单表连接查询-双重否定"><a href="#考点3-单表连接查询-双重否定" class="headerlink" title="考点3:单表连接查询 双重否定"></a>考点3:单表连接查询 双重否定</h1><p>一张学生成绩表score，部分内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name       course     grade</span><br><span class="line">张三        操作系统      67</span><br><span class="line">张三        数据结构      86</span><br><span class="line">李四        软件工程      89;</span><br></pre></td></tr></table></figure>
<p>用一条SQL 语句查询出每门课都大于80 分的学生姓名，SQL语句实现正确的是：（      ）</p>
<ul>
<li>A <code>Select distinct name from score where name not in(Select name from score where grade &lt;= 80);</code></li>
<li>B <code>Select distinct name from score where name in(Select name from score where grade &lt;= 80);</code></li>
<li>C <code>Select name from score where name not in(Select name from score where grade &lt;= 80);</code></li>
<li>D <code>Select name from score where name in(Select name from score where grade &lt;= 80);</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p><strong>不存在 小于八十分的课&#x3D;所有的 课大于八十分</strong><br>遇到<strong>都</strong>，<strong>所有</strong>，需要留意，看看能不能转换为双重否定。</p>
<p><strong>每门课都大于80&#x3D;不存在一门课 小于等于80</strong></p>
<h1 id="考点4-group-by-having子句"><a href="#考点4-group-by-having子句" class="headerlink" title="考点4:group by-having子句"></a>考点4:group by-having子句</h1><p>SQL语句中与Having子句同时使用的语句是？（）</p>
<ul>
<li>A Group By</li>
<li>B 联盟链</li>
<li>C left Join</li>
<li>D Where</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>HAVING语句通常与GROUP BY语句联合使用，用来过滤由GROUP BY语句返回的记录集。</p>
<h1 id="考点5-select-into语句"><a href="#考点5-select-into语句" class="headerlink" title="考点5:select into语句"></a>考点5:select into语句</h1><p>某打车公司将驾驶里程（drivedistanced）超过5000里的司机信息转移到一张称为seniordrivers 的表中,他们的详细情况被记录在表drivers 中，正确的sql为（）</p>
<ul>
<li>A <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> seniordrivers</span><br><span class="line">drivedistanced<span class="operator">&gt;=</span><span class="number">5000</span> <span class="keyword">from</span> drivers <span class="keyword">where</span>;</span><br></pre></td></tr></table></figure></li>
<li>B <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> seniordrivers (drivedistanced) <span class="keyword">values</span> <span class="keyword">from</span> drivers <span class="keyword">where</span> drivedistanced<span class="operator">&gt;=</span><span class="number">5000</span>;</span><br></pre></td></tr></table></figure></li>
<li>C <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> seniordrivers</span><br><span class="line">(drivedistanced)<span class="keyword">values</span><span class="operator">&gt;=</span><span class="number">5000</span> <span class="keyword">from</span> drivers <span class="keyword">where</span>;</span><br></pre></td></tr></table></figure></li>
<li>D <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">into</span> seniordrivers <span class="keyword">from</span> drivers <span class="keyword">where</span> drivedistanced <span class="operator">&gt;=</span><span class="number">5000</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<p>insert into 要求目标表必须存在，select into 如果不存最目标表的话会自动创建</p>
<h2 id="SQL-INSERT-INTO-SELECT-语句"><a href="#SQL-INSERT-INTO-SELECT-语句" class="headerlink" title="SQL INSERT INTO SELECT 语句"></a>SQL INSERT INTO SELECT 语句</h2><p><a href="https://www.runoob.com/sql/sql-insert-into-select.html">https://www.runoob.com/sql/sql-insert-into-select.html</a></p>
<p>通过<code>SQL</code>，您可以从一个表复制信息到另一个表。</p>
<p><code>INSERT INTO SELECT</code>语句从一个表复制数据，然后把数据插入到一个已存在的表中。</p>
<p><code>SQL INSERT INTO SELECT</code>语句<br><code>INSERT INTO SELECT</code>语句从一个表复制数据，然后把数据插入到一个已存在的表中。目标表中任何已存在的行都不会受影响。</p>
<h3 id="SQL-INSERT-INTO-SELECT语法"><a href="#SQL-INSERT-INTO-SELECT语法" class="headerlink" title="SQL INSERT INTO SELECT语法"></a>SQL INSERT INTO SELECT语法</h3><p>我们可以从一个表中复制所有的列插入到另一个已存在的表中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table2</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1;</span><br></pre></td></tr></table></figure>
<p>或者我们可以只复制希望的列插入到另一个已存在的表中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table2</span><br><span class="line">(column_name(s))</span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1;</span><br></pre></td></tr></table></figure>
<p>演示数据库<br>在本教程中，我们将使用 RUNOOB 样本数据库。</p>
<p>下面是选自 “Websites” 表的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+--------------+---------------------------+-------+---------+</span><br><span class="line">| id | name         | url                       | alexa | country |</span><br><span class="line">+----+--------------+---------------------------+-------+---------+</span><br><span class="line">| 1  | Google       | https://www.google.cm/    | 1     | USA     |</span><br><span class="line">| 2  | 淘宝          | https://www.taobao.com/   | 13    | CN      |</span><br><span class="line">| 3  | 菜鸟教程      | http://www.runoob.com/    | 4689  | CN      |</span><br><span class="line">| 4  | 微博          | http://weibo.com/         | 20    | CN      |</span><br><span class="line">| 5  | Facebook     | https://www.facebook.com/ | 3     | USA     |</span><br><span class="line">| 7  | stackoverflow | http://stackoverflow.com/ |   0 | IND     |</span><br><span class="line">+----+---------------+---------------------------+-------+---------+</span><br></pre></td></tr></table></figure>
<p>下面是 “apps” APP 的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM apps;</span><br><span class="line">+----+------------+-------------------------+---------+</span><br><span class="line">| id | app_name   | url                     | country |</span><br><span class="line">+----+------------+-------------------------+---------+</span><br><span class="line">|  1 | QQ APP     | http://im.qq.com/       | CN      |</span><br><span class="line">|  2 | 微博 APP | http://weibo.com/       | CN      |</span><br><span class="line">|  3 | 淘宝 APP | https://www.taobao.com/ | CN      |</span><br><span class="line">+----+------------+-------------------------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="SQL-INSERT-INTO-SELECT-实例"><a href="#SQL-INSERT-INTO-SELECT-实例" class="headerlink" title="SQL INSERT INTO SELECT 实例"></a>SQL INSERT INTO SELECT 实例</h3><p>复制 “apps” 中的数据插入到 “Websites” 中：</p>
<p>实例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Websites (name, country)</span><br><span class="line"><span class="keyword">SELECT</span> app_name, country <span class="keyword">FROM</span> apps;</span><br></pre></td></tr></table></figure>
<p>只复 QQ 的 APP 到 “Websites” 中：</p>
<p>实例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Websites (name, country)</span><br><span class="line"><span class="keyword">SELECT</span> app_name, country <span class="keyword">FROM</span> apps</span><br><span class="line"><span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="SQL-SELECT-INTO-语句"><a href="#SQL-SELECT-INTO-语句" class="headerlink" title="SQL SELECT INTO 语句"></a>SQL SELECT INTO 语句</h2><p><a href="https://www.runoob.com/sql/sql-select-into.html">https://www.runoob.com/sql/sql-select-into.html</a><br>通过<code>SQL</code>，您可以从一个表复制信息到另一个表。</p>
<p><code>SELECT INTO</code>语句从一个表复制数据，然后把数据插入到另一个新表中。</p>
<blockquote>
<p>注意：<br>MySQL 数据库不支持 SELECT … INTO 语句，但支持 INSERT INTO … SELECT 。<br>当然你可以使用以下语句来拷贝表结构及数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 新表</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 旧表 ;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="SQL-SELECT-INTO-语法"><a href="#SQL-SELECT-INTO-语法" class="headerlink" title="SQL SELECT INTO 语法"></a>SQL SELECT INTO 语法</h3><p>我们可以复制所有的列插入到新表中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">INTO</span> newtable [<span class="keyword">IN</span> externaldb]</span><br><span class="line"><span class="keyword">FROM</span> table1;</span><br></pre></td></tr></table></figure>
<p>或者只复制希望的列插入到新表中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">INTO</span> newtable [<span class="keyword">IN</span> externaldb]</span><br><span class="line"><span class="keyword">FROM</span> table1;</span><br></pre></td></tr></table></figure>
<p>提示：新表将会使用 SELECT 语句中定义的列名称和类型进行创建。您可以使用 AS 子句来应用新名称。</p>
<h3 id="SQL-SELECT-INTO-实例"><a href="#SQL-SELECT-INTO-实例" class="headerlink" title="SQL SELECT INTO 实例"></a>SQL SELECT INTO 实例</h3><p>创建 Websites 的备份复件：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">INTO</span> WebsitesBackup2016</span><br><span class="line"><span class="keyword">FROM</span> Websites;</span><br></pre></td></tr></table></figure>
<p>只复制一些列插入到新表中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, url</span><br><span class="line"><span class="keyword">INTO</span> WebsitesBackup2016</span><br><span class="line"><span class="keyword">FROM</span> Websites;</span><br></pre></td></tr></table></figure>
<p>只复制中国的网站插入到新表中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">INTO</span> WebsitesBackup2016</span><br><span class="line"><span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">WHERE</span> country<span class="operator">=</span><span class="string">&#x27;CN&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>复制多个表中的数据插入到新表中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Websites.name, access_log.count, access_log.date</span><br><span class="line"><span class="keyword">INTO</span> WebsitesBackup2016</span><br><span class="line"><span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> access_log</span><br><span class="line"><span class="keyword">ON</span> Websites.id<span class="operator">=</span>access_log.site_id;</span><br></pre></td></tr></table></figure>
<p>提示：SELECT INTO 语句可用于通过另一种模式创建一个新的空表。只需要添加促使查询没有数据返回的 WHERE 子句即可：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">INTO</span> newtable</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="number">1</span><span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>select into from 和 insert into select 都是用来复制表<br>两者的主要区别为： </p>
<ul>
<li><code>select into from</code>要求目标表不存在，因为在插入时会自动创建；</li>
<li><code>insert into select from</code>要求目标表存在。</li>
</ul>
<blockquote>
<ul>
<li>select into from ：将查询出来的数据整理到一张新表中保存，表结构与查询结构一致。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span>(查询出来的结果) <span class="keyword">into</span> newtable(新的表名)<span class="keyword">from</span> <span class="keyword">where</span> (后续条件);</span><br></pre></td></tr></table></figure>
即，查询出来结果—&gt;复制一张同结构的空表—&gt;将数据拷贝进去。</li>
<li>insert into select ：为已经存在的表批量添加新数据。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span>  (准备好的表) <span class="keyword">select</span> <span class="operator">*</span>(或者取用自己想要的结构)<span class="keyword">from</span> 表名 <span class="keyword">where</span> 各种条件;</span><br></pre></td></tr></table></figure>
即，指定一张想要插入数据的表格—&gt;对数据进行加工筛选—&gt;填入一张准备好的表格。</li>
</ul>
</blockquote>
<h3 id="create-table复制表结构或数据"><a href="#create-table复制表结构或数据" class="headerlink" title="create table复制表结构或数据"></a>create table复制表结构或数据</h3><h4 id="1-复制表结构及其数据："><a href="#1-复制表结构及其数据：" class="headerlink" title="1. 复制表结构及其数据："></a>1. 复制表结构及其数据：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name_new <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name_old;</span><br></pre></td></tr></table></figure>
<h4 id="2-只复制表结构："><a href="#2-只复制表结构：" class="headerlink" title="2. 只复制表结构："></a>2. 只复制表结构：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name_new <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name_old <span class="keyword">where</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name_new <span class="keyword">like</span> table_name_old;</span><br></pre></td></tr></table></figure>
<h3 id="insert-into-复制表数据："><a href="#insert-into-复制表数据：" class="headerlink" title="insert into 复制表数据："></a>insert into 复制表数据：</h3><p>如果两个表结构一样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name_new <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name_old;</span><br></pre></td></tr></table></figure>
<p>如果两个表结构不一样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name_new(column1,column2...) <span class="keyword">select</span> column1,column2... <span class="keyword">from</span> table_name_old;</span><br></pre></td></tr></table></figure>

<h1 id="考点6-多表联查-连接查询-量词"><a href="#考点6-多表联查-连接查询-量词" class="headerlink" title="考点6:多表联查 连接查询 量词"></a>考点6:多表联查 连接查询 量词</h1><p>运动会比赛信息的数据库，有如下三个表：<br>运动员ATHLETE（运动员编号 Ano，姓名Aname，性别Asex，所属系名 Adep）， 项目 ITEM （项目编号Ino，名称Iname，比赛地点Ilocation）， 成绩SCORE （运动员编号Ano，项目编号Ino，积分Score）。<br>写出目前总积分最高的系名及其积分，SQL语句实现正确的是：（      ）</p>
<ul>
<li>A <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Adep,<span class="built_in">SUM</span>(Score) <span class="keyword">FROM</span> ATHLETE,SCORE <span class="keyword">WHERE</span> ATHLETE.Ano<span class="operator">=</span>SCORE.Ano <span class="keyword">GROUP</span> <span class="keyword">BY</span> Adep <span class="keyword">HAVING</span> <span class="built_in">SUM</span>(Score)</span><br><span class="line"><span class="operator">&gt;=</span><span class="keyword">ANY</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(Score) <span class="keyword">FROM</span> ATHLETE,SCORE <span class="keyword">WHERE</span> ATHLETE.Ano<span class="operator">=</span>SCORE.Ano <span class="keyword">GROUP</span> <span class="keyword">BY</span> Adep)</span><br></pre></td></tr></table></figure></li>
<li>B <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Adep,<span class="built_in">SUM</span>(Score) <span class="keyword">FROM</span> ATHLETE,SCORE <span class="keyword">WHERE</span> ATHLETE.Ano<span class="operator">=</span>SCORE.Ano <span class="keyword">GROUP</span> <span class="keyword">BY</span> Adep <span class="keyword">HAVING</span> <span class="built_in">SUM</span>(Score)</span><br><span class="line"><span class="operator">&gt;=</span><span class="keyword">SOME</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(Score) <span class="keyword">FROM</span> ATHLETE,SCORE <span class="keyword">WHERE</span> ATHLETE.Ano<span class="operator">=</span>SCORE.Ano <span class="keyword">GROUP</span> <span class="keyword">BY</span> Adep)</span><br></pre></td></tr></table></figure></li>
<li>C <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Adep,<span class="built_in">SUM</span>(Score) <span class="keyword">FROM</span> ATHLETE,SCORE <span class="keyword">WHERE</span> ATHLETE.Ano<span class="operator">=</span>SCORE.Ano <span class="keyword">GROUP</span> <span class="keyword">BY</span> Adep <span class="keyword">HAVING</span> <span class="built_in">SUM</span>(Score) </span><br><span class="line"><span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(Score) <span class="keyword">FROM</span> ATHLETE,SCORE <span class="keyword">WHERE</span> ATHLETE.Ano<span class="operator">=</span>SCORE.Ano <span class="keyword">GROUP</span> <span class="keyword">BY</span> Adep)</span><br></pre></td></tr></table></figure></li>
<li>D <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Adep,<span class="built_in">SUM</span>(Score) <span class="keyword">FROM</span> ATHLETE,SCORE <span class="keyword">WHERE</span> ATHLETE.Ano<span class="operator">=</span>SCORE.Ano <span class="keyword">GROUP</span> <span class="keyword">BY</span> Adep <span class="keyword">HAVING</span> <span class="built_in">SUM</span>(Score)</span><br><span class="line"><span class="operator">&gt;=</span><span class="keyword">ALL</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(Score) <span class="keyword">FROM</span> ATHLETE,SCORE <span class="keyword">WHERE</span> ATHLETE.Ano<span class="operator">=</span>SCORE.Ano <span class="keyword">GROUP</span> <span class="keyword">BY</span> Adep)</span><br></pre></td></tr></table></figure></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>All：对所有数据都满足条件，整个条件才成立；<br>Any：只要有一条数据满足条件，整个条件成立；<br>Some的作用和Any一样 .</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运动员ATHLETE（运动员编号 Ano，姓名Aname，性别Asex，所属系名 Adep）， </span><br><span class="line">项目ITEM （项目编号Ino，名称Iname，比赛地点Ilocation）， </span><br><span class="line">成绩SCORE （运动员编号Ano，项目编号Ino，积分Score）</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ATHLETE（Ano，Aname，Asex，Adep）， </span><br><span class="line">ITEM（Ino，Iname，Ilocation）， </span><br><span class="line">SCORE（Ano，Ino，Score）</span><br></pre></td></tr></table></figure>
<p>写出目前总积分最高的系名及其积分，SQL语句实现正确的是</p>
<h1 id="考点7-select-into-from和insert-into-select"><a href="#考点7-select-into-from和insert-into-select" class="headerlink" title="考点7:select into from和insert into select"></a>考点7:select into from和insert into select</h1><p>某打车公司将驾驶里程（drivedistanced）超过5000里的司机信息转移到一张称为seniordrivers 的表中,他们的详细情况被记录在表drivers 中，正确的sql为（）</p>
<ul>
<li>A <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> seniordrivers drivedistanced<span class="operator">&gt;=</span><span class="number">5000</span> <span class="keyword">from</span> drivers <span class="keyword">where</span>;</span><br></pre></td></tr></table></figure></li>
<li>B <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> seniordrivers (drivedistanced) <span class="keyword">values</span> <span class="keyword">from</span> drivers <span class="keyword">where</span> drivedistanced<span class="operator">&gt;=</span><span class="number">5000</span>;</span><br></pre></td></tr></table></figure></li>
<li>C <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> seniordrivers (drivedistanced)<span class="keyword">values</span><span class="operator">&gt;=</span><span class="number">5000</span> <span class="keyword">from</span> drivers <span class="keyword">where</span></span><br></pre></td></tr></table></figure></li>
<li>D <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">into</span> seniordrivers <span class="keyword">from</span> drivers <span class="keyword">where</span> drivedistanced <span class="operator">&gt;=</span><span class="number">5000</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h1 id="考点8-as取别名"><a href="#考点8-as取别名" class="headerlink" title="考点8:as取别名"></a>考点8:as取别名</h1><p>在MySql中进行数据查询时，如果要对查询结果的列名重新命名，将sno列重新命名为学号，则下列语句正确的是（ ）</p>
<ul>
<li>A <code>select sno as 学号 from T</code></li>
<li>B <code>select 学号= sno from T</code></li>
<li>C <code>select sno 学号 from T</code></li>
<li>D <code>select sno=学号 from T</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>


<p>as只用于mysql语言中，as可以为列或者表起别名，as可以省略，但是要用空格代替</p>
<h1 id="考点9-select语句"><a href="#考点9-select语句" class="headerlink" title="考点9:select语句"></a>考点9:select语句</h1><p>SQL语句中，可以查看到学生信息表中，学生姓名的SQL语句为？（）</p>
<ul>
<li>A <code>select 学生信息 from 学生信息</code></li>
<li>B <code>select 学生信息 from 学生姓名</code></li>
<li>C <code>select * from 学生信息</code></li>
<li>D <code>select 学生姓名 from 学生信息</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: CD</details>

<h2 id="SQL-SELECT-语法"><a href="#SQL-SELECT-语法" class="headerlink" title="SQL SELECT 语法"></a>SQL SELECT 语法</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name,column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>

<h1 id="考点10-聚合函数不统计null值-count-和count-1-都是统计行数"><a href="#考点10-聚合函数不统计null值-count-和count-1-都是统计行数" class="headerlink" title="考点10:聚合函数不统计null值 count(*)和count(1)都是统计行数"></a>考点10:聚合函数不统计null值 count(*)和count(1)都是统计行数</h1><p>表结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `score` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `sno` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `cno` tinyint(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `score` tinyint(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ;</span><br></pre></td></tr></table></figure>
<p>以下查询语句结果一定相等的是（）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A.SELECT sum(score) / count(*) FROM score WHERE cno = 2;</span><br><span class="line">B.SELECT sum(score) / count(id) FROM score WHERE cno = 2;</span><br><span class="line">C.SELECT sum(score) / count(sno) FROM score WHERE cno = 2;</span><br><span class="line">D.SELECT sum(score) / count(score) FROM score WHERE cno = 2;</span><br><span class="line">E.SELECT sum(score) / count(1) FROM score WHERE cno = 2;</span><br><span class="line">F.SELECT avg(score) FROM score WHERE cno = 2;</span><br></pre></td></tr></table></figure>
<ul>
<li>A A,E,F</li>
<li>B A,D,F</li>
<li>C A,B,C,D</li>
<li>D D,F</li>
<li>E A,B,E,F</li>
<li>F A,B,C,E</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: DF</details>

<h2 id="聚合函数-字段名-会忽略null值"><a href="#聚合函数-字段名-会忽略null值" class="headerlink" title="聚合函数(字段名)会忽略null值"></a>聚合函数(字段名)会忽略null值</h2><p><code>count(字段名)</code>：会忽略该列中所有的null值<br><code>avg(字段名)</code>函数会忽略null值</p>
<h2 id="count-和count-1-都是统计行数"><a href="#count-和count-1-都是统计行数" class="headerlink" title="count(*)和count(1)都是统计行数"></a>count(*)和count(1)都是统计行数</h2><p><code>count(*)</code>：不会忽略null值，本质计算的是行数<br><code>count(1)</code>：不会忽略null值，本质计算的是行数</p>
<p>由于id、sno都not null，因此<code>count(*)</code>、<code>count(1)</code>、<code>count(id)</code>、<code>count(sno)</code>本质都是计算行数，ABCE的分子一样，分母也相等，所以结果相等。</p>
<p>score字段default null，avg(score)计算时，忽略null值，sum(score)和count(score)也同样忽略null值。<br>所以计算得到的avg(score)和sum(score)&#x2F;count(score)的值也是相等的。即DF结果一样。</p>
<p>Score是默认约束为null，<br>count(score)统计忽略空值行（对象），<br>avg(score)也会忽略空值行（对象）</p>
<p>所以都是求平均成绩：D和F都会忽略 空值，所以DF一样结果</p>
<p>id,sno是not null约束的，不会有空值，所以 count(id)和count(sno)都是统计行数，count(*)和count(1)也是统计行数，所以</p>
<p>ABCE都是计算的全部，所以是一样的结果</p>
<p>主要考察：<br><code>avg(column_name)</code>时忽略空值，<br><code>count(column_name)</code>时忽略空值</p>
<p><code>Count(1)</code>和<code>count(*)</code>效果一样，统计全部个数（<code>count(1)</code>比<code>count(*)</code>高效）</p>
<p>默认约束 default 的默认值设置了null</p>
<p>1、<code>count(*)</code>, <code>count(1)</code>是记录表格出现的行数，<code>count(sno)</code>, <code>count(id)</code>因为都是非空元素，计数也等于表格总行数<br>2、count(score)是记录score非空的行数，ave()函数也只对非空元素作用</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>2019年10月31日 智力题1</title>
    <url>/exam//b97b7079/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>水果店店长早晨通知店员，苹果应减10%,中午发现该减价是香蕉而非苹果，便又通知了香蕉减价10%,苹果提价10%,那么苹果是否恢复了原价?()</p>
<ul>
<li>A 不能确定</li>
<li>B 否</li>
<li>C 是</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>原价x元，降价后y&#x3D;x(1-10%)&#x3D;0.9x，升价后z&#x3D;y(1+10%)&#x3D;1.1y&#x3D;0.99x。</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>如果6个苹果和4根香蕉的价钱是4.6元，7个苹果和9根香蕉的价钱是7.1元，那么一个苹果的价钱是（）元？</p>
<ul>
<li>A 0.3</li>
<li>B 0.4</li>
<li>C 0.5</li>
<li>D 0.6</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>假设苹果的价格为a,香蕉的价格为b，通过解方程得出苹果的价格为0.5<br>6a+4b&#x3D;4.6<br>7a+9b&#x3D;7.1</p>
<h1 id="考点3-2-1-2-x2F-3-1-x2F-2"><a href="#考点3-2-1-2-x2F-3-1-x2F-2" class="headerlink" title="考点3 2,1,2&#x2F;3,1&#x2F;2,()"></a>考点3 2,1,2&#x2F;3,1&#x2F;2,()</h1><p>2,1,2&#x2F;3,1&#x2F;2,()</p>
<ul>
<li>A 0.75</li>
<li>B 0.25</li>
<li>C 0.4</li>
<li>D 0.83</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>2&#x2F;1, 2&#x2F;2, 2&#x2F;3, 2&#x2F;4, 2&#x2F;5…</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>凯物喜欢 225，但不喜欢 224，喜欢 900，但不喜欢 800，喜欢 121，但不喜欢 120，那么请你猜一猜，他会喜欢下面哪个数字?</p>
<ul>
<li>A 401</li>
<li>B 400</li>
<li>C 501</li>
<li>D 500</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>B，225是25的平方，900是30的平分，121是11的平方，同理，400是20的平方，所以是B</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>智力题</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月06日 计算机_编程基础1</title>
    <url>/exam//def2879b/</url>
    <content><![CDATA[<h1 id="考点1-C语言命名规则"><a href="#考点1-C语言命名规则" class="headerlink" title="考点1:C语言命名规则"></a>考点1:C语言命名规则</h1><p>以下叙述中正确的是()</p>
<ul>
<li>A 语言中的关键字不能作变量名,但可以作为函数名</li>
<li>B 标识符的长度不能任意长,最多只能包含16个字符</li>
<li>C 标识符可以由字母、数字和下划线组成,且第一个字符不得为数字</li>
<li>D 用户自定义的标识符必须”见名知义”,如果随意定义,则会出编译错误</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h3 id="C语言标识符命名规则"><a href="#C语言标识符命名规则" class="headerlink" title="C语言标识符命名规则"></a>C语言标识符命名规则</h3><p>解析：【解析】<br>C语言中的关键字即不能做变量名也不能做用户函数名,所以A错误。</p>
<p>标识符的命名规则,即：</p>
<ol>
<li>由下划线、字母、数字组成,</li>
<li>且不能以数字开头，可以就是必须以下划线或字母开头,</li>
<li>也不能和关键字一致。</li>
</ol>
<p>不同C语言规定标识符的有效长度可能会不同,但没有限制最大长度,所以B错误。</p>
<p>用户定义的标识符只要满足标识符命名规则没有特殊要求,<strong>不必一定”见名知义”</strong>,所以D错误。</p>
<h1 id="考点2-排错法？"><a href="#考点2-排错法？" class="headerlink" title="考点2:排错法？"></a>考点2:排错法？</h1><p>小孙发现某学生成绩管理系统运行后,不能正常处理分数为90分的成绩。于是小孙再次设计了多个成绩数据进行测试,又发现了它对一些特定分数的成绩处理有错。小孙从所有错误结果中归纳征兆,从而确定错误是由于程序对个位数为0的整数成绩处理有误。小孙排错采用的方法是( )。</p>
<ul>
<li>A 归纳排错法</li>
<li>B 演绎排错法</li>
<li>C 回溯排错法</li>
<li>D 穷举排错法</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<h1 id="考点3-源程序转换为可执行程序要经过的步骤"><a href="#考点3-源程序转换为可执行程序要经过的步骤" class="headerlink" title="考点3:源程序转换为可执行程序要经过的步骤"></a>考点3:源程序转换为可执行程序要经过的步骤</h1><p>用高级语言编写的源程序转化为可执行程序,必须经过()。</p>
<ul>
<li>A 汇编和解释</li>
<li>B 编辑和链接</li>
<li>C 编译和链接</li>
<li>D 解释和编译</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>一个计算机程序执行的过程可分为编辑、编译、连接和运行四个过程。用高级语言编写程序的过程称为编辑，之后利用编译程序从源语言编写的源程序产生目标程序的过程称为编译，翻译完的目标程序不能立即被执行，要通过连接将目标程序和有关的系统函数库以及系统提供的其他信息连接起来，形成一个可执行程序。综上所述，用高级语言编写的源程序，将其转化成能在计算机上运行的程序过程是编辑、编译、连接。</p>
<h1 id="考点4-汉字输入码"><a href="#考点4-汉字输入码" class="headerlink" title="考点4:汉字输入码"></a>考点4:汉字输入码</h1><p>在拼音输入法中,输入拼音”zhengchang”,其编码属于( )。</p>
<ul>
<li>A 字形码</li>
<li>B 地址码</li>
<li>C 外码</li>
<li>D 内码</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h3 id="外码-汉字输入码"><a href="#外码-汉字输入码" class="headerlink" title="外码 汉字输入码"></a>外码 汉字输入码</h3><p>汉字输入码是为使用户能够使用西文键盘输入汉字而编制的编码，也叫外码。</p>
<h3 id="汉字输入码分类"><a href="#汉字输入码分类" class="headerlink" title="汉字输入码分类"></a>汉字输入码分类</h3><p>汉字输入码有多种不同的编码方案，大致包括:</p>
<ol>
<li>音码（以汉语拼音字母和数字为汉字编码）、</li>
<li>音形码（以拼音为主，辅以字形字义进行编码）、</li>
<li>形码（根据汉字的字形结构对汉字进行编码）和</li>
<li>数字码（直接用固定位数的数字给汉字编码）4类。</li>
</ol>
<p>故正确答案为C选项。</p>
<h1 id="考点5-C-重载运算符"><a href="#考点5-C-重载运算符" class="headerlink" title="考点5:C++重载运算符"></a>考点5:C++重载运算符</h1><p>在表达式 <code>+y*z</code> 中, + 是作为成员函数重载的运算符, <code>*</code> 是作为非成员函数重载的运算符。则 <code>operator+</code> 有______个参数, <code>operator*</code> 有________参数。 (    )</p>
<ul>
<li>A 2、2</li>
<li>B 2、1</li>
<li>C 1、1</li>
<li>D 1、2</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>运算符可重载为成员函数，也可重载为非成员函数函数。</p>
<ul>
<li>当重载为<strong>成员函数</strong>时，运算符重载函数的<strong>形参个数要比运算符操作数的个数少一个</strong>；</li>
<li>当重载为<strong>非成员函数</strong>时，其<strong>形参个数应与操作数的个数相同</strong>。</li>
</ul>
<h1 id="考点6-位运算"><a href="#考点6-位运算" class="headerlink" title="考点6:位运算"></a>考点6:位运算</h1><p>下面有关位运算的一些结论哪些是正确的 (    )</p>
<ul>
<li>A 十二进制数81的二进制数为: <code>01100001</code></li>
<li>B 十进制数-11的补码为:<code>11110101</code></li>
<li>C 十进制数76和81异或的结果为十进制数28</li>
<li>D 位运算<code>(A|B)&amp;C = (A&amp;C)|(B&amp;C)</code></li>
<li>E 加法运算等同于位或运算,如<code>A+B=A|B</code></li>
<li>F 与二进制数00101101等值的十六进制数是<code>2C</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>

<h3 id="A选项-N进制数转10进制数：按权展开"><a href="#A选项-N进制数转10进制数：按权展开" class="headerlink" title="A选项 N进制数转10进制数：按权展开"></a>A选项 N进制数转10进制数：按权展开</h3><h4 id="十二进制的81转10进制"><a href="#十二进制的81转10进制" class="headerlink" title="十二进制的81转10进制"></a>十二进制的81转10进制</h4><p>$$<br>(81)_{12}&#x3D;8\times 12^1+1\times 12^0&#x3D;96+1&#x3D;97<br>$$</p>
<h4 id="二进制01100001转10进制"><a href="#二进制01100001转10进制" class="headerlink" title="二进制01100001转10进制"></a>二进制01100001转10进制</h4><p>$$<br>(01100001)_{2}&#x3D;0+1\times 2^6+1\times 2^5+0+0+0+0+1&#x3D;2^6+2^5+1&#x3D;64+32+1&#x3D;96+1&#x3D;97<br>$$</p>
<p>所以A正确</p>
<h3 id="B选项-原码反码补码"><a href="#B选项-原码反码补码" class="headerlink" title="B选项 原码反码补码"></a>B选项 原码反码补码</h3><p><strong>正数的原码，反码，补码都一样</strong></p>
<h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p>原码是直接将一个数值换算成二进制数。最高位为符号位，正数为0，负数为1</p>
<h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p>正数的反码是就是原码</p>
<p>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p>
<h4 id="补码的计算规则"><a href="#补码的计算规则" class="headerlink" title="补码的计算规则"></a>补码的计算规则</h4><p>计算机以补码的形式保存所有的整数。</p>
<ul>
<li><p>正数的补码和原码完全相同,</p>
</li>
<li><p>负数的补码是其反码加1;</p>
<p>   负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1.(即在反码的基础上+1)</p>
</li>
</ul>
<p>$$<br>(-11)&#x3D;8+2+1<br>$$</p>
<h4 id="补码转原码"><a href="#补码转原码" class="headerlink" title="补码转原码"></a>补码转原码</h4><p><strong>补码的补码就是原码</strong>，就像负负得正一样</p>
<h4 id="二进制十进制转换表"><a href="#二进制十进制转换表" class="headerlink" title="二进制十进制转换表"></a>二进制十进制转换表</h4><table>
<thead>
<tr>
<th align="left">2^n</th>
<th align="left">2^7</th>
<th align="left">2^6</th>
<th align="left">2^5</th>
<th align="left">2^4</th>
<th align="left">2^3</th>
<th align="left">2^2</th>
<th align="left">2^1</th>
<th align="left">2^0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">值</td>
<td align="left">128</td>
<td align="left">64</td>
<td align="left">32</td>
<td align="left">16</td>
<td align="left">8</td>
<td align="left">4</td>
<td align="left">2</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">-11原码</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">-11反码</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">-11补码</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>所以<br>$$<br>(-11)<em>{原码}&#x3D;1000 1011 \newline<br>(-11)</em>{反码}&#x3D;1000 0100 \newline<br>(-11)_{补码}&#x3D;1111 0101<br>$$</p>
<p>所以B选项正确</p>
<h3 id="C选项-亦或运算"><a href="#C选项-亦或运算" class="headerlink" title="C选项 亦或运算"></a>C选项 亦或运算</h3><p>如果a、b两个值不相同，则异或结果为1。<br>如果a、b两个值相同，异或结果为0。</p>
<p><strong>相同为0，相异为1</strong></p>
<h4 id="亦或真值表"><a href="#亦或真值表" class="headerlink" title="亦或真值表"></a>亦或真值表</h4><table>
<thead>
<tr>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a⊕b</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
</tbody></table>
<h4 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h4><p>76展开：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">76-64=12</span><br><span class="line">12-8=4</span><br><span class="line">4-4=0</span><br></pre></td></tr></table></figure>
<p>81展开：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">81-64=17</span><br><span class="line">17-16=1</span><br><span class="line">1-1=0</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">2^n</th>
<th align="left">2^7</th>
<th align="left">2^6</th>
<th align="left">2^5</th>
<th align="left">2^4</th>
<th align="left">2^3</th>
<th align="left">2^2</th>
<th align="left">2^1</th>
<th align="left">2^0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">值</td>
<td align="left">128</td>
<td align="left">64</td>
<td align="left">32</td>
<td align="left">16</td>
<td align="left">8</td>
<td align="left">4</td>
<td align="left">2</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">+76补码</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">+81补码</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">+76⊕+81补码</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>$$<br>+76⊕81&amp;&#x3D;&amp;0  0  0  1  1  1  0  1 \newline<br>&amp;&#x3D;&amp;16+8+4+1 \newline<br>&amp;&#x3D;&amp;29<br>$$</p>
<p>所以C选项错误</p>
<h3 id="D选项"><a href="#D选项" class="headerlink" title="D选项"></a>D选项</h3><p>位运算(A|B)&amp;C &#x3D; (A&amp;C)|(B&amp;C)</p>
<h4 id="交换律-结合律-分配律"><a href="#交换律-结合律-分配律" class="headerlink" title="交换律 结合律 分配律"></a>交换律 结合律 分配律</h4><p><a href="https://www.shuxuele.com/associative-commutative-distributive.html">https://www.shuxuele.com/associative-commutative-distributive.html</a></p>
<h5 id="交换律"><a href="#交换律" class="headerlink" title="交换律"></a>交换律</h5><p>符号相同的时候</p>
<p>$a+b&#x3D;b+a$</p>
<h5 id="结合律"><a href="#结合律" class="headerlink" title="结合律"></a>结合律</h5><p>符号相同的时候</p>
<p>$(a+b)+c&#x3D;a+(b+c)$</p>
<p>$(a\times b) \times c&#x3D;a\times (b \times c)$</p>
<h5 id="分配率"><a href="#分配率" class="headerlink" title="分配率"></a>分配率</h5><p>符号不同的时候</p>
<p>$a\times (b+c)&#x3D;a\times b+a\times c$</p>
<h4 id="按位或按位与满足分配率"><a href="#按位或按位与满足分配率" class="headerlink" title="按位或按位与满足分配率"></a>按位或按位与满足分配率</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> A=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> B=<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> C=<span class="number">3</span>;</span><br><span class="line">        System.out.println(((A | B) &amp; C) == ((A &amp; C) | (B &amp; C)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>

<h3 id="E选项"><a href="#E选项" class="headerlink" title="E选项"></a>E选项</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> A=-<span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> B=<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> C=<span class="number">6</span>;</span><br><span class="line">System.out.println(A+B);</span><br><span class="line">System.out.println(A|B);</span><br><span class="line">System.out.println(C+B);</span><br><span class="line">System.out.println(C|B);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">-3</span><br><span class="line">11</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>计算机-编程基础</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月06日 计算机_编程基础2</title>
    <url>/exam//1cc5a5a2/</url>
    <content><![CDATA[<h1 id="考点1-左移运算符"><a href="#考点1-左移运算符" class="headerlink" title="考点1:左移运算符"></a>考点1:左移运算符</h1><p>代码<code>int i=3;i&lt;&lt;=4;</code>i的值等于多少？()</p>
<ul>
<li>A 40</li>
<li>B 110000(二进制)</li>
<li>C 12</li>
<li>D -48</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p><code>&lt;&lt;</code>是左移运算符的意思，左移运算符是用来将一个数的各二进制位全部左移若干位。<br>这里可以理解为把3化为2进制，然后统一左移4位。</p>
<p>比如3的二进制  <code>0000 0011</code>  左移4位 <code>0011 0000</code> &#x3D; 48</p>
<h1 id="考点2-循环条件"><a href="#考点2-循环条件" class="headerlink" title="考点2:循环条件"></a>考点2:循环条件</h1><p>下面的程序中, <code>int32_t</code>表示一个有符号的 32 位整数,程序的入口是 main 函数,问最终 res 的结果是多少？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int32_t f(int32_t a,int32_t b)&#123;</span><br><span class="line">    while(a+b&gt;0)&#123;</span><br><span class="line">        a=a+1;</span><br><span class="line">        b=b-1;</span><br><span class="line">    &#125;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line">int32_t main()&#123;</span><br><span class="line">    int32_t res=f(1,0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A <code>–(2^31+2^30+…+2^2+2^1+2^0)</code></li>
<li>B <code>0</code></li>
<li>C <code>-1</code></li>
<li>D <code>程序会死循环</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<h1 id="考点3-C语言指针-内存图"><a href="#考点3-C语言指针-内存图" class="headerlink" title="考点3:C语言指针 内存图"></a>考点3:C语言指针 内存图</h1><p>下列代码段将打印出 ().</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">2</span>,*p1,**p2;</span><br><span class="line">    p2=&amp;p1;</span><br><span class="line">    p1=&amp;a;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,a,*p1,**p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 3,2,3</li>
<li>B 2,2,2</li>
<li>C 3,3,3</li>
<li>D 3,3,2</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>首先经过a++，a变成了3；<br>p1是指向a的地址的，因此<code>*p1</code>就是a的值，即为3；<br>p2是指向p1的地址的，因此<code>*p2</code>就是p1的值，即a的地址，那么<code>**p2</code>就是a的值，也就是3</p>
<h1 id="考点4-自增运算"><a href="#考点4-自增运算" class="headerlink" title="考点4:自增运算"></a>考点4:自增运算</h1><p><code>i=2,(i++)/3</code>的结果是()</p>
<ul>
<li>A 0</li>
<li>B 2</li>
<li>C 0.67</li>
<li>D 1</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h3 id="后-先取值，再加一"><a href="#后-先取值，再加一" class="headerlink" title="后++,先取值，再加一"></a>后++,先取值，再加一</h3><p>因为i++操作是在i&#x2F;3完成之后，再对i进行加1操作的，所以结果是2&#x2F;3，又因为2个int型相除，所以结果是0；</p>
<p>验证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, b = (i++) / <span class="number">3</span>;</span><br><span class="line">System.out.println(i);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h1 id="考点5-重载要求：参数列表不同"><a href="#考点5-重载要求：参数列表不同" class="headerlink" title="考点5:重载要求：参数列表不同"></a>考点5:重载要求：参数列表不同</h1><p>下面哪个方法是 <code>public void  example()&#123;...&#125;</code> 的重载方法？ ( )</p>
<ul>
<li>A <code>public void Example( int m)&#123;...&#125;</code></li>
<li>B <code>public int example()&#123;...&#125;</code></li>
<li>C <code>public void example2()&#123;...&#125;</code></li>
<li>D <code>public int example ( int m, float f)&#123;...&#125;</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h3 id="两同一不同"><a href="#两同一不同" class="headerlink" title="两同一不同"></a>两同一不同</h3><ul>
<li>在同一个类中</li>
<li>方法名相同</li>
<li>参数列表不同<ul>
<li>参数类型不同</li>
<li>参数位置不同</li>
<li>参数个数不同</li>
</ul>
</li>
</ul>
<h1 id="考点6-二进制的表示范围"><a href="#考点6-二进制的表示范围" class="headerlink" title="考点6:二进制的表示范围"></a>考点6:二进制的表示范围</h1><p>中国人口数量在10亿～20亿,如果用二进制记录人口数量,则至少需要_____位的长度。</p>
<ul>
<li>A 30</li>
<li>B 31</li>
<li>C 33</li>
<li>D 63</li>
<li>E 64</li>
<li>F 65</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>$2^{32}&#x3D;42 9496 7295$约等于42亿<br>$2^{31}&#x3D;21 4748 3647$约等于21亿</p>
<p>10个亿就是1 000 000 000<br>20个亿就是2 000 000 000<br>要求：「如果用二进制记录人口数量，则至少需要_____位的长度」<br>给出的四个选项中<br>A.$2^{30}&#x3D;10 7374 1824$ 满足了10个亿但是显然不满足20亿<br>B.$2^{31}&#x3D;21 4748 3648$ 满足20个亿完全符合题意。所以选B</p>
<p>C.D.E.F嫌大</p>
<h1 id="考点7-计算机的存储系统一般指"><a href="#考点7-计算机的存储系统一般指" class="headerlink" title="考点7:计算机的存储系统一般指"></a>考点7:计算机的存储系统一般指</h1><p>计算机的存储系统一般指(   )</p>
<ul>
<li>A <code>ROM</code></li>
<li>B 内存(主存)</li>
<li>C <code>RAM</code></li>
<li>D 外存(辅存)</li>
<li>E 控制器</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BD</details>

<p>内存：包括随机存储器（RAM），只读存储器（ROM），以及高速缓存（CACHE）。<br>外存：磁盘、光盘、固态存储器等等。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>计算机-编程基础</category>
      </categories>
  </entry>
  <entry>
    <title>2019年10月31日 计算机网络 1</title>
    <url>/exam//3fcd8c5a/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>ARP 的功能是将IP地址解析为MAC地址。</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>ARP 协议（Address Resolution Protocol），或称地址解析协议。在以太网链路上仅仅知道某台主机的IP address，并不能立即将封包传送过去，必须先查明该主机的实体地址(Physical address&#x2F;MAC address)才能真正发送出去，而ARP协议的功用就是在于将IP address转换成实体地址，查询目标设备的MAC地址，以保证通信的顺利进行。</p>
<p>并且只能在区域网路内使用，解析网路装置的MAC位址，ARP是TCP&#x2F;IP设计者利用乙太网的广播性质，设计出来的位址解释协定；它的主要特性和优点是它的位址对应关系是动态的，它以查询的方式来获得IP位址和实体位</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>OSI七层模型中,物理层，数据链路层，网络层，传输层的单位是什么（）</p>
<ul>
<li>A 帧frame，包packet，段segment，比特bit</li>
<li>B 比特bit，帧frame，包packet，段segment</li>
<li>C 帧frame，比特bit，段segment，包packet</li>
<li>D 比特bit，包packet，帧frame，段segment</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>比特成帧，帧成报文，报文成包，包成段</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>The lower layers of the OSI model are in correct order ( )</p>
<ul>
<li>A physical,system,network,logical</li>
<li>B physical,logical,network,system</li>
<li>C physical,transport,network,datalink</li>
<li>D physical,datalink,network,transport</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>从下往上是：物理层，数据链路层，网络层，传输层</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>在 OSI 参考模型的物理层、数据链路层、网络层传送的数据单位分别为 （）。</p>
<ul>
<li>A 比特、帧、分组</li>
<li>B 比特、分组、帧</li>
<li>C 帧、分组、比特</li>
<li>D 分组、比特、帧</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>承载信息量的基本信号单位是 （） 。</p>
<ul>
<li>A 码元</li>
<li>B 比特</li>
<li>C 数据传输速率</li>
<li>D 误码率</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>帧中继网是一种（ ）。</p>
<ul>
<li>A 广域网</li>
<li>B 局域网</li>
<li>C ATM网</li>
<li>D 以太网</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>几种常用的广域网：<br>公用电话交换网（ P S T N）、<br>分组交换网（X . 2 5）、<br>数字数据网（ D D N）、<br>帧中继（ F R）、<br>交换式多兆位数据服务（ S M D S）和<br>异步传输模式（AT M）。</p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>在TCP&#x2F;IP模型中，数据从应用层到网际接口层所经历的传输格式分别是(    )。</p>
<ul>
<li>A 报文或字节流—&gt;IP数据报—&gt;网络帧—&gt;传输协议分组</li>
<li>B 报文或字节流—&gt;传输协议分组—&gt;IP数据报—&gt;网络帧</li>
<li>C 传输协议分组—&gt;IP数据报—&gt;网络帧—&gt;报文或字节流</li>
<li>D IP数据报—&gt;报文或字节流—&gt;网络帧—&gt;传输协议分组</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>OSI:<br>物理层——比特流<br>数据链路层——帧<br>网络层——包<br>传输层——段&#x2F;消息<br>表示层——字符或字<br>应用层——程序<br>TCP&#x2F;IP为四层模型<br>应用层：报文<br>运输层：传输层协议<br>网际层：数据报<br>网络接口层：网络帧</p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>下列地址中哪些是私有地址</p>
<ul>
<li>A 172.32.0.1</li>
<li>B 172.0.0.1</li>
<li>C 172.16.0.255</li>
<li>D 172.15.255.255</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>私有地址如下：<br>A类：10.0.0.0到10.255.255.255<br>B类：172.16.0.0到172.31.255.255<br>C类：192.168.0.0到192.168.255.255</p>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>在某办公室内铺设一个小型局域网,总共有4台PC机需要通过一台集线器连接起来。采用的线缆类型为5类双绞线。则理论上任意两台PC机的最大间隔距离是()</p>
<ul>
<li>A 400米</li>
<li>B 100米</li>
<li>C 200米</li>
<li>D 500米</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>5类双绞线的最大传输距离为100，意思是两个节点之间的总距离应该在100以内，否则传输就会造成损耗。所以集线器节点-集线器-节点距离应为100米，集线器只是将线缆汇集的一个中心。</p>
<h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>以下请求是一个订单提交的请求，请观察该请求包，说出你认为可能存在的安全风险点（）：<br>POST <a href="http://test.mi.cn/insert.html">http://test.mi.cn/insert.html</a> HTTP&#x2F;1.1<br>Host: test.mi.com<br>Referer: <a href="http://test.mi.cn/index.php?data=58">http://test.mi.cn/index.php?data=58</a><br>Cookie: uid&#x3D;1504174654; </p>
<p>addressid&#x3D;1&amp;productid&#x3D;123&amp;num&#x3D;1&amp;price&#x3D;120</p>
<ul>
<li>A CSRF</li>
<li>B 订单金额篡改</li>
<li>C 越权操作</li>
<li>D SQL 注入</li>
</ul>
<p>正确答案: ABCD</p>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><p>看不到这题什么意思</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月7日 计算机网络1</title>
    <url>/exam//3a826652/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>Internet中地理域名中国的缩写是（        ）</p>
<ul>
<li>A ch</li>
<li>B cn</li>
<li>C china</li>
<li>D chi</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>在 OSI 分层模型中，把传输的比特流划分为帧，是哪一层的功能（ ）</p>
<ul>
<li>A 物理层</li>
<li>B 网络层</li>
<li>C 数据链路层</li>
<li>D 传输层</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><table>
<thead>
<tr>
<th align="left">层次</th>
<th align="left">传输数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">传输层</td>
<td align="left">片段</td>
</tr>
<tr>
<td align="left">网络层</td>
<td align="left">包</td>
</tr>
<tr>
<td align="left">数据链路层</td>
<td align="left">帧</td>
</tr>
<tr>
<td align="left">物理层</td>
<td align="left">比特</td>
</tr>
</tbody></table>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>正确的 IP 地址是 (  ) 。</p>
<ul>
<li>A 202.112.111.1</li>
<li>B 202.2.2.2.2</li>
<li>C 202.202.1</li>
<li>D 202.257.14.13</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>每个IP地址分为4段，段与段之间用小数点隔开，每段再用一个十进制整数表示，每个十进制整数的取值范围是0-255。故正确答案为A。</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>HTML语言是一种(    )</p>
<ul>
<li>A 标注语言</li>
<li>B 机器语言</li>
<li>C 汇编语言</li>
<li>D 算法语言</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>HTML 指的是超文本标记语言 (Hyper Text Markup Language)<br>HTML 不是一种编程语言，而是一种标记语言 (markup language)<br>标记语言是一套标记标签 (markup tag)<br>HTML 使用标记标签来描述网页</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p><img data-src="https://uploadfiles.nowcoder.com/images/20180504/7366756_1525400408051_C312F56A2A650D1C2E64A70165833D39" alt="图片"><br>在OSI参考模型中，路由器R1、交换机Switch、集线器Hub实现的最高功能层分别是 。</p>
<ul>
<li>A 2、2、1</li>
<li>B 2、2、2</li>
<li>C 3、2、1</li>
<li>D 3、2、2</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>OSI参考模型中各层如下：</p>
<table>
<thead>
<tr>
<th align="left">层次</th>
<th align="left">名称</th>
</tr>
</thead>
<tbody><tr>
<td align="left">7</td>
<td align="left">应用层</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">表示层</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">会话层</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">传输层</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">网络层</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">数据链路层</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">物理层</td>
</tr>
</tbody></table>
<p><strong>集线器</strong>是一个多端口的中继器，工作在<strong>物理层</strong>。<br><strong>以太网交换机</strong>是一个多端口的网桥，工作在<strong>数据链路层</strong>。<br><strong>路由器</strong>是网络层设备，它实现了网络模型的下三层，即<strong>物理层、数据链路层和网络层</strong>。</p>
<p>题中R1、Switch和Hub分别是路由器、交换机和集线器，实现的<strong>最高层</strong>功能分别是网络层（即3）、数据链路层（即2）和物理层（即1）。</p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>在整个网络的设计中，对功能、可靠性和费用方面有着重要影响的因素是( )</p>
<ul>
<li>A 误码率</li>
<li>B 拓扑结构</li>
<li>C 网络距离</li>
<li>D 网络传输速率</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>拓扑结构是指网络中各个站点相互连接的形式，在局域网中明确一点讲就是文件服务器、工作站和电缆等的连接形式。<br>络的拓扑结构反映出网中各实体的结构关系，是建设<strong>计算机网络的第一步</strong>，是实现各种网络协议的基础，它对网络的性能，系统的可靠性与通信费用都有重大影响。</p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>ADSL技术主要解决的问题是（  ）</p>
<ul>
<li>A 宽带传输</li>
<li>B 宽带接入</li>
<li>C 宽带交换</li>
<li>D 多媒体技术</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>一个5960字节的数据报（其中20字节IP首部加上5940字节的IP有效载荷）到达一台路由器，并且必须被转发到一条MTU为1500字节的链路上，并且原始数据报附加的标识号为587，试问此数据报被分的片数、第二分片的标识号和第四分片的标志位分别为（ ）</p>
<ul>
<li>A 4、587、0</li>
<li>B 5、587、1</li>
<li>C 4、588、1</li>
<li>D 5、588、0</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><h3 id="分片计算方法"><a href="#分片计算方法" class="headerlink" title="分片计算方法"></a>分片计算方法</h3><p>每个分片都需要有IP首部，MTU&#x3D;1500，ip首部长度为20，则每个分片的数据的最大长度为1480<br>第一分片：20+1480；<br>第二分片：20+1480；<br>第三分片：20+1480；<br>第四分片：20+1480；<br>第五分片：20+20；<br>5940&#x2F;1480＝4.0135135135135<br> 4.0135135135135向上取整等于5，所以五个分片</p>
<h3 id="确定标识号"><a href="#确定标识号" class="headerlink" title="确定标识号"></a>确定标识号</h3><p>相同的标识号使得分片后的数据报片能正确的重装成原来的数据报；所有分片的标识号都应该一样，都和第一条分片的标识号587相同</p>
<h3 id="确定MF"><a href="#确定MF" class="headerlink" title="确定MF"></a>确定MF</h3><p>标志位的最低位MF&#x3D;1表示后面还有分片。<br>总共有5个分片，第4个分片的MF为1，<br>第5个分片MF为0</p>
<h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>在公司局域网上ping <a href="http://www.bilibili.com/">www.bilibili.com</a> 没有涉及到的网络协议是？（）</p>
<ul>
<li>A TCP</li>
<li>B DNS</li>
<li>C ICMP</li>
<li>D ARP</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>ping 使用的协议为icmp，通过域名解析，需要用到DNS，局域网中使用arp进行主机间的通信。</p>
<p>TCP层是位于IP层之上,应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>2021年10月04日 设计模式</title>
    <url>/exam//d98c5bee/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1:"></a>考点1:</h1><p>对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用以下哪种设计模式最好？</p>
<ul>
<li>A 建造者模式</li>
<li>B 观察者模式</li>
<li>C 策略模式</li>
<li>D 代理模式</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>


<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2:"></a>考点2:</h1><p>如果需要一个语言解释执行，并且可以将语言中的句子表示为一个抽象语法树的时候，对效率要求不高的情况下，应该选择何种设计模式？</p>
<ul>
<li>A 解释器模式</li>
<li>B 动态代理模式</li>
<li>C 装饰模式</li>
<li>D 访问者模式</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3:"></a>考点3:</h1><p>如果强调一系列相关产品的接口，以便联合使用它们的时候，应该选择何种设计模式：</p>
<ul>
<li>A 模板方法模式</li>
<li>B 备忘录模式</li>
<li>C 抽象工厂模式</li>
<li>D 组合模式</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4:"></a>考点4:</h1><p>如果让你来实现前端的MVVM框架，View层需要支持不同终端的不同交互，下面哪些设计模式不太适合用来实现这个需求（）</p>
<ul>
<li>A 单例模式</li>
<li>B 观察者模式</li>
<li>C 适配器模式</li>
<li>D 代理模式</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5:"></a>考点5:</h1><p>下图的UML类结构图表示的是哪种设计模式？</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211004223947.png" alt="img"></p>
<ul>
<li>A 解释器模式</li>
<li>B 装饰模式</li>
<li>C 桥接模式</li>
<li>D 责任链模式</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6:"></a>考点6:</h1><p>下面的选项中哪些属于工厂模式()</p>
<ul>
<li>A 静态工厂模式</li>
<li>B 工厂方法模式</li>
<li>C 抽象工厂模式</li>
<li>D 简单工厂模式</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details>


<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7:"></a>考点7:</h1><p>下列描述中，哪些是外观模式的特点（      ）</p>
<ul>
<li>A 对客户端屏蔽了子系统组件</li>
<li>B 实现了子系统与客户端之间的紧耦合关系</li>
<li>C 单个子系统的修改不影响其他子系统</li>
<li>D 子系统类变化时，只需要修改外观类即可</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details>

<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8:"></a>考点8:</h1><p>以下设计模式的应用场景中，属于代理模式的选项有（）</p>
<ul>
<li>A 树形结构的遍历</li>
<li>B 产品簇创建场景</li>
<li>C 防火墙</li>
<li>D CopyOnWriteList</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: CD</details>


]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>NC101 缺失数字</title>
    <url>/exam//ea99b438/</url>
    <content><![CDATA[<h1 id="NC101-缺失数字"><a href="#NC101-缺失数字" class="headerlink" title="NC101 缺失数字"></a>NC101 缺失数字</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>位运算<br>数组<br>数学<br>二分</p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>从 0,1,2,…,n 这 n+1 个数中选择 n 个数，选择出的数字依然保持有序，找出这 n 个数中缺失的那个数，要求$O(n)$或 $O(log(n))$ 并尽可能小。</p>
<p>数据范围： $0\leq n \leq 10000$<br>要求： 空间复杂度 $O(1)$ ，时间复杂度 $O(n)$<br>进阶：空间复杂度 $O(1)$ ，时间复杂度 $O(logn)$</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0,1,2,3,4,5,7]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0,2,3]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0,1,2,3,4]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<p>关联企业:</p>
<p>字节跳动<br>华为<br>百度</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>编程题</category>
        <category>在线编程</category>
      </categories>
  </entry>
  <entry>
    <title>NC103 反转字符串_入门</title>
    <url>/exam//3a21477b/</url>
    <content><![CDATA[<h1 id="NC103-反转字符串"><a href="#NC103-反转字符串" class="headerlink" title="NC103 反转字符串"></a>NC103 反转字符串</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000）</p>
<p>数据范围： $0 \le n \le 10000≤n≤1000$<br>要求：空间复杂度 $O(n)$，时间复杂度 $O(n)$</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;abcd&quot;</span><br><span class="line">返回值：&quot;dcba&quot;</span><br></pre></td></tr></table></figure>
<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;&quot;</span><br><span class="line">返回值：&quot;&quot;</span><br></pre></td></tr></table></figure>
<h2 id="关联企业"><a href="#关联企业" class="headerlink" title="关联企业"></a>关联企业</h2><p>百度<br>微盟<br>携程<br>腾讯</p>
<h2 id="关联职位"><a href="#关联职位" class="headerlink" title="关联职位"></a>关联职位</h2><p>测试<br>研发<br>前端<br>算法</p>
<h1 id="我的题解"><a href="#我的题解" class="headerlink" title="我的题解"></a>我的题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">solve</span> <span class="params">(String str)</span> &#123;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str.length());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=str.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            sb.append(str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式2</span></span><br><span class="line"><span class="type">char</span>[] arr=str.toCharArray();</span><br><span class="line"><span class="type">char</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">    temp=arr[i];</span><br><span class="line">    arr[i]=arr[arr.length-<span class="number">1</span>-i];</span><br><span class="line">    arr[arr.length-<span class="number">1</span>-i]=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式3：使用亦或进行交换</span></span><br><span class="line"><span class="comment">// a^=b;</span></span><br><span class="line"><span class="comment">// b^=a;</span></span><br><span class="line"><span class="comment">// a^=b;</span></span><br><span class="line"><span class="type">char</span>[] arr=str.toCharArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">    arr[i]^=arr[arr.length-<span class="number">1</span>-i];</span><br><span class="line">    arr[arr.length-<span class="number">1</span>-i]^=arr[i];</span><br><span class="line">    arr[i]^=arr[arr.length-<span class="number">1</span>-i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式4：使用valueOf(char[])方法返回字符串</span></span><br><span class="line"><span class="type">char</span>[] arr=str.toCharArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">    arr[i]^=arr[arr.length-<span class="number">1</span>-i];</span><br><span class="line">    arr[arr.length-<span class="number">1</span>-i]^=arr[i];</span><br><span class="line">    arr[i]^=arr[arr.length-<span class="number">1</span>-i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> String.valueOf(arr);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式5：库函数实现</span></span><br><span class="line">StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str.length());</span><br><span class="line">sb.append(str);</span><br><span class="line"><span class="keyword">return</span> sb.reverse().toString();</span><br></pre></td></tr></table></figure>
<p>方式5：库函数实现2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str).reverse().toString();</span><br></pre></td></tr></table></figure>

<h1 id="官方-精华题解"><a href="#官方-精华题解" class="headerlink" title="官方 精华题解"></a>官方 精华题解</h1><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p><a href="https://www.nowcoder.com/practice/c3a6afee325e472386a1c4eb1ef987f3?tab=note">https://www.nowcoder.com/practice/c3a6afee325e472386a1c4eb1ef987f3?tab=note</a></p>
<!-- <video src='https://uploadfiles.nowcoder.com/files/20210122/993000_1611283786722/nc103%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.mp4' 
       type='video/mp4'
       controls='controls' 
       preload="auto" 
       width='100%' 
       height='100%'>
</video> -->

<p>&lt;video src&#x3D;’<a href="https://uploadfiles.nowcoder.com/files/20210122/993000_1611283786722/nc103%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.mp4&#39;">https://uploadfiles.nowcoder.com/files/20210122/993000_1611283786722/nc103%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.mp4&#39;</a> type&#x3D;’video&#x2F;mp4’controls&#x3D;’controls’ preload&#x3D;”auto” width&#x3D;’100%’ height&#x3D;’100%’&gt;</video></p>
<!-- https://uploadfiles.nowcoder.com/files/20210122/993000_1611283786722/nc103%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.mp4 -->

<h2 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一:"></a>解法一:</h3><p>开辟一个和str长度大小相同的一个字符串ans，把传入的str倒序赋值到ans字符串上， 时间复杂度$O(n)$,额外空间复杂度$O(n)$。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">solve</span> <span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ans = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len ;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                ans[i] = str.charAt(len-<span class="number">1</span>-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二:"></a>解法二:</h3><p>原地交换，<img data-src="https://www.nowcoder.com/equation?tex=str%5Bi%5D%20=%20str%5Blen-1-i%5D&preview=true" alt="img">,注意：交换进行的次数是<img data-src="https://www.nowcoder.com/equation?tex=len/2&preview=true" alt="img">次</p>
<p>时间复杂度<img data-src="https://www.nowcoder.com/equation?tex=O(n)&preview=true" alt="img">,额外空间复杂度<img data-src="https://www.nowcoder.com/equation?tex=O(1)&preview=true" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">solve</span> <span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cstr = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt; len/<span class="number">2</span> ;i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> cstr[i];</span><br><span class="line">            cstr[i] = cstr[len-<span class="number">1</span>-i];</span><br><span class="line">            cstr[len-<span class="number">1</span>-i]=t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(cstr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三"><a href="#解法三" class="headerlink" title="解法三:"></a>解法三:</h3><p>直接调用库函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">solve</span> <span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);<span class="comment">//此方法针对的是io流，不能针对字符串。</span></span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>编程题</category>
        <category>在线编程</category>
      </categories>
  </entry>
  <entry>
    <title>NC110 旋转数组</title>
    <url>/exam//78543362/</url>
    <content><![CDATA[<h1 id="NC110-旋转数组"><a href="#NC110-旋转数组" class="headerlink" title="NC110 旋转数组"></a>NC110 旋转数组</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>一个数组A中存有 n 个整数，在不允许使用另外数组的前提下，将每个整数循环向右移 $M$（ $M&gt;&#x3D;0$）个位置，即将A中的数据由<br>$$<br>A_0 , A_1, \cdots , A_{N-1}<br>$$</p>
<p>变换为<br>$$<br>A_{N-M},\cdots,A_{N-1},A_0,A_1,\cdots ,A_{N-M-1}<br>$$</p>
<p>（最后 M 个数循环移至最前面的 M 个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p>
<p>数据范围：$0&lt;n \leq 10$，$0 \leq m \leq 1000$<br>进阶：空间复杂度 $O(1)$，时间复杂度 $O(n)$</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6,2,[1,2,3,4,5,6]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[5,6,1,2,3,4]</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4,0,[1,2,3,4]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2,3,4]</span><br></pre></td></tr></table></figure>

<h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1&lt;=N&lt;=100,M&gt;=0)</span><br></pre></td></tr></table></figure>
<h1 id="我的题解"><a href="#我的题解" class="headerlink" title="我的题解"></a>我的题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 旋转数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 数组长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m int整型 右移距离</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a int整型一维数组 给定数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] solve (<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span>[] a) &#123;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="comment">// 每次循环可以把数组最后一个元素循环移动到数组的第一个元素</span></span><br><span class="line">        <span class="comment">// 循环m次即可把数组循环右移m个位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="comment">// 缓存最后一个元素</span></span><br><span class="line">            temp = a[a.length - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 从后向前遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">// 把前一格元素移动到后一格</span></span><br><span class="line">                a[i] = a[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把最后一个元素放到第一格</span></span><br><span class="line">            a[<span class="number">0</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据题目可以值n就是数组的长度，所以可以把上面的a.length替换成n：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 旋转数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 数组长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m int整型 右移距离</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a int整型一维数组 给定数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] solve (<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span>[] a) &#123;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="comment">// 缓存最后一个元素</span></span><br><span class="line">            temp = a[n - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 从后向前遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">// 把前一格元素移动到后一格</span></span><br><span class="line">                a[i] = a[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把最后一个元素放到第一格</span></span><br><span class="line">            a[<span class="number">0</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="大神题解"><a href="#大神题解" class="headerlink" title="大神题解"></a>大神题解</h1><p>三次翻转<br>假设 n&#x3D;7且 k&#x3D;3</p>
<table>
<thead>
<tr>
<th align="left">描述</th>
<th align="left">数组状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">原始数组</td>
<td align="left">1 2 3 4 5 6 7</td>
</tr>
<tr>
<td align="left">反转所有数字后</td>
<td align="left">7 6 5 4 3 2 1</td>
</tr>
<tr>
<td align="left">反转前 k&#x3D;3 个数字后</td>
<td align="left">5 6 7_4 3 2 1</td>
</tr>
<tr>
<td align="left">反转后 n-k&#x3D;4 个数字后</td>
<td align="left">5 6 7_1 2 3 4 –&gt; 结果</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] solve (<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span>[] a) &#123;</span><br><span class="line">        <span class="type">int</span> k=m%n;</span><br><span class="line">        reverse(a,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">        reverse(a,<span class="number">0</span>,k-<span class="number">1</span>);</span><br><span class="line">        reverse(a,k,n-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start&lt;end)&#123;</span><br><span class="line">            <span class="type">int</span> temp=a[start];</span><br><span class="line">            a[start]=a[end];</span><br><span class="line">            a[end]=temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组翻转"><a href="#数组翻转" class="headerlink" title="数组翻转"></a>数组翻转</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/e19927a8fd5d477794dac67096862042?answerType=1&amp;f=discussion">https://www.nowcoder.com/questionTerminal/e19927a8fd5d477794dac67096862042?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p> 该方法基于如下的事实：将数组的元素向右移动 k 次后，尾部 m mod n 个元素会移动至数组头部，其余元素向后移动 m mod n 个位置。<br> 该方法为数组的翻转：翻转算法参考 反转链表中的双指针方法 <a href="https://blog.nowcoder.net/n/d259b250747b4085bc7975f102d248c4">https://blog.nowcoder.net/n/d259b250747b4085bc7975f102d248c4</a></p>
<p>  1、可以先将所有元素翻转，这样尾部的 m mod n 个元素就被移至数组头部， </p>
<p>  2、然后再翻转 [0,m mod n−1] 区间的元素 </p>
<p>  3、 最后翻转[m mod n,n−1] 区间的元素即能得到最后的答案。 </p>
<p><strong>实例：</strong><br> 以 n&#x3D;7，m&#x3D;3 为例进行如下展示：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>原始数据</td>
<td>【1，2，3，4，5，6，7】</td>
</tr>
<tr>
<td>翻转所有元素</td>
<td>【7，6，5，4，3，2，1】</td>
</tr>
<tr>
<td>翻转 [0,m mod n −1] 区间的元素</td>
<td>【5，6，7，4，3，2，1】</td>
</tr>
<tr>
<td>翻转 [m mod n, n −1] 区间的元素</td>
<td>【5，6，7，1，2，3，4】</td>
</tr>
</tbody></table>
<p> 最后返回：【5，6，7，1，2，3，4】</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(N)，其中 N 为数组的长度。每个元素被翻转两次，一共 N 个元素，因此总时间复杂度为 O(2N)&#x3D;O(N)。<br>空间复杂度：O(1)。使用常数级空间变量</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>编程题</category>
        <category>在线编程</category>
      </categories>
  </entry>
  <entry>
    <title>NC141 判断回文</title>
    <url>/exam//291b0db9/</url>
    <content><![CDATA[<h1 id="NC141-判断回文-入门"><a href="#NC141-判断回文-入门" class="headerlink" title="NC141 判断回文_入门"></a>NC141 判断回文_入门</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个长度为 n 的字符串，请编写一个函数判断该字符串是否回文。如果是回文请返回true，否则返回false。</p>
<p>字符串回文指该字符串正序与其逆序逐字符一致。</p>
<p>数据范围：$0&lt;n \leq 1000000$</p>
<p>要求：空间复杂度 $O(1)$，时间复杂度 $O(n)$</p>
<h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：”absba”<br>返回值：true</p>
<h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：”ranko”<br>返回值：false</p>
<h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><p>输入：”yamatomaya”<br>返回值：false</p>
<h3 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h3><p>输入：”a”<br>返回值：true</p>
<h3 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h3><p>字符串长度不大于1000000，且仅由小写字母组成</p>
<h3 id="关联企业"><a href="#关联企业" class="headerlink" title="关联企业"></a>关联企业</h3><p>腾讯<br>阿里巴巴<br>字节跳动</p>
<h3 id="关联职位"><a href="#关联职位" class="headerlink" title="关联职位"></a>关联职位</h3><p>算法<br>研发<br>测试<br>前端</p>
<h1 id="我的解析"><a href="#我的解析" class="headerlink" title="我的解析"></a>我的解析</h1><h2 id="翻转还相等，则是回文"><a href="#翻转还相等，则是回文" class="headerlink" title="翻转还相等，则是回文"></a>翻转还相等，则是回文</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str string字符串 待判断的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judge</span> <span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 如果翻转字符串之后，还是和原来的字符串相等，则是回文数</span></span><br><span class="line">        <span class="keyword">return</span> str.equals(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str).reverse().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历判断是否对称：使用单指针"><a href="#遍历判断是否对称：使用单指针" class="headerlink" title="遍历判断是否对称：使用单指针"></a>遍历判断是否对称：使用单指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str string字符串 待判断的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judge</span> <span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,length=str.length();i&lt;=length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)!=str.charAt(length-<span class="number">1</span>-i))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历判断是否对称：使用双指针"><a href="#遍历判断是否对称：使用双指针" class="headerlink" title="遍历判断是否对称：使用双指针"></a>遍历判断是否对称：使用双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str string字符串 待判断的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judge</span> <span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=str.length()-<span class="number">1</span>;i&lt;=j;i++,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)!=str.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>编程题</category>
        <category>在线编程</category>
      </categories>
  </entry>
  <entry>
    <title>NC151 最大公约数</title>
    <url>/exam//35f7a35/</url>
    <content><![CDATA[<h1 id="NC151-最大公约数"><a href="#NC151-最大公约数" class="headerlink" title="NC151 最大公约数"></a>NC151 最大公约数</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>如果有一个自然数 a 能被自然数 b 整除，则称 a 为 b 的倍数， b 为 a 的约数。几个自然数公有的约数，叫做这几个自然数的公约数。公约数中最大的一个公约数，称为这几个自然数的最大公约数。</p>
<p>输入 a 和 b , 请返回 a 和 b 的最大公约数。</p>
<p>数据范围：$1\leq a,b\leq10^9$</p>
<p>进阶：空间复杂度 $O(1)$，时间复杂度$O(logn)$</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3,6</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8,12</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h2><p>a和b的范围是[1-109]</p>
<p>关联企业</p>
<h1 id="我的解析"><a href="#我的解析" class="headerlink" title="我的解析"></a>我的解析</h1><h2 id="使用辗转相除法"><a href="#使用辗转相除法" class="headerlink" title="使用辗转相除法"></a>使用辗转相除法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 求出a、b的最大公约数。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> a int </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> b int </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="comment">// 辗转相除法求最大公约数</span></span><br><span class="line">        <span class="comment">// 保证a&gt;=b</span></span><br><span class="line">        <span class="keyword">if</span>(a&lt;b)&#123;</span><br><span class="line">            a^=b;</span><br><span class="line">            b^=a;</span><br><span class="line">            a^=b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求余数</span></span><br><span class="line">        <span class="type">int</span> yushu=a%b;</span><br><span class="line">        <span class="comment">// 如果余数为0,那么商就是最大公约数</span></span><br><span class="line">        <span class="keyword">if</span>(yushu==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 转换成求商和余数的最大公约数</span></span><br><span class="line">            <span class="keyword">return</span> gcd(b,yushu);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用辗转相减法"><a href="#使用辗转相减法" class="headerlink" title="使用辗转相减法"></a>使用辗转相减法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 求出a、b的最大公约数。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a int </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b int </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="comment">// 辗转相减法求最大公约数</span></span><br><span class="line">        <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">                a = a - b;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b = b - a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="精华题解"><a href="#精华题解" class="headerlink" title="精华题解"></a>精华题解</h1><h2 id="更相减损法"><a href="#更相减损法" class="headerlink" title="更相减损法"></a>更相减损法</h2><p>这个思想起源于我国古代的《九章算术》，它原本是为约分而设计的，但它适用于任何需要求最大公约数的场合。原文是这么描述的：“<strong>可半者半之，不可半者，副置分母、子之数，以少减多，更相减损，求其等也。以等数约之。</strong>”</p>
<p>翻译成白话将就是：</p>
<p>第一步：对于任意给定的两个正整数a、b，要求出他们的最大公约数，首先判断他们俩是否都是偶数（能被2整除），如果都是偶数则一直除以2约简，直至不能再被2整除:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(a%<span class="number">2</span>==<span class="number">0</span> &amp;&amp; b%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">    a = a/<span class="number">2</span>;</span><br><span class="line">    b = b/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步：如果不是，那么就执行下一步，即用较大的数减去较小的数，然后将所得的差值赋值给原先拥有较大值的那个变量，再拿这个变量与较小值的那个变量进行比较，继续用二者中较大的减去较小的，直到两个变量相等；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (a % b == <span class="number">0</span> || b % a == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a % b == <span class="number">0</span> ? b : a;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(a != b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">            a = a - b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b = b - a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(a%b==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="网络题解"><a href="#网络题解" class="headerlink" title="网络题解"></a>网络题解</h1><p><a href="https://www.cnblogs.com/HuangWj/p/11261870.html">https://www.cnblogs.com/HuangWj/p/11261870.html</a></p>
<p>大数减小数，直到两数相等时，即为最大公约数。</p>
<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 辗转相减法，递归实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GCD</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> GCD(a,b);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> GCD(b,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 辗转相减法，迭代实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GCD</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(a == b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) a -= b;</span><br><span class="line">        <span class="keyword">else</span> b -= a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文章2"><a href="#文章2" class="headerlink" title="文章2"></a>文章2</h2><p><a href="https://blog.csdn.net/Holmofy/article/details/76401074">https://blog.csdn.net/Holmofy/article/details/76401074</a></p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>编程题</category>
        <category>在线编程</category>
      </categories>
  </entry>
  <entry>
    <title>NC65 斐波那契数列_入门</title>
    <url>/exam//a9ceec98/</url>
    <content><![CDATA[<h1 id="NC65-斐波那契数列-入门"><a href="#NC65-斐波那契数列-入门" class="headerlink" title="NC65 斐波那契数列_入门"></a>NC65 斐波那契数列_入门</h1><p>知识点:数组</p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>大家都知道斐波那契数列，现在要求输入一个正整数 n ，请你<strong>输出斐波那契数列的第 n 项</strong>。</p>
<p>斐波那契数列是一个满足</p>
<p>$$fib(x)&#x3D;\begin{cases}<br>&amp;1\text{ } &amp;x&#x3D;1,2 \\<br>&amp;fib(x-1)+fib(x-2)\text{ } &amp;x&gt;2<br>\end{cases}$$</p>
<p>的数列</p>
<p>数据范围：$1 \leq n \leq 39$</p>
<p>要求：空间复杂度 $O(1)$，时间复杂度 $O(n)$ ，本题也有时间复杂度 $O(logn)$ 的解法</p>
<h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h3><p>一个正整数n</p>
<h3 id="返回值描述："><a href="#返回值描述：" class="headerlink" title="返回值描述："></a>返回值描述：</h3><p>输出一个正整数。</p>
<h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：4<br>返回值：3<br>说明：根据斐波那契数列的定义可知，fib(1)&#x3D;1,fib(2)&#x3D;1,fib(3)&#x3D;fib(3-1)+fib(3-2)&#x3D;2,fib(4)&#x3D;fib(4-1)+fib(4-2)&#x3D;3，所以答案为4。</p>
<h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：1<br>返回值：1</p>
<h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><p>输入：2<br>返回值：1</p>
<h3 id="关联企业"><a href="#关联企业" class="headerlink" title="关联企业"></a>关联企业</h3><p>作业帮 瓜子二手车 小米 美团 字节跳动</p>
<h3 id="关联职位"><a href="#关联职位" class="headerlink" title="关联职位"></a>关联职位</h3><p>前端 研发 算法 测试</p>
<h1 id="官方解析"><a href="#官方解析" class="headerlink" title="官方解析"></a>官方解析</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>此题是非常经典的入门题了。我记得第一次遇到此题是在课堂上，老师拿来讲“递归”的（哈哈哈）。同样的类型的题还有兔子繁殖的问题。大同小异。此题将用三个方法来解决，从入门到会做。<br>考察知识：递归，记忆化搜索，动态规划和动态规划的空间优化。<br>难度：一星</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><p>题目分析，斐波那契数列公式为：f[n] &#x3D; f[n-1] + f[n-2], 初始值f[0]&#x3D;0, f[1]&#x3D;1，目标求f[n]<br>看到公式很亲切，代码秒秒钟写完。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span> || n==<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>) + Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点，代码简单好写，缺点：慢，会超时<br><strong>时间复杂度</strong>：O(2^n)<br><strong>空间复杂度</strong>：递归栈的空间</p>
<h3 id="方法二：记忆化搜索"><a href="#方法二：记忆化搜索" class="headerlink" title="方法二：记忆化搜索"></a>方法二：记忆化搜索</h3><p>拿求f[5] 举例<br><img data-src="https://uploadfiles.nowcoder.com/images/20200331/284295_1585636370308_1946BA36B55EFC1A019C4017DE68D41D"></p>
<p>通过图会发现，方法一中，存在很多重复计算，因为为了改进，就把计算过的保存下来。<br>那么用什么保存呢？一般会想到map， 但是此处不用牛刀，此处用数组就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fib</span><span class="params">(<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; dp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span> || n==<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">if</span> (dp[n] != <span class="number">-1</span>) <span class="keyword">return</span> dp[n];</span><br><span class="line">    <span class="keyword">return</span> dp[n] = <span class="built_in">Fib</span>(n<span class="number">-1</span>) + <span class="built_in">Fib</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">45</span>, <span class="number">-1</span>)</span></span>; <span class="comment">// 因为答案都是&gt;=0 的， 所以初始为-1，表示没计算过</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Fib</span>(n, dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：$O(n)$， 没有重复的计算<br><strong>空间复杂度</strong>：$O(n)$ 和递归栈的空间</p>
<h3 id="方法三：动态规划"><a href="#方法三：动态规划" class="headerlink" title="方法三：动态规划"></a>方法三：动态规划</h3><p>虽然方法二可以解决此题了，但是如果想让空间继续优化，那就用动态规划，优化掉递归栈空间。<br>方法二是从上往下递归的然后再从下往上回溯的，最后回溯的时候来合并子树从而求得答案。<br>那么动态规划不同的是，不用递归的过程，直接从子树求得答案。过程是从下往上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：$O(n)$<br><strong>空间复杂度</strong>：$O(n)$</p>
<h3 id="继续优化"><a href="#继续优化" class="headerlink" title="继续优化"></a>继续优化</h3><p>发现计算f[5]的时候只用到了f[4]和f[3], 没有用到f[2]…f[0],所以保存f[2]..f[0]是浪费了空间。<br>只需要用3个变量即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>, c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">        c = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：$O(n)$<br><strong>空间复杂度</strong>：$O(1)$<br>完美！</p>
<h1 id="我的解析"><a href="#我的解析" class="headerlink" title="我的解析"></a>我的解析</h1><h2 id="递归实现："><a href="#递归实现：" class="headerlink" title="递归实现："></a>递归实现：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span> || n==<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>) + Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">45</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dp.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fib(n,dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span>[] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span>(dp[n]!=-<span class="number">1</span>) <span class="keyword">return</span> dp[n];</span><br><span class="line">        <span class="keyword">return</span> dp[n]=fib(n-<span class="number">1</span>,dp)+fib(n-<span class="number">2</span>,dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划法："><a href="#动态规划法：" class="headerlink" title="动态规划法："></a>动态规划法：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;=n;++i)&#123;</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">1</span>, c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>编程题</category>
        <category>在线编程</category>
      </categories>
  </entry>
  <entry>
    <title>2019年10月28日_java_1</title>
    <url>/exam//cbbb206b/</url>
    <content><![CDATA[<h1 id="考点1-Integer与int的区别"><a href="#考点1-Integer与int的区别" class="headerlink" title="考点1 Integer与int的区别"></a>考点1 Integer与int的区别</h1><p><code>Integer</code>与<code>int</code>的区别</p>
<ul>
<li><code>int</code>是<code>java</code>提供的8种原始数据类型之一</li>
<li><code>Integer</code>是<code>java</code>为<code>int</code>提供的封装类</li>
<li><code>int</code>的默认值为0</li>
<li><code>Integer</code>的默认值为<code>null</code></li>
</ul>
<h1 id="考点3-一维数组的初始化"><a href="#考点3-一维数组的初始化" class="headerlink" title="考点3 一维数组的初始化"></a>考点3 一维数组的初始化</h1><blockquote>
<p>只有在定义数组的同时执行数组初始化才支持使用简化的静态初始化。</p>
</blockquote>
<p>题目省略<br>定义一维数组的语句</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>Java一维数组有两种初始化方法<br>1、静态初始化<br><code>int array[] = new int[]&#123;1,2,3,4,5&#125;;</code><br>或者简写为：<br> <code>int array[] = &#123;1,2,3,4,5&#125;</code><br>需要注意的是，写成如下形式也是错误的<br> <code>int array[] = new int[5]&#123;1,2,3,4,5&#125;</code><br>2、动态初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> array[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">array[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">array[<span class="number">1</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>静态与动态初始化的区别就在于，前者是声明的时候就初始化，后者是先声明，再动态初始化。</p>
<p>声明的时候不能初始化容量,只有new的时候才可以。<br>也就是说</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>这种写法是错误的</p>
<h1 id="考点4-可以追加文件的IO流"><a href="#考点4-可以追加文件的IO流" class="headerlink" title="考点4 可以追加文件的IO流"></a>考点4 可以追加文件的IO流</h1><p>以下哪个I&#x2F;O类可以附加或更新文件</p>
<ul>
<li>A RandomAccessFile()</li>
<li>B OutputStream()</li>
<li>C DataOutputStream()</li>
<li>D None of the above</li>
</ul>
<p>正确答案:<details><summary>展开&#x2F;折叠</summary><br>A</details></p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><ul>
<li><code>OutputStream()</code>和<code>DataOutputStream()</code>类都需要实例化<code>FileOutputStream()</code>对象，并在参数里加<code>true</code>后才能对文件追加内容；</li>
<li>而<code>RandomAccessFile()</code>可以通过文件指针向文件末尾追加内容。</li>
</ul>
<h1 id="考点5-WebService"><a href="#考点5-WebService" class="headerlink" title="考点5 WebService"></a>考点5 WebService</h1><p>下面有关<code>WebService</code>的描述，错误的是？</p>
<ul>
<li><code>A WebService</code>是跨平台，跨语言的远程调用技术</li>
<li><code>B WebService</code>通信机制实质就是<code>JSON</code>数据交换</li>
<li><code>C WebService</code>采用了<code>SOAP</code>协议（简单对象协议）进行通信</li>
<li><code>D WSDL</code>是用于描述 <code>Web Services</code> 以及如何对它们进行访问</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><ul>
<li><code>Webservice</code>是跨平台，跨语言的远程调用技术;</li>
<li>它的通信机制实质就是<code>xml</code>数据交换;<ul>
<li><code>JSON</code>是轻量级的</li>
<li><code>XML</code>是重量级的。<code>XML</code>具有跨平台，适合大量解析数据，目前<code>webService</code>主流是<code>XML</code></li>
</ul>
</li>
<li>它采用了<code>soap</code>协议（简单对象协议）进行通信</li>
<li><code>WSDL</code> 指网络服务描述语言 (<code>Web Services Description Language</code>)。<code>WSDL</code> 是一种使用 <code>XML</code> 编写的文档。这种文档可描述某个 <code>Web service</code>。它可规定服务的位置，以及此服务提供的操作（或方法）</li>
</ul>
<h1 id="考点6-final修饰符"><a href="#考点6-final修饰符" class="headerlink" title="考点6 final修饰符"></a>考点6 final修饰符</h1><p>下列说法正确的是（）</p>
<ul>
<li><code>A final</code>是<code>java</code>中的修饰符，可以修饰类、接口、抽象类、方法和属性</li>
<li><code>B final</code>修饰的类肯定不能被继承</li>
<li><code>C final</code>修饰的方法不能被重载</li>
<li><code>D final</code>修饰的变量不允许被再次赋值</li>
</ul>
<details><summary>正确答案: </summary>
AC</details>


<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><ul>
<li><code>final</code>修饰的类不能被继承或者实现,抽象类用于给子类继承的，接口是用来给实现类实现的。<ul>
<li>所以<code>final</code>不可以修饰抽象类，不能修饰接口</li>
</ul>
</li>
<li><code>final</code>修饰的方法不能被子类重写，但是可以重载。</li>
<li><code>final</code>修饰的变量只能赋值一次</li>
</ul>
<h1 id="考点7-抽象"><a href="#考点7-抽象" class="headerlink" title="考点7 抽象"></a>考点7 抽象</h1><p>题目省略</p>
<ul>
<li>抽象类可以没有抽象方法，</li>
<li>但是包含抽象方法的类必须是抽象类。</li>
</ul>
<h1 id="考点8-面向对象三个基本特征"><a href="#考点8-面向对象三个基本特征" class="headerlink" title="考点8 面向对象三个基本特征"></a>考点8 面向对象三个基本特征</h1><p>判断题:<br>面向对象程序设计语言的三个基本特征是 <strong>封装</strong> 、 <strong>继承</strong> 、 <strong>多态</strong> 。</p>
<details><summary>答案</summary>
正确</details>

<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><ul>
<li>这里说的是 <code>三个</code> 基本特征。所以是封装，继承，多态。</li>
<li>如果说的是 <code>4个</code> 基本特征。就是封装，继承，多态，抽象。</li>
</ul>
<h1 id="考点10-异常处理"><a href="#考点10-异常处理" class="headerlink" title="考点10 异常处理"></a>考点10 异常处理</h1><p>判断题<br>捕获到的异常只能在当前方法中处理，不能在其他方法中处理</p>
<details><summary>答案</summary>
错误</details>

<details><summary>解析</summary>

<p><strong>捕获到的异常</strong> 不仅可以在当前方法中处理，还 <strong>可以将该异常抛给调用它的上一级方法来处理</strong> 。</p>
</details>

 
<h1 id="考点11-访问控制符"><a href="#考点11-访问控制符" class="headerlink" title="考点11 访问控制符"></a>考点11 访问控制符</h1><p>哪个修饰符可以使在一个类中定义的成员变量只能被同一包中的类访问？<br>正确答案: <strong>无修饰符</strong></p>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>展开/折叠</summary>

<p><strong>私有</strong> 只能在当前类内访问。<br><strong>默认</strong> 可以在当前类内，或者相同包内访问到<br><strong>保护</strong> 可以在当前类内，相同包内，子类访问到。<br><strong>公共</strong>,可以在任意地方访问到</details></p>
<h1 id="问题12-接口默认修饰符"><a href="#问题12-接口默认修饰符" class="headerlink" title="问题12 接口默认修饰符"></a>问题12 接口默认修饰符</h1><p>题目省略</p>
<details><summary>展开/折叠</summary>

<ul>
<li>接口中的变量默认是<code>public static final</code>修饰的，</li>
<li>接口中的方法默认是<code>public abstract</code>修饰的</details></li>
</ul>
<h1 id="考点13-运行时常量池"><a href="#考点13-运行时常量池" class="headerlink" title="考点13 运行时常量池"></a>考点13 运行时常量池</h1><p>关于运行时常量池，下列哪个说法是正确的</p>
<ul>
<li>A 运行时常量池大小受栈区大小的影响</li>
<li>B <strong>运行时常量池大小受方法区大小的影响</strong> </li>
<li>C <strong>存放了编译时期生成的各种字面量</strong> </li>
<li>D <strong>存放编译时期生成的符号引用</strong></li>
</ul>
<p>正确答案: BCD</p>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>运行时常量池（<code>Runtime Constant Pool</code>）是 <strong>方法区的<code>一部分</code><strong>。所以，</strong>运行时常量池受方法区大小的影响</strong>。<br><code>Class</code>文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池(<code>Constant Pool Table</code>）， <strong>常量池用于存放编译器生成的各种字面量和符号引用</strong> ，常量池中的内容将在<code>类加载后</code>存放到<code>方法区</code>的<code>运行时常量池</code>中。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年10月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年10月28日_java_2</title>
    <url>/exam//b08798a7/</url>
    <content><![CDATA[<h1 id="考点2-JVM参数"><a href="#考点2-JVM参数" class="headerlink" title="考点2 JVM参数"></a>考点2 JVM参数</h1><p>假如某个JAVA进程的JVM参数配置如下：<br><code>-Xms1G</code><br><code>-Xmx2G</code><br><code>-Xmn500M</code><br><code>-XX:MaxPermSize=64M</code><br><code>-XX:+UseConcMarkSweepGC</code><br><code>-XX:SurvivorRatio=3</code><br>请问eden区最终分配的大小是多少？</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p><code>-Xmx2G</code>：设置<code>JVM</code>最大可用内存为<code>2G</code>。<br><code>-Xms1G</code>：设置<code>JVM</code>促使内存为<code>1G</code>。此值可以设置与<code>-Xmx</code>相同，以避免每次垃圾回收完成后<code>JVM</code>重新分配内存。<br><code>-Xmn500M</code>：设置年轻代大小为<code>500M</code>。</p>
<p>整个<code>JVM</code>内存大小&#x3D;年轻代大小+年老代大小 + 持久代大小。</p>
<p>新生代中又会划分为 <code>Eden</code> 区，<code>from Survivor</code>区、<code>to Survivor</code> 区。</p>
<p>其中 <code>Eden</code> 和 <code>Survivor</code> 区的比例默认是 <code>8:1:1</code>，当然也支持参数调整<br><code>-XX:SurvivorRatio=3</code>的话就是<code>3:1:1</code>。</p>
<p>故该题为<code>500*(3/5)=300M</code>.</p>
<h1 id="考点3-多线程-多进程"><a href="#考点3-多线程-多进程" class="headerlink" title="考点3 多线程 多进程"></a>考点3 多线程 多进程</h1><p>关于多线程和多进程，下面描述正确的是（）：</p>
<ul>
<li>A 多进程里，子进程可获得父进程的所有堆和栈的数据；而线程会与同进程的其他线程共享数据，拥有自己的栈空间。</li>
<li>B 线程因为有自己的独立栈空间且共享数据，所有执行的开销相对较大，同时不利于资源管理和保护。</li>
<li>C 线程的通信速度更快，切换更快，因为他们在同一地址空间内。</li>
<li>D 一个线程可以属于多个进程。</li>
</ul>
<details><summary>正确答案:</summary>
AC</details>

<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>1、<strong>一个线程只能属于一个进程</strong> ，而一个进程可以有多个线程，但至少有一个线程（通常说的主线程）。<br>2、<strong>资源分配给进程</strong> ，同一进程的所有线程共享该进程的所有资源。<br>3、线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。<br>5、线程是指进程内的一个执行单元，也是进程内的可调度实体。<br>6、同一个进程下的多个线程之间可以共享数据，因此 <strong>开销较小</strong> 。</p>
<h1 id="考点4-基本类型占字节数"><a href="#考点4-基本类型占字节数" class="headerlink" title="考点4 基本类型占字节数"></a>考点4 基本类型占字节数</h1><p><code>java</code>有8种基本类型，请问<code>byte</code>、<code>int</code>、<code>long</code>、<code>char</code>、<code>float</code>、<code>double</code>、<code>boolean</code>各占多少个字节？</p>
<p>正确答案: <code>1 4 8 2 4 8 1</code></p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><table>
<thead>
<tr>
<th align="left">基本数据类型</th>
<th align="left">占用空间</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>byte</code></td>
<td align="left">占一个字节</td>
</tr>
<tr>
<td align="left"><code>short</code></td>
<td align="left">占两个字节</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left">占四个字节</td>
</tr>
<tr>
<td align="left"><code>long</code></td>
<td align="left">占八个字节</td>
</tr>
<tr>
<td align="left"><code>float</code></td>
<td align="left">占四个字节</td>
</tr>
<tr>
<td align="left"><code>double</code></td>
<td align="left">占八个字节</td>
</tr>
<tr>
<td align="left"><code>char</code></td>
<td align="left">占两个字节</td>
</tr>
<tr>
<td align="left"><code>boolean</code></td>
<td align="left">占一个字节</td>
</tr>
</tbody></table>
<h1 id="考点5-运算符优先级"><a href="#考点5-运算符优先级" class="headerlink" title="考点5 运算符优先级"></a>考点5 运算符优先级</h1><p>表达式<code>(short)10/10.2*2</code>运算后结果是什么类型？</p>
<ul>
<li>A short</li>
<li>B int</li>
<li>C double</li>
<li>D float</li>
</ul>
<details><summary>正确答案: </summary>
C</details>

<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><ul>
<li>强制类型转换运算符的优先级比算数运算符要高,所以先进行强制类型转换，也就是<code>(short)</code>只对最近的10有转换效果。</li>
<li>浮点数默认数据类型为double</li>
</ul>
<h1 id="考点6-导致线程中断或停止运行的情况"><a href="#考点6-导致线程中断或停止运行的情况" class="headerlink" title="考点6 导致线程中断或停止运行的情况"></a>考点6 导致线程中断或停止运行的情况</h1><p>下列哪些情况下会导致线程中断或停止运行（      ）</p>
<ul>
<li>A <code>InterruptedException</code>异常被捕获</li>
<li>B 线程调用了<code>wait</code>方法</li>
<li>C 当前线程创建了一个新的线程</li>
<li>D 高优先级线程进入就绪状态</li>
</ul>
<p>正确答案: AB</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>A选项正确，<code>Java</code>中一般通过<code>interrupt</code>方法中断线程<br>B选项正确，线程使用了<code>wait</code>方法，会强行打断当前操作，进入阻塞（暂停）状态，然后需要<code>notify</code>方法或<code>notifyAll</code>方法才能进入就绪状态<br>C选项错误，新创建的线程不会抢占时间片，只有等当前线程把时间片用完，其他线程才有资格拿到时间片去执行。<br>D选项错误，调度算法未必是剥夺式的，而准备就绪但是还没有获得<code>CPU</code>，它的权限更高只能说明它获得<code>CPU</code>被执行的几率更大而已</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年10月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年10月29日_java_2</title>
    <url>/exam//71094767/</url>
    <content><![CDATA[<h1 id="考点1-java程序命令文件名"><a href="#考点1-java程序命令文件名" class="headerlink" title="考点1 java程序命令文件名"></a>考点1 java程序命令文件名</h1><p>编译<code>java</code>程序的命令文件是( )</p>
<ul>
<li>A <code>java.exe</code></li>
<li>B <code>javac.exe</code></li>
<li>C <code>applet.exe</code></li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: B</details>

<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul>
<li><code>javac.exe</code>是编译功能<code>javaCompiler</code></li>
<li><code>java.exe</code>是执行程序，用于执行编译好的.<code>class</code>文件</li>
<li><code>javadoc.exe</code>用来制作<code>java</code>文档</li>
<li><code>jdb.exe</code>是<code>java</code>的调试器</li>
<li><code>javaprof.exe</code>是剖析工具</li>
</ul>
<h1 id="考点2-循环"><a href="#考点2-循环" class="headerlink" title="考点2 循环"></a>考点2 循环</h1><p>以下代码的循环次数是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(--i);</span><br><span class="line">            --i;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i != <span class="number">0</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 0</li>
<li>B 1</li>
<li>C 7</li>
<li>D 无限次</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: D</details>

<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>每次循环都是减去2，7-2n恒不等于0，所以循环一直持续下去</p>
<h1 id="考点3-C语言指针"><a href="#考点3-C语言指针" class="headerlink" title="考点3 C语言指针"></a>考点3 C语言指针</h1><p><code>int a[]= &#123;1,2,3,4,5&#125;</code>, <code>int *p = a</code>,  下列表达式与 <code>++*p</code> 相同的是（）</p>
<ul>
<li>A <code>*++p</code></li>
<li>B <code>a[0]</code></li>
<li>C <code>++a[0]</code></li>
<li>D <code>*p++</code></li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: C</details>

<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>为什么<code>java</code>的题中老是出现C语言的题<br><code>*p</code>指针指向第一位，也就是<code>a[0]</code>，<br><code>++*p</code>就是<code>++a[0]</code>。</p>
<h1 id="考点4-负数求余运算"><a href="#考点4-负数求余运算" class="headerlink" title="考点4 负数求余运算"></a>考点4 负数求余运算</h1><p>以下代码段执行后的输出结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> -<span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> -<span class="number">12</span>;</span><br><span class="line">        System.out.println(y % x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A -1</li>
<li>B 2</li>
<li>C 1</li>
<li>D -2</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: D</details>

<h2 id="解析-求余运算本质上是减法"><a href="#解析-求余运算本质上是减法" class="headerlink" title="解析 求余运算本质上是减法"></a>解析 求余运算本质上是减法</h2><ul>
<li><strong>求余（取模运算）结果与被除数符号相同</strong></li>
<li>取余模运算都属于除法，除法就可看作减法，-12-(-5)-(-5)</li>
</ul>
<h1 id="考点4-构造函数的正确格式"><a href="#考点4-构造函数的正确格式" class="headerlink" title="考点4 构造函数的正确格式"></a>考点4 构造函数的正确格式</h1><p>尝试编译以下程序会产生怎么样的结果？（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="keyword">var</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">long</span> param)</span> &#123; <span class="keyword">var</span> = param; &#125;<span class="comment">//(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyClass a, b;</span><br><span class="line">        a =<span class="keyword">new</span> <span class="title class_">MyClass</span>();<span class="comment">//(2)</span></span><br><span class="line">        b =<span class="keyword">new</span> <span class="title class_">MyClass</span>(<span class="number">5</span>);<span class="comment">//(3)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 编译错误将发生在（1），因为构造函数不能指定返回值</li>
<li>B 编译错误将发生在（2），因为该类没有默认构造函数</li>
<li>C 编译错误将在（3）处发生，因为该类没有构造函数，该构造函数接受一个int类型的参数</li>
<li>D 该程序将正确编译和执行</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: C</details>

<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>（1）处代码，虽然方法名和类名相同，不过由于void的修饰，所以它并不是一个构造方法，只是一个普通方法。<br>因此这个类仍然只有默认的无参构造器，所以(2)处代码正确<br>（3）处代码，没有带参数构造器 所以错误。</p>
<h1 id="考点5-静态成员和普通成员的执行顺序"><a href="#考点5-静态成员和普通成员的执行顺序" class="headerlink" title="考点5 静态成员和普通成员的执行顺序"></a>考点5 静态成员和普通成员的执行顺序</h1><p>以下代码执行后输出结果为（ ）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Test</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;blockA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;blockB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A blockAblockBblockA</li>
<li>B blockAblockAblockB</li>
<li>C blockBblockBblockA</li>
<li>D blockBblockAblockB</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: A</details>

<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><ul>
<li>静态块：用<code>static</code>申明，<code>JVM</code>加载类时执行，仅执行一次 </li>
<li>构造块：类中直接用{}定义，每一次创建对象时执行 </li>
<li>执行顺序优先级：静态块&gt;main()&gt;构造块&gt;构造方法 </li>
<li>静态块按照声明的顺序执行，先执行<code>public static Test t1 = new Test()</code>;所以先输出<code>blockA</code>，</li>
<li>然后执行静态块，输出<code>blockB</code>，</li>
<li>最后执行<code>main</code>方法中的<code>Test t2 = new Test()</code>;输出<code>blockA</code>。</li>
</ul>
<h1 id="考点6-String类的split方法"><a href="#考点6-String类的split方法" class="headerlink" title="考点6 String类的split方法"></a>考点6 String类的split方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">System.out.print(str.split(<span class="string">&quot;,&quot;</span>).length);</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<ul>
<li>A 0</li>
<li>B 1</li>
<li>C 出现异常</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: B</details>

<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>就是单纯的分片成列表，因为不含有’<code>,</code>‘,所以就成为<code>[&quot;&quot;]</code>这样的列表</p>
<h1 id="考点7-集合Collection接口子接口"><a href="#考点7-集合Collection接口子接口" class="headerlink" title="考点7 集合Collection接口子接口"></a>考点7 集合Collection接口子接口</h1><p>以下哪些继承自Collection接口（）</p>
<ul>
<li>A List</li>
<li>B Set</li>
<li>C Map</li>
<li>D Array</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: AB</details>

<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><h1 id="考点8-Java合法标识符"><a href="#考点8-Java合法标识符" class="headerlink" title="考点8 Java合法标识符"></a>考点8 Java合法标识符</h1><p>下列可作为java语言标识符的是（）</p>
<ul>
<li>A <code>a1</code></li>
<li>B <code>$1</code></li>
<li>C <code>_1</code></li>
<li>D <code>11</code></li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: ABC</details>

<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p><code>java</code>中标识符由</p>
<ul>
<li>字母，数字，下划线, 美元符组成</li>
<li>首位不能为数字</li>
<li><code>Java</code>关键字不能当作<code>Java</code>标识符</li>
</ul>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年10月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年10月29日_java_3</title>
    <url>/exam//60e77f1/</url>
    <content><![CDATA[<h1 id="考点1-序列化接口"><a href="#考点1-序列化接口" class="headerlink" title="考点1 序列化接口"></a>考点1 序列化接口</h1><p>要使对象具有序列化能力，则其类应该实现如下哪个接口(    )。</p>
<ul>
<li>A java.io.Serializable</li>
<li>B java.lang.Cloneable,</li>
<li>C java.lang.CharSequence</li>
<li>D java.lang.Comparable</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: A</details>

<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>java.io.Serializable接口是一个标志性接口，在接口内部没有定义任何属性与方法。只是用于标志此接口的实现类可以被序列化与反序列化。<br>java.lang.Cloneable接口是一个标志性接口，在接口内部没有定义任何属性与方法。以指示Object.clone()方法可以合法地对该类实例进行按字段复制。<br>java.lang.CharSequence接口对许多不同种类的char序列提供统一的只读访问接口。CharSequence是char值的一个可读序列。<br>java.lang.Comparable接口，此接口强制对实现它的每个类的对象进行整体排序，此序列被称为该类的自然排序</p>
<h1 id="考点2-子类调用父类方法的方式"><a href="#考点2-子类调用父类方法的方式" class="headerlink" title="考点2 子类调用父类方法的方式"></a>考点2 子类调用父类方法的方式</h1><p>子类要调用继承自父类的方法，必须使用super关键字。</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: B</details>

<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>1、子类构造函数调用父类构造函数用super<br>2、子类重写父类方法后，若想调用父类中被重写的方法，用super<br>3、未被重写的方法可以直接调用。</p>
<h1 id="考点3-泛型"><a href="#考点3-泛型" class="headerlink" title="考点3 泛型"></a>考点3 泛型</h1><p>以下说法错误的是（）</p>
<ul>
<li>A 虚拟机中没有泛型，只有普通类和普通方法</li>
<li>B 所有泛型类的类型参数在编译时都会被擦除</li>
<li>C 创建泛型对象时请指明类型，让编译器尽早的做参数检查</li>
<li>D 泛型的类型擦除机制意味着不能在运行时动态获取List<T>中T的实际类型</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: D</details>

<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><ul>
<li>Java泛型是使用擦除来实现的，这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此<code>List&lt;String&gt;</code>和<code>List&lt;Integer&gt;</code>在运行时实际上是相同的类型。这两种类型都被擦除成它们的“原生”类型，即List。</li>
<li>因此， <strong>虚拟机中没有泛型，只有普通类和普通方法</strong> 。</li>
<li>不过还是可以通过反射获得泛型类T的实际类型</li>
</ul>
<h1 id="考点4-实例化子类对象时-优先调用子类重写的方法"><a href="#考点4-实例化子类对象时-优先调用子类重写的方法" class="headerlink" title="考点4 实例化子类对象时 优先调用子类重写的方法"></a>考点4 实例化子类对象时 优先调用子类重写的方法</h1><p>以下代码执行的结果显示是多少（ ）？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">        <span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        Super()&#123;</span><br><span class="line">            test();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Super.test() flag=&quot;</span>+flag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">        Sub(<span class="type">int</span> i)&#123;</span><br><span class="line">            flag=i;</span><br><span class="line">            System.out.println(<span class="string">&quot;Sub.Sub()flag=&quot;</span>+flag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Sub.test()flag=&quot;</span>+flag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Demo</span>().<span class="keyword">new</span> <span class="title class_">Sub</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A Sub.test() flag&#x3D;1 Sub.Sub() flag&#x3D;5</li>
<li>B Sub.Sub() flag&#x3D;5 Sub.test() flag&#x3D;5</li>
<li>C Sub.test() flag&#x3D;0 Sub.Sub() flag&#x3D;5</li>
<li>D Super.test() flag&#x3D;1 Sub.Sub() flag&#x3D;5</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: A</details>

<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>在只想new Sub(5)的时候，父类先初始化了int flag &#x3D; 1，然后执行父类的构造函数Super()，父类构造函数中执行的test()方法，因子类是重写了test()方法的，因此父类构造函数中的test()方法实际执行的是子类的test()方法，所以输出为Sub.test() flag&#x3D;1，接着执行子类构造函数Sub(5) 将flag赋值为5，因此输出结果Sub.Sub() flag&#x3D;5</p>
<p> <strong>重点在于要时刻记得子类重写父类方法，实例化子类对象，调用时会调用子类重写之后的方法</strong> </p>
<h1 id="考点5-子类通过类名引用父类的静态成员，只会初始化父类，不会初始化子类"><a href="#考点5-子类通过类名引用父类的静态成员，只会初始化父类，不会初始化子类" class="headerlink" title="考点5 子类通过类名引用父类的静态成员，只会初始化父类，不会初始化子类"></a>考点5 子类通过类名引用父类的静态成员，只会初始化父类，不会初始化子类</h1><p>运行代码，输出的结果是（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">P</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">abc</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;P is init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">S</span> <span class="keyword">extends</span> <span class="title class_">P</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;S is init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(S.abc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A <br>P is init<br>123</li>
<li>B <br>S is init<br>P is init<br>123</li>
<li>C <br>P is init<br>S is init<br>123</li>
<li>D <br>S is init<br>123</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: A</details>

<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>静态代码块在 <strong>类初始化的时候</strong> 执行<br><code>S.abc</code>属于 <strong>被动引用</strong> 不会出发子类初始化<br><strong>1.子类引用父类的静态字段，只会触发子类的加载、父类的初始化，不会导致子类初始化</strong><br>2.通过数组定义来引用类，不会触发子类的初始化<br>3.<strong>常量在编译阶段会进行常量优化，将常量存入调用类的常量池中， 本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</strong>。<br>参考：《深入理解Java虚拟机》<br>这里有类主动引用和被动引用的demo：<a href="https://www.jianshu.com/p/3afa5d24bf71">https://www.jianshu.com/p/3afa5d24bf71</a></p>
<h1 id="考点6-String常量"><a href="#考点6-String常量" class="headerlink" title="考点6 String常量"></a>考点6 String常量</h1><p>关于下面的一段代码，以下哪些说法是正确的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;myString&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;myString&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;my&quot;</span> + <span class="string">&quot;String&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> c;</span><br><span class="line">    System.out.print(a == b);</span><br><span class="line">    System.out.print(a == c);</span><br><span class="line">    System.out.print(b == c);</span><br><span class="line">    System.out.print(b == d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A System.out.print(a &#x3D;&#x3D; b)打印出来的是false</li>
<li>B System.out.print(a &#x3D;&#x3D; c)打印出来的是true</li>
<li>C System.out.print(b &#x3D;&#x3D; c)打印出来的是false</li>
<li>D System.out.print(b &#x3D;&#x3D; d)打印出来的是true</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: AD</details>

<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>a是运行时动态加载的，此时会在堆内存中生成一个myString字符串，指向堆内存字符串地址<br>b是编译时静态加载的，此时会在常量池中存放一个myString字符串，指向常量池字符串地址<br>A：a指向堆内存，b指向常量池，因此地址不相等，false<br>B：java有常量优化机制，c也指向常量池，且与b指向同一个，则a与c地址不相等,false；<br>C：b与c地址相等，true<br>D：d是c的副本，地址相同，所以b与d地址相等，true</p>
<h1 id="考点7-系列化和反序列化"><a href="#考点7-系列化和反序列化" class="headerlink" title="考点7 系列化和反序列化"></a>考点7 系列化和反序列化</h1><p>下列关于系列化和反序列化描述正确的是：</p>
<ul>
<li>A 序列化是将数据转为n个 byte序列的过程</li>
<li>B 反序列化是将n个 byte转换为数据的过程</li>
<li>C 将类型int转换为4 byte是反序列化过程</li>
<li>D 将8个字节转换为long类型的数据为序列化过程</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: AB</details>

<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>序列化：将数据结构转换称为二进制数据流或者文本流的过程。序列化后的数据方便在网络上传输和在硬盘上存储。<br>反序列化：与序列化相反，是将二进制数据流或者文本流转换称为易于处理和阅读的数据结构的过程。</p>
<h1 id="考点8-使线程释放锁资源"><a href="#考点8-使线程释放锁资源" class="headerlink" title="考点8 使线程释放锁资源"></a>考点8 使线程释放锁资源</h1><p>下列哪些操作会使线程释放锁资源？</p>
<ul>
<li>A sleep()</li>
<li>B wait()</li>
<li>C join()</li>
<li>D yield()</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: BC</details>

<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>1.sleep会使当前线程睡眠指定时间，不释放锁<br>2.yield会使当前线程重回到可执行状态，等待cpu的调度，不释放锁<br>3.wait会使当前线程回到线程池中等待，释放锁，当被其他线程使用notify，notifyAll唤醒时进入可执行状态<br>4.当前线程调用 某线程.join（）时会使当前线程等待某线程执行完毕再结束，底层调用了wait()方法的，wait()释放锁资源，故join也释放锁资源</p>
<h1 id="考点9-类加载器"><a href="#考点9-类加载器" class="headerlink" title="考点9 类加载器"></a>考点9 类加载器</h1><p>关于Java中的ClassLoader下面的哪些描述是错误的：(         )</p>
<ul>
<li>A 默认情况下，Java应用启动过程涉及三个ClassLoader: Boostrap, Extension, System</li>
<li>B 一般的情况不同ClassLoader装载的类是不相同的，但接口类例外，对于同一接口所有类装载器装载所获得的类是相同的</li>
<li>C 类装载器需要保证类装载过程的线程安全</li>
<li>D ClassLoader的loadClass在装载一个类时，如果该类不存在它将返回null</li>
<li>E ClassLoader的父子结构中，默认装载采用了父优先</li>
<li>F 所有ClassLoader装载的类都来自CLASSPATH环境指定的路径</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: BDF</details>

<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>A、java中类的加载有5个过程，加载、验证、准备、解析、初始化；这便是类加载的5个过程，而类加载器的任务是根据一个类的全限定名来读取此类的二进制字节流到JVM中，然后转换为一个与目标类对应的java.lang.Class对象实例，在虚拟机提供了3种类加载器，引导（Bootstrap）类加载器、扩展（Extension）类加载器、系统（System）类加载器（也称应用类加载器）。A正确<br>B、一个类，由不同的类加载器实例加载的话，会在方法区产生两个不同的类，彼此不可见，并且在堆中生成不同Class实例。所以B前面部分是正确的，后面接口的部分真的没有尝试过，等一个大佬的讲解吧；<br>C、类加载器是肯定要保证线程安全的；C正确<br>D、装载一个不存在的类的时候，因为采用的双亲加载模式，所以强制加载会直接报错，D错误<br>java.lang.SecurityException: Prohibited package name: java.lang<br>E、双亲委派模式是在Java 1.2后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成，所以默认是父装载，E正确<br>F、自定义类加载器实现 继承ClassLoader后重写了findClass方法加载指定路径上的class，F错误</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年10月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年10月29日_java_4</title>
    <url>/exam//986ae252/</url>
    <content><![CDATA[<h1 id="考点1-java-main方法"><a href="#考点1-java-main方法" class="headerlink" title="考点1 java main方法"></a>考点1 java main方法</h1><p>在Java中，main()方法的返回值的类型是：</p>
<ul>
<li>A public</li>
<li>B static</li>
<li>C void</li>
<li>D String</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: C</details>

<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>main方法的格式讲解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>public:公共的，访问权限是最大的。由于main方法是被jvm调用，所以权限要够大。</li>
<li>static:静态的，不需要创建对象，通过类名就可以。方便jvm的调用。</li>
<li>void:方法的返回值是返回给调用者，而main方法是被jvm调用。你返回内容给jvm没有意义。</li>
<li>main:是一个常见的方法入口。我见过的语言都是以main作为入口。</li>
<li>String[] args:这是一个字符串数组。这个东西早期是为了接收键盘录入的数据的。</li>
</ul>
<h1 id="考点2-多线程-同一个对象作为锁的情况"><a href="#考点2-多线程-同一个对象作为锁的情况" class="headerlink" title="考点2 多线程 同一个对象作为锁的情况"></a>考点2 多线程 同一个对象作为锁的情况</h1><p>执行如下程序，输出结果是（ ）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        result += <span class="number">2</span>;</span><br><span class="line">        data += <span class="number">2</span>;</span><br><span class="line">        System.out.print(result + <span class="string">&quot;  &quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadExample</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Test mv;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadExample</span><span class="params">(Test mv)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.mv = mv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(mv)</span><br><span class="line">        &#123;</span><br><span class="line">            mv.m();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadExample</span>(mv);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadExample</span>(mv);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadExample</span>(mv);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 0 22 44 6</li>
<li>B 2 42 42 4</li>
<li>C 2 24 46 6</li>
<li>D 4 44 46 6</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: C</details>

<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>只要注意这里锁住的是对象就可以了<br>这里只创建了一个对象Test mv &#x3D; new Test();<br>如果换成synchronized(Test.class)锁住的就是这个类,执行的结果就不一样了<br>这里是同一个对象锁 所以一个线程执行完另一个线程才能访问<br>三个线程传输的是同一个mv,而且加了同步锁synchronized(mv)，所以执行的时候按照顺序执行即可</p>
<h1 id="考点3-访问修饰符"><a href="#考点3-访问修饰符" class="headerlink" title="考点3 访问修饰符"></a>考点3 访问修饰符</h1><p>下列哪个对访问修饰符作用范围由大到小排列是正确的？</p>
<ul>
<li>A private&gt;default&gt;protected&gt;public</li>
<li>B public&gt;default&gt;protected&gt;private</li>
<li>C private&gt;protected&gt;default&gt;public</li>
<li>D public&gt;protected&gt;default&gt;private</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: D</details>

<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><h1 id="考点4-访问修饰符"><a href="#考点4-访问修饰符" class="headerlink" title="考点4 访问修饰符"></a>考点4 访问修饰符</h1><p>下面哪个修饰符修饰的变量是所有同一个类生成的对象共享的（ ）</p>
<ul>
<li>A public</li>
<li>B private</li>
<li>C static</li>
<li>D final</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: C</details>

<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h1 id="考点5-包装类之间的比较"><a href="#考点5-包装类之间的比较" class="headerlink" title="考点5 包装类之间的比较"></a>考点5 包装类之间的比较</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">42</span>; </span><br><span class="line"><span class="type">Long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">42l</span>; </span><br><span class="line"><span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">42.0</span>; </span><br></pre></td></tr></table></figure>
<p>下面为true的是</p>
<ul>
<li>A (i &#x3D;&#x3D; l)</li>
<li>B (i &#x3D;&#x3D; d)</li>
<li>C (l &#x3D;&#x3D; d)</li>
<li>D i.equals(d)</li>
<li>E d.equals(l)</li>
<li>F i.equals(l)</li>
<li>G l.equals(42L)</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: G</details>

<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><h1 id="考点6-for循环语句"><a href="#考点6-for循环语句" class="headerlink" title="考点6 for循环语句"></a>考点6 for循环语句</h1><p>设m和都是int类型,那么以下for循环语句的执行情况是( )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (m = <span class="number">0</span>, n = -<span class="number">1</span>; n = <span class="number">0</span>; m++, n++)</span><br><span class="line">n++;</span><br></pre></td></tr></table></figure>

<ul>
<li>A 循环体一次也不执行 循环体执行一次 是无限循环 有限次循环 循环结束判断条件不合法 运行出错</li>
<li>B 循环体执行一次 是无限循环</li>
<li>C 有限次循环</li>
<li>D 循环结束判断条件不合法</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: D</details>

<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>循环条件:<code>n = 0</code>是int类型，不是boolean型的。<br>所以语法错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化语句;判断条件语句;控制条件语句)&#123;</span><br><span class="line">    循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考点7-String-常量池"><a href="#考点7-String-常量池" class="headerlink" title="考点7 String 常量池"></a>考点7 String 常量池</h1><p><code>String s = new String(&quot;xyz&quot;);</code>创建了几个StringObject？</p>
<ul>
<li>A 两个或一个都有可能</li>
<li>B 两个</li>
<li>C 一个</li>
<li>D 三个</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: A</details>

<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><ul>
<li>如果在常量池中已经存在“xyz”，那么只创建一个new String(“xyz”)的对象。</li>
<li>如果常量池中没有“xyz”，则会创建两个对象，一个是常量池中的对象“xyz”，一个是new String(“xyz”)的对象。</li>
</ul>
<h1 id="考点8-Object类方法"><a href="#考点8-Object类方法" class="headerlink" title="考点8 Object类方法"></a>考点8 Object类方法</h1><p>java中下面哪些是Object类的方法（）</p>
<ul>
<li>A notify()</li>
<li>B notifyAll()</li>
<li>C sleep()</li>
<li>D wait()</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: ABD</details>

<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><h1 id="考点9-Java继承"><a href="#考点9-Java继承" class="headerlink" title="考点9 Java继承"></a>考点9 Java继承</h1><p>java中关于继承的描述正确的是（）</p>
<ul>
<li>A 一个子类只能继承一个父类</li>
<li>B 子类可以继承父类的构造方法</li>
<li>C 继承具有传递性</li>
<li>D 父类一般具有通用性，子类更具体</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: ACD</details>

<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>子类不可以继承父类的构造方法，只可以调用父类的构造方法。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年10月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年10月29日_java_5</title>
    <url>/exam//ef6dd2c4/</url>
    <content><![CDATA[<h1 id="考点1-boolean类型的正确赋值语句"><a href="#考点1-boolean类型的正确赋值语句" class="headerlink" title="考点1 boolean类型的正确赋值语句"></a>考点1 boolean类型的正确赋值语句</h1><p>现有一变量声明为 boolean aa; 下面赋值语句中正确的是 （ ）</p>
<ul>
<li>A aa&#x3D;false;</li>
<li>B aa&#x3D;False;</li>
<li>C aa&#x3D;”true”;</li>
<li>D aa&#x3D;0;</li>
</ul>
<p>正确答案:</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h1 id="考点2-重载函数"><a href="#考点2-重载函数" class="headerlink" title="考点2 重载函数"></a>考点2 重载函数</h1><p>下面有关重载函数的说法中正确的是</p>
<ul>
<li>A 重载函数必须具有不同的返回值类型</li>
<li>B 重载函数形参个数必须不同</li>
<li>C 重载函数必须有不同的形参列表</li>
<li>D 重载函数名可以不同</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: C</details>

<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>两同一不同：同一个类中，方法名相同，形参列表不同。</p>
<h1 id="考点3-String-StringBuffer-StringBuilder"><a href="#考点3-String-StringBuffer-StringBuilder" class="headerlink" title="考点3 String StringBuffer StringBuilder"></a>考点3 String StringBuffer StringBuilder</h1><p>关于String、StringBuffer、StringBuilder以下说法错误的是</p>
<ul>
<li>A StringBuilder运行速度最快</li>
<li>B StringBuffer是线程安全的</li>
<li>C String的值是可变的</li>
<li>D StringBuffer运行速度比String快</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: C</details>

<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>String的值一旦确认了就不可变，每次的变化实际上都创建了一个新的String，所以有多次变化时最好还是用StringBuffer更好<br>速度：String&lt; Stringbuffer &lt; Stringbuilder</p>
<h1 id="考点4-网络编程"><a href="#考点4-网络编程" class="headerlink" title="考点4 网络编程"></a>考点4 网络编程</h1><p>客户端要获取一个socket对象通过实例化，而服务器获得一个socket对象则通过什么方法的返回值？</p>
<ul>
<li>A getRemoteSocketAddress()</li>
<li>B getInputStream()</li>
<li>C getOutputStream()</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: A</details>

<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h1 id="考点5-垃圾收集"><a href="#考点5-垃圾收集" class="headerlink" title="考点5 垃圾收集"></a>考点5 垃圾收集</h1><p>下面关于垃圾收集的说法正确的是</p>
<ul>
<li>A 一旦一个对象成为垃圾，就立刻被收集掉。</li>
<li>B 对象空间被收集掉之后，会执行该对象的finalize方法</li>
<li>C finalize方法和C++的析构函数是完全一回事情</li>
<li>D 一个对象成为垃圾是因为不再有引用指着它，但是线程并非如此</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: D</details>

<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>A,B其实是一个知识点，既一个对象到GC Roots没有任何引用链相连时就是一个可回收对象，可回收对象在被回收之前，JVM会判断是否有finalize方法，如果有则会调用finalize方法，在这个方法里面对象可以自救的。<br>C 肯定不对啦 </p>
<ol>
<li>与C++的析构函数不同，析构函数调用确定，而finalize()方法是不确定的，因为finalize()方法在对象被GC回收时调用。 </li>
<li>JVM将重写了finalize方法的对象放置于F-Queue队列，稍后会被一个优先级很低的Finalizer线程执行。Finalizer线程随时会终止，为了防止对象的finalize方法执行缓慢，或者发生死循环。</li>
<li><strong>finaliz的设计目的是保证对象在被垃圾收集前完成特定资源的回收或给予对象最后一次重生机会等</strong> 。 </li>
<li>finalize是个不太可控的方法因此并不常用，并且在JDK9+版本被标注为过时方法。</li>
</ol>
<h1 id="考点6-抽象类-抽象方法-重载的依据-赋值表达式可以出现的位置"><a href="#考点6-抽象类-抽象方法-重载的依据-赋值表达式可以出现的位置" class="headerlink" title="考点6 抽象类 抽象方法 重载的依据 赋值表达式可以出现的位置"></a>考点6 抽象类 抽象方法 重载的依据 赋值表达式可以出现的位置</h1><p>选项中哪一行代码可以替换 &#x2F;&#x2F;add code here 而不产生编译错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">constInt</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//add code here</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A public abstract void method(int a);</li>
<li>B consInt&#x3D;constInt+5;</li>
<li>C public int method();</li>
<li>D public abstract void anotherMethod(){}</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: A</details>

<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>A 是抽象方法，抽象类可以包含抽象方法，也可以不包含，抽象方法可以重载。正确<br>B 在类中不能constInt &#x3D; constInt +5这样的运算。错误<br>C 返回值不能作为重载的依据，错误<br>D 有方法体的不能作为抽象函数，错误</p>
<h1 id="考点7-Java-Web-容器的作用"><a href="#考点7-Java-Web-容器的作用" class="headerlink" title="考点7 Java Web 容器的作用"></a>考点7 Java Web 容器的作用</h1><p>在Web应用程序中，(    )负责将HTTP请求转换为HttpServletRequest对象</p>
<ul>
<li>A Servlet对象</li>
<li>B HTTP服务器</li>
<li>C Web容器</li>
<li>D JSP网页</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: C</details>

<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>web容器是一种服务程序，在服务器一个端口就有一个提供相应服务的程序，而这个程序就是处理从客户端发出的请求，如JAVA中的Tomcat容器，ASP的IIS或PWS都是这样的容器。一个服务器可以多个容器。</p>
<h1 id="考点8-垃圾回收器"><a href="#考点8-垃圾回收器" class="headerlink" title="考点8 垃圾回收器"></a>考点8 垃圾回收器</h1><p>如何放掉一个指定占据的内存空间？（）</p>
<ul>
<li>A 调用free()方法</li>
<li>B 代用system.gc()方法</li>
<li>C 赋值给该项对象的引用为null</li>
<li>D 程序员无法明确强制垃圾回收器运行</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: D</details>

<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><h1 id="考点9-网络编程-如何创建服务端socket"><a href="#考点9-网络编程-如何创建服务端socket" class="headerlink" title="考点9 网络编程 如何创建服务端socket"></a>考点9 网络编程 如何创建服务端socket</h1><p>如果希望监听TCP端口9000，服务器端应该怎样创建socket?</p>
<ul>
<li>A new Socket(“localhost”,9000);</li>
<li>B new ServerSocket(9000);</li>
<li>C new Socket(9000);</li>
<li>D new ServerSocket(“localhost”,9000);</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: B</details>

<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">9000</span>); <span class="comment">//客户端连接端口 </span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9000</span>); <span class="comment">//服务器端监听端口</span></span><br></pre></td></tr></table></figure>
<ul>
<li>服务端：<code>ServerSocket(port)</code>，因为<strong>服务器知道自己的IP所以不需要输入IP</strong></li>
<li>客户端：<code>Socket(host,port)</code>，因为客户端不知道连接哪条IP所以需要输入IP</li>
</ul>
<p>服务器端创建监听：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="type">int</span> port)</span><br></pre></td></tr></table></figure>
<p>客户端创建监听：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress address, <span class="type">int</span> port)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年10月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年10月30日_java_1</title>
    <url>/exam//Infinity/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>java中，用（ ）关键字定义常量？</p>
<ul>
<li>A final</li>
<li>B #define</li>
<li>C float</li>
<li>D const</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>final关键字可用于修饰类、变量和方法。final修饰变量时，表示该变量一旦获得了初始值就不可被改变，final既可以修饰成员变量也可以修饰局部变量、形参。</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>下面关于hibernate核心接口说明错误的是？</p>
<ul>
<li>A Configuration 接口：配置Hibernate，根据其启动hibernate，创建SessionFactory 对象</li>
<li>B SessionFactory 接口：负责保存、更新、删除、加载和查询对象，是线程不安全的，避免多个线程共享同一个session，是轻量级、一级缓存</li>
<li>C Query 和Criteria 接口：执行数据库的查询</li>
<li>D Transaction 接口：管理事务</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>B选项中应该是Session接口而不是SessionFactory接口<br>1，Configuration接口：配置Hibernate，根据其启动Hibernate，创建SessionFactory对象；<br>2，SessionFactory接口：初始化Hibernate，充当数据存储源的代理，创建session对象，SessionFactory是<br>线程安全的，意味着它的同一个实例可以被应用的多个线程共享，是重量级二级缓存；<br>3，session接口：负责保存、更新、删除、加载和查询对象，是一个非线程安全的，避免多个线程共享一个session，是轻量级，一级缓存。<br>4，Transaction接口：管理事务。可以对事务进行提交和回滚；<br>5，Query和Criteria接口：执行数据库的查询。</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>执行如下代码段后，变量s1引用的字符串值是(    )。<br>String s1 &#x3D; “ABCD”;<br>String s2 &#x3D; “1234”;<br>System.out.println(s1 + s2);</p>
<ul>
<li>A ABCD</li>
<li>B 1234</li>
<li>C ABCD1234</li>
<li>D 1234ABCD</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>有以下类定义：<br>abstract class Animal{<br>    abstract void say();<br>}<br>public class Cat extends Animal{<br>    public Cat(){<br>        System.out.printf(“I am a cat”);<br>    }<br>    public static void main(String[] args) {<br>        Cat cat&#x3D;new Cat();<br>    }<br>}<br>运行后：</p>
<ul>
<li>A I am a cat</li>
<li>B Animal能编译，Cat不能编译</li>
<li>C Animal不能编译，Cat能编译</li>
<li>D 编译能通过，但是没有输出结果</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意， <strong>抽象类和普通类</strong> 的主要有三点区别：<br>1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。<br>2）抽象类不能用来创建对象；<br>3） <strong>如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法</strong> 。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。<br>在其他方面，抽象类和普通的类并没有区别。</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>以下代码执行的结果显示是多少（）？<br>public class Demo{<br>    public static void main(String[] args){<br>        System.out.print(getNumber(0));<br>        System.out.print(getNumber(1));<br>        System.out.print(getNumber(2));<br>        System.out.print(getNumber(4));<br>    }</p>
<pre><code>public static int getNumber(int num)&#123;
    try&#123;
        int result = 2 / num;
        return result;
    &#125;catch (Exception exception)&#123;
        return 0;
    &#125;finally&#123;
        if(num == 0)&#123;
            return -1;
        &#125;
        if(num == 1)&#123;
            return 1;
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</p>
<ul>
<li>A 0110</li>
<li>B -1110</li>
<li>C 0211</li>
<li>D -1211</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>finally中return语句会覆盖try-catch中的return语句</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>以下代码对其执行后，NumberList里的元素依次为：<br>List<Integer> NumberList &#x3D; new ArrayList<Integer>();<br>NumberList.add(2);<br>NumberList.add(4);<br>NumberList.add(1);<br>NumberList.add(3);<br>NumberList.add(5);<br>for(int i &#x3D;0;i&lt;NumberList.size();++i){<br>    int v &#x3D; NumberList.get(i);<br>    if(v%2&#x3D;&#x3D;0){<br>        NumberList.remove(v);<br>    }<br>}<br>System.out.println(NumberList);</p>
<ul>
<li>A 2,4,1,3,5</li>
<li>B 2,1,3,5</li>
<li>C 4,1,3,5</li>
<li>D 会出现越界情况</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>1.ArrayList删除元素后，剩余元素会依次向前移动，因此下标一直在变，size()也会减小；<br>2.这里的remove()方法调用的是remove(int index)，而不是remove(Object o)，因此删除的是index索引处的元素；<br>对于List而言，想要移除元素，要不然就用迭代器。要不然就从后往前删除。<br>万万不可从前往后删，会出现角标越界。</p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>String str1 &#x3D; “abc”，“abc”分配在内存哪个区域？</p>
<ul>
<li>A 堆</li>
<li>B 栈</li>
<li>C 字符串常量区</li>
<li>D 寄存器</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>答案：C<br>用new创建的对象在堆区<br>函数中的临时变量在栈去<br>java中的字符串在字符串常量区</p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>当编译并运行下面程序时会发生什么结果（）<br>public class Bground extends Thread{<br>    public static void main(String argv[]){<br>        Bground b &#x3D; new Bground();<br>        b.run();<br>    }<br>    public void start(){<br>        for(int i&#x3D;0;i&lt;10;i++){<br>            System.out.println(“Value of i &#x3D; “+i);<br>        }<br>    }<br>}</p>
<ul>
<li>A 编译错误，指明run方法没有定义</li>
<li>B 运行错误，只鞥呢run方法没有定义</li>
<li>C 编译通过并输出0到9</li>
<li>D 编译通过，但无输出</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>对于线程而言，start是让线程从new变成runnable。run方法才是执行体的入口。<br>但是在Thread中，run方法是个空方法，没有具体实现。<br>Bground继承了Thread，但是没有重写run方法，那么调用run方法肯定是无输出。<br>首先继承Thread，然后调用run方法，bgroud并没有重写run方法，那么就是调用父类Thread的run方法。</p>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>下面选项中,哪些是interface中合法方法定义?()</p>
<ul>
<li>A public void main(String [] args);</li>
<li>B private int getSum();</li>
<li>C boolean setFlag(Boolean [] test);</li>
<li>D public float get(int x);</li>
</ul>
<p>正确答案: ACD</p>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>在jdk8之前，interface之中可以定义变量和方法，变量必须是public、static、final的，方法必须是public、abstract的。<br>JDK8及以后，允许我们在接口中定义static方法和default方法。<br>静态方法，只能通过接口名调用，不可以通过实现类的类名或者实现类的对象调用。default方法，只能通过接口实现类的对象来调用。<br>当然如果接口中的默认方法不能满足某个实现类需要，那么实现类可以覆盖默认方法。<br>JDK 1.9时，接口中的方法可以是private的</p>
<h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>下面哪些属于JSP内置对象及方法？</p>
<ul>
<li>A request</li>
<li>B out</li>
<li>C application</li>
<li>D config</li>
</ul>
<p>正确答案: ABCD</p>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><p>JSP内置对象有：<br>1.request对象<br>     客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。<br>2.response对象<br>     response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>3.session对象<br>     session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.<br>4.out对象<br>     out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>5.page对象<br>     page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例<br>6.application对象<br>     application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。<br>7.exception对象<br>   exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象<br>8.pageContext对象<br>pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。<br>9.config对象<br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年10月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年10月30日_java_2</title>
    <url>/exam//91e1358d/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下列叙述错误的是( )</p>
<ul>
<li>A java提供了丰富的类库</li>
<li>B java很好的利用了网络资源</li>
<li>C java支持多线程</li>
<li>D java不支持TCP&#x2F;IP协议</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>对于java类型变量char c,short s,float f,double d,表达式c*s+f+d的结果类型为（）</p>
<ul>
<li>A float</li>
<li>B char</li>
<li>C short</li>
<li>D double</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>自动类型转换遵循下面的规则：<br>1.若参与运算的数据类型不同，则先转换成同一类型，然后进行运算。<br>2.转换按数据长度增加的方向进行，以保证精度不降低。例如int型和long型运算时，先把int量转成long型后再进行运算。<br>3.所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。<br>4.char型和short型参与运算时，必须先转换成int型。<br>5.在赋值运算中，赋值号两边的数据类型不同时，需要把右边表达式的类型将转换为左边变量的类型。如果右边表达式的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度。<br>byte-&gt;short-&gt;int<br>char -&gt; int -&gt; long<br>float -&gt; double<br>int -&gt; float-&gt;double<br>long -&gt; double</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>以下程序的运行结果是（）<br>public class Increment<br>{<br>    public static void main(String args[])<br>    {<br>        int a;<br>        a &#x3D; 6;<br>        System.out.print(a);<br>        System.out.print(a++);<br>        System.out.print(a);<br>    }<br>}</p>
<ul>
<li>A 666</li>
<li>B 667</li>
<li>C 677</li>
<li>D 676</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>a++表示先用后+，<br>而++a表示先+后用</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>BufferedReader的父类是以下哪个？</p>
<ul>
<li>A FilterReader</li>
<li>B InputStreamReader</li>
<li>C PipedReader</li>
<li>D Reader</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>枚举（enum）属于原始数据类型（primitive type）。</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>这里的原始数据类型就是基本数据类型<br>byte,short,int,long,float,double,boolean,char.<br>枚举类是一种特殊对的类，既然是类。那他就不是原始数据类型了</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>public class contained in a Java program file must have the same name as the file, except for the extension “.java”.</p>
<ul>
<li>A FALSE</li>
<li>B TRUE</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>1、java文件中类型为public的类有两种，一种是外部类，一种是内部类；<br>2、当外部类的类型为public时，文件名需要与其相同；<br>3、当内部类的类型为public时，而外部类不是public类型的，则文件名可随意，但需要满足命名规范（以字母或下划线开头）。</p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>关于java编译和运行命令叙述不正确的是？  ( )</p>
<ul>
<li>A 运行“java Scut.class”</li>
<li>B 运行“java Scut”</li>
<li>C 运行“javac Scut.java”的输出文件是Scut.class</li>
<li>D java这个命令的运行对象是Scut.class</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>先编译：javac scut.java.产生字节码文件(scut.class).<br>再运行字节码文件:java scut.此时不需要加后缀</p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>在java中重写方法应遵循规则的包括（）</p>
<ul>
<li>A 访问修饰符的限制一定要大于被重写方法的访问修饰符</li>
<li>B 可以有不同的访问修饰符</li>
<li>C 参数列表必须完全与被重写的方法相同</li>
<li>D 必须具有不同的参数列表</li>
</ul>
<p>正确答案: BC</p>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>两同两小一大原则：<br>两同：方法名和参数列表相同<br>两小：返回值或声明异常比父类小（或相同）<br>一大：访问修饰符比父类的大（或相同）<br>访问权限可以相同，所以A不对。<br>访问权限可以更大，则不同，所以B对</p>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>以下程序执行后，错误的结果是（）<br>public class Test {<br>    private String name &#x3D; “abc”;<br>    public static void main(String[] args) {<br>        Test test &#x3D; new Test();<br>        Test testB &#x3D; new Test();<br>        String result &#x3D; test.equals(testB) + “,”;<br>        result +&#x3D; test.name.equals(testB.name) + “,”;<br>        result +&#x3D; test.name &#x3D;&#x3D; testB.name;<br>        System.out.println(result);<br>    }<br>}</p>
<ul>
<li>A true,true,true</li>
<li>B true,false,false</li>
<li>C false,true,false</li>
<li>D false,true,true</li>
</ul>
<p>正确答案: ABC</p>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>Test重写equals方法。比较的是地址。所以test.equals(testB) 返回false。<br>String重写了equals方法,比较的是内容，所以，test.name.equals(testB.name)返回true。<br>String name &#x3D; “abc”，name引用的是字符串直接量，字符串直接量放在常量区，只创建一次，所以是同一对象，所以test.name &#x3D;&#x3D; testB.name返回true<br>也就是false,true,true</p>
<p>但是题目要你选错误的</p>
<h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>下面有关java的引用类型，说法正确的有？</p>
<ul>
<li>A 对于一个对象来说，只要有强引用的存在，它就会一直存在于内存中</li>
<li>B 如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</li>
<li>C 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存</li>
<li>D 一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的空间</li>
</ul>
<p>正确答案: ABCD</p>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><p>1、强引用：一个对象赋给一个引用就是强引用，比如new一个对象，一个对象被赋值一个对象。<br>2、软引用：用SoftReference类实现，一般不会轻易回收，只有内存不够才会回收。<br>3、弱引用：用WeekReference类实现，一旦垃圾回收已启动，就会回收。<br>4、虚引用：不能单独存在，必须和引用队列联合使用。主要作用是跟踪对象被回收的状态。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年10月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年10月30日_java_3</title>
    <url>/exam//e6e6051b/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>以下代码执行后输出结果为（ ）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassTest</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] ch = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(String str, <span class="type">char</span> ch[])</span>&#123;</span><br><span class="line">    str=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">    ch[<span class="number">0</span>]=<span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ClassTest</span> <span class="variable">test1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassTest</span>();</span><br><span class="line">    test1.fun(test1.str,test1.ch);</span><br><span class="line">    System.out.print(test1.str + <span class="string">&quot; and &quot;</span>);</span><br><span class="line">    System.out.print(test1.ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A hello and dbc</li>
<li>B world and abc</li>
<li>C hello and abc</li>
<li>D world and dbc</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>ArrayList list &#x3D; new ArrayList(20);中的list扩充几次</p>
<ul>
<li>A 0</li>
<li>B 1</li>
<li>C 2</li>
<li>D 3</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>ArrayList list&#x3D;new ArrayList(); 这种是默认创建大小为10的数组，每次扩容大小为1.5倍<br> ArrayList list&#x3D;new ArrayList(20); 这种是指定数组大小的创建，创建时直接分配其大小，没有扩充。 所以，扩充为0次</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>下面程序的输出结果是？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithms.com.guan.javajicu;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span><span class="string">&quot;&quot;</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> i)</span>&#123;  </span><br><span class="line">       <span class="keyword">try</span>&#123;  </span><br><span class="line">           <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;  </span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;<span class="keyword">catch</span>(Exception e)&#123;  </span><br><span class="line">           output += <span class="string">&quot;2&quot;</span>;  </span><br><span class="line">           <span class="keyword">return</span> ;  </span><br><span class="line">       &#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line">           output += <span class="string">&quot;3&quot;</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       output += <span class="string">&quot;4&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">       foo(<span class="number">0</span>);  </span><br><span class="line">       foo(<span class="number">1</span>);  </span><br><span class="line">       System.out.println(output); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<ul>
<li>A 出错</li>
<li>B 342</li>
<li>C 34234</li>
<li>D 3423</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>下列哪个选项是合法的标识符？（）</p>
<ul>
<li>A 123</li>
<li>B _name</li>
<li>C class</li>
<li>D first</li>
</ul>
<p>正确答案: BD</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>Java标识符由数字、字母、下划线(_)、美元符号($)组成，首位不能是数字。并且Java关键字不能作为标识符</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年10月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年10月30日_java_4</title>
    <url>/exam//788290b8/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下面的方法，当输入为2的时候返回值是多少？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        result = result + i;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        result = result + i * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        result = result + i * <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 0</li>
<li>B 2</li>
<li>C 4</li>
<li>D 10</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>没有<code>break</code>，发生<code>case</code>穿透现象，程序会继续向下执行，直到遇到<code>break</code>或者结束<code>switch</code>语句的大括号为止。</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>下面那些情况可以终止当前线程的运行？</p>
<ul>
<li>A 当一个优先级高的线程进入就绪状态时</li>
<li>B 抛出一个异常时</li>
<li>C 当该线程调用sleep()方法时</li>
<li>D 当创建一个新线程时</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><ul>
<li>当一个优先级高的线程进入就绪状态时，它只是有较高的概率能够抢到<code>CPU</code>的执行权，不是一定就能抢到执行权，所以A错</li>
<li>抛出一个例外时，该线程就终止了，所以B正确</li>
<li>当前线程调用<code>sleep()</code>方法或者<code>wait()</code>方法时，只是暂时停止了该线程的运行，不是终止线程，注意题目说的是“终止”，就是完全停止,所以C错误</li>
<li>当创建一个新的线程时，该线程也加入到了抢占<code>CPU</code>执行权的队伍中，但是是否能抢到，并不清楚，和A的思想一样，所以D错误</li>
</ul>
<p>线程结束的三个原因：</p>
<ul>
<li><code>run</code>方法执行完成，线程正常结束</li>
<li>线程抛出一个未捕获的<code>Exception</code>或者<code>Error</code></li>
<li>直接调用该线程的<code>Stop</code>方法结束线程（不建议使用，容易导致死锁）</li>
</ul>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>下列关于<code>java</code> 中的 <code>wait()</code>方法和 <code>sleep()</code>方法的区别描述错误的是？</p>
<ul>
<li>A <code>wait()</code>方法属于<code>Object</code>类，<code>sleep()</code>属于<code>Thread</code>类</li>
<li>B 调用<code>wait()</code>方法的时候，线程会放弃对象锁</li>
<li>C 调用<code>sleep()</code>方法的过程中，线程不会释放对象锁</li>
<li>D <code>sleep()</code>方法导致了程序暂停执行指定的时间，让出<code>cpu</code>给其他线程</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>sleep和wait的区别有：</p>
<ol>
<li>这两个方法来自不同的类分别是<code>Thread</code>和<code>Object</code></li>
<li>最主要是**<code>sleep</code>方法没有释放锁，而<code>wait</code>方法释放了锁**，使得敏感词线程可以使用同步控制块或者方法。</li>
<li><strong><code>wait</code>，<code>notify</code>和<code>notifyAll</code>只能在同步控制方法或者同步控制块里面使用</strong>，而<code>sleep</code>可以在任何地方使用<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(x)&#123;</span><br><span class="line">   x.notify()</span><br><span class="line">  <span class="comment">//或者wait()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>sleep</code>必须捕获异常，而<code>wait</code>，<code>notify</code>和<code>notifyAll</code>不需要捕获异常</li>
</ol>
<p>D是<strong>线程</strong>暂停执行指定时间而不是<strong>程序</strong>暂停执行指定的时间。</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>执行以下程序后的输出结果是（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;A&quot;</span>); </span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;B&quot;</span>); </span><br><span class="line">        operator(a, b); </span><br><span class="line">        System.out.println(a + <span class="string">&quot;,&quot;</span> + b); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operator</span><span class="params">(StringBuffer x, StringBuffer y)</span> &#123; </span><br><span class="line">        x.append(y); y = x; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A A,A</li>
<li>B A,B</li>
<li>C B,B</li>
<li>D AB,B</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>关于<code>C++/JAVA</code>类中<code>static</code> 成员和对象成员的说法正确的是？</p>
<ul>
<li>A <code>static</code> 成员变量在对象构造时生成</li>
<li>B <code>static</code> 成员函数在对象成员函数中无法调用</li>
<li>C 虚成员函数不可能是<code>static</code> 成员函数</li>
<li>D <code>static</code> 成员函数不能访问<code>static</code> 成员变量</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p><code>C++</code>中<strong>虚函数</strong>类似<code>java</code>语言中的<strong>抽象方法</strong>，抽象方法中不能用<code>private</code>，<code>static</code>， <code>synchronized</code>，<code>native</code>等修饰词修饰。</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>给出下面的代码段:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="type">int</span> w, x, y ,z;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">    &#123;</span><br><span class="line">        x=a; y=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// assignment x=a, y=b</span></span><br><span class="line">        w=d;z=c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码说明&#x2F;&#x2F; assignment x&#x3D;a, y&#x3D;b处写入如下哪几个代码是正确的？（） </p>
<ul>
<li>A <code>Base(a,b);</code></li>
<li>B <code>x=a, y=b;</code></li>
<li>C <code>x=a; y=b;</code></li>
<li>D <code>this(a,b);</code></li>
</ul>
<p>正确答案: CD</p>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>下列哪些操作会使线程释放锁资源？</p>
<ul>
<li>A <code>sleep()</code></li>
<li>B <code>wait()</code></li>
<li>C <code>join()</code></li>
<li>D <code>yield()</code></li>
</ul>
<p>正确答案: BC</p>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>往OuterClass类的代码段中插入内部类声明, 哪一个是错误的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> f=<span class="number">1.0f</span>;</span><br><span class="line">    <span class="comment">//插入代码到这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A class InnerClass{public static float func(){return f;} }</li>
<li>B abstract class InnerClass{ public abstract float func(){} }</li>
<li>C static class InnerClass{ protected static float func(){return f;} }</li>
<li>D public class InnerClass{ static float func(){return f;} }</li>
</ul>
<p>正确答案: ABCD</p>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>主要考核了这几个知识点：<br>1.<strong>静态内部类才可以声明静态方法</strong>,所以A错，D错<br>2.静态方法不可以使用非静态变量，所以C错误<br>3.抽象方法不可以有函数体，所以B错误</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年10月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年10月30日_java_5</title>
    <url>/exam//f85a02e/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>_______意味着一个操作在不同的类中可以有不同的实现方式。</p>
<ul>
<li>A 多态性</li>
<li>B 多继承</li>
<li>C 类的组合</li>
<li>D 类的复用</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>类的复用有两种方式：组成(has-a)和继承(is-a)<br>1）组成就是在新的类中直接创建旧类的对象，这里我们复用的只是代码的功能而不是它的形式。<br>2）继承是在原有的类的基础上建立一个新类，新类具有旧类的形式，但也加入了一些新的特性。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>指一个新的类继承原有类的基本特性，并增加了新的特性。（Java不允许多继承，而C++可以）</p>
<h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。<br>1）多态存在的三个必要条件<br>①要有继承 ②要有重写 ③父类引用指向子类对象（向上转型）<br>2）实现多态性的三种形式</p>
<ul>
<li>①方法的重载 </li>
<li>②通过继承机制而产生方法覆盖</li>
<li>③通过接口实现方法覆盖<br>3）多态的分类<br>多态分为编译时多态和运行时多态。其中<br>编译</li>
<li>时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编译之后会变成两个不同的函数，在运行时谈不上多态。</li>
<li>而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们平常所说的多态性。</li>
</ul>
<p>多态的本质是：一个程序中同名的不同方法。在面向对象的程序设计中，多态主要有以下三种方式来实现。</p>
<ul>
<li>通过子类对父类方法的覆盖来实现多态。</li>
<li>通过一个类中方法的重载来实现多态。</li>
<li>通过将子类的对象作为父类的对象实现多态。</li>
</ul>
<p> 方法中的成员变量不具备多态性，因为变量不会被重写，在编译时有两块存储堆内存，并取决于编译时所声明变量类型。和运行时对象的变量不是一块内存区域。简洁得来说，<strong>不能重写就没法表现出多态。</strong></p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>以下关于java封装的描述中，正确的是：</p>
<ul>
<li>A 封装的主要作用在于对外隐藏内部实现细节，增强程序的安全性</li>
<li>B 封装的意义不大，因此在编码中尽量不要使用</li>
<li>C 如果子类继承父类，对于父类中进行封装的方法，子类仍然可以直接调用</li>
<li>D 只能对一个类中的方法进行封装，不能对属性进行封装</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><h3 id="什么是封装"><a href="#什么是封装" class="headerlink" title="什么是封装"></a>什么是封装</h3><p><strong>封装就是将属性私有化，提供公有的方法访问私有属性</strong>。所以CD错误。</p>
<h3 id="如何实现封装"><a href="#如何实现封装" class="headerlink" title="如何实现封装"></a>如何实现封装</h3><p>做法就是：<br>修改属性的可见性来限制对属性的访问，<br>并为每个属性创建一对取值（getter）方法和赋值（setter）方法，用于对这些属性的访问。<br>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么需要封装"><a href="#为什么需要封装" class="headerlink" title="为什么需要封装"></a>为什么需要封装</h3><p>通过封装，可以实现对属性的数据访问限制，同时增加了程序的可维护性。<br>由于取值方法和赋值方法隐藏了实现的变更，因此并不会影响读取或修改该属性的类，避免了大规模的修改，程序的可维护性增强</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>java 语言使用的字符码集是</p>
<ul>
<li>A ASCII</li>
<li>B BCD</li>
<li>C DCB</li>
<li>D Unicode</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>如果int x&#x3D;20, y&#x3D;5，则语句System.out.println(x+y +””+(x+y)+y);  的输出结果是（）</p>
<ul>
<li>A 2530</li>
<li>B 55</li>
<li>C 2052055</li>
<li>D 25255</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>1）不论有什么运算，<strong>小括号的优先级都是最高的</strong>，先计算小括号中的运算，得到x+y +””+25+y<br>2）任何字符与字符串相加都是字符串，但是是有顺序的，字符串前面的按原来的格式相加，字符串后面的都按字符串相加，得到25+””+25+5<br>3）上面的结果按字符串相加得到25255</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>以下哪一项正则能正确的匹配网址: <a href="http://www.bilibili.com/video/av21061574">http://www.bilibili.com/video/av21061574</a> （）</p>
<ul>
<li>A <code>/^(https?:\/\/)?([a-zA-Z\d]+).bilibili.com\/?video\/av(\D&#123;1,8&#125;)\/?$/</code></li>
<li>B <code>/^(http:\/\/)?(\w+)\.bilibili\.com\/?video\/av(\d&#123;1,8&#125;)\/?$/</code></li>
<li>C <code>/^(https?:\/\/)?(\w+)\.bilibili\.com\/?\w*$/</code></li>
<li>D <code>/^(http:\/\/)?([a-zA-Z\d]+).bilibili.com\/?video\/av\w*\/+$/</code></li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下列代码执行结果为（）<br>public static void main(String args[])throws InterruptedException{<br>            Thread t&#x3D;new Thread(new Runnable() {<br>                public void run() {<br>                    try {<br>                        Thread.sleep(2000);<br>                    } catch (InterruptedException e) {<br>                        throw new RuntimeException(e);<br>                    }<br>                    System.out.print(“2”);<br>                }<br>            });<br>            t.start();</p>
<pre><code>        t.join();
        System.out.print(&quot;1&quot;);
    &#125;
</code></pre>
<ul>
<li>A 21</li>
<li>B 12</li>
<li>C 可能为12，也可能为21</li>
<li>D 以上答案都不对</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。</p>
<p>join()可以理解为<strong>先执行</strong>，<code>t.join();</code>可以理解为先执行t线程。则main线程等待</p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>关于继承的说法正确的是（）。</p>
<ul>
<li>A 子类将继承父类所有的数据域和方法。</li>
<li>B 子类将继承父类的其可见的数据域和方法。</li>
<li>C 子类只继承父类public方法和数据域</li>
<li>D 子类只继承父类的方法，而不继承数据域</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>在一个子类被创建的时候，首先会在内存中创建一个父类对象，然后在父类对象外部放上子类独有的属性，两者合起来形成一个子类的对象。所以所谓的继承使子类拥有父类所有的属性和方法其实可以这样理解，子类对象确实拥有父类对象中所有的属性和方法，但是父类对象中的私有属性和方法，子类是无法访问到的，只是拥有，但不能使用。就像有些东西你可能拥有，但是你并不能使用。所以子类对象是绝对大于父类对象的，所谓的子类对象只能继承父类非私有的属性及方法的说法是错误的。<strong>可以继承，只是无法访问到而已</strong>。</p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>ArrayLists和LinkedList的区别，下述说法正确的有？</p>
<ul>
<li>A ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</li>
<li>B 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</li>
<li>C 对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。</li>
<li>D ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。</li>
</ul>
<p>正确答案: ABCD</p>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>Servlet的生命周期可以分为初始化阶段，运行阶段和销毁阶段三个阶段，以下过程属于初始化阶段是（）。</p>
<ul>
<li>A 加载Servlet类及.class对应的数据</li>
<li>B 创建servletRequest和servletResponse对象</li>
<li>C 创建ServletConfig对象</li>
<li>D 创建Servlet对象</li>
</ul>
<p>正确答案: ACD</p>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>Servlet的生命周期一般可以用三个方法来表示：</p>
<ul>
<li>init()：仅执行一次，负责在装载Servlet时初始化Servlet对象</li>
<li>service() ：核心方法，一般HttpServlet中会有get,post两种处理方式。在调用doGet和doPost方法时会构造servletRequest和servletResponse请求和响应对象作为参数。</li>
<li>destory()：在停止并且卸载Servlet时执行，负责释放资源</li>
<li>初始化阶段：Servlet启动，会读取配置文件中的信息，构造指定的Servlet对象，创建ServletConfig对象，将ServletConfig作为参数来调用init()方法。所以选ACD。B是在调用service方法时才构造的</li>
</ul>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年10月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月10日 Java1</title>
    <url>/exam//c0d50785/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>代码 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="number">10</span>%<span class="number">3</span>*<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>将打印？</p>
<ul>
<li>A 1</li>
<li>B 2</li>
<li>C 4</li>
<li>D 6</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p><code>%</code>和<code>*</code>是同一个优先级，从左到右运算</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>对于非运行时异常，程序中一般可不做处理，由java虚拟机自动进行处理。</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>Java异常都继承自类Throwable，Throwable子类有Error和Exception，其中Exception又分为运行时异常和编译时异常。</p>
<ul>
<li>编译时异常是未雨绸缪性质的异常，需要显示处理。</li>
<li>运行时异常是程序员问题造成，并不强制进行显示处理。</li>
</ul>
<p>非运行异常&#x3D;检查异常 需要try catch捕获或者throws抛出</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>如果一个list初始化为{5，3，1}，执行以下代码后，其结果为（）？<br>nums.add(6);<br>nums.add(0,4);<br>nums.remove(1);</p>
<ul>
<li>A [5, 3, 1, 6]</li>
<li>B [4, 3, 1, 6]</li>
<li>C [4, 3, 6]</li>
<li>D [5, 3, 6]</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><ul>
<li>初始化为{5,3,1}</li>
<li>nums.add(6)后list为{5,3,1,6}</li>
<li>nums.add(0,4)是在0号索引上添加数字4得到list为{4,5,3,1,6}</li>
<li>nums.remove(1)是将1号索引上的5进行remove得到list为{4,3,1,6}</li>
</ul>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>给出以下代码 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestObj</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Object o=<span class="keyword">new</span> <span class="title class_">Object</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; </span><br><span class="line">        System.out.println(o.equals(“Fred”));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>请给出结果：（）</p>
<ul>
<li>A 运行时抛出异常</li>
<li>B true</li>
<li>C Fred</li>
<li>D 第三行编译错误</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>本题涉及匿名内部类、多态和覆盖三个知识点。 语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o=<span class="keyword">new</span> <span class="title class_">Object</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>创建了一个匿名内部类，并将所创建的匿名对象赋给 Object (多态：子类对象赋给超类引用)。同时，该匿名内部类重写了 Object<br>类的 equals 方法。<br>在执行语句<br>o.equals(“Fred”)<br>时，根据多态及覆盖原则，会调用匿名内部类重写后的 equals 方法。</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>以下J2EE中常用的名词解释错误的是？</p>
<ul>
<li>A EJB容器：Enterprise java bean 容器</li>
<li>B JNDI：JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。</li>
<li>C JMS：JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。</li>
<li>D JAF：JAVA安全认证框架。提供一些安全控制方面的框架。</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><h3 id="J2EE中常用的名词解释"><a href="#J2EE中常用的名词解释" class="headerlink" title="J2EE中常用的名词解释"></a>J2EE中常用的名词解释</h3><p>1.<strong>web容器</strong>：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接和容器中的环境变量接接口互，不必关注其它系统问题。主要有WEB服务器来实现。例如：TOMCAT,WEBLOGIC,WEBSPHERE等。该容器提供的接口严格遵守J2EE规范中的WEB APPLICATION 标准。我们把遵守以上标准的WEB服务器就叫做J2EE中的WEB容器。<br>2.<strong>Web container</strong>：实现J2EE体系结构中Web组件协议的容器。这个协议规定了一个Web组件运行时的环境，包括安全，一致性，生命周期管理，事务，配置和其它的服务。一个提供和JSP和J2EE平台APIs界面相同服务的容器。一个Web container 由Web服务器或者J2EE服务器提供。<br>3.<strong>EJB容器</strong>：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。一个实现了J2EE体系结构中EJB组件规范的容器。<br>这个规范指定了一个Enterprise bean的运行时环境，包括安全，一致性，生命周期，事务，<br>配置，和其他的服务。<br>4.<strong>JNDI</strong>：（Java Naming &amp; Directory Interface）JAVA命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。<br>5.<strong>JMS</strong>：（Java Message Service）JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。<br>6.<strong>JTA</strong>：（Java Transaction API）JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。<br>7.<strong>JAF</strong>：（Java Action FrameWork）JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。<br>8.<strong>RMI&#x2F;IIOP</strong>:（Remote Method Invocation &#x2F;internet对象请求中介协议）他们主要用于通过远程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。RMI-IIOP出现以前，只有RMI和CORBA两种选择来进行分布式程序设计。RMI-IIOP综合了RMI和CORBA的优点，克服了他们的缺点，使得程序员能更方便的编写分布式程序设计，实现分布式计算。首先，RMI-IIOP综合了RMI的简单性和CORBA的多语言性（兼容性），其次RMI-IIOP克服了RMI只能用于Java的缺点和CORBA的复杂性（可以不用掌握IDL）。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月11日 Java2</title>
    <url>/exam//b61e3d01/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>哪个关键字可以对对象加互斥锁？()</p>
<ul>
<li>A synchronized</li>
<li>B volatile</li>
<li>C serialize</li>
<li>D static</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><p>用来给对象和方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这个段代码。</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>用来确保将变量的跟新操作通知到其他线程，当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。然而，在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比 synchronized关键字更轻量级的同步机制。</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>下面代码的执行结果是 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Chinese</span> <span class="variable">objref</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Chinese</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Chinese</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Chinese <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> objref;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestChinese</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span> &#123;</span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">obj1</span> <span class="operator">=</span> Chinese.getInstance();</span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">obj2</span> <span class="operator">=</span> Chinese.getInstance();</span><br><span class="line">        System.out.println(obj1 == obj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A true</li>
<li>B false</li>
<li>C TRUE</li>
<li>D FALSE</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>这是<strong>饿汉式单例模式</strong>，在类创建时，就已经实例化完成</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>假定Base b &#x3D; new Derived(); 调用执行b.methodOne（）后,输出结果是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodOne</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        methodTwo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodOne</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.methodOne();</span><br><span class="line">        System.out.print(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.methodTwo();</span><br><span class="line">        System.out.print(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A ABDC</li>
<li>B AB</li>
<li>C ABCD</li>
<li>D ABC</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>这是一道类多态的向上转型题。<br>Base b &#x3D; new Derived();<br>向上转型：父类只能调用父类方法或者子类覆写后的方法,而子类中的单独方法则是无法调用的。<br>因此：<br>调用的顺序是：(1)、(2)、(3)、(4)、(5)、(6)、(7) ; 得到的结果是：ABDC</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodOne</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="comment">//执行到这里的时候调用子类的覆盖方法 (4)</span></span><br><span class="line">        methodTwo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// (7)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodOne</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// (2)</span></span><br><span class="line">        <span class="built_in">super</span>.methodOne();</span><br><span class="line">        System.out.print(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该方法为重写了父类的方法 (5)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//(6)</span></span><br><span class="line">        <span class="built_in">super</span>.methodTwo();</span><br><span class="line">        System.out.print(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>java程序内存泄露的最直接表现是( )</p>
<ul>
<li>A 频繁FullGc</li>
<li>B jvm崩溃</li>
<li>C 程序抛内存控制的Exception</li>
<li>D java进程异常消失</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>java是自动管理内存的，通常情况下程序运行到稳定状态，内存大小也达到一个 基本稳定的值<br>但是内存泄露导致Gc不能回收泄露的垃圾，内存不断变大.<br>最终超出内存界限，抛出<strong>OutOfMemoryExpection</strong></p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>在Java中,对于不再使用的内存资源，如调用完成的方法，”垃圾回收器”会自动将其释放。(  )</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>调用方法是在<strong>栈内存</strong>中完成的,调用完成会自动释放,<br>而gc释放的是<strong>堆区</strong>的内容</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下面哪些情况下需要使用抽象类？</p>
<ul>
<li>A 当一个类的一个或多个方法是抽象方法时</li>
<li>B 当类是一个抽象类的子类,并且不能为任何抽象方法提供任何实现细节或方法体时</li>
<li>C 当一个类实现多个接口时</li>
<li>D 当一个类实现一个接口，并且不能为任何抽象方法提供实现细节或方法体时</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>

<p>D:当你不想实现接口中的所有方法，只想实现接口中的个别方法时，你可以先写一个抽象类来实现该接口，并实现除了你想要的方法之外的所有方法(可以简单的将方法体设为空)<br>接着再用你的类继承这个抽象类，这个类中就只用实现你需要的方法了，这样就可以达到你的需要了。<br>如果你直接实现接口的话，你就需要实现接口的所有方法。</p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>下列容器中,哪些容器按 key 查找的复杂度为 O(log(n)) ()</p>
<ul>
<li>A std::unordered_set</li>
<li>B std::multimap</li>
<li>C std::map</li>
<li>D std::deque</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<p>STL库中，map和multimap底层都是红黑树实现的，两者的不同在于multimap允许重复，而map中不行。<br><strong>红黑树的查找复杂度为O(log(n))</strong><br>unodered_map&#x2F;_set底层是哈希表实现的，<strong>哈希表查找复杂度为O(1)</strong></p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>Java.Thread的方法resume()负责重新开始被以下哪个方法中断的线程的执行()。</p>
<ul>
<li>A stop</li>
<li>B sleep</li>
<li>C wait</li>
<li>D suspend</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的 resume() 被调用，才能使得线程重新进入可执行状态</p>
<p><img data-src="https://uploadfiles.nowcoder.com/files/20171113/7172803_1510563467506_20140828202610671" alt="线程状态"></p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月11日 java1</title>
    <url>/exam//eed643bf/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>What will be printed when you execute the following code?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    C() &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">    A() &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    A(String s) &#123;</span><br><span class="line">        System.out.print(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    Test() &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A BB</li>
<li>B CBB</li>
<li>C BAB</li>
<li>D None of the above</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="父类和子类的初始化顺序"><a href="#父类和子类的初始化顺序" class="headerlink" title="父类和子类的初始化顺序"></a>父类和子类的初始化顺序</h3><ol>
<li>父类静态初始化代码，包括静态初始化块，或者静态变量声明。</li>
<li>子类静态初始化代码，包括静态初始化块，或者静态变量声明。</li>
<li>父类实例初始化块</li>
<li>父类构造器</li>
<li>子类实例初始化块</li>
<li>子类构造器</li>
</ol>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>说明输出结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperTest</span> <span class="keyword">extends</span> <span class="title class_">Date</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">super</span>.getClass().getName());</span><br><span class="line">    &#125;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SuperTest</span>().test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>A SuperTest</li>
<li>B SuperTest.class</li>
<li>C test.SuperTest</li>
<li>D test.SuperTest.class</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<ul>
<li>Object的getClass方法是final的,所以TestSuper和Date都不能重写getClass方法。</li>
<li>调用的都是Object的getClass方法，而Object的getClass作用是返回的是<strong>运行时</strong>的类的名字。这个运行时的类就是当前类SuperTest</li>
<li>class对象.getName()的返回返回值为:<code>包名+类名</code></li>
</ul>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>以下说法中正确的有？</p>
<ul>
<li>A StringBuilder是 线程不安全的</li>
<li>B Java类可以同时用 abstract和final声明</li>
<li>C HashMap中,使用 get(key)&#x3D;&#x3D;null可以 判断这个Hasmap是否包含这个key</li>
<li>D volatile关键字不保证对变量操作的原子性</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details>

<ul>
<li>abstract修饰的类是抽象类，是可以继承的，而final修饰的类表示不能再被继承，故肯定不能共同使用。故B错。</li>
<li>HashMap中提供的get(key)获取的是变量，无法判断是否存在key。所以C是错的</li>
<li>volatile关键字是一种轻量级的同步机制，只保证数据的可见性，而不保证数据的原子性。故D对</li>
</ul>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>Java是一门支持反射的语言,基于反射为Java提供了丰富的动态性支持,下面关于Java反射的描述，哪些是错误的:(          )</p>
<ul>
<li>A Java反射主要涉及的类如Class, Method, Filed,等，他们都在java.lang.reflet包下</li>
<li>B 通过反射可以动态的实现一个接口，形成一个新的类，并可以用这个类创建对象，调用对象方法</li>
<li>C 通过反射，可以突破Java语言提供的对象成员、类成员的保护机制，访问一般方式不能访问的成员</li>
<li>D Java反射机制提供了字节码修改的技术，可以动态的修剪一个类</li>
<li>E Java的反射机制会给内存带来额外的开销。例如对永生堆的要求比不通过反射要求的更多</li>
<li>F Java反射机制一般会带来效率问题，效率问题主要发生在查找类的方法和字段对象，因此通过缓存需要反射类的字段和方法就能达到与之间调用类的方法和访问类的字段一样的效率</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ADF</details>

<p>反射指的是在运行时能够分析类的能力的程序。<br>反射机制可以用来：<br>1.Field、Method、Constructor位于java.lang.reflect包中。<strong>Class类在<code>java.lang</code>中</strong>。<br>2.在运行时查看对象。<br>3.实现通用的数组操作代码。</p>
<p>反射机制的功能：<br>在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态代理。<br>反射机制常见作用：<br>动态加载类、动态获取类的信息（属性、方法、构造器）；动态构造对象；动态调用类和对象的任意方法、构造器；动态调用和处理属性；获取泛型信息（新增类型：ParameterizedType,GenericArrayType等）；处理注解（反射API:getAnnotationsdeng等）。<br>反射机制性能问题：<br><strong>反射会降低效率</strong>。<br>void setAccessible(boolean flag):是否启用访问安全检查的开关，true屏蔽Java语言的访问检查，使得对象的私有属性也可以被查询和设置。<strong>禁止安全检查，可以提高反射的运行速度</strong>。<br>可以考虑使用：cglib&#x2F;javaassist操作。</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>在异常处理中,若try中的代码可能产生多种异常则可以对应多个catch语句，若catch中的参数类型有父类子类关系，此时应该将父类放在后面，子类放在前面。</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>如果将父类放在前面的话，异常将被父类完全捕获，子类永远不能捕获异常</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>如何跳出Array的forEach循环？( )</p>
<ul>
<li>A break</li>
<li>B return true</li>
<li>C return false</li>
<li>D 以上都不是</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>foreach循环是for循环的增强版,for循环怎么跳,foreach就怎么跳。<br>这里让人迷惑分点就是这个Array，不要理解成ArrayList的forEach方法。</p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>下列哪个选项是Java调试器？如果编译器返回程序代码的错误,可以用它对程序进行调试。</p>
<ul>
<li>A java.exe</li>
<li>B javadoc.exe</li>
<li>C jdb.exe</li>
<li>D javaprof.exe</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<ul>
<li>javac.exe是编译.java文件</li>
<li>java.exe是执行编译好的.class文件</li>
<li>javadoc.exe是生成Java说明文档</li>
<li>jdb.exe是Java调试器</li>
<li>javaprof.exe是剖析工具</li>
</ul>
<p>jdb是”java debuger”的简写</p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>ResultSet中记录行的第一列索引为？</p>
<ul>
<li>A -1</li>
<li>B 0</li>
<li>C 1</li>
<li>D 以上都不是</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>ResultSet跟普通的数组不同，索引从1开始而不是从0开始</p>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>下列关于final、finally、finalize说法正确的是( )</p>
<ul>
<li>A final可以用来修饰类、方法、变量</li>
<li>B finally是java保证重点代码一定要被执行的一种机制</li>
<li>C 变量被final修饰后不能再指向其他对象,但可以重写</li>
<li>D finalize设计的目的是保证对象在被垃圾收集前完成特定资源的回收</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>

<p>finalize()是Object的方法，子类可以覆盖该方法以实现资源清理工作的目的，GC会在回收对象之前调用该方法<br>final修饰的变量也不能重写(重新赋值)</p>
<h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NameList</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">List</span> <span class="variable">names</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        names.add(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">printAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; names.size();i++)&#123;</span><br><span class="line">            System.out.print(names.get(i) + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">NameList</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NameList</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                    sl.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                    sl.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                    sl.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">                    sl.printAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             .start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Which two statements are true if this class is compiled and run?</p>
<ul>
<li>A An exception may be thrown at runtime.</li>
<li>B The code may run with no output, without exiting.</li>
<li>C The code may run with no output, exiting normally(正常地).</li>
<li>D The code may rum with output “A B A B C C “, then exit.</li>
<li>E The code may rum with output “A B C A B C A B C “, then exit.</li>
<li>F The code may ruin with output “A A A B C A B C C “, then exit.</li>
<li>G The code may ruin with output “A B C A A B C A B C “, then exit.</li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: EG</details>

<p>首先最主要的是，有两条线程在同时进行。</p>
<ul>
<li><strong>线程内的是顺序进行</strong>，</li>
<li><strong>线程之间的顺序不定，可能是交叉执行，也有可能是先执行了一个线程后执行了另一个线程。</strong></li>
</ul>
<p>但是无论怎样，两个线程不可能同时执行一个操作，这就说明<br>执行慢的那个线程s1.println();这行代码将会打印出完整的6个字符的字串（但是两个进程添加顺序不确定，有可能是ABCABC，也有可能最后字串是AABBCC或ABABCC等），这就意味着最后6个字符就是真正的添加顺序。<br>根据逻辑判断，第一次s1.println()结束时，可能两个线程添加都已经添加完，此时第一次s1.println()输出字符最多6个，第二次s1.println()输出字符个数是6个，也就是最多输出12个。<br>最少的情况，也就是s1.println()结束时，只有第一个线程进行了add()操作，此时字符输出最少3个，第二次是6个，也就是9个。<br>也就是输出的字符串个数一定在9~12个之间。所以A、B、C、D排除。<br>所以看选项E的话，最后字串是ABCABC，那第一次s1.println()操作可能在第一个s1.add(“c”)操作结束到第二个s1.add(“c”)操作之间。比如：(ABC)ABCABC、(ABCA)ABCABC、(ABCAB)ABCABC、(ABCABC)ABCABC。这些都是可能的输出，所以G也正确。所以E、G正确<br>而选项F。最后6个字符是BCABCC。首先这不可能，因为虽然添加字符顺序是不确定的，但是确定的是第一个添加的字符肯定是A，并且字符串必须由2个A、2个B、2个C组成。</p>
<p>这题烧脑</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月13日 java1</title>
    <url>/exam//ea239382/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>以下()不是合法的标识符？</p>
<ul>
<li>A <code>STRING</code></li>
<li>B <code>x3x</code></li>
<li>C <code>void</code></li>
<li>D <code>deSf</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>void属于java中的关键字</p>
<ul>
<li><code>Java</code>标识符只能由数字、字母、下划线”_”或”$”符号以及<code>Unicode</code>字符集组成</li>
<li><code>Java</code>标识符必须以字母、下划线”_”或”$”符号以及<code>Unicode</code>字符集开头</li>
<li><code>Java</code>标识符不可以是<code>Java</code>关键字、保留字(<code>const</code>、<code>goto</code>)和字面量(<code>true</code>、<code>false</code>、<code>null</code>)</li>
<li><code>Java</code>标识符区分大小写,是大小写敏感的</li>
</ul>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>在<code>Java</code>中,关于<code>HashMap</code>类的描述,以下错误的是()？</p>
<ul>
<li>A <code>HashMap</code>能够保证其中元素的顺序</li>
<li>B <code>HashMap</code>允许将<code>null</code>用作值</li>
<li>C <code>HashMap</code>允许将<code>null</code>用作键</li>
<li>D <code>HashMap</code>使用键&#x2F;值得形式保存数据</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p><code>HashMap</code>的底层是由数组加链表实现的，对于每一个<code>key</code>值，都需要计算哈希值，然后通过哈希值来确定顺序，并不是按照加入顺序来存放的，因此可以认为是无序的，但不管是有序还是无序，它都一个自己的顺序。故A错。<br>最开始有<code>Hashtable</code>，<code>Hashtable</code>是不允许<code>key</code>和<code>value</code>的值为空的</p>
<p>A.HashMap不能保证元素的顺序，而LinkedHashMap可以保持数据的插入顺序，TreeMap可以按照键值进行排序（可自定比较器）<br>B.HashMap允许存在多条null值<br>C.HashMap允许且仅允许一条null键<br>D.Map就是通过键&#x2F;值形式保存数据的<br>可能有误，仅供参考，欢迎大佬批评指正。<br>HashMap</p>
<p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。<br>HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。<br>HashTable是Java中的遗留类，现在不怎么用了，也许HashTable类的设计者当时认为null作为key 和value 是没有什么用的。</p>
<p>HashMap是之后的版本引进的类，它的接口Map表达的意义更为广泛，也许HashMap的设计者认为null作为key和value是有实际意义的，所以才允许为null.</p>
<p>当然实际项目中，真的是有value为null的情况的。key为null的情况比较少见，但不代表没有。HashMap允许null为key和value应当是类的设计者思考让这个类更有用的设计吧。</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>以下代码结果是什么？<br><code>public class foo</code> {<br><code>public static void main(String sgf[])</code> {<br><code>StringBuffer a=new StringBuffer(&quot;A&quot;)</code>;<br><code>StringBuffer b=new StringBuffer(&quot;B&quot;)</code>;<br><code>operate(a,b)</code>;<br><code>System.out.println(a+&quot;.&quot;+b)</code>;<br>}<br><code>static void operate(StringBuffer x,StringBuffer y)</code> {<br><code>x.append(y)</code>;<br><code>y=x</code>;<br>}<br>}</p>
<ul>
<li>A 代码可以编译运行,输出”<code>AB.AB</code>“。</li>
<li>B 代码可以编译运行,输出”<code>A.A</code>“。</li>
<li>C 代码可以编译运行,输出”<code>AB.B</code>“。</li>
<li>D 代码可以编译运行,输出”<code>A.B</code>“。</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>构造方法用于创建类的实例对象,构造方法名应与类名相同,返回类型为void。</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>构造函数，名称与类相同，没有返回类型的<br>如果”构造器”有返回值，那就说普通方法，而不是构造器</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>以下程序的执行结果是:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">foo</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">    System.out.print(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(foo(<span class="string">&#x27;A&#x27;</span>);foo(<span class="string">&#x27;B&#x27;</span>)&amp;&amp;(i&lt;<span class="number">2</span>);foo(<span class="string">&#x27;C&#x27;</span>))&#123;</span><br><span class="line">        i++;</span><br><span class="line">        foo(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A <code>ABDCBDCB</code></li>
<li>B <code>ABCDABCD</code></li>
<li>C 编译时出错</li>
<li>D 运行时抛出异常</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h3 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h3><ul>
<li>for循环的执行顺序</li>
<li>短路与运算符</li>
</ul>
<h4 id="for循环格式"><a href="#for循环格式" class="headerlink" title="for循环格式"></a>for循环格式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化语句; 布尔表达式; 更新语句) &#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="for循环执行顺序"><a href="#for循环执行顺序" class="headerlink" title="for循环执行顺序"></a>for循环执行顺序</h4><ol>
<li><strong>初始化语句</strong>, 仅在循环开始前执行一次;</li>
<li><strong>布尔表达式</strong>, 用于决定是否继续执行正文过程, 表达式中异常则结束循环;</li>
<li><strong>循环体</strong>, 如果过程中存在break, return或者异常, 循环结束(不会执行更新语句), 如果遇到continue, 则会执行更新语句后进入下一轮循环;</li>
<li><strong>更新语句</strong>, 注意更新语句不做逻辑真假判断, 到这里一轮循环结束;</li>
</ol>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下列说法正确的是( )</p>
<ul>
<li>A <code>volatile</code>,<code>synchronized</code> 都可以修改变量,方法以及代码块</li>
<li>B <code>volatile</code>,<code>synchronized</code> 在多线程中都会存在阻塞问题</li>
<li>C <code>volatile</code>能保证数据的可见性,但不能完全保证数据的原子性,<code>synchronized</code>即保证了数据的可见性也保证了原子性</li>
<li>D <code>volatile</code>解决的是变量在多个线程之间的可见性、原子性,而<code>sychroized</code>解决的是多个线程之间访问资源的同步性</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h3 id="synchronized关键字和volatile关键字比较"><a href="#synchronized关键字和volatile关键字比较" class="headerlink" title="synchronized关键字和volatile关键字比较"></a>synchronized关键字和volatile关键字比较</h3><ul>
<li>volatile关键字是线程同步的<strong>轻量级</strong>实现，所以<strong>volatile性能肯定比synchronized关键字要好</strong>。</li>
<li>但是<strong>volatile关键字只能用于变量</strong>而<strong>synchronized关键字可以修饰方法以及代码块</strong>。</li>
<li>synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。</li>
<li>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</li>
<li>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</li>
<li>volatile关键字主要用于解决<code>变量</code>在多个线程之间的<code>可见性</code>，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<p>synchronized: 具有原子性，有序性和可见性；（三个都有）<br>volatile：具有有序性和可见性（缺一个原子性）</p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>经过强制类型转换以后,变量a, b的值分别为( )short a &#x3D; 128; byte b &#x3D; (byte) a;</p>
<ul>
<li>A 128 127</li>
<li>B 128 -128</li>
<li>C 128 128</li>
<li>D 编译错误</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>byte在内存中占一个字节，范围是 -128到127之间。<br>java中short占用2bytes，强转short类型为byte，会将多出的高8位进行截断，short类型的 128的补码：0000 0000 1000 0000，强转为byte后的补码：1000 0000,最高位是符号位，</p>
<p>这样就表示-0，但是注意，没有-0，只有0，为了充分利用资源，java就将原来本应该表示“-0”的原码<strong>规定</strong>为-128，故结果为-128，类型也就能够表示的范围是-128。</p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>以下JAVA程序代码的输出是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">14</span>^<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 2744</li>
<li>B 13</li>
<li>C 17</li>
<li>D 11</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>^表示异或 就是相同是0 不同是1<br>14是1110<br>3是0011<br>所以14^3&#x3D;1101，即13</p>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>下面这条语句一共创建了多少个对象:String s&#x3D;”welcome”+”to”+360;</p>
<ul>
<li>A 1</li>
<li>B 2</li>
<li>C 3</li>
<li>D 4</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h3 id="编译器对直接量的优化"><a href="#编译器对直接量的优化" class="headerlink" title="编译器对直接量的优化"></a>编译器对直接量的优化</h3><p>“welcome”，”to”，360这三个都是<strong>直接量</strong>,直接量的连接在编译阶段就可以确定下来。编译器会将其优化成”welcometo360”，也就是只有一个对象。<br>字符串直接量的连接只生成一个对象</p>
<h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>Java 提供的事件处理模型是一种人机交互模型。它有三个基本要素</p>
<ul>
<li>A 事件源</li>
<li>B 事件对象</li>
<li>C 事件过程</li>
<li>D 事件监听器</li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>

<p>Java提供的事件处理模型是一种人机交互模型。它有三个基本要素：</p>
<ol>
<li>事件源(Event Source):即事件发生的场所,就是指各个组件,如按钮等,点击按钮其实就是组件上发生的一个事件;</li>
</ol>
<p>2)事件(Event):事件封装了组件上发生的事情,比如按钮单击、按钮松开等等;<br>3) 事件监听器(Event Listener):负责监听事件源上发生的特定类型的事件,当事件到来时还必须负责处理相应的事件;</p>
<h1 id="考点11"><a href="#考点11" class="headerlink" title="考点11"></a>考点11</h1><p>常用的servlet包的名称是？</p>
<ul>
<li>A <code>java.servlet</code></li>
<li>B <code>javax.servlet</code></li>
<li>C <code>servlet.http</code></li>
<li>D <code>javax.servlet.http</code></li>
</ul>
<h2 id="解析-10"><a href="#解析-10" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BD</details>

<p><code>JEE5.0</code>中的<code>Servlet</code>相关的就下面这几个包:</p>
<ul>
<li><code>javax.servlet</code></li>
<li><code>javax.servlet.jsp</code></li>
<li><code>java.servlet.jsp.el</code></li>
<li><code>java.servlet.jsp.tagext</code></li>
</ul>
<p>而最用得多的就是<br><code>javax.servlet</code><br><code>javax.servlet.http</code><br>这两个包了.</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月14日 java1</title>
    <url>/exam//8ff88fb/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System. out. println(<span class="string">&quot;Value is&quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面这段代码,以下说法正确的是:<br>A 程序会打出 “Value is 0”<br>B 程序会抛出 NullPointerException<br>C 非静态变量不能够被静态方法引用<br>D 编译器会抛出 “possible reference before assignment”的错误</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>main方法是静态方法，静态成员不能访问非静态成员。</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>下列哪个说法是正确的()</p>
<ul>
<li>A <code>ConcurrentHashMap</code>使用<code>synchronized</code>关键字保证线程安全</li>
<li>B <code>HashMap</code>实现了<code>Collction</code>接口</li>
<li>C <code>Array.asList</code>方法返回<code>java.util.ArrayList</code>对象</li>
<li>D <code>SimpleDateFormat</code>是线程不安全的</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>A选项中，ConcurrentHashMap<br>使用segment来分段和管理锁，segment继承自ReentrantLock，因此<strong>ConcurrentHashMap使用ReentrantLock来保证线程安全</strong>。<br>B中，HashMap定义规则如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>
<p>C中，应该是Arrays.asList()，其将一个数组转化为一个List对象，这个方法会返回一个ArrayList类型的对象，<br>这个ArrayList类并非java.util.ArrayList类，而是Arrays类的内部类</p>
<p><strong>java并发集合</strong>有不懂有空了解一下</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>关于匿名内部类叙述正确的是？ ( )</p>
<ul>
<li>A 匿名内部类可以继承一个基类,不可以实现一个接口</li>
<li>B 匿名内部类不可以定义构造器</li>
<li>C 匿名内部类不能用于形参</li>
<li>D 以上说法都不正确</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="匿名内部类不能有构造器"><a href="#匿名内部类不能有构造器" class="headerlink" title="匿名内部类不能有构造器"></a>匿名内部类不能有构造器</h3><p>由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器。</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>下列关于构造方法的叙述中,错误的是()</p>
<ul>
<li>A <code>java</code>语言规定构造方法名与类名必须相同</li>
<li>B <code>java</code>语言规定构造方法没有返回值,但不同<code>void</code>声明</li>
<li>C <code>java</code>语言规定构造方法不可以重载</li>
<li>D <code>java</code>语言规定构造方法只能通过<code>new</code>自动调用</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: CD</details>

<p>构造方法除了 new 关键字调用外，还可以通过如下方式调用</p>
<ul>
<li>反射</li>
<li>反序列化</li>
<li>this调用</li>
<li>super调用</li>
</ul>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下面哪些具体实现类可以用于存储键,值对,并且方法调用提供了基本的多线程安全支持:(  )</p>
<ul>
<li>A <code>java.util.ConcurrentHashMap</code></li>
<li>B <code>java.util.Map</code></li>
<li>C <code>java.util.TreeMap</code></li>
<li>D <code>java.util.SortMap</code></li>
<li>E <code>java.util.Hashtable</code></li>
<li>F <code>java.util.HashMap</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AE</details>

<p>线程安全的类有</p>
<ul>
<li>hashtable</li>
<li>concurrentHashMap </li>
<li>synchronizedMap</li>
</ul>
<p>有空了解一下</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>关于Java中的ClassLoader下面的哪些描述是错误的:(    )</p>
<ul>
<li>A 默认情况下,<code>Java</code>应用启动过程涉及三个<code>ClassLoader: Boostrap, Extension, System</code></li>
<li>B 一般的情况不同<code>ClassLoader</code>装载的类是不相同的,但接口类例外,对于同一接口所有类装载器装载所获得的类是相同的</li>
<li>C 类装载器需要保证类装载过程的线程安全</li>
<li>D <code>ClassLoader</code>的<code>loadClass</code>在装载一个类时,如果该类不存在它将返回<code>null</code></li>
<li>E <code>ClassLoader</code>的父子结构中,默认装载采用了父优先</li>
<li>F 所有<code>ClassLoader</code>装载的类都来自<code>CLASSPATH</code>环境指定的路径</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BDF</details>

<p>反射相关的内容，有空了解一下</p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>class A {}<br>class B extends A {}<br>class C extends A {}<br>class D extends B {}<br>Which four statements are true ?</p>
<ul>
<li>A <code>The type List&lt;A&gt;is assignable to List.</code></li>
<li>B <code>The type List&lt;B&gt;is assignable to List&lt;A&gt;.</code></li>
<li>C <code>The type List&lt;Object&gt;is assignable to List</code>&lt;?&gt;.</li>
<li>D <code>The type List&lt;D&gt;is assignable to List</code>&lt;?<code>extends B&gt;.</code></li>
<li>E <code>The type List</code>&lt;?<code>extends A&gt;is assignable to List&lt;A&gt;.</code></li>
<li>F <code>The type List&lt;Object&gt;is assignable to any List reference.</code></li>
<li>G <code>The type List</code>&lt;?<code>extends B&gt;is assignable to List</code>&lt;?<code>extends A&gt;.</code></li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACDG</details>

<p>泛型相关的内容，有空了解一下</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月14日 java2</title>
    <url>/exam//91f6d941/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>有关线程的叙述正确的是()</p>
<ul>
<li>A 可以获得对任何对象的互斥锁定。</li>
<li>B 通过继承<code>Thread</code>类或实现<code>Runnable</code>接口,可以获得对类中方法的互斥锁定。</li>
<li>C 线程通过使用<code>synchronized</code>关键字可获得对象的互斥锁定。</li>
<li>D 线程的创建只能通过继承<code>Thread</code>类来实现。</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>采用<code>synchronized</code>修饰符实现的同步机制叫做互斥锁机制，它所获得的锁叫做互斥锁。<br>每个对象都有一个<code>monitor</code>(锁标记)，当线程拥有这个锁标记时才能访问这个资源，没有锁标记便进入<strong>锁池</strong>。<br>任何一个对象系统都会为其创建一个互斥锁，这个锁是为了分配给线程的，防止打断原子操作。每个对象的锁只能分配给一个线程，因此叫做<strong>互斥锁</strong>。</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>设int x&#x3D;1,float y&#x3D;2,则表达式x&#x2F;y的值是:()</p>
<ul>
<li>A 0</li>
<li>B 1</li>
<li>C 2</li>
<li>D 以上都不是</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>直接量2是int类型，可以自动转成float类型<br>表达式的计算结果的类型为操作数中范围最大的<br>x&#x2F;y的结果为float类型，等于0.5</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>java接口的方法修饰符可以为？(忽略内部接口)</p>
<ul>
<li>A <code>private</code></li>
<li>B <code>protected</code></li>
<li>C <code>final</code></li>
<li>D <code>abstract</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>接口方法默认public abstract</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>java中提供了哪两种用于多态的机制</p>
<ul>
<li>A 通过子类对父类方法的覆盖实现多态</li>
<li>B 利用重载来实现多态.即在同一个类中定义多个同名的不同方法来实现多态。</li>
<li>C 利用覆盖来实现多态.即在同一个类中定义多个同名的不同方法来实现多态。</li>
<li>D 通过子类对父类方法的重载实现多态</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AB</details>

<p>多态分为 编译时多态 和 运行时多态 。<br>其中 编辑时多态是静态的 ， 主要是指方法的重载 ，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。<br>而 运行时多态是动态的 ，它是 通过动态绑定来实现的 ，也就是我们所说的多态性(要有继承关系 2.子类要重写父类的方法 3.父类引用指向子类)</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下列哪个选项是错误的。()</p>
<ul>
<li>A 一个文件中只能有一个<code>public class</code>。</li>
<li>B 一个文件中可以有多个类。</li>
<li>C 一个类中可以有两个<code>main</code>方法。</li>
<li>D 若类中只含一个<code>main</code>方法,则必须是<code>public</code>的。</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details>

<p>A.一个文件中，可以有多个public class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即，<strong>外部类为public，还可以有public的内部类</strong>。<br>B.一个文件中可以有多个类，可以是多个并列的类，也可以是外部类、内部类结合。<br>C.一个类中，可以有多个main方法，这是重载，但是<br><code>public static void main(String[] args)</code><br>的方法只能有一个。<br>D.类中，可以有main方法，也可以没有main方法，而有一个main()方法的时候，也可以是任意访问权限。因为这个类不一定要执行，可以只是辅助类。</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下面有关java threadlocal说法正确的有？</p>
<ul>
<li>A <code>ThreadLocal</code>存放的值是线程封闭,线程间互斥的,主要用于线程内共享一些数据,避免通过参数来传递</li>
<li>B 线程的角度看,每个线程都保持一个对其线程局部变量副本的隐式引用,只要线程是活动的并且 <code>ThreadLocal</code> 实例是可访问的;在线程消失之后,其线程局部实例的所有副本都会被垃圾回收</li>
<li>C 在<code>Thread</code>类中有一个<code>Map</code>,用于存储每一个线程的变量的副本。</li>
<li>D 对于多线程资源共享的问题,同步机制采用了”以时间换空间”的方式,而<code>ThreadLocal</code>采用了”以空间换时间”的方式</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>

<p>有空了解一下</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月15日 java1</title>
    <url>/exam//e73de3c5/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>要表示10个学生的成绩,下列声明并初始化数组正确的是()</p>
<ul>
<li>A <code>int[] score=new int[ ]</code></li>
<li>B <code>int score[10]</code></li>
<li>C <code>int score[]=new int[9]</code></li>
<li>D <code>int score[]=new int[10]</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>以下两种写法都可以：<br>int score[] &#x3D; new int[10];<br>int[] score &#x3D; new int[10];</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>下面有关java基本类型的默认值和取值范围,说法错误的是？</p>
<ul>
<li>A 字节型的类型默认值是0,取值范围是-2^7—2^7-1</li>
<li>B <code>boolean</code>类型默认值是<code>false</code>,取值范围是<code>true</code>`false&#96;</li>
<li>C 字符型类型默认是0,取值范围是-2^15 —2^15-1</li>
<li>D <code>long</code>类型默认是0,取值范围是-2^63—2^63-1</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>关于下列程序段的输出结果,说法正确的是:( ) </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String argv[])</span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 有错误,变量i没有初始化。</li>
<li>B <code>null</code></li>
<li>C 1</li>
<li>D 0</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>成员变量会默认初始化<br>静态成员可以访问静态成员</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>java中下面哪个能创建并启动线程()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="comment">//some code here </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A <code>new Runnable(MyRunnable).start()</code></li>
<li>B <code>new Thread(MyRunnable).run()</code></li>
<li>C <code>new Thread(new MyRunnable()).start()</code></li>
<li>D <code>new MyRunnable().start()</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>list是一个ArrayList的对象,哪个选项的代码填到&#x2F;&#x2F;todo delete处,可以在Iterator遍历的过程中正确并安全的删除一个list中保存的对象？()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> it.next();</span><br><span class="line">    <span class="comment">//needDelete返回boolean,决定是否要删除  </span></span><br><span class="line">    <span class="keyword">if</span> (needDelete(obj))&#123;</span><br><span class="line">        <span class="comment">//todo delet</span></span><br><span class="line">        e</span><br><span class="line">    &#125;</span><br><span class="line">    index ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A it.remove();<br>B list.remove(obj);<br>C list.remove(index);<br>D list.remove(obj,index);</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>Iterator 支持从源集合中安全地删除对象，只需在 Iterator 上调用 remove() 即可。这样做的好处是可以避免 ConcurrentModifiedException ，当打开 Iterator 迭代集合时，同时又在对集合进行修改。有些集合不允许在迭代时删除或添加元素，但是调用 Iterator 的remove() 方法是个安全的做法。</p>
<h3 id="在循环中调用List的remove方法出现的问题"><a href="#在循环中调用List的remove方法出现的问题" class="headerlink" title="在循环中调用List的remove方法出现的问题"></a>在循环中调用List的remove方法出现的问题</h3><p>如果在循环的过程中调用集合的remove()方法，就会导致循环出错，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">    list.remove(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环过程中list.size()的大小变化了，就导致了错误。</p>
<p>所以，如果你想在循环语句中删除集合中的某个元素，就要用迭代器iterator的remove()方法，因为它的remove()方法不仅会删除元素，还会维护一个标志，用来记录目前是不是可删除状态，例如，你不能连续两次调用它的remove()方法，调用之前至少有一次next()方法的调用。</p>
<h3 id="正确使用List的remove方法删除元素的写法"><a href="#正确使用List的remove方法删除元素的写法" class="headerlink" title="正确使用List的remove方法删除元素的写法"></a>正确使用List的remove方法删除元素的写法</h3><p>for循环删除问题，如果真想用，可以这样，既不出错，也能正确删除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">    list.remove(i);</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> String x=<span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> y=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> z=<span class="number">2</span>;</span><br><span class="line">        System.out.println(x+y+z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>关于下面的程序Test.java说法正确的是(    )。</p>
<ul>
<li>A 3</li>
<li>B 112</li>
<li>C 13</li>
<li>D 程序有编译错误</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h3 id="static不能修饰局部变量"><a href="#static不能修饰局部变量" class="headerlink" title="static不能修饰局部变量"></a>static不能修饰局部变量</h3><p>被static修饰的变量称为静态变量，静态变量属于整个类，而局部变量属于方法，只在该方法内有效，所以<strong>static不能修饰局部变量</strong></p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>下面代码的运行结果为:()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">foo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">        String s;</span><br><span class="line">        System.out.println(<span class="string">&quot;s=&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 代码得到编译,并输出”s&#x3D;”</li>
<li>B 代码得到编译,并输出”<code>s=null</code>“</li>
<li>C 由于<code>String s</code>没有初始化,代码不能编译通过</li>
<li>D 代码得到编译,但捕获到 <code>NullPointException</code>异常</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h3 id="局部变量不会默认初始化"><a href="#局部变量不会默认初始化" class="headerlink" title="局部变量不会默认初始化"></a>局部变量不会默认初始化</h3><p>局部变量可以先声明不用必须初始化，但使用局部变量之前一定要先初始化。</p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>Java语言中,下面哪个语句是创建数组的正确语句？(     )</p>
<ul>
<li>A <code>float f[][] = new float[6][6];</code></li>
<li>B <code>float []f[] = new float[6][6];</code></li>
<li>C <code>float f[][] = new float[][6];</code></li>
<li>D <code>float [][]f = new float[6][6];</code></li>
<li>E <code>float [][]f = new float[6][];</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABDE</details>

<h3 id="二维数组变量和两个中括号可以全排列"><a href="#二维数组变量和两个中括号可以全排列" class="headerlink" title="二维数组变量和两个中括号可以全排列"></a>二维数组变量和两个中括号可以全排列</h3><h3 id="二维数组的一维长度必须确定"><a href="#二维数组的一维长度必须确定" class="headerlink" title="二维数组的一维长度必须确定"></a>二维数组的一维长度必须确定</h3><p>二维数组定义时，一维的长度必须定义，二维可以后续定义</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月15日 java2</title>
    <url>/exam//7e34b27f/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>已知表达式int m[]&#x3D;{0,1,2,3,4,5,6};下面哪个表达式的值与数组下标量最大值相等？</p>
<ul>
<li>A <code>m. length()</code></li>
<li>B <code>m. length-1</code></li>
<li>C <code>m. length()+1</code></li>
<li>D <code>m. length+1</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<table>
<thead>
<tr>
<th align="left">获取长度的方式</th>
<th align="left">数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>length</code>属性</td>
<td align="left">数组</td>
</tr>
<tr>
<td align="left"><code>length()</code></td>
<td align="left">String&#96;</td>
</tr>
<tr>
<td align="left"><code>size()</code></td>
<td align="left">集合</td>
</tr>
</tbody></table>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>与未加访问控制符的缺省情况相比,public和protected修饰符扩大了属性和方法的被访问范围,private修饰符则缩小了这种范围。</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>区分类中重载方法的依据是(    )。</p>
<ul>
<li>A 不同的形参名称</li>
<li>B 不同的返回值类型</li>
<li>C 不同的形参列表</li>
<li>D 不同的访问权限</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>字符界面下接受用户从键盘输入,需要import的包是:( )</p>
<ul>
<li>A <code>java.lang</code>包</li>
<li>B <code>java.awt</code>包</li>
<li>C <code>java.io</code>包</li>
<li>D <code>java.applet</code>包</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下面哪个Set类是排序的？</p>
<ul>
<li>A <code>LinkedHashSet</code></li>
<li>B <code>TreeSet</code></li>
<li>C <code>HashSet</code></li>
<li>D <code>AbstractSet</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<ul>
<li>TreeSet排序，</li>
<li>LinkedHashSet有序。</li>
</ul>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下列关于Java并发的说法中正确的是()</p>
<ul>
<li>A <code>CopyOnWriteArrayList</code>适用于写多读少的并发场景</li>
<li>B <code>ReadWriteLock</code>适用于读多写少的并发场景</li>
<li>C <code>ConcurrentHashMap</code>的写操作不需要加锁,读操作需要加锁</li>
<li>D 只要在定义<code>int</code>类型的成员变量i的时候加上<code>volatile</code>关键字,那么多线程并发执行i++这样的操作的时候就是线程安全的了</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>A，CopyOnWriteArrayList适用于<strong>写少读多</strong>的并发场景<br>B，ReadWriteLock即为读写锁，他要求<strong>写与写之间互斥，读与写之间互斥</strong>，<br>   读与读之间可以并发执行。在读多写少的情况下可以提高效率<br>C，ConcurrentHashMap是同步的HashMap，<strong>读写都加锁</strong><br>D，volatile只保证多线程操作的可见性，不保证原子性</p>
<p>有空了解一下</p>
<p>CopyOnWrite指的是修改容器之前，先将原来的容器拷贝一份副本，在副本中进行修改，修改之后使用原来的容器指向修改好的容器，这样保证了两个容器可以同时读，用于<strong>读多于写</strong>的场景</p>
<p>volatile变量自身具有以下特性：1。可见性2.原子性：对任意单个volatile变量的读写具有原子性，但类似i++这种复合操作或者多个volatile操作不具有原子性</p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>由3 个”1”和 5 个”0”组成的 8 位二进制补码,能表示的最小整数()</p>
<ul>
<li>A -126</li>
<li>B -125</li>
<li>C -32</li>
<li>D -3</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>一个1作为符号位，表示负数，剩下两个1,最大值是3，-(128-3)＝-125</p>
<p>既然求最小整数，那肯定先想到负数，则最高位（符号位）一定为1，原码中肯定是1所在的位数越高，值越小，而补码是由原码取反加1得到的，则在补码中1所在的位数一定要越低，即补码为1000 0011；由补码求得原码：1111 1101&#x3D;-(64+32+16+8+4+1)&#x3D;-125;</p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>下列Java代码中的变量a、b、c分别在内存的____存储区存放。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;bb&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;cc&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 堆区、堆区、堆区</li>
<li>B 堆区、栈区、堆区</li>
<li>C 堆区、栈区、栈区</li>
<li>D 堆区、堆区、栈区</li>
<li>E 静态区、栈区、堆区</li>
<li>F 静态区、栈区、栈区</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<ul>
<li>a是类中的成员变量，存放在堆区</li>
<li>b、c都是方法中的局部变量，存放在栈区</li>
</ul>
<p>堆区:只存放类对象,线程共享;<br>方法区:又叫静态存储区,存放class文件和静态数据,线程共享;<br>栈区:存放方法局部变量,基本类型变量区、执行环境上下文、操作指令区,线程不共享;</p>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>Consider the following code:<br>Integer s&#x3D;new Integer(9);<br>Integer t&#x3D;new Integer(9);<br>Long u&#x3D;new Long(9);<br>Which test would return true?</p>
<ul>
<li>A <code>(s==u)</code></li>
<li>B <code>(s==t)</code></li>
<li>C <code>(s.equals(t))</code></li>
<li>D <code>(s.equals(9))</code></li>
<li>E <code>(s.equals(new Integer(9))</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: CDE</details>

<p>B关于s&#x3D;&#x3D;t，添加一点说明：<br>当Integer的值在-128~127之间时，使用拆箱方式创建Integer对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line">Integer i=<span class="number">9</span>; </span><br><span class="line"><span class="comment">//手动拆箱</span></span><br><span class="line">Integer j=Integer.valueOf(<span class="number">9</span>);</span><br></pre></td></tr></table></figure>
<p>得到的对象使用&#x3D;&#x3D;会得到true。<br>而使用new Integer()方式创建的对象，使用&#x3D;&#x3D;会得到false。<br>当Integer的值不在这个范围内时，无论以何种方式创建两个Integer对象，使用&#x3D;&#x3D;都会是false。</p>
<h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>判断一块内存空间是否符合垃圾收集器收集的标准有哪些？</p>
<ul>
<li>A 给对象赋予了空值<code>null</code>,以下再没有调用过</li>
<li>B 对象重新分配了内存空间</li>
<li>C 给对象赋予了空值<code>null</code></li>
<li>D 给对象赋予了新值</li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>

<p>在java语言中，判断一块内存空间是否符合垃圾收集器收集标准的标准只有两个：<br>1.给对象赋值为null，以下没有调用过。<br>2.给对象赋了新的值，重新分配了内存空间。</p>
<p>一块内存空间符合了垃圾收集器的收集标准，并不意味着这块内存空间就一定会被垃圾收集器收集。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月15日 java3</title>
    <url>/exam//93382e9/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>执行下列代码的输出结果是( )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(test(num));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            b += <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(RuntimeException e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e2)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            b += <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 10</li>
<li>B 20</li>
<li>C 30</li>
<li>D 40</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>如果finally块中有return语句的话，它将覆盖掉try或者catch语句中其他return语句。</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>给出以下代码,请给出结果.<br>class Two{<br>    Byte x;<br>}<br>class PassO{<br>    public static void main(String[] args){<br>        PassO p&#x3D;new PassO();<br>        p.start();<br>    }<br>    void start(){<br>        Two t&#x3D;new Two();<br>        System.out.print(t.x+””);<br>        Two t2&#x3D;fix(t);<br>        System.out.print(t.x+” “ +t2.x);<br>    }<br>    Two fix(Two tt){<br>        tt.x&#x3D;42;<br>        return tt;<br>    }<br>}</p>
<ul>
<li>A <code>null null 42</code></li>
<li>B <code>null 42 42</code></li>
<li>C 0 0 42</li>
<li>D 0 42 42</li>
<li>E <code>An exception is thrown at runtime</code></li>
<li>F <code>Compilation</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>成员变量会默认初始化。<br>Byte是byte的包装类型，初始化为null而不是0</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>以下关于对象序列化描述正确的是</p>
<ul>
<li>A 使用<code>FileOutputStream</code>可以将对象进行传输</li>
<li>B 使用<code>PrintWriter</code>可以将对象进行传输</li>
<li>C 使用<code>transient</code>修饰的变量不会被序列化</li>
<li>D 对象序列化的所属类需要实现<code>Serializable</code>接口</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: CD</details>

<p>使用ObjectOutputStream和ObjectInputStream可以将对象进行传输.</p>
<h3 id="什么是对象序列化"><a href="#什么是对象序列化" class="headerlink" title="什么是对象序列化"></a>什么是<code>对象</code>序列化</h3><p>Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能。</p>
<p>使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，<strong>对象序列化保存的是</strong><code>对象</code>的”状态”，即它的成员变量<strong>。<br>由此可知，</strong>对象序列化不会关注类中的静态变量**。</p>
<p>A、B：使用ObjectInputStream和ObjectoutputStream进行对象的传输<br>注意：<br>1.基本数据类型的变量可以直接序列化<br>2.对象要被序列化，它的类必须实现Serializable接口，如果一个类中有引用类型的变量，这个引用类型的变量的类也必须实现Serializable接口。如果这个引用类型的变量不想被实例化，则用transient修饰（ObjectInputStream）</p>
<h3 id="对象序列化只能保存对象的数据"><a href="#对象序列化只能保存对象的数据" class="headerlink" title="对象序列化只能保存对象的数据"></a>对象序列化只能保存对象的数据</h3><p>而static代表类的状态， transient代表对象的临时数据。<br>所以声明为static和transient类型的成员数据不能被序列化。</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>What might cause the current thread to stop or pause executing</p>
<ul>
<li>A An InterruptedException is thrown.</li>
<li>B The thread executes a wait() call.</li>
<li>C The thread constructs a new Thread.</li>
<li>D A thread of higher priority becomes ready.</li>
<li>E The thread executes a waitforID()call on a MediaTracker.</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABE</details>

<p>题目:什么操作会使得当前线程停止。<br>A:一个InterruptedException 异常被捕获  大家都知道的嘛 (一般通过interrupt方法 中断线程)  如果抓到一个线程  都会关紧catch里面 然后中断当前操作,A正确。<br>B:线程执行了wait()方法。   线程使用了wait方法,会强行打断当前操作,(暂停状态,不会中断线程) 进入阻塞(暂停)状态,然后需要notify方法或notifyAll方法才能进入就绪状态。 B 正确。<br>C:当前线程创建了一个新的线程。   新创建的线程不会抢占时间片,只有等当前线程把时间片用完,其他线程才有资格拿到时间片去执行。<br>D:一个高优先级别的线程就绪。  如C相同,你优先级别再高 也待等我现在弄完才会给你。(就像我们玩游戏,会员虽然有排队优先权,但是还是要等正在登陆的用户进去游戏之后才能抢到他原来那个位置,不能说我在过关卡的过程中你一脚把我踢开,然后霸占我的位置吧,我原来的那些数据咋办!!!)<br>E:线程在MediaTracker上执行了waitforID()调用。<br>这个应该大家也不太熟悉。这个类是awt里面的,我查API才知道。<br>然后他的功能是加载图像,直到完成之前,该方法一直等待!这个方法是必须要抛出A选项的InterruptedException 异常的  说明这玩意会让其他线程 wait他完成!   所以会暂停当前线程</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下面哪些描述是正确的:(  )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> B ref;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">(B b)</span> &#123;</span><br><span class="line">            ref = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class B &#123;</span><br><span class="line">        <span class="keyword">private</span> A ref;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(A a)</span> &#123;</span><br><span class="line">            ref = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        …start();</span><br><span class="line">        ….</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        a.setB(b);</span><br><span class="line">        b = <span class="literal">null</span>;</span><br><span class="line">         <span class="comment">//a = null;</span></span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A <code>b = null</code>执行后b可以被垃圾回收</li>
<li>B <code>a = null</code>执行后b可以被垃圾回收</li>
<li>C <code>a = null</code>执行后a可以被垃圾回收</li>
<li>D <code>a,b</code>必须在整个程序结束后才能被垃圾回收</li>
<li>E 类A和类B在设计上有循环引用,会导致内存泄露</li>
<li>F <code>a, b</code> 必须在<code>start</code>方法执行完毕才能被垃圾回收</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<p>内存如下：<br>a -&gt; “a(b)”<br>b -&gt; “b”<br>a引用指向一块空间，这块空间里面包含着b对象<br>b引用指向一块空间，这块空间是b对象<br>A选项，b &#x3D; null执行后b可以被垃圾回收。这里”b可以被垃圾回收”中的b指的是引用b指向的内存。这块内存即使不被引用b指向，还是被引用a指向着，不会被回收。<br>B选项，a &#x3D; null执行后b可以被垃圾回收。从代码中可以看到，a &#x3D; null是在b &#x3D; null后执行的，该行执行后，引用a和b都没有指向对象，对象会被回收。</p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>对 Map 的用法,正确的有:</p>
<ul>
<li>A <code>new java.util.Map().put(&quot;key&quot; , &quot;value&quot;) ;</code></li>
<li>B <code>new java.util.SortedMap().put(&quot;key&quot; , &quot;value&quot;) ;</code></li>
<li>C <code>new java.util.HashMap().put( null , null ) ;</code></li>
<li>D <code>new java.util.TreeMap().put( 0 , null ) ;</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: CD</details>

<h3 id="接口不能new"><a href="#接口不能new" class="headerlink" title="接口不能new"></a>接口不能new</h3><p>A选项Map属于<strong>接口</strong>类型，不可以new的方式创建对象。所以A错误。<br>B选项SortedMap属于<strong>接口</strong>类型，不可以new的方式创建对象。所以B错误。</p>
<h3 id="TreeMap的key不能为null"><a href="#TreeMap的key不能为null" class="headerlink" title="TreeMap的key不能为null"></a>TreeMap的key不能为null</h3><p>C选项HashMap基于哈希表实现Map接口的类，并允许null的值和null键。<br>D选项TreeMap通过红黑树实现Map接口的类，<strong>key不可以为null</strong>，会报NullPointerException异常,value可以为null。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月16日 java1</title>
    <url>/exam//c0a58c6/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>Java的Daemon线程,setDaemon( )设置必须要？</p>
<ul>
<li>A 在<code>start</code>之前</li>
<li>B 在<code>start</code>之后</li>
<li>C 前后都可以</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>setDaemon()方法必须在线程启动之前调用，当线程正在运行时调用会产生异常。</p>
<h3 id="java中线程分类"><a href="#java中线程分类" class="headerlink" title="java中线程分类"></a>java中线程分类</h3><ul>
<li>前台线程。通过Thread.setDaemon(false)设置为前台线程;</li>
<li>守护线程。通过Thread.setDaemon(true)设置为守护线程</li>
</ul>
<p>前台线程创建的线程默认就是前台线程。</p>
<p>多线程方面的需要加强<br>有空了解一下</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>在java7中,下列不能做switch()的参数类型是？</p>
<ul>
<li>A <code>int</code>型</li>
<li>B 枚举类型</li>
<li>C 字符串</li>
<li>D 浮点型</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>switch支持：</p>
<ul>
<li>支持小于等于int的类型（byte,short,char,int），</li>
<li>不支持八大基础数据类型中的boolean,long,float,double</li>
<li>支持枚举类型</li>
<li>java7开始支持支持String类型</li>
</ul>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>在Java图形用户界面编程中,如果需要显示信息,一般是使用__________类的对象来实现。</p>
<ul>
<li>A <code>JLabel</code></li>
<li>B <code>JButton</code></li>
<li>C <code>JTextArea</code></li>
<li>D <code>JtextField</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<ul>
<li>JTextField单行文本</li>
<li>JTextArea多行文本</li>
<li>JButton按键显示</li>
<li>JLable显示标签 信息</li>
</ul>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>以下哪些方法可以取到http请求中的cookie值()?</p>
<ul>
<li>A <code>request.getAttribute</code></li>
<li>B <code>request.getHeader</code></li>
<li>C <code>request.getParameter</code></li>
<li>D <code>request.getCookies</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BD</details>

<p>下面的方法可用在 Servlet 程序中读取 HTTP 头。这些方法通过 HttpServletRequest 对象可用：<br>1）Cookie[] getCookies()<br>返回一个数组，包含客户端发送该请求的所有的 Cookie 对象。<br>2）Object getAttribute(String name)<br>以对象形式返回已命名属性的值，如果没有给定名称的属性存在，则返回 null。<br>3）String getHeader(String name)<br>以字符串形式返回指定的请求头的值。Cookie也是头的一种；<br>4）String getParameter(String name)<br>以字符串形式返回请求参数的值，或者如果参数不存在则返回 null。</p>
<p>JSP servlet方面的知识忘记了，有空了解一下</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下面程序段执行后b的值是()。<br>Integer integ &#x3D;new Integer(9);<br>boolean b &#x3D; integ  instanceof  Object;</p>
<ul>
<li>A 9</li>
<li>B <code>true</code></li>
<li>C 1</li>
<li>D <code>false</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>A instanceOf B，是判断对象A</p>
<ul>
<li>是否属于B类的实例</li>
<li>是否属于B类的子类的实例</li>
<li>是否属于B接口的实现类的实例</li>
<li>是否属于B接口的子接口的实现类的实例。</li>
</ul>
<p>任何数据类型都可以赋值给Object对象。<br><img data-src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexoSettings/FrontAwesome/find.png" alt="测试"></p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>以下哪些类是线程安全的()</p>
<ul>
<li>A <code>Vector</code></li>
<li>B <code>HashMap</code></li>
<li>C <code>ArrayList</code></li>
<li>D <code>StringBuffer</code></li>
<li>E <code>Properties</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ADE</details>

]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月22日 java1</title>
    <url>/exam//9c039ebd/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下面所示的java代码,运行时,会产生()类型的异常<br>int Arry_a[] &#x3D; new int[10];<br>System.out.println(Arry_a[10]);</p>
<ul>
<li>A <code>ArithmeticException</code></li>
<li>B <code>NullPointException</code></li>
<li>C <code>IOException</code></li>
<li>D <code>ArrayIndexOutOfBoundsException</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p><img data-src="https://uploadfiles.nowcoder.com/images/20160921/5459305_1474429057978_AE040A3D9B415BA24D436E0954EAD4D4" alt="这里有图片"></p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>以下哪个区域不属于新生代？</p>
<ul>
<li>A <code>eden</code>区</li>
<li>B <code>from</code>区</li>
<li>C 元数据区</li>
<li>D <code>to</code>区</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p><code>Java</code> 中的堆是<code>JVM</code> 所管理的最大的一块内存空间,主要用于存放各种类的实例对象。<br>在<code>Java</code> 中,<code>堆</code>被划分成两个不同的区域:</p>
<ul>
<li>新生代(<code>Young</code>)、</li>
<li>老年代(<code>Old</code>)。</li>
</ul>
<p>新生代(<code>Young</code>)又被划分为三个区域:</p>
<ul>
<li><code>Eden</code>、</li>
<li><code>From Survivor</code>、</li>
<li><code>To Survivor</code>。</li>
</ul>
<p>这样划分的目的是为了使 <code>JVM</code> 能够更好的管理堆内存中的对象,包括内存的分配以及回收。<br>堆的内存模型大致为:<br><a href="http://www.blogjava.net/images/blogjava_net/fancydeepin/JVM/%E5%A0%86%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B2.png">这里有图片</a><br>从图中可以看出： 堆大小 &#x3D; 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。<br>本人使用的是 JDK1.6，以下涉及的 JVM 默认值均以该版本为准。<br>默认的新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：</p>
<ul>
<li>新生代 ( Young ) &#x3D; 1&#x2F;3 的堆空间大小。</li>
<li>老年代 ( Old ) &#x3D; 2&#x2F;3 的堆空间大小。</li>
</ul>
<p>其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。<br>默认的，Edem : from : to &#x3D; 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： </p>
<ul>
<li>Eden &#x3D; 8&#x2F;10 的新生代空间大小，</li>
<li>from &#x3D; to &#x3D; 1&#x2F;10 的新生代空间大小。</li>
</ul>
<p>JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，<strong>总是有一块 Survivor 区域是空闲着的</strong>。<br>因此，新生代实际可用的内存空间为 9&#x2F;10 ( 即90% )的新生代空间。</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>以下JAVA程序代码的输出是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">17</span>^<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 12</li>
<li>B 22</li>
<li>C 20</li>
<li>D 1419857</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p> 异或运算是一个二进制运算：两者相同为0，两者不同为1</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">数据</th>
</tr>
</thead>
<tbody><tr>
<td align="left">17</td>
<td align="left">0001 0001</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">0000 0101</td>
</tr>
<tr>
<td align="left">亦或结果</td>
<td align="left">0001 0100</td>
</tr>
<tr>
<td align="left">转10进制</td>
<td align="left">20</td>
</tr>
</tbody></table>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>下面程序的运行结果是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Wangyi;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SonB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        base.method();</span><br><span class="line">        base.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>A Base SonB</li>
<li>B Son SonB</li>
<li>C Base Son SonB</li>
<li>D 编译不通过</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h3 id="多态-编译看左边-运行看右边"><a href="#多态-编译看左边-运行看右边" class="headerlink" title="多态 编译看左边 运行看右边"></a>多态 编译看左边 运行看右边</h3><p>这类多态问题中，无论向上或向下转型，都记住一句话就可以了。<br><strong>编译看左边，运行看右边</strong></p>
<ul>
<li>意思编译时候，看左边有没有该方法，</li>
<li>运行的时候结果看new的对象是谁，就调用谁的方法。</li>
</ul>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>关于 访问权限说法正确 的是 ？ (    )</p>
<ul>
<li>A 类定义前面可以修饰<code>public,protected</code>和<code>private</code></li>
<li>B 内部类前面可以修饰<code>public,protected</code>和<code>private</code></li>
<li>C 局部内部类前面可以修饰<code>public,protected</code>和<code>private</code></li>
<li>D 以上说法都不正确</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="内部类分类"><a href="#内部类分类" class="headerlink" title="内部类分类"></a>内部类分类</h3><p>在Java中，可以将一个类定义在另一个类里面或者一个方法里边，这样的类称为内部类，广泛意义上的内部类一般包括四种：</p>
<ul>
<li>成员内部类，</li>
<li>局部内部类，</li>
<li>匿名内部类，</li>
<li>静态内部类 。</li>
</ul>
<h3 id="1-成员内部类"><a href="#1-成员内部类" class="headerlink" title="1.成员内部类"></a>1.成员内部类</h3><h4 id="成员内部类中可以访问外部类的所有成员"><a href="#成员内部类中可以访问外部类的所有成员" class="headerlink" title="成员内部类中可以访问外部类的所有成员"></a>成员内部类中可以访问外部类的所有成员</h4><p>该类像是外部类的一个成员，可以无条件的访问外部类的所有成员属性和成员方法（包括private成员和静态成员）；</p>
<h4 id="成员内部类的成员会隐藏外部类成员"><a href="#成员内部类的成员会隐藏外部类成员" class="headerlink" title="成员内部类的成员会隐藏外部类成员"></a>成员内部类的成员会隐藏外部类成员</h4><p>成员内部类拥有与外部类同名的成员变量时，会发生隐藏现象，即成员内部类中，默认情况下访问的是成员内部类中的成员。如果要访问外部类中的成员，需要以下形式访问：<br>【外部类.this.成员变量  或  外部类.this.成员方法】；</p>
<h4 id="外部类中要先创建内部类对象才能调用内部类的成员"><a href="#外部类中要先创建内部类对象才能调用内部类的成员" class="headerlink" title="外部类中要先创建内部类对象才能调用内部类的成员"></a>外部类中要先创建内部类对象才能调用内部类的成员</h4><p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象；<br>在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问；</p>
<h4 id="内部类可以拥有四种访问权限"><a href="#内部类可以拥有四种访问权限" class="headerlink" title="内部类可以拥有四种访问权限"></a>内部类可以拥有四种访问权限</h4><p>内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。</p>
<ul>
<li>如果成员内部类用private修饰，则只能在外部类的内部访问；</li>
<li>如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；</li>
<li>如果是默认访问权限，则只能在同一个包下访问。</li>
<li>如果用public修饰，则任何地方都能访问；</li>
</ul>
<h4 id="外部类只能有两种访问权限"><a href="#外部类只能有两种访问权限" class="headerlink" title="外部类只能有两种访问权限"></a>外部类只能有两种访问权限</h4><p>外部类只能被public和包访问两种权限修饰。</p>
<h3 id="2-局部内部类"><a href="#2-局部内部类" class="headerlink" title="2.局部内部类"></a>2.局部内部类</h3><h4 id="局部内部类只在方法或者代码块中可见"><a href="#局部内部类只在方法或者代码块中可见" class="headerlink" title="局部内部类只在方法或者代码块中可见"></a>局部内部类只在方法或者代码块中可见</h4><p>局部内部类是定义在一个方法或者一个代码块里面的类<br>它和成员内部类的区别在于<br>局部内部类的访问仅限于方法内或者该作用域内；</p>
<h4 id="局部内部类不能用访问修饰符修饰"><a href="#局部内部类不能用访问修饰符修饰" class="headerlink" title="局部内部类不能用访问修饰符修饰"></a>局部内部类不能用访问修饰符修饰</h4><p>局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</p>
<h3 id="3-匿名内部类"><a href="#3-匿名内部类" class="headerlink" title="3.匿名内部类"></a>3.匿名内部类</h3><ul>
<li>匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</li>
<li>匿名内部类是唯一一种没有构造器的类；</li>
<li>匿名内部类是不能有访问修饰符和static修饰符的；</li>
<li>一般使用匿名内部类的方法来编写事件监听代码；<h4 id="4-内部静态类"><a href="#4-内部静态类" class="headerlink" title="4.内部静态类"></a>4.内部静态类</h4></li>
<li>静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似；</li>
<li>静态成员不能访问非静态成员，也就是静态内部类不能使用外部类的非static成员变量或者方法</li>
</ul>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下面哪一项不属于优化Hibernate所鼓励的？</p>
<ul>
<li>A 使用单向一对多关联,不使用双向一对多</li>
<li>B 不用一对一,用多对一取代</li>
<li>C 配置对象缓存,不使用集合缓存</li>
<li>D 继承类使用显式多态</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>有空了解一下</p>
<h3 id="优化Hibernate所鼓励的7大措施"><a href="#优化Hibernate所鼓励的7大措施" class="headerlink" title="优化Hibernate所鼓励的7大措施"></a>优化Hibernate所鼓励的7大措施</h3><p>1.尽量使用many-to-one，避免使用单项one-to-many<br>2.灵活使用单向one-to-many<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag 多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism&#x3D;”exlicit”<br>避免查处所有对象<br>7.消除大表，使用二级缓存</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月23日 java1</title>
    <url>/exam//73c1f583/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下列程序执行后结果为( )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;Result=&quot;</span> + a.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;Result=&quot;</span> + b.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A <code>Result=150Result=150</code></li>
<li>B <code>Result=100Result=100</code></li>
<li>C <code>Result=100Result=150</code></li>
<li>D <code>Result=150Result=100</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h3 id="编译看左边-运行看右边"><a href="#编译看左边-运行看右边" class="headerlink" title="编译看左边 运行看右边"></a>编译看左边 运行看右边</h3><p>编译时，看左边是否有这个方法。也就是父类引用只能调用父类中声明的方法<br>运行时，调用右边的方法，也就是调用的是new创建的实际对象的方法，</p>
<ul>
<li>如果重写了该方法，则调用子类重写的方法，</li>
<li>如果没有重写该方法，则调用从父类继承来的方法。</li>
</ul>
<p>静态方法编译看左，运行看左<br>成员方法编译看左，运行看右<br>成员变量编译看左，运行看左</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>有程序片段如下,以下表达式结果为 true 的是( )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Float  s=<span class="keyword">new</span>  <span class="title class_">Float</span>(<span class="number">0.1f</span>);</span><br><span class="line">Float  t=<span class="keyword">new</span>  <span class="title class_">Float</span>(<span class="number">0.1f</span>);</span><br><span class="line">Double  u=<span class="keyword">new</span>  <span class="title class_">Double</span>(<span class="number">0.1</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>A <code>s==t</code></li>
<li>B <code>s.equals(t)</code></li>
<li>C <code>u.equals(s)</code></li>
<li>D <code>t.equals(u)</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>Float类和Double类都重写对于的equals方法，在比较之前都会判断是否同属于Float对象或Double对象，如果不是直接返回false，如果是再继续比较对应的数值大小。<br>JDK1.8的源码如下：<br>1.Float类重写了equals方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> (obj <span class="keyword">instanceof</span> Float) </span><br><span class="line">          &amp;&amp; (floatToIntBits(((Float)obj).value) == floatToIntBits(value)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.Double类重写了equals方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123; </span><br><span class="line">   <span class="keyword">return</span> (obj <span class="keyword">instanceof</span> Double) </span><br><span class="line">          &amp;&amp; (doubleToLongBits(((Double)obj).value) == doubleToLongBits(value)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考点1-1"><a href="#考点1-1" class="headerlink" title="考点1"></a>考点1</h1><p>Math.floor(-8.5)&#x3D;( )</p>
<ul>
<li>A (<code>float)-8.0</code></li>
<li>B (<code>long)-9</code></li>
<li>C (<code>long)-8</code></li>
<li>D (<code>double)-9.0</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>Math.floor(-8.5)&#x3D;( )</p>
<ul>
<li>A (<code>float)-8.0</code></li>
<li>B (<code>long)-9</code></li>
<li>C (<code>long)-8</code></li>
<li>D (<code>double)-9.0</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>Math.floor()   表示向下取整，返回double类型   （floor—地板）<br>Math.ceil()   表示向上取整，返回double类型    （ceil—天花板）<br>Math.round()  四舍五入，返回int类型</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>下面关于volatile的功能说法正确的是哪个</p>
<ul>
<li>A 原子性</li>
<li>B 有序性</li>
<li>C 可见性</li>
<li>D 持久性</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<ul>
<li>synchronized保证三大性，原子性，有序性，可见性，</li>
<li>volatile保证有序性，可见性，不能保证原子性。</li>
</ul>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>以下哪几种方式可用来实现线程间通知和唤醒:( )</p>
<ul>
<li>A <code>Object.wait/notify/notifyAll</code></li>
<li>B <code>ReentrantLock.wait/notify/notifyAll</code></li>
<li>C <code>Condition.await/signal/signalAll</code></li>
<li>D <code>Thread.wait/notify/notifyAll</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

<p>wait()、notify()和notifyAll()是Object类中的方法；<br>Condition是在java1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、 notify()，使用Condition1的await()、signal()这种方式实现线程间协作更加安全和高效。</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>JavaWEB中有一个类,当会话种邦定了属性或者删除了属性时,他会得到通知,这个类是:(    )</p>
<ul>
<li>A <code>HttpSessionAttributeListener</code></li>
<li>B <code>HttpSessionBindingListener</code></li>
<li>C <code>HttpSessionObjectListener</code></li>
<li>D <code>HttpSessionListener;</code></li>
<li>E <code>HttpSession</code></li>
<li>F <code>HttpSessionActivationListener</code></li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>HttpSessionAttributeListener：可以实现此侦听器接口获取此web应用程序中<strong>会话属性列表更改的通知</strong>；<br>HttpSessionBindingListener：当该对象从一个会话中被绑定或者解绑时通知该对象，这个对象由HttpSessionBindingEvent对象通知。这可能是servlet程序显式地从会话中解绑定属性的结果，可能是由于会话无效，也可能是由于会话超时；<br>HttpSessionObjectListener：没有该接口API；<br>HttpSessionListener：当web应用程序中的活动会话列表发生更改时通知该接口的实现类，为了接收该通知事件，必须在web应用程序的部署描述符中配置实现类；<br>HttpSessionActivationListener：绑定到会话的对象可以侦听容器事件，通知它们会话将被钝化，会话将被激活。需要一个在虚拟机之间迁移会话或持久会话的容器来通知所有绑定到实现该接口会话的属性。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月23日 java2</title>
    <url>/exam//eac8a439/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>以下哪个区域不属于新生代？</p>
<ul>
<li>A <code>eden</code>区</li>
<li>B <code>from</code>区</li>
<li>C 元数据区</li>
<li>D <code>to</code>区</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月24日 java1</title>
    <url>/exam//911deefa/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下面哪段程序能够正确的实现了GBK编码字节流到UTF-8编码字节流的转换:<br>byte[] src,dst;</p>
<ul>
<li>A <code>dst=String.fromBytes(src,&quot;GBK&quot;).getBytes(&quot;UTF-8&quot;)</code></li>
<li>B <code>dst=new String(src,&quot;GBK&quot;).getBytes(&quot;UTF-8&quot;)</code></li>
<li>C <code>dst=new String(&quot;GBK&quot;,src).getBytes()</code></li>
<li>D <code>dst=String.encode(String.decode(src,&quot;GBK&quot;)),&quot;UTF-8&quot; )</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>先解码再编码</p>
<ul>
<li>用<code>new String(src,&quot;GBK&quot;)</code>解码得到字符串</li>
<li>用<code>getBytes(&quot;UTF-8&quot;)</code>得到字符串对应的<code>UTF8</code>编码字节数组</li>
</ul>
<p>String类没有fromBytes()和encode以及decode方法</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>在java7中,下列哪个说法是正确的:</p>
<ul>
<li>A <code>ConcurrentHashMap</code>使用<code>synchronized</code>关键字保证线程安全</li>
<li>B <code>HashMap</code>实现了<code>Collection</code>接口</li>
<li>C <code>Arrays.asList</code>方法返回<code>java.util.ArrayList</code>对象</li>
<li>D <code>SimpleDateFormat</code>对象是线程不安全的</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h3 id="ConcurrentHashMap使用ReentrantLock来保证线程安全"><a href="#ConcurrentHashMap使用ReentrantLock来保证线程安全" class="headerlink" title="ConcurrentHashMap使用ReentrantLock来保证线程安全"></a><code>ConcurrentHashMap</code>使用<code>ReentrantLock</code>来保证线程安全</h3><p><code>ConcurrentHashMap</code>使用<code>segment</code>来分段和管理锁,<code>segment</code>继承自<code>ReentrantLock</code>,因此<code>ConcurrentHashMap</code>使用<code>ReentrantLock</code>来保证线程安全。</p>
<h3 id="Arrays-asList-返回Arrays类的静态内部类"><a href="#Arrays-asList-返回Arrays类的静态内部类" class="headerlink" title="Arrays.asList()返回Arrays类的静态内部类"></a><code>Arrays.asList()</code>返回<code>Arrays</code>类的静态内部类</h3><p><code>Arrays.asList()</code>将一个数组转化为一个<code>List</code>对象,这个方方法返回一个<code>ArrayList</code>类型的对象, 这个<code>ArrayList</code>类是<code>Arrays</code>类的静态内部类<br>而不是<code>java.util.ArrayList</code>类,</p>
<p>不能对这个列表进行添加删除更新操作,否则会报<code>UnsupportedOperationException</code>异常。</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>以下哪个命令用于查看tar(backup.tar)文件的内容而不提取它?()</p>
<ul>
<li>A <code>tar -xvf backup.tar</code></li>
<li>B <code>tar -tvf backup.tar</code></li>
<li>C <code>tar -svf backup.tar</code></li>
<li>D <code>none of these</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="Linux解压缩和压缩命令"><a href="#Linux解压缩和压缩命令" class="headerlink" title="Linux解压缩和压缩命令"></a>Linux解压缩和压缩命令</h3><p>有空了解一下<br>把常用的tar解压命令总结下，当作备忘：<br>tar<br>-c: 建立压缩档案<br>-x：解压<br>-t：查看内容<br>-r：向压缩归档文件末尾追加文件<br>-u：更新原压缩包中的文件<br>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。<br>-z：有gzip属性的<br>-j：有bz2属性的<br>-Z：有compress属性的<br>-v：显示所有过程<br>-O：将文件解开到标准输出<br>下面的参数-f是必须的<br>-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</p>
<h1 id="tar-cf-all-tar-jpg"><a href="#tar-cf-all-tar-jpg" class="headerlink" title="tar -cf all.tar *.jpg"></a>tar -cf all.tar *.jpg</h1><p>这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。</p>
<h1 id="tar-rf-all-tar-gif"><a href="#tar-rf-all-tar-gif" class="headerlink" title="tar -rf all.tar *.gif"></a>tar -rf all.tar *.gif</h1><p>这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。</p>
<h1 id="tar-uf-all-tar-logo-gif"><a href="#tar-uf-all-tar-logo-gif" class="headerlink" title="tar -uf all.tar logo.gif"></a>tar -uf all.tar logo.gif</h1><p>这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。</p>
<h1 id="tar-tf-all-tar"><a href="#tar-tf-all-tar" class="headerlink" title="tar -tf all.tar"></a>tar -tf all.tar</h1><p>这条命令是列出all.tar包中所有文件，-t是列出文件的意思</p>
<h1 id="tar-xf-all-tar"><a href="#tar-xf-all-tar" class="headerlink" title="tar -xf all.tar"></a>tar -xf all.tar</h1><p>这条命令是解出all.tar包中所有文件，-x是解开的意思<br>压缩<br>tar –cvf jpg.tar *.jpg  将目录里所有jpg文件打包成tar.jpg<br>tar –czf jpg.tar.gz *.jpg   将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz<br>tar –cjf jpg.tar.bz2 *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2<br>tar –cZf jpg.tar.Z *.jpg   将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z<br>rar a jpg.rar *.jpg rar格式的压缩，需要先下载rar for linux<br>zip jpg.zip *.jpg   zip格式的压缩，需要先下载zip for linux<br>解压<br>tar –xvf file.tar  解压 tar包<br>tar -xzvf file.tar.gz 解压tar.gz<br>tar -xjvf file.tar.bz2   解压 tar.bz2<br>tar –xZvf file.tar.Z   解压tar.Z<br>unrar e file.rar 解压rar<br>unzip file.zip 解压zip<br>总结<br>*.tar 用 tar –xvf 解压<br>*.gz 用 gzip -d或者gunzip 解压<br><em>.tar.gz和</em>.tgz 用 tar –xzf 解压<br>*.bz2 用 bzip2 -d或者用bunzip2 解压<br>*.tar.bz2用tar –xjf 解压<br>*.Z 用 uncompress 解压<br>*.tar.Z 用tar –xZf 解压<br>*.rar 用 unrar e解压<br>*.zip 用 unzip 解压<br>linux下最常用的打包程序就是tar了，使用tar程序打出来的包我们常称为tar包，tar包文件的命令通常都是以.tar结尾的。生成tar包后，就可以用其它的程序来进行压缩。<br>1．命令格式：<br>tar[必要参数][选择参数][文件]<br>2．命令功能：<br>用来压缩和解压文件。tar本身不具有压缩功能。他是调用压缩功能实现的<br>3．命令参数：<br>必要参数有如下：<br>-A 新增压缩文件到已存在的压缩<br>-B 设置区块大小<br>-c 建立新的压缩文件<br>-d 记录文件的差别<br>-r 添加文件到已经压缩的文件<br>-u 添加改变了和现有的文件到已经存在的压缩文件<br>-x 从压缩的文件中提取文件<br>-t 显示压缩文件的内容<br>-z 支持gzip解压文件<br>-j 支持bzip2解压文件<br>-Z 支持compress解压文件<br>-v 显示操作过程<br>-l 文件系统边界设置<br>-k 保留原有文件不覆盖<br>-m 保留文件不被覆盖<br>-W 确认压缩文件的正确性<br>可选参数如下：<br>-b 设置区块数目<br>-C 切换到指定目录<br>-f 指定压缩文件<br>–help 显示帮助信息<br>–version 显示版本信息<br>4．常见解压&#x2F;压缩命令<br>tar<br>解包：tar xvf FileName.tar<br>打包：tar cvf FileName.tar DirName<br>（注：tar是打包，不是压缩！）<br>.gz<br>解压1：gunzip FileName.gz<br>解压2：gzip -d FileName.gz<br>压缩：gzip FileName<br>.tar.gz 和 .tgz<br>解压：tar zxvf FileName.tar.gz<br>压缩：tar zcvf FileName.tar.gz DirName<br>.bz2<br>解压1：bzip2 -d FileName.bz2<br>解压2：bunzip2 FileName.bz2<br>压缩： bzip2 -z FileName<br>.tar.bz2<br>解压：tar jxvf FileName.tar.bz2<br>压缩：tar jcvf FileName.tar.bz2 DirName<br>.bz<br>解压1：bzip2 -d FileName.bz<br>解压2：bunzip2 FileName.bz<br>压缩：未知<br>.tar.bz<br>解压：tar jxvf FileName.tar.bz<br>压缩：未知<br>.Z<br>解压：uncompress FileName.Z<br>压缩：compress FileName<br>.tar.Z<br>解压：tar Zxvf FileName.tar.Z<br>压缩：tar Zcvf FileName.tar.Z DirName<br>.zip<br>解压：unzip FileName.zip<br>压缩：zip FileName.zip DirName<br>.rar<br>解压：rar x FileName.rar<br>压缩：rar a FileName.rar DirName<br>5．使用实例<br>实例1：将文件全部打包成tar包<br>命令：<br>tar -cvf log.tar log2012.log<br>tar -zcvf log.tar.gz log2012.log<br>tar -jcvf log.tar.bz2 log2012.log</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>jdk1.8版本之前的前提下,接口和抽象类描述正确的有( )</p>
<ul>
<li>A 抽象类没有构造函数</li>
<li>B 接口没有构造函数</li>
<li>C 抽象类不允许多继承</li>
<li>D 接口中的方法可以有方法体</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<p>抽象类可以有构造函数。只是不能被实例化！<br>JDK8以后的默认方法和静态方法可以有方法体，题目的方法应该是指普通方法</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>以下选项中,合法的赋值语句是()</p>
<ul>
<li>A <code>a&gt;1;</code></li>
<li>B <code>i++;</code></li>
<li>C <code>a= a+1=5;</code></li>
<li>D <code>y = int ( i );</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>
`i++`算是自我赋值
D选择不一定对y为short、byte、char时，
y = （int）i; //发生向下转型，不可赋值

<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>执行完以下代码 int [ ]  x &#x3D; new int[10] ;后,以下哪项说明是正确的( )</p>
<ul>
<li>A <code>x[9]</code>为0</li>
<li>B <code>x[9]</code>未定义</li>
<li>C <code>x[10]</code>为0</li>
<li>D <code>x[0]</code>为空</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<ul>
<li>基本类型数组: <code>byte[],short[],int[]</code> ,默认值为0；</li>
<li><code>boolean[]</code>默认值为<code>false</code>；</li>
<li><code>float[],double[]</code>,默认值为0.0；</li>
<li>对象类型数组: 默认值为<code>null</code></li>
</ul>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>Java的体系结构包含(    )。</p>
<ul>
<li>A <code>Java</code>编程语言</li>
<li>B <code>Java</code>类文件格式</li>
<li>C <code>Java API</code></li>
<li>D <code>JVM</code></li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>


<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>以下代码的循环次数是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(--i);</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">while</span> (i != <span class="number">0</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 0</li>
<li>B 1</li>
<li>C 7</li>
<li>D 无限次</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>每次循环都减2,7÷2不可能等于0。所以死循环。</p>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>一个Java源程序文件中定义几个类和接口,则编译该文件后生成几个以.class为后缀的字节码文件。</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>如果类中有内部类，会产生<code>类名$内部类名.class</code>，<br>如果有匿名类则会产生<code>类名$1.class</code></p>
<p>有空测试一下</p>
<h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>java8中,下面哪个类用到了解决哈希冲突的开放定址法 </p>
<ul>
<li>A <code>LinkedHashSet</code></li>
<li>B <code>HashMap</code></li>
<li>C <code>ThreadLocal</code></li>
<li>D <code>TreeMap</code></li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<ul>
<li>ThreadLocalMap使用开放定址法解决hash冲突，</li>
<li>HashMap使用链地址法解决hash冲突。</li>
</ul>
<h1 id="考点11"><a href="#考点11" class="headerlink" title="考点11"></a>考点11</h1><p>Java程序的种类有( )</p>
<ul>
<li>A 类(<code>Class)</code></li>
<li>B <code>Applet</code></li>
<li>C <code>Application</code></li>
<li>D <code>Servlet</code></li>
</ul>
<h2 id="解析-10"><a href="#解析-10" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details>

<p>java程序的种类有:<br>内嵌于web文件中,由浏览器来观看的Applet<br>可独立运行的Application<br>服务器端的Servlet</p>
<h1 id="考点12"><a href="#考点12" class="headerlink" title="考点12"></a>考点12</h1><p>有这样一段程序:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>&#123; </span><br><span class="line">        List list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>(); </span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Set set=<span class="keyword">new</span> <span class="title class_">HashSet</span>(); </span><br><span class="line">        set.add(<span class="string">&quot;a&quot;</span>); </span><br><span class="line">        set.add(<span class="string">&quot;b&quot;</span>); </span><br><span class="line">        set.add(<span class="string">&quot;a&quot;</span>); </span><br><span class="line">        System.out.println(list.size()+<span class="string">&quot;,&quot;</span>+set.size()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请问运行主要的程序会打印出的是什么()</p>
<ul>
<li>A 2,2</li>
<li>B 2,3</li>
<li>C 3,2</li>
<li>D 3,3</li>
</ul>
<h2 id="解析-11"><a href="#解析-11" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>list有序可重复，set无序不可重复</p>
<h1 id="考点13"><a href="#考点13" class="headerlink" title="考点13"></a>考点13</h1><p>以下程序输出()<br>public static void main(String[] args) {<br>   int num &#x3D; 2;<br>   switch (num) {<br>   case 1:<br>        ++num;<br>   case 2:<br>        ++num;<br>   case 3:<br>        ++num;<br>   default:<br>        ++num;<br>   break;<br>   }<br>   System.out.println(num);<br> }<br>}</p>
<ul>
<li>A 2</li>
<li>B 3</li>
<li>C 4</li>
<li>D 5</li>
</ul>
<h2 id="解析-12"><a href="#解析-12" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h3 id="case遇到break才跳出"><a href="#case遇到break才跳出" class="headerlink" title="case遇到break才跳出"></a>case遇到break才跳出</h3><ul>
<li>匹配到case 2 num等于3 </li>
<li>但是其后没有break,所以继续执行case 3 num等于4、</li>
<li>还是没有break，继续匹配到default语句  num等于5</li>
</ul>
<p>所以答案为 5</p>
<h1 id="考点14"><a href="#考点14" class="headerlink" title="考点14"></a>考点14</h1><p>以下代码在编译和运行过程中会出现什么情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TestDemo test=<span class="keyword">new</span> <span class="title class_">TestDemo</span>(<span class="number">88</span>);</span><br><span class="line">        System.out.println(test.count);</span><br><span class="line">    &#125;</span><br><span class="line">    TestDemo(<span class="type">int</span> a) &#123;</span><br><span class="line">        count=a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 编译运行通过,输出结果是88</li>
<li>B 编译时错误,<code>count</code>变量定义的是私有变量</li>
<li>C 编译时错误,<code>System.out.println</code>方法被调用时<code>test</code>没有被初始化</li>
<li>D 编译和执行时没有输出结果</li>
</ul>
<h2 id="解析-13"><a href="#解析-13" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月28日 java1</title>
    <url>/exam//8b210e74/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下面有关maven和ant的描述,描述错误的是？</p>
<ul>
<li>A <code>Ant</code> 没有正式的约定如一个一般项目的目录结构,你必须明确的告诉 <code>Ant</code> 哪里去找源代码</li>
<li>B <code>Maven</code> 拥有约定,因为你遵循了约定,它已经知道你的源代码在哪里</li>
<li>C <code>maven</code>和<code>ant</code>都有”生命周期”的概念,当你输入一个命令后,<code>maven</code>或者<code>ant</code>会执行一系列的有序的步骤,直到到达你指定的生命周期</li>
<li>D <code>Ant</code>构建文件默认命名为<code>build.xml,Maven</code>默认构建文件为<code>pom.xml</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p><code>Ant</code>没有生命周期，你必须定义目标和目标之间的依赖。你必须手工为每个目标附上一个任务序列。<br>有空了解一下<br>Ant的作用：是一种基于Java的build工具</p>
<p>能够用ant编译java类。生成class文件<br>ant能够自己定义标签、配置文件，用于构建。<br>ant能够把相关层构建成jar包 。<br>ant把整个项目生成web包。并公布到Tomcat<br>Ant的长处：</p>
<p>跨平台性：Ant是纯Java语言编写的，因此具有非常好的跨平台性。<br>操作简单：Ant是由一个内置任务和可选任务组成的。Ant执行时须要一个XML文件(构建文件)。<br>Ant通过调用target树，就能够运行各种task：每一个task实现了特定接口对象。因为Ant构建文件时XML格式的文件。所以非常easy维护和书写，并且结构非常清晰。<br>Ant能够集成到开发环境中：因为Ant的跨平台性和操作简单的特点。它非常easy集成到一些开发环境中去。<br>Maven的作用： 除了以程序构建能力为特色之外，还提供高级项目管理工具。<br>Maven除了具备Ant的功能外。还添加了下面基本的功能：<br>使用Project Object Model来对软件项目管理。<br>内置了很多其它的隐式规则，使得构建文件更加简单。<br>内置依赖管理和Repository来实现依赖的管理和统一存储；<br>内置了软件构建的生命周期；<br>Maven的长处：<br>拥有约定，知道你的代码在哪里，放到哪里去<br>拥有一个生命周期，比如运行 mvn install就能够自己主动运行编译，測试。打包等构建过程<br>仅仅须要定义一个pom.xml,然后把源代码放到默认的文件夹，Maven帮你处理其它事情<br>拥有依赖管理。仓库管理<br>总体的比較：<br>       Ant将提供了非常多能够重用的task，比如 copy, move, delete以及junit单元測试Maven则提供了非常多能够重用的过程。</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>有一个源代码,只包含import java.util.* ; 这一个import语句,下面叙述正确的是？   ( )</p>
<ul>
<li>A 只能写在源代码的第一句</li>
<li>B 可以访问<code>java/util</code>目录下及其子目录下的所有类</li>
<li>C 能访问<code>java/util</code>目录下的所有类,不能访问<code>java/util</code>子目录下的所有类</li>
<li>D 编译错误</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>导入java.util.*不能读取其子目录的类，因为如果java.util里面有个a类，java.util.regex里面也有个a类，我们若是要调用a类的方法或属性时，应该使用哪个a类呢。所以也应该选C</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>下面代码的输出结果为:<br>String str &#x3D;<br>“”;<br>System.out.print(str.split(“,”).length);</p>
<ul>
<li>A 0</li>
<li>B 1</li>
<li>C 出现异常</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>String的 split 方法默认返回一个数组，  如果没有找到分隔符， 会把整个字符串当成一个长度为1的字符串数组返回到结果， 所以此处结果就是1</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>局部内部类可以用哪些修饰符修饰？</p>
<ul>
<li>A <code>public</code></li>
<li>B <code>private</code></li>
<li>C <code>abstract</code></li>
<li>D <code>final</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: CD</details>

<p>局部内部类定义在方法中，可以看成局部变量，局部本身就是访问权限修饰，不能有public，protected，public修饰，另外，普通方法中不能定义static内部类。 </p>
<p>成员内部类定义在类中，是类的成员，类的成员可以有public，protected，public，static修饰。</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>在socket编程中,可以使用方法(      )获取本机的ip地址</p>
<ul>
<li>A <code>getInetAddress()</code></li>
<li>B <code>getLocalAddress()</code></li>
<li>C <code>getReuseAddress()</code></li>
<li>D <code>getLocalPort()</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<ul>
<li><code>getInetAddress</code>获取主机名和<code>IP</code>地址</li>
<li><code>getLocalAddress()</code>顾名思义，获取本地<code>IP</code>地址</li>
<li><code>getReuseAddress()</code>返回布尔类型，表示复用地址</li>
</ul>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>以下 b 的值是: byte b &#x3D; (byte)129;</p>
<ul>
<li>A -126</li>
<li>B -127</li>
<li>C -128</li>
<li>D -129</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>byte型占一个字节，也就是8位，int型4个字节，32位）；二、在计算机系统中，数值一律用补码来表示（存储）<br>正数：补码&#x3D;反码&#x3D;原码（当然以二进制形式表达）<br>129 int类型（4个字节）二进制： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000 00000000 00000000 10000001</span><br></pre></td></tr></table></figure>
<p>强制转换byte型后，只有一个字节即</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0001</span><br></pre></td></tr></table></figure>
<p>（注意这里从二进制角度看，第一位是符号位，即求负数的补码接下来）<br>只要求出上面原码对应的补码就行了，然后再转换对应的int型数值（因为题干所给的答案都是比较int型）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0001</span><br></pre></td></tr></table></figure>
<p>（原码）<br>对应的反码为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1110</span><br></pre></td></tr></table></figure>
<p>又补码等于反码+1，即</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111</span><br></pre></td></tr></table></figure>
<p>该二进制转换int型刚好是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-127＝(1+2+4+8+16+32+64)</span><br></pre></td></tr></table></figure>
<p>普及一下</p>
<ul>
<li>正数原码，反码，补码相同</li>
<li>负数反码除了符号位不变，其他位取反，</li>
<li>负数补码&#x3D;反码+1；</li>
</ul>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>下列关于包(package)的描述,正确的是()</p>
<ul>
<li>A 包(<code>package</code>)是<code>Java</code>中描述操作系统对多个源代码文件组织的一种方式。</li>
<li>B <code>import</code>语句将所对应的<code>Java</code>源文件拷贝到此处执行。</li>
<li>C 包(<code>package</code>)是<code>Eclipse</code>组织<code>Java</code>项目特有的一种方式。</li>
<li>D 定义在同一个包(<code>package</code>)内的类可以不经过<code>import</code>而直接相互使用。</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>1、为了更好地组织类,Java提供了包机制。包是类的容器,用于分隔类名空间。如果没有指定包名,所有的示例都属于一个默认的无名包。Java中的包一般均包含相关的类,<strong>java是跨平台的,所以java中的包和操作系统没有任何关系</strong>,java的包是用来组织文件的一种虚拟文件系统。A错<br>2、import语句并没有将对应的java源文件拷贝到此处仅仅是引入,告诉编译器有使用外部文件,<strong>编译的时候要去读取这个外部文件</strong>。B错<br>3、Java提供的包机制与IDE没有关系。C错<br>4、定义在同一个包(package)内的类可以不经过import而直接相互使用。</p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>某程序要求每次输入只能是正整数,并且每次输入的数值要求必须是100的倍数且小于等于500,则下列哪个是正确的无效等价类(        )</p>
<ul>
<li>A (0,100)、(100,200)、(200,300)、(300,400)、(400,500)、(500,+∞);</li>
<li>B (500,+∞)</li>
<li>C (500,+∞)、任意大于0小于500的非100倍数的整数;</li>
<li>D (-∞,100)、(100,200)、(200,300)、(300,400)、(400,500)、(500,+∞);</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h3 id="什么是有效等价类"><a href="#什么是有效等价类" class="headerlink" title="什么是有效等价类"></a>什么是有效等价类</h3><ul>
<li>无效等价类是指不满足软件规格说明的输入数据集合，也就是没有意义的、不合理的输入数据集合。<ul>
<li>利用无效等价类可以找出程序异常说明情况，检查程序的功能和性能的实现是否有不符合规格说明要求的地方。</li>
</ul>
</li>
</ul>
<h3 id="什么是无效等价类"><a href="#什么是无效等价类" class="headerlink" title="什么是无效等价类"></a>什么是无效等价类</h3><ul>
<li>有效等价类是指输入数据完全满足程序输入的规格说明，是有效、有意义的输入数据所构成的集合。<ul>
<li>利用有效等价类可以检验程序是否满足规格说明所规定的功能和性能。</li>
</ul>
</li>
</ul>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>关于volatile关键字,下列描述不正确的是？</p>
<ul>
<li>A 用<code>volatile</code>修饰的变量,每次更新对其他线程都是立即可见的。</li>
<li>B 对<code>volatile</code>变量的操作是原子性的。</li>
<li>C 对<code>volatile</code>变量的操作不会造成阻塞。</li>
<li>D 不依赖其他锁机制,多线程环境下的计数器可用<code>volatile</code>实现。</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BD</details>

<p>有空了解一下</p>
<h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>JSP分页代码中,哪个步骤次序是正确的？</p>
<ul>
<li>A 先取总记录数,得到总页数,最后显示本页的数据。</li>
<li>B 先取所有的记录,得到总页数,再取总记录数,最后显示本页的数据。</li>
<li>C 先取总页数,得到总记录数,再取所有的记录,最后显示本页的数据。</li>
<li>D 先取本页的数据,得到总页数,再取总记录数,最后显示所有的记录。</li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<h1 id="考点11"><a href="#考点11" class="headerlink" title="考点11"></a>考点11</h1><p>对下面Spring声明式事务的配置含义的说明错误的是()</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txProxyTemplate&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=</span></span><br><span class="line"><span class="tag"><span class="string">&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;myTransactionManager&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;transactionAttributes&quot;</span>&gt;</span>      </span><br><span class="line"> <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;get*&quot;</span>&gt;</span>PROPAGATION_REQUIRED,readOnly<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;*&quot;</span>&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>A 定义了声明式事务的配置模板</li>
<li>B 对<code>get</code>方法采用只读事务</li>
<li>C 缺少<code>sessionFactory</code>属性的注入</li>
<li>D 配置需要事务管理的<code>bean</code>的代理时,通过<code>parent</code>引用这个配置模板,代码如下:<bean id="petBiz" parent="txProxyTemplate">
<property name="target" ref="petTarget"/>
</bean></li>
</ul>
<h2 id="解析-10"><a href="#解析-10" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>有空了解一下。</p>
<h1 id="考点12"><a href="#考点12" class="headerlink" title="考点12"></a>考点12</h1><p>JSP分页代码中,哪个步骤次序是正确的？</p>
<ul>
<li>A 先取总记录数,得到总页数,最后显示本页的数据。</li>
<li>B 先取所有的记录,得到总页数,再取总记录数,最后显示本页的数据。</li>
<li>C 先取总页数,得到总记录数,再取所有的记录,最后显示本页的数据。</li>
<li>D 先取本页的数据,得到总页数,再取总记录数,最后显示所有的记录。</li>
</ul>
<h2 id="解析-11"><a href="#解析-11" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>有空了解一下。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月28日 java2</title>
    <url>/exam//12285fce/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下列程序段的输出结果是:( ) </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complicatedexpression_r</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">20</span>, y=<span class="number">30</span>;</span><br><span class="line">    <span class="type">boolean</span> b;</span><br><span class="line">    b = x &gt; <span class="number">50</span> &amp;&amp; y &gt; <span class="number">60</span> || x &gt; <span class="number">50</span> &amp;&amp; y &lt; -<span class="number">60</span> || x &lt; -<span class="number">50</span> &amp;&amp; y &gt; <span class="number">60</span> || x &lt; -<span class="number">50</span> &amp;&amp; y &lt; -<span class="number">60</span>;</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A <code>true</code></li>
<li>B <code>false</code></li>
<li>C 1</li>
<li>D 0</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>


<p>&amp;&amp;的优先级大于||   而不是相等   所以原式&#x3D;(x&gt;50&amp;&amp;y&gt;60)||(x&gt;50&amp;&amp;y&lt;-60)||(x&lt;-50&amp;&amp;y&gt;60)||(x&lt;-50&amp;&amp;y&lt;-60);</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>函数()把文件位置重定位到文件中的指定位置</p>
<ul>
<li>A <code>fseek</code></li>
<li>B <code>fread</code></li>
<li>C <code>fopen</code></li>
<li>D <code>fgets</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>这是c语言的题</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>关于struts框架,下面那些说法是正确的？</p>
<ul>
<li>A <code>Struts</code>中无法完成上传功能</li>
<li>B <code>Struts</code>框架基于<code>MVC</code>模式</li>
<li>C <code>Struts</code>框架容易引起流程复杂、结构不清晰等问题</li>
<li>D <code>Struts</code>可以有效地降低项目的类文件数目</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>有空了解一下</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>有关hashMap跟hashTable的区别,说法正确的是？</p>
<ul>
<li>A <code>HashMap</code>和<code>Hashtable</code>都实现了<code>Map</code>接口</li>
<li>B <code>HashMap</code>是非<code>synchronized</code>,而<code>Hashtable</code>是<code>synchronized</code></li>
<li>C <code>HashTable</code>使用<code>Enumeration,HashMap</code>使用<code>Iterator</code></li>
<li>D <code>HashMap</code>允许将 <code>null</code> 作为一个 <code>entry</code> 的 <code>key</code> 或者 <code>value</code>,而 <code>Hashtable</code> 不允许。</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>



<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下面哪些类可以被继承？ Java.lang.Thread、java.lang.Number、java.lang.Double、java.lang.Math、 java.lang.ClassLoader</p>
<ul>
<li>A <code>Thread</code></li>
<li>B <code>Number</code></li>
<li>C <code>Double</code></li>
<li>D <code>Math</code></li>
<li>E <code>ClassLoader</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABE</details>

<ul>
<li>A，Thread可以被继承，用于创建新的线程</li>
<li>B，Number类可以被继承，Integer，Float，Double等都继承自Number类</li>
<li>C，Double类的声明为<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Double</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span></span><br></pre></td></tr></table></figure>
final生明的类不能被继承</li>
<li>D，Math类的声明为<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Math</span> <span class="keyword">extends</span> <span class="title class_">Object</span></span><br></pre></td></tr></table></figure>
不能被继承</li>
<li>E，ClassLoader可以被继承，用户可以自定义类加载器</li>
</ul>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>关于ThreadLocal类 以下说法正确的是</p>
<ul>
<li>A <code>ThreadLocal</code>继承自<code>Thread</code></li>
<li>B <code>ThreadLocal</code>实现了<code>Runnable</code>接口</li>
<li>C <code>ThreadLocal</code>重要作用在于多线程间的数据共享</li>
<li>D <code>ThreadLocal</code>是采用哈希表的方式来为每个线程都提供一个变量的副本</li>
<li>E <code>ThreadLocal</code>保证各个线程间数据安全,每个线程的数据不会被另外线程访问和破坏</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: DE</details>

<p>1、ThreadLocal的类声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt;</span><br></pre></td></tr></table></figure>
<p>可以看出ThreadLocal并没有继承自Thread，也没有实现Runnable接口。所以AB都不对。<br>2、ThreadLocal类为每一个线程都维护了自己独有的变量拷贝。每个线程都拥有了自己独立的一个变量。<br>所以ThreadLocal重要作用并不在于多线程间的数据共享，而是<strong>数据的独立</strong>，C选项错。<br>由于每个线程在访问该变量时，读取和修改的，都是自己独有的那一份变量拷贝，不会被其他线程访问，<br>变量被彻底封闭在每个访问的线程中。所以E对。<br>3、ThreadLocal中定义了一个哈希表用于为每个线程都提供一个变量的副本：</p>
<p><code>ThreadLocal</code>继承<code>Object</code>，相当于没继承任何特殊的。<br><code>ThreadLocal</code>没有实现任何接口。<br><code>ThreadLocal</code>并不是一个<code>Thread</code>，而是<code>Thread</code>的局部变量。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月29日 java1</title>
    <url>/exam//64e3654a/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>关于依赖注入,下列选项中说法错误的是()</p>
<ul>
<li>A 依赖注入能够独立开发各组件,然后根据组件间关系进行组装</li>
<li>B 依赖注入使组件之间相互依赖,相互制约</li>
<li>C 依赖注入提供使用接口编程</li>
<li>D 依赖注入指对象在使用时动态注入</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>依赖注入是相互依赖(减少耦合)，使开发更加简洁</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>如果一个接口Cup有个方法use(),有个类SmallCup实现接口Cup,则在类SmallCup中正确的是？  ( )</p>
<ul>
<li>A <code>void use() &#123; …&#125;</code></li>
<li>B <code>protected void use() &#123; …&#125;</code></li>
<li>C <code>public void use() &#123; …&#125;</code></li>
<li>D 以上语句都可以用在类<code>SmallCup</code>中</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<ul>
<li>接口中的常量修饰符是public static final，</li>
<li>接口中的方法修饰符是public abstract</li>
<li>两头两小一大</li>
</ul>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>使用mvc模式设计的web应用程序具有以下优点,除了？</p>
<ul>
<li>A 可维护行强</li>
<li>B 可扩展性强</li>
<li>C 代码重复少</li>
<li>D 大大减少代码量</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>关于ASCII码和ANSI码,以下说法不正确的是()？</p>
<ul>
<li>A 标准<code>ASCII</code>只使用7个<code>bit</code></li>
<li>B 在简体中文的<code>Windows</code>系统中,<code>ANSI</code>就是<code>GB2312</code></li>
<li>C <code>ASCII</code>码是<code>ANSI</code>码的子集</li>
<li>D <code>ASCII</code>码都是可打印字符</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>A、标准<code>ASCII</code>只使用7个<code>bit</code>，扩展的<code>ASCII</code>使用8个<code>bit</code>。<br>B、<code>ANSI</code>通常使用 0<code>x00</code><del>0<code>x7f</code> 范围的1 个字节来表示 1 个英文字符。超出此范围的使用0<code>x80</code></del>0<code>xFFFF</code>来编码，即扩展的<code>ASCII</code>编码。不同 <code>ANSI</code> 编码之间互不兼容。在简体中文<code>Windows</code>操作系统中，<code>ANSI</code> 编码代表 <code>GBK</code> 编码；在繁体中文<code>Windows</code>操作系统中，<code>ANSI</code>编码代表<code>Big5</code>；在日文<code>Windows</code>操作系统中，<code>ANSI</code> 编码代表 <code>Shift_JIS</code> 编码。<br>C、<code>ANSI</code>通常使用 0<code>x00</code>~0<code>x7f</code> 范围的1 个字节来表示 1 个英文字符，即<code>ASCII</code>码<br>D、<code>ASCII</code>码包含一些特殊空字符，这些特殊的空字符无法打印。</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>在开发中使用泛型取代非泛型的数据类型(比如用ArrayList<String>取代ArrayList),程序的运行时性能会变得更好。() </p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>泛型仅仅是java的语法糖，它不会影响java虚拟机生成的汇编代码，在编译阶段，虚拟机就会把泛型的类型擦除，还原成没有泛型的代码，顶多编译速度稍微慢一些，执行速度是完全没有什么区别的.</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>java中将ISO8859-1字符串转成GB2312编码,语句为 ？  </p>
<ul>
<li>A <code>new String(&quot;ISO8859-1&quot;.getBytes(&quot;ISO8859-1&quot;),&quot;GB2312&quot;)</code></li>
<li>B <code>new String(String.getBytes(&quot;GB2312&quot;), ISO8859-1)</code></li>
<li>C <code>new String(String.getBytes(&quot;ISO8859-1&quot;))</code></li>
<li>D <code>new String(String.getBytes(&quot;GB2312&quot;))</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p> 得到的是以charsetName编码得到的byte数组;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> [  ]  String.getBytes(String charsetName);</span><br></pre></td></tr></table></figure>

<p>String的构造函数有:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String(<span class="type">byte</span>[] bytes, String charsetName);</span><br></pre></td></tr></table></figure>

<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>对于以下代码段,4个输出语句中输出true的个数是(    )。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;&#125;</span><br><span class="line"><span class="type">A</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">System.out.println(obj <span class="keyword">instanceof</span> B);</span><br><span class="line">System.out.println(obj <span class="keyword">instanceof</span> C);</span><br><span class="line">System.out.println(obj <span class="keyword">instanceof</span> D);</span><br><span class="line">System.out.println(obj <span class="keyword">instanceof</span> A);</span><br></pre></td></tr></table></figure>
<ul>
<li>A 1</li>
<li>B 2</li>
<li>C 3</li>
<li>D 4</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>a instanceof A；表示的是a指向的<code>实际对象</code>，是否是A类或者A的子类的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br></pre></td></tr></table></figure>
<p>这里obj指向的实际对象类型为D</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> B</span><br></pre></td></tr></table></figure>
<p>obj是B的子类D的实例，true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> D</span><br></pre></td></tr></table></figure>
<p>obj是D对象的实例，true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> A</span><br></pre></td></tr></table></figure>
<p>obj是A类的子类B的子类D的实例，true</p>
<p>总结可以从obj的实际类型D开始，依次向上查找父类，如果在继承链中找到这个类，则返回true。</p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>关于异常的编程,以下描述错误的是:( )</p>
<ul>
<li>A 在有除法存在的代码处,为了防止分母为零,必须抛出并捕获异常</li>
<li>B <code>int i=Integer.parseInt(&quot;123a&quot;);</code>将产生<code>NumberFormatException</code></li>
<li>C <code>int a[]=null;</code> <code>a[0]=1;</code> 将产生<code>NullPointerException</code></li>
<li>D 输入输出流编程中,读和写时都要抛出<code>IOException</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p><strong>除零异常是运行时异常，不需要显示处理</strong><br>Java的异常分为两种，一种是运行时异常（RuntimeException），一种是非运行异常也叫检查式异常（CheckedException）。</p>
<p>1、<strong>运行时异常不需要程序员去处理</strong>，当异常出现时，JVM会帮助处理。常见的运行时异常有：</p>
<ul>
<li>ClassCastException(类转换异常)</li>
<li>ClassNotFoundException</li>
<li>IndexOutOfBoundsException(数组越界异常)</li>
<li>NullPointerException(空指针异常)</li>
<li>ArrayStoreException(数组存储异常，即数组存储类型不一致)</li>
<li>除零异常</li>
<li>还有IO操作的BufferOverflowException异常</li>
</ul>
<p>2、非运行异常需要程序员手动去捕获或者抛出异常进行显示的处理，因为Java认为Checked异常都是可以被修复的异常。常见的异常有：</p>
<ul>
<li>IOException</li>
<li>SqlException</li>
</ul>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>关于java集合下列说法不正确的有哪些()</p>
<ul>
<li>A <code>HashSet</code> 它是线程安全的,不允许存储相同的对象</li>
<li>B <code>ConcurrentHashMap</code> 它是线程安全的,其中存储的键对象可以重复,值对象不能重复</li>
<li>C <code>Collection</code>接口是<code>List</code>接口和<code>Set</code>接口的父接口,通常情况下不被直接使用</li>
<li>D <code>ArrayList</code>线程安全的,允许存放重复对象</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>

<p>线程安全(Thread-safe)的集合对象：</p>
<ul>
<li>Vector 线程安全：</li>
<li>HashTable 线程安全：</li>
</ul>
<p>非线程安全的集合对象：</p>
<ul>
<li>ArrayList </li>
<li>LinkedList</li>
<li>HashMap</li>
<li>HashSet</li>
<li>TreeMap</li>
<li>TreeSet</li>
</ul>
<p>StringBuffer线程安全<br>StringBulider线程不安全</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月2日_java_1</title>
    <url>/exam//d4314bc1/</url>
    <content><![CDATA[<h1 id="考点1-抽象类和接口"><a href="#考点1-抽象类和接口" class="headerlink" title="考点1 抽象类和接口"></a>考点1 抽象类和接口</h1><p>关于抽象类和接口叙述正确的是？ ( )</p>
<ul>
<li>A 抽象类和接口都能实例化的</li>
<li>B 抽象类不能实现接口</li>
<li>C 抽象类方法的访问权限默认都是public</li>
<li>D 接口方法的访问权限默认都是public</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: D</details>

<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>如果一个类含有抽象方法那么这个类就是抽象类。<br>抽象类需要使用关键字abstract来声明。<br>抽象类中的抽象方法只需要声明，并不需要实现。<br>抽象类一定具有子类，并且子类必须覆写抽象类中的所有的抽象方法。<br>在使用abstract定义抽象方法时，抽象方法的权限不能为private，这是因为抽象方法必须被覆写，如果使用private来定义方法的权限，那么该方法无法被子类覆写，会出现错误</p>
<h3 id="普通通类和抽象类的区别"><a href="#普通通类和抽象类的区别" class="headerlink" title="普通通类和抽象类的区别"></a>普通通类和抽象类的区别</h3><p>实际上抽象类相比于普通类，只是在类定义的时候多定义了一个抽象方法，除了不能直接进行对象的实例化之外没有其它区别</p>
<h1 id="考点2-合法标识符-合法变量名"><a href="#考点2-合法标识符-合法变量名" class="headerlink" title="考点2 合法标识符 合法变量名"></a>考点2 合法标识符 合法变量名</h1><p>下面属于java合法变量定义的是？</p>
<ul>
<li>A final</li>
<li>B 1var1</li>
<li>C _var2</li>
<li>D var3&amp;</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: C</details>

<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>标识符可以包括这4种字符：</p>
<ul>
<li>字母、数字，下划线、$、</li>
<li>开头不能是数字；</li>
<li>不能是关键字</li>
</ul>
<p>A.final 是关键字<br>B.不能以数字做首写<br>C.首写字母可以为下划线<br>D.符号只能使用美元符合下划线，不能使用&amp;</p>
<h1 id="考点3-程序初始化顺序"><a href="#考点3-程序初始化顺序" class="headerlink" title="考点3 程序初始化顺序"></a>考点3 程序初始化顺序</h1><p>运行下面代码，输出的结果是（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;class A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123; System.out.println(<span class="string">&quot;I&#x27;m A class&quot;</span>); &#125; </span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">&quot;class A static&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;class B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m B class&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;class B static&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">B</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A static</span><br><span class="line">class B static</span><br><span class="line">I&#x27;m A class</span><br><span class="line">class A</span><br><span class="line">I&#x27;m B class</span><br><span class="line">class B</span><br></pre></td></tr></table></figure>
<p>B</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A static</span><br><span class="line">I&#x27;m A class</span><br><span class="line">class A</span><br><span class="line">class B static</span><br><span class="line">I&#x27;m B class</span><br><span class="line">class B</span><br></pre></td></tr></table></figure>
<p>C</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A static</span><br><span class="line">class B static</span><br><span class="line">class A</span><br><span class="line">I&#x27;m A class</span><br><span class="line">class B</span><br><span class="line">I&#x27;m B class</span><br></pre></td></tr></table></figure>
<p>D</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A static</span><br><span class="line">class A</span><br><span class="line">I&#x27;m A class</span><br><span class="line">class B static</span><br><span class="line">class B</span><br><span class="line">I&#x27;m B class</span><br></pre></td></tr></table></figure>
<details><summary>展开/折叠</summary>
正确答案: A</details>

<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>Java程序初始化顺序：</p>
<ol>
<li>父类的静态代码块</li>
<li>子类的静态代码块</li>
<li>父类的普通代码块</li>
<li>父类的构造方法</li>
<li>子类的普通代码块</li>
<li>子类的构造方法</li>
</ol>
<h1 id="考点4-成员变量有默认值-数组有默认值"><a href="#考点4-成员变量有默认值-数组有默认值" class="headerlink" title="考点4 成员变量有默认值 数组有默认值"></a>考点4 成员变量有默认值 数组有默认值</h1><p>关于如下程序的描述哪个是正确的？（ ）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String a[])</span>&#123;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A 编译将产生错误</li>
<li>B 编译时正确，但运行时将产生错误</li>
<li>C 正确，输出0</li>
<li>D 正确，输出 null</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: C</details>

<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h3 id="数组会自动初始化"><a href="#数组会自动初始化" class="headerlink" title="数组会自动初始化"></a>数组会自动初始化</h3><p><strong>数组</strong>无论是在定义为实例变量还是局部变量，若没有初始化，都<strong>会被自动初始化</strong></p>
<ul>
<li>Java中对于整型数组默认初始化0。</li>
<li>对字符数组初始化空格。</li>
<li>对对象数组初始化为null。</li>
</ul>
<h3 id="成员变量有默认值"><a href="#成员变量有默认值" class="headerlink" title="成员变量有默认值"></a>成员变量有默认值</h3><p>只有类的成员变量才有默认初始值。</p>
<h3 id="局部变量必须手动赋值"><a href="#局部变量必须手动赋值" class="headerlink" title="局部变量必须手动赋值"></a>局部变量必须手动赋值</h3><p>局部变量必须手动赋初值，否则编译报错</p>
<h1 id="考点5-JSP分页"><a href="#考点5-JSP分页" class="headerlink" title="考点5 JSP分页"></a>考点5 JSP分页</h1><p>JSP分页代码中，哪个步骤次序是正确的？</p>
<ul>
<li>A 先取总记录数，得到总页数，最后显示本页的数据。</li>
<li>B 先取所有的记录，得到总页数，再取总记录数，最后显示本页的数据。</li>
<li>C 先取总页数，得到总记录数，再取所有的记录，最后显示本页的数据。</li>
<li>D 先取本页的数据，得到总页数，再取总记录数，最后显示所有的记录。</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: A</details>

<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>不足:JSP方面的我还不是很了解<br>先取总记录数，得到总页数，再取所有的记录，最后显示本页的数据</p>
<h1 id="考点6-编译"><a href="#考点6-编译" class="headerlink" title="考点6 编译"></a>考点6 编译</h1><p>下面关于程序编译说法正确的是（）</p>
<ul>
<li>A java语言是编译型语言，会把java程序编译成二进制机器指令直接运行</li>
<li>B java编译出来的目标文件与具体操作系统有关</li>
<li>C java在运行时才进行翻译指令</li>
<li>D java编译出来的目标文件，可以运行在任意jvm上</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: C</details>

<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>A:java编译成的是字节码，再被各系统的jvm翻译成本系统可以识别的机器码，这就是java一次编程多平台应用的跨平台性<br>B:java源文件生成的是class文件，与系统无关<br>C:注意字节码和机器码不是一回事 java程序在运行时字节码才会被jvm翻译成机 器码，所以说java是解释性语言<br>D:注意jvm的版本，好比人穿裤子，一条裤子能被任何人穿上吗<br>低版本的jvm没有办法运行高版本的java代码</p>
<h1 id="考点7-线程"><a href="#考点7-线程" class="headerlink" title="考点7 线程"></a>考点7 线程</h1><p>下面说法正确的是？（）</p>
<ul>
<li>A 调用Thread的sleep()方法会释放锁，调用wait()方法不释放锁</li>
<li>B 一个线程调用yield方法，可以使具有相同优先级线程获得处理器</li>
<li>C 在Java中，高优先级的可运行的线程会抢占低优先级线程的资源</li>
<li>D java中，线程可以调用yield方法使比自己低优先级的线程运行</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: BC</details>

<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>yield()让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会。因此，<strong>使用yield()的目的是让具有<code>相同优先级</code>的线程之间能够适当的轮换执行</strong>。但是，实际中无法保证yield()达到让步的目的，因为，让步的线程可能被线程调度程序再次选中。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://m.baidu.com/s?iscookie=1&from=2001p&wd=java%E6%8A%BD%E8%B1%A1%E7%B1%BB+%E6%8E%A5%E5%8F%A3">抽象类和接口的区别</a></p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月4日_java_1</title>
    <url>/exam//3c848182/</url>
    <content><![CDATA[<h1 id="考点1-is-a-has-a-use-a"><a href="#考点1-is-a-has-a-use-a" class="headerlink" title="考点1 is-a has-a use-a"></a>考点1 is-a has-a use-a</h1><p>在面向对象编程里，经常使用is-a来说明对象之间的继承关系，下列对象中不具备继承关系的是？（）</p>
<ul>
<li>A 手机与小米手机</li>
<li>B 企业家与雷军</li>
<li>C 编程语言与Java</li>
<li>D 中国与北京</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: D</details>


<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>is-a 的关系：<br>A：小米手机是一个手机，没毛病<br>B：雷军是一个企业家，没毛病<br>C：Java是一门编程语言，没毛病<br>D：北京是一个中国，不对</p>
<h3 id="use-a-has-a-is-a"><a href="#use-a-has-a-is-a" class="headerlink" title="use-a has-a is-a"></a>use-a has-a is-a</h3><p>类之间存在以下几种常见的关系</p>
<ul>
<li>use-a :是依赖关系</li>
<li>has-a :一般是组合关系</li>
<li>is-a : 一般是继承关系</li>
</ul>
<h1 id="考点2-垃圾收集器"><a href="#考点2-垃圾收集器" class="headerlink" title="考点2 垃圾收集器"></a>考点2 垃圾收集器</h1><p>下面关于垃圾收集的描述哪个是错误的？</p>
<ul>
<li>A 使用垃圾收集的程序不需要明确释放对象</li>
<li>B 现代垃圾收集能够处理循环引用问题</li>
<li>C 垃圾收集能提高程序员效率</li>
<li>D 使用垃圾收集的语言没有内在泄漏问题</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: D</details>


<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>内存泄露(Memory Leak)是指<strong>一个不再被使用的对象或者变量还在内存中占有存储空间</strong>。<br>在C&#x2F;C++语言中，内存泄露出现在开发人员忘记释放已分配的内存就会造成内存泄露。<br>在java语言中引入垃圾回收机制，有GC负责进行回收不再使用的对象，释放内存。但是还是会存在内存泄露的问题。</p>
<h3 id="内存泄露主要有两种情况"><a href="#内存泄露主要有两种情况" class="headerlink" title="内存泄露主要有两种情况"></a>内存泄露主要有两种情况</h3><ol>
<li>在堆中申请的空间没有释放。</li>
<li>对象已不再被使用(注意：这里的不在被使用是指对程序来说没有用处，如数据库连接使用后没有关。但是还是存在着引用)，但是仍然在内存中保留着。GC机制的引入只能解决第一种情况，对于第2种情况无法保证不再使用的对象会被释放。java语言中的内存泄露主要指第2种情况。</li>
</ol>
<h3 id="内存泄露的原因"><a href="#内存泄露的原因" class="headerlink" title="内存泄露的原因"></a>内存泄露的原因</h3><ol>
<li>静态集合类。如HashMap和Vector。这些容器是静态的，生命周期和程序的生命周期一致，那么在容器中对象的生命周期也和其一样，对象在程序结束之前将不能被释放，从而会造成内存泄露。</li>
<li>各种连接，如数据库连接，网络连接，IO连接，不再使用时如果连接不释放容易造成内存泄露。</li>
<li>监听器，释放对象时往往没有相应的删除监听器，可能会导致内存泄露。</li>
</ol>
<h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>内存溢出（OOM）是指程序在申请内存时没有足够的内存供使用，进而导致程序崩溃这是结果描述。</p>
<p>内存泄露（Memory Leak）最终会导致内存溢出。</p>
<h3 id="Java的内存分配策略"><a href="#Java的内存分配策略" class="headerlink" title="Java的内存分配策略"></a>Java的内存分配策略</h3><p>Java 程序运行时的内存分配策略有三种,分别是<br><strong>静态分配</strong>,<strong>栈式分配</strong>,和<strong>堆式分配</strong>，对应的，<br>三种存储策略使用的内存空间主要分别是<strong>静态存储区</strong>（也称<strong>方法区</strong>）、<strong>栈区</strong>和<strong>堆区</strong>。</p>
<ul>
<li><strong>静态存储区（方法区）</strong>：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。</li>
<li><strong>栈区</strong>：当方法被执行时，方法体内的局部变量（其中包括基础数据类型、对象的引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li>
<li><strong>堆区</strong> ： 又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存，也就是对象的实例（包括该对象其中的所有成员变量）。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。</li>
</ul>
<h3 id="Java中的内存管理"><a href="#Java中的内存管理" class="headerlink" title="Java中的内存管理"></a>Java中的内存管理</h3><p>Java的内存管理就是对象的分配和释放问题。在 Java 中，程序员需要通过关键字 new 为每个对象申请内存空间 (基本类型除外)，所有的对象都在堆 (Heap)中分配空间。</p>
<h3 id="关于提高效率"><a href="#关于提高效率" class="headerlink" title="关于提高效率"></a>关于提高效率</h3><p>对象的释放是由 GC 决定和执行的。在 Java 中，内存的分配是由程序完成的，而内存的释放是由 GC 完成的，这种收支两条线的方法确实简化了程序员的工作。但同时，它也加重了JVM的工作。</p>
<h3 id="关于消除循环引用"><a href="#关于消除循环引用" class="headerlink" title="关于消除循环引用"></a>关于消除循环引用</h3><p>Java使用<strong>有向图</strong>的方式进行内存管理，可以消除引用循环的问题。<br>例如有三个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的。这种方式的优点是管理内存的精度很高，但是效率较低。<br>另外一种常用的内存管理技术是使用<strong>计数器</strong>。具体如下：gc清理时的引用计数方式：<br>当引用连接至新对象时，引用计数+1；<br>当某个引用离开作用域或被设置为null时，引用计数-1，<br>GC发现这个计数为0时，就回收其占用的内存。这个开销会在引用程序的整个生命周期发生，并且不能处理循环引用的情况。所以这种方式只是用来说明GC的工作方式，而不会被任何一种Java虚拟机应用。例如COM模型采用计数器方式管理构件，它与有向图相比，精度行低(很难处理循环引用的问题)，但执行效率很高。</p>
<h3 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h3><p>在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，</p>
<ul>
<li>首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；</li>
<li>其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</li>
</ul>
<p>有兴趣看引起内存泄漏的原因的可以参考这篇文章<a href="http://www.jb51.net/article/92311.htm">http://www.jb51.net/article/92311.htm</a></p>
<h1 id="考点3-x3D-x3D-比较运算符等于"><a href="#考点3-x3D-x3D-比较运算符等于" class="headerlink" title="考点3 &#x3D;&#x3D; 比较运算符等于"></a>考点3 &#x3D;&#x3D; 比较运算符等于</h1><p>下面的输出结果是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        String str=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A true</li>
<li>B false</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: B</details>

<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>这种题烂大街</p>
<h1 id="考点4-类方法-对象方法"><a href="#考点4-类方法-对象方法" class="headerlink" title="考点4 类方法 对象方法"></a>考点4 类方法 对象方法</h1><p>类方法中可以直接调用对象变量。（ ）</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: B</details>

<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h3 id="静态成员不能调用非静态成员"><a href="#静态成员不能调用非静态成员" class="headerlink" title="静态成员不能调用非静态成员"></a>静态成员不能调用非静态成员</h3><p>静态方法中不能调用对象的变量，因为静态方法在类加载时就初始化，对象变量需要在新建对象后才能使用</p>
<h1 id="考点5-方法形参传递-Java只有值传递"><a href="#考点5-方法形参传递-Java只有值传递" class="headerlink" title="考点5 方法形参传递 Java只有值传递"></a>考点5 方法形参传递 Java只有值传递</h1><p>下列java程序的输出结果为____。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span>&#123;</span><br><span class="line">    String str=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] ch=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        Example ex=<span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">        ex.change(ex.str,ex.ch);</span><br><span class="line">        System.out.print(ex.str+<span class="string">&quot; and &quot;</span>);</span><br><span class="line">        System.out.print(ex.ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str,<span class="type">char</span> ch[])</span>&#123;</span><br><span class="line">        str=<span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A hello and ab</li>
<li>B hello and cb</li>
<li>C hello and a</li>
<li>D test ok and ab</li>
<li>E test ok and cb</li>
<li>F test ok and c</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: B</details>

<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>java中只有值传递，改变形参的地址不影响到实参</p>
<h1 id="考点6-重载-重写"><a href="#考点6-重载-重写" class="headerlink" title="考点6 重载 重写"></a>考点6 重载 重写</h1><p>类Parent和Child定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Parent</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="type">float</span>  <span class="title function_">aFun</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Child</span>  <span class="keyword">extends</span>  <span class="title class_">Parent</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将以下哪种方法插入行5是不合法的。（    ）</p>
<ul>
<li>A <code>float aFun(float a, float b)&#123; &#125;</code></li>
<li>B <code>public int aFun(int a, int b) &#123; &#125;</code></li>
<li>C <code>public float aFun(float p, float q)&#123; &#125;</code></li>
<li>D <code>private int aFun(int a, int b)&#123; &#125;</code></li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: A</details>

<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>A.方法重写。子类方法不能缩小父类方法的访问权限，错误。<br>B.方法重载。参数列表不同，满足重载条件，正确。<br>C.方法重写。方法声明和父类相同，满足重写条件，正确。<br>D.方法重载。参数列表不同，满足重载条件，正确。</p>
<h3 id="方法重写-两同两小一大"><a href="#方法重写-两同两小一大" class="headerlink" title="方法重写 两同两小一大"></a>方法重写 两同两小一大</h3><p>方法重写要遵循“两同两小一大”规则，</p>
<ul>
<li>“两同”即<strong>方法名相同</strong>、<strong>形参列表</strong>相同；</li>
<li>“两小”指的是子类方法<strong>返回值类型</strong>应比父类方法返回值类型更小或相等，子类方法声明<strong>抛出的异常类</strong>应比父类方法声明抛出的异常类更小或相等；</li>
<li>“一大”指的是子类方法的<strong>访问权限</strong>应比父类方法的访问权限更大或相等。</li>
<li>并且，覆盖方法和被覆盖方法要么都是类方法，要么都是实例方法，不能一个是类方法一个是实例方法。</li>
</ul>
<h1 id="考点7-重载"><a href="#考点7-重载" class="headerlink" title="考点7 重载"></a>考点7 重载</h1><p>下面哪几个函数 public void example(){….} 的重载函数？（）</p>
<ul>
<li>A public void example(int m){…}</li>
<li>B public int example(){..}</li>
<li>C public void example2(){..}</li>
<li>D public int example(int m,float f){…}</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: AD</details>


<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><h3 id="方法重载-两同一不同"><a href="#方法重载-两同一不同" class="headerlink" title="方法重载 两同一不同"></a>方法重载 两同一不同</h3><p>同一个类中，方法名相同，形参列表不同<br>方法重载只用关心两个点：<br>1.方法名相同<br>2.参数列表不同（个数不同、顺序不同、类型不同）</p>
<h1 id="考点8-抽象类和接口的区别-JDK1-7"><a href="#考点8-抽象类和接口的区别-JDK1-7" class="headerlink" title="考点8 抽象类和接口的区别 JDK1.7"></a>考点8 抽象类和接口的区别 JDK1.7</h1><p>在Jdk1.7中，下述说法中抽象类与接口的区别与联系正确的有哪些？</p>
<ul>
<li>A 抽象类中可以有普通成员变量，接口中没有普通成员变量。</li>
<li>B 抽象类和接口中都可以包含静态成员常量。</li>
<li>C 一个类可以实现多个接口，但只能继承一个抽象类</li>
<li>D 抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法。</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: ABCD</details>


<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><table>
<thead>
<tr>
<th align="left">特点</th>
<th align="left">抽象类</th>
<th align="left">接口</th>
</tr>
</thead>
<tbody><tr>
<td align="left">构造方法</td>
<td align="left">有</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">普通成员变量</td>
<td align="left">有</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">普通方法</td>
<td align="left">可以有非抽象的</td>
<td align="left">必须是抽象的</td>
</tr>
<tr>
<td align="left">抽象方法的访问类型</td>
<td align="left">public、protected和默认</td>
<td align="left">只能是public的，默认public abstract</td>
</tr>
<tr>
<td align="left">静态方法</td>
<td align="left">可以有</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">静态成员变量</td>
<td align="left">有</td>
<td align="left">有 public static final的</td>
</tr>
<tr>
<td align="left">其他类</td>
<td align="left">只能继承一个抽象类</td>
<td align="left">可以实现多个接口</td>
</tr>
<tr>
<td align="left">应用场景</td>
<td align="left">模块之间通信契约</td>
<td align="left">代码重用</td>
</tr>
</tbody></table>
<h1 id="考点9-抽象类和接口的区别JDK1-8"><a href="#考点9-抽象类和接口的区别JDK1-8" class="headerlink" title="考点9 抽象类和接口的区别JDK1.8"></a>考点9 抽象类和接口的区别JDK1.8</h1><p>jdk1.8中，下面有关java 抽象类和接口的区别，说法错误的是？</p>
<ul>
<li>A 抽象类可以有构造方法，接口中不能有构造方法</li>
<li>B 抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法</li>
<li>C 一个类可以实现多个接口，但只能继承一个抽象类</li>
<li>D 接口中可以有普通成员变量，抽象类中没有普通成员变量</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: BD</details>

<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>B 的后半句是错误的，java8在接口中允许有方法体，不过必须是静态方法；<br>接口中不能有普通成员变量，所以D错误</p>
<h1 id="考点10-volatile-多线程"><a href="#考点10-volatile-多线程" class="headerlink" title="考点10 volatile 多线程"></a>考点10 volatile 多线程</h1><p>以下哪种JAVA得变量声明方式可以避免程序在多线程竞争情况下读到不正确的值(  )</p>
<ul>
<li>A volatile</li>
<li>B static volatile</li>
<li>C synchronized</li>
<li>D static</li>
</ul>
<p>正确答案: AB</p>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><p>synchronized不是修饰变量的 它修饰方法或代码块或对象</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月5日 java3</title>
    <url>/exam//d28ae0ae/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下面语句正确的是（）</p>
<ul>
<li>A x+1&#x3D;5</li>
<li>B i++&#x3D;1</li>
<li>C a++b&#x3D;1</li>
<li>D x+&#x3D;1</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="赋值运算左值必须是变量"><a href="#赋值运算左值必须是变量" class="headerlink" title="赋值运算左值必须是变量"></a>赋值运算左值必须是变量</h3><p>赋值运算符“&#x3D;”右值可以是任何常数、变量或者表达式（只要能生成一个值就行）。但<strong>左值必须是一个明确的、已命名的变量</strong><br>所以对于i++ &#x3D; 1，a++b &#x3D; 1，x+1&#x3D;5来说，赋值运算符的左边不是一个变量当然是错误的。</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>类Person里面有个方法sleep()，如果直接用Person.sleep()，则方法sleep前面必须用的关键词是？  (    )</p>
<ul>
<li>A class</li>
<li>B static</li>
<li>C public</li>
<li>D final</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>下列描述中，错误的是</p>
<ul>
<li>A SQL语言又称为结构化查询语言</li>
<li>B java中”static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问</li>
<li>C 面向对象开发中，引用传递意味着传递的并不是实际的对象，而是对象的引用，因此，外部对引用对象所做的改变不会反映到所引用的对象上</li>
<li>D java是强类型语言，javascript是弱类型语言</li>
<li>E 面向对象的三大特性包括：封装，继承，多态</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>这道题选C，因为引用代表就是所引用的是实际的对象，<strong>对引用的修改就是对对象的修改</strong>，可以理解为两把钥匙可以打开同一扇门，所以C错；其他几个选项都是对的</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>下列说法正确的是()</p>
<ul>
<li>A WebLogic中开发消息Bean的non－persistent 方式可以保证消息的可靠</li>
<li>B EJB容器发生错误，non－persistent方式下JMS容器仍然会将消息发送</li>
<li>C EJB容器发生错误，persistent方式下JMS容器仍然会将消息发送</li>
<li>D EJB容器发生错误，两种方式下JMS容器仍会在MDB可用的时候将消息发送</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>我不懂，解析我也看不懂，有空了解一下</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下列语句正确的是：</p>
<ul>
<li>A 形式参数可被字段修饰符修饰</li>
<li>B 形式参数不可以是对象</li>
<li>C 形式参数为方法被调用时真正被传递的参数</li>
<li>D 形式参数可被视为local variable</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>A：形式参数只能被final修饰<br>B：形式参数可以是对象<br>C：形式参数被调用时被传递的是实际参数的拷贝<br>D：local variable：局部变量</p>
<h3 id="修饰符待整理"><a href="#修饰符待整理" class="headerlink" title="修饰符待整理"></a>修饰符待整理</h3><p>Java语言提供了很多修饰符，大概分为两类： </p>
<ol>
<li>访问权限修饰符 </li>
<li>非访问权限修饰符<br>访问权限修饰符<br>public：共有访问。对所有的类都可见。<br>protected：保护型访问。对同一个包可见，对不同的包的子类可见。<br>default：默认访问权限。只对同一个包可见，注意对不同的包的子类不可见。<br>private：私有访问。只对同一个类可见，其余都不见。<br>非访问权限修饰符<br>static 修饰符，用来创建类方法和类变量。<br>final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。<br>abstract 修饰符，用来创建抽象类和抽象方法。<br>synchronized 用于多线程的同步。<br>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。<br>transient：序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。<br>类<br>外部类修饰符<br>public（访问控制符），将一个类声明为公共类，它可以被任何对象访问，一个程序的主类必须是公共类。<br>default（访问控制符），类只对包内可见，包外不可见。<br>abstract（非访问控制符），将一个类声明为抽象类，抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充，抽象类可以包含抽象方法和非抽象方法。。<br>final（非访问控制符），将一个类生命为最终（即非继承类），表示它不能被其他类继承。<br> 注意：</li>
</ol>
<p>1.protected 和 private 不能修饰外部类，是因为外部类放在包中，只有两种可能，包可见和包不可见。<br>2. final 和 abstract不能同时修饰外部类，因为该类要么能被继承要么不能被继承，二者只能选其一。<br>3.不能用static修饰类，因为类加载后才会加载静态成员变量。所以不能用static修饰类和接口，因为类还没加载，无法使用static关键字。<br>内部类修饰符<br>       内部类与成员变量地位一直，所以可以public,protected、default和private，同时还可以用static修饰，表示嵌套内部类，不用实例化外部类，即可调用。<br>方法修饰符<br>public（公共控制符），包外包内都可以调用该方法。<br>protected（保护访问控制符）指定该方法可以被它的类和子类进行访问。具体细节可参考：<a href="http://blog.csdn.net/dawn_after_dark/article/details/74453915">http://blog.csdn.net/dawn_after_dark/article/details/74453915</a><br>default(默认权限），指定该方法只对同包可见，对不同包（含不同包的子类）不可见。<br>private（私有控制符）指定此方法只能有自己类等方法访问，其他的类不能访问（包括子类），非常严格的控制。<br>final ,指定方法已完备，不能再进行继承扩充。<br>static，指定不需要实例化就可以激活的一个方法，即在内存中只有一份，通过类名即可调用。<br>synchronize，同步修饰符，在多个线程中，该修饰符用于在运行前，对它所属的方法加锁，以防止其他线程的访问，运行结束后解锁。<br>native，本地修饰符。指定此方法的方法体是用其他语言在程序外部编写的。<br>abstract ,抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。抽象方法不能被声明成 final 和 static。 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 抽象方法的声明以分号结尾，例如：public abstract sample();。<br>成员变量修饰符<br>public（公共访问控制符），指定该变量为公共的，它可以被任何对象的方法访问。<br>protected（保护访问控制符）指定该变量可以别被自己的类和子类访问。在子类中可以覆盖此变量。<br>default(默认权限），指定该变量只对同包可见，对不同包（含不同包的子类）不可见。<br>private（私有访问控制符）指定该变量只允许自己的类的方法访问，其他任何类（包括子类）中的方法均不能访问。<br>final，最终修饰符，指定此变量的值不能变。<br>static（静态修饰符）指定变量被所有对象共享，即所有实例都可以使用该变量。变量属于这个类。<br>transient（过度修饰符）指定该变量是系统保留，暂无特别作用的临时性变量。不持久化。<br>volatile（易失修饰符）指定该变量可以同时被几个线程控制和修改，保证两个不同的线程总是看到某个成员变量的同一个值。<br> final 和 static 经常一起使用来创建常量。<br>局部变量修饰符<br>only final is permitted。<br>为什么不能赋予权限修饰符？<br>因为局部变量的生命周期为一个方法的调用期间，所以没必要为其设置权限访问字段，既然你都能访问到这个方法，所以就没必要再为其方法内变量赋予访问权限，因为该变量在方法调用期间已经被加载进了虚拟机栈，换句话说就是肯定能被当前线程访问到，所以设置没意义。<br>为什么不能用static修饰<br>我们都知道静态变量在方法之前先加载的，所以如果在方法内设置静态变量，可想而知，方法都没加载，你能加载成功方法内的静态变量？<br>接口<br>接口修饰符<br>接口修饰符只能用public、default和abstract。<br>不能用final、static修饰。<br>接口默认修饰为abstract。<br>接口中方法修饰符<br>only public &amp; abstract are permitted 。<br>意思只能用 public abstract修饰，当然如果你什么都不写，默认就是public abstract。<br>注意：在Java1.8之后，接口允许定义static 静态方法了！所以也可以用static来修饰！</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>变量a是一个64位有符号的整数，初始值用16进制表示为：0Xf000000000000000； 变量b是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF。 则a-b的结果用10进制表示为多少？（）</p>
<ul>
<li>A 1</li>
<li>B -(2^62+2^61+2^60+1)</li>
<li>C 2^62+2^61+2^60+1</li>
<li>D 2^59+(2^55+2^54+…+2^2+2^1+2^0)</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0Xf000000000000000补码为1111000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">0x7FFFFFFFFFFFFFFF补码为0111111111111111111111111111111111111111111111111111111111111111</span><br><span class="line">a-b=a+(-b)=</span><br><span class="line">1111000000000000000000000000000000000000000000000000000000000000+</span><br><span class="line">1000000000000000000000000000000000000000000000000000000000000001=</span><br><span class="line">10111000000000000000000000000000000000000000000000000000000000001(高位溢出舍去)</span><br><span class="line">则结果为</span><br><span class="line">0111000000000000000000000000000000000000000000000000000000000001=</span><br><span class="line">2^62+2^61+2^60+1</span><br><span class="line">答案为C</span><br></pre></td></tr></table></figure>

<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>Java对象的初始化方式有（ ）</p>
<ul>
<li>A 初始化块</li>
<li>B 构造器</li>
<li>C 定义变量时指定初始化值</li>
<li>D 其它各项都不对</li>
</ul>
<p>正确答案: ABC</p>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><h3 id="对象的初始化方式"><a href="#对象的初始化方式" class="headerlink" title="对象的初始化方式"></a>对象的初始化方式</h3><p>1.new时初始化<br>2.静态工厂 newInstance；<br>3.反射Class.forName()；<br>4.clone方式；<br>5.反序列化；</p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>下面关于变量及其范围的陈述哪些是不正确的（）</p>
<ul>
<li>A 实例变量是类的成员变量</li>
<li>B 实例变量用关键字static声明</li>
<li>C 在方法中定义的局部变量在该方法被执行时创建</li>
<li>D 局部变量在使用前必须被初始化</li>
</ul>
<p>正确答案: BC</p>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>实例变量属于对象<br>c选项应该是在线程为该方法<strong>创建栈桢时</strong>被创建，而不是方法<strong>执行</strong>时创建</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月5日_Java_1</title>
    <url>/exam//3c848182/</url>
    <content><![CDATA[<h1 id="考点1-重载"><a href="#考点1-重载" class="headerlink" title="考点1 重载"></a>考点1 重载</h1><p>一个类中，有两个方法名、形参类型、顺序和个数都完全一样，返回值不一样的方法,这种现象叫覆盖。（  ）</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: B</details>


<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h1 id="考点2-Object类"><a href="#考点2-Object类" class="headerlink" title="考点2 Object类"></a>考点2 Object类</h1><p>以下关于Object类的说法正确的是（）</p>
<ul>
<li>A Java中所有的类都直接或间接继承自Object，无论是否明确的指明，无论其是否是抽象类。</li>
<li>B Java中的接口(interface)也继承了Object类</li>
<li>C 利用“&#x3D;&#x3D;”比较两个对象时，Java调用继承自Object的equals方法，判断是否相等。</li>
<li>D 如果类的定义中没有重新定义toString()方法，则该类创建的对象无法使用toStrig()方法。</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: A</details>

<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><ul>
<li>A. Java中的所有类都直接或间接继承自Object，无论是否明确的指明，也无论其是否是抽象类。</li>
<li>B. Java中的接口（interface）并没有继承自Object一个类的子类必然是另一个类，如果interface继承自Object，那么interface也必然是一个类。这和接口的定义矛盾</li>
</ul>
<h1 id="考点3-try-catch-finally返回值"><a href="#考点3-try-catch-finally返回值" class="headerlink" title="考点3 try-catch-finally返回值"></a>考点3 try-catch-finally返回值</h1><p>执行如下代码后输出结果为（ ）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;return value of getValue(): &quot;</span> + getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A return value of getValue(): 1</li>
<li>B return value of getValue(): 4</li>
<li>C return value of getValue(): 5</li>
<li>D 其他几项都不对</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: C</details>


<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><h1 id="考点4-集合Collection-List和Set的区别"><a href="#考点4-集合Collection-List和Set的区别" class="headerlink" title="考点4 集合Collection List和Set的区别"></a>考点4 集合Collection List和Set的区别</h1><p>列表(List)和集合(Set)下面说法正确的是？  ( )</p>
<ul>
<li>A Set中至多只能有一个空元素</li>
<li>B List中至多只能有一个空元素</li>
<li>C List和Set都可以包含重复元素的有序集合</li>
<li>D List和Set都是有序集合</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: A</details>

<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><ul>
<li>Set 不能有重复的元素，且是无序的，要有空值也就只能有一个。因为它不允许重复。 </li>
<li>List 可以有重复元素，且是有序的，要有空值也可以有多个，因为它可重复</li>
</ul>
<h3 id="集合中的有序的含义"><a href="#集合中的有序的含义" class="headerlink" title="集合中的有序的含义"></a>集合中的有序的含义</h3><p>java里面讲的<strong>有序无序</strong>，指的是你按照顺序存进去数据，然后再按照顺序取出来，两者是一样的。比如List(0)我放的是“a”，那么我list.get(0)取出来也是“a”。<br>并不代表我存了打乱顺序存1到10十个数，它会自己给按照升序或者降序给你排好序。</p>
<h1 id="考点5-静态成员变量"><a href="#考点5-静态成员变量" class="headerlink" title="考点5 静态成员变量"></a>考点5 静态成员变量</h1><p>关于以下程序代码的说明正确的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasStatic</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[ ])</span>&#123;</span><br><span class="line">        <span class="type">HasStatic</span> <span class="variable">hs1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HasStatic</span>();</span><br><span class="line">        hs1.x++;</span><br><span class="line">        <span class="type">HasStatic</span> <span class="variable">hs2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HasStatic</span>();</span><br><span class="line">        hs2.x++;</span><br><span class="line">        hs1=<span class="keyword">new</span> <span class="title class_">HasStatic</span>();</span><br><span class="line">        hs1.x++;</span><br><span class="line">        HasStatic.x--;</span><br><span class="line">        System.out.println( <span class="string">&quot;x=&quot;</span> +x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 5行不能通过编译，因为引用了私有静态变量</li>
<li>B 10行不能通过编译，因为x是私有静态变量</li>
<li>C 程序通过编译，输出结果为：x&#x3D;103</li>
<li>D 程序通过编译，输出结果为：x&#x3D;102</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: D</details>

<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><ul>
<li>此处是main函数在这个类内部，因而可以访问私有的静态成员。</li>
<li>在其他类中的main方法是会显示语法有错</li>
</ul>
<h1 id="考点6-命令行参数"><a href="#考点6-命令行参数" class="headerlink" title="考点6 命令行参数"></a>考点6 命令行参数</h1><p>如下的Java程序 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        System.out.println(args[<span class="number">0</span>]); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p> 若采用命令行“java Test one two three”调用，则程序输出的结果为：</p>
<ul>
<li>A Test</li>
<li>B one</li>
<li>C two</li>
<li>D java</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: B</details>

<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>不要和linux脚本的参数弄混了。</p>
<ul>
<li>Linux里$0是程序名，$1以后才是参数</li>
<li>java里arg[0]就是第一个参数</li>
</ul>
<h1 id="考点7-前加加和后加加不可同时使用"><a href="#考点7-前加加和后加加不可同时使用" class="headerlink" title="考点7 前加加和后加加不可同时使用"></a>考点7 前加加和后加加不可同时使用</h1><p>以下代码段执行后的输出结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">5</span>;</span><br><span class="line">        i =  ++(i++);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A -7</li>
<li>B -3</li>
<li>C 编译错误</li>
<li>D -5</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: C</details>


<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>i++表示<strong>先赋值后加1</strong>，但前面又有一个++<strong>表示先加1再赋值</strong>，矛盾，编译器报错。</p>
<h1 id="考点8-JVM规范-java内存区域"><a href="#考点8-JVM规范-java内存区域" class="headerlink" title="考点8 JVM规范 java内存区域"></a>考点8 JVM规范 java内存区域</h1><p>以下哪些内存区域属于JVM规范？（　　）</p>
<ul>
<li>A 方法区</li>
<li>B 实例变量</li>
<li>C 静态变量</li>
<li>D 程序计数器</li>
<li>E 虚拟机栈</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: ADE</details>

<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>JVM内存区：</p>
<ul>
<li>程序计数器、</li>
<li>虚拟机栈、</li>
<li>本地方法栈、</li>
<li>堆、</li>
<li>方法区（包括常量池）。</li>
</ul>
<p>不属于JVM内存区：直接内存（Direct Memory），用户I&#x2F;O操作</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月5日_Java_2</title>
    <url>/exam//a58dd038/</url>
    <content><![CDATA[<h1 id="考点1-数据库-关系模型和对象模型的匹配关系"><a href="#考点1-数据库-关系模型和对象模型的匹配关系" class="headerlink" title="考点1 数据库 关系模型和对象模型的匹配关系"></a>考点1 数据库 关系模型和对象模型的匹配关系</h1><p>一般情况下，以下哪个选项不是关系数据模型与对象模型之间匹配关系？</p>
<ul>
<li>A 表对应类</li>
<li>B 记录对应对象</li>
<li>C 表的字段对应类的属性</li>
<li>D 表之间的参考关系对应类之间的依赖关系</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: D</details>

<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>一般关系数据模型和对象数据模型之间有以下对应关系：</p>
<ul>
<li>表对应类，</li>
<li>记录对应对象，</li>
<li>表的字段对应类的属性</li>
</ul>
<p>目前ORMapping只是规定了数据结构和数据集的映射关系，还没到规定赖关系的阶段</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>已知有下列Test类的说明，在该类的main方法内，则下列哪个语句是正确的？（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.0f</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String args[])</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A t.f;</li>
<li>B this.n;</li>
<li>C Test.m</li>
<li>D Test.f</li>
</ul>
<details><summary>展开/折叠</summary>
正确答案: A</details>

<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>A的答案中变量虽然为private，但因为main函数在该类中，所以即使private也仍可使用</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>下面赋值语句中正确的是（）</p>
<ul>
<li>A double d&#x3D;5.3e12;</li>
<li>B float f&#x3D;11.1;</li>
<li>C int i&#x3D;0.0;</li>
<li>D Double oD&#x3D;3;</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>java中整型默认的是int,浮点默认的是double.<br>A: double类型遵循IEEE754标准（具体自己查一下），约为10^-308<del>10^308和-10^-308</del>-10^308，所以本题在范围里<br>B: double类型的11.1 转成 float，是需要强制转换的<br>C: double类型的0.0 转成 int，也是需要强制转换的<br>D: int 转为 封装类型Double，是无法编译的，int虽可以转换成double，但在类型转换时无法进行自动装箱，故错误</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>下列不属于Java语言性特点的是</p>
<ul>
<li>A Java致力于检查程序在编译和运行时的错误</li>
<li>B Java能运行虚拟机实现跨平台</li>
<li>C Java自己操纵内存减少了内存出错的可能性</li>
<li>D Java还实现了真数组，避免了覆盖<code>数据类型</code>的可能</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h3 id="什么是真数组"><a href="#什么是真数组" class="headerlink" title="什么是真数组"></a>什么是真数组</h3><p>程序设计语言中，数组元素在内存中是一个接着一个线性存放的，通过第一个元素就能访问随后的元素，这样的数组称之为“真数组”。<br>实现了真数组为Java语言健壮性的特点之一。</p>
<p>真数组：<br>1、在内存中连续分配。<br>2、数组所存在的内存空间为数组专用，避免了<code>数据</code>被覆盖的问题。</p>
<p>是避免数据覆盖，而不是数据类型覆盖</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>在java语言中，如果你编写一个多线程序，可以使用的方法是（）</p>
<ul>
<li>A 扩展类Thread</li>
<li>B 实现Runnable接口</li>
<li>C 扩展类 Runnable</li>
<li>D 实现接口Thread</li>
</ul>
<p>正确答案: AB</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>Java多线程实现方式主要有四种：<br>1、继承Thread类<br>2、实现Runnable接口<br>3、实现Callable接口通过FutureTask包装器来创建Thread线程<br>4、使用ExecutorService、Callable、Future实现有返回结果的多线程</p>
<p>前两种方式线程执行完后都没有返回值，后两种是带返回值的。</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下面哪几个语句正确的声明一个整型的二维数组（）</p>
<ul>
<li>A int a[][]&#x3D;new int[][]</li>
<li>B int b[10][10]&#x3D;new int[][]</li>
<li>C int c[][]&#x3D;new int[10][10]</li>
<li>D int []d[]&#x3D;new int[10][10]</li>
</ul>
<p>正确答案: CD</p>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><ol>
<li>定义一维数组时，必须显式指明数组的长度；</li>
<li>定义多维数组时，其<strong>一维数组的长度必须首先指明</strong>，其他维数组长度可以稍后指定；</li>
<li>采用给定值初始化数组时，不必指明长度；</li>
<li>“[]” 是数组运算符的意思，在声明一个数组时，数组运算符可以放在数据类型与变量之间，也可以放在变量之后。</li>
</ol>
<p>一维数组中，[]在变量名arr前还是后，这个写法没有固定的要求，<br>二维数组中，[][]a这三个元素其实可以作<strong>全排列</strong>，不论怎么排都不影响最后的编译结果，写法没有固定的要求。<br>在实际编程中，但最好统一。</p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>有以下程序段， 则下面正确的选项是（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThead</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyThead t=<span class="keyword">new</span> <span class="title class_">MyThead</span>();</span><br><span class="line">        MyThead s=<span class="keyword">new</span> <span class="title class_">MyThead</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;one.&quot;</span>);</span><br><span class="line">        s.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;two.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 编译失败</li>
<li>B 程序运行可能结果为： one. Thread two. Thread</li>
<li>C 程序运行可能结果是： one. two. Thread Thread</li>
<li>D 程序运行结果不稳定</li>
</ul>
<p>正确答案: BCD</p>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>同一个线程中的输出顺序是确定的，main线程中的输出语句确定，也就是，只要one在two前面输出，thread在其后面那个位置输出无所谓。</p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>java8中，忽略内部接口的情况，不能用来修饰interface里的方法的有（ ）</p>
<ul>
<li>A private</li>
<li>B public</li>
<li>C protected</li>
<li>D static</li>
</ul>
<p>正确答案: AC</p>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>java8 接口新特性：可以定义：</p>
<ul>
<li>静态方法（有方法体） 和</li>
<li>default方法（有方法体</li>
</ul>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>有关线程的叙述正确的是()</p>
<ul>
<li>A 可以获得对任何对象的互斥锁定</li>
<li>B 通过继承Thread类或实现Runnable接口，可以获得对类中方法的互斥锁定</li>
<li>C 线程通过使用synchronized关键字可获得对象的互斥锁定</li>
<li>D 线程调度算法是平台独立的</li>
</ul>
<p>正确答案: CD</p>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>A，“任何对象”锁定，太绝对了，你能锁住你没有权限访问的对象吗？<br>B，前半句话讲的是创建线程的方式，后半句讲的是锁定，驴头不对马嘴。<br>C，正确。<br>D，线程调度分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。<br>以上，选CD</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月6日 java1</title>
    <url>/exam//e64ad3fc/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>关于容器下面说法正确的是？ ( )</p>
<ul>
<li>A 列表(List)和集合(Set)存放的元素都是可重复的。</li>
<li>B 列表(List)和集合(Set)存放的元素都是不可重复的。</li>
<li>C 映射(Map)&lt;key,value&gt;中key是可以重复的。</li>
<li>D 映射(Map)&lt;key,value&gt;中value是可以重复的。</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul>
<li>List列表的元素是有序的，可重复的</li>
<li>集合Set的元素是无序的，不可重复的</li>
<li>map是使用的是键值对存放，key不重复，value是可重复的</li>
</ul>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>以下关于继承的叙述正确的是</p>
<ul>
<li>A 在Java中类只允许单一继承</li>
<li>B 在Java中一个类不能同时继承一个类和实现一个接口</li>
<li>C 在Java中接口只允许单一继承</li>
<li>D 在Java中一个类只能实现一个接口</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><ul>
<li>类支持单继承，</li>
<li>接口支持多继承，一个接口可以有多个父接口，子接口扩展某个父接口，将会获得父接口里定义的所有抽象方法、常量。一个接口继承多个父接口时，多个父接口排在extends关键字之后。</li>
</ul>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>以下会产生信息丢失的类型转换是( ）</p>
<ul>
<li>A float a&#x3D;10</li>
<li>B int a&#x3D;（int）8846.0</li>
<li>C byte a&#x3D;10； int b&#x3D;-a</li>
<li>D double d&#x3D;100</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>精度丢失只会发生在从大范围到小范围的转换<br>上面四个选项，只有 B 是从 double 到 int，也就是从大范围到小范围。</p>
<p>float a&#x3D;10.0; 是把 double 转车 float. 会损失精度. 正确的写法是 float&#x3D;10.0f;</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>java Thread中，run方法和start方法的区别，下面说法错误的是？</p>
<ul>
<li>A 通过调用Thread类的start()方法来启动一个线程，这时此线程是处于就绪状态，并没有运行。</li>
<li>B 他们都可以实现了多线程运行。</li>
<li>C run方法是thread的一个普通方法调用。</li>
<li>D 调用start方法后，一旦得到cpu时间片，就开始执行run()方法。</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h3 id="start方法和run方法的区别"><a href="#start方法和run方法的区别" class="headerlink" title="start方法和run方法的区别"></a>start方法和run方法的区别</h3><h4 id="1-start方法"><a href="#1-start方法" class="headerlink" title="1.start方法"></a>1.start方法</h4><p>用start方法来启动线程，是真正实现了多线程，<br>通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法。但要注意的是，此时无需等待run()方法执行完毕，即可继续执行下面的代码。所以run()方法并没有实现多线程。</p>
<h4 id="2-run方法"><a href="#2-run方法" class="headerlink" title="2.run方法"></a>2.run方法</h4><p>run()方法只是类的一个普通方法而已，<strong>如果直接调用run方法，程序中依然只有主线程这一个线程</strong>，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码。</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下面哪个选项正确创建socket连接？</p>
<ul>
<li>A Socket s &#x3D; new Socket(8080);</li>
<li>B Socket s &#x3D; new Socket(“192.168.1.1”,8080)</li>
<li>C SocketServer s &#x3D; new Socket(8080);</li>
<li>D Socket s &#x3D; new SocketServer(“192.168.1.1”,8080)</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><h3 id="创建客户端Socket"><a href="#创建客户端Socket" class="headerlink" title="创建客户端Socket"></a>创建客户端Socket</h3><p>创建 Socket 肯定要知道服务器ip 和 port 啊<br>服务器的 ServerSocket 只需要开放端口号就行啦<br>也就是<br>服务器端：ServerSocket提供的实例 ServerSocket server &#x3D; new ServerSocket(端口号)<br>客户端：Socket提供的实例 Socket client &#x3D; new Socket(IP地址，端口号)</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>变量a是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF;变量b是一个64位有符号的整数，初始值用16进制表示为：0x8000000000000000。则a+b的结果用10进制表示为多少？</p>
<ul>
<li>A 1</li>
<li>B -1</li>
<li>C 2^63+2^62+…+2^2+2^1+2^0</li>
<li>D –(2^63+2^62+…+2^2+2^1+2^0)</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>计算机中是以补码存储并参与运算的，所以题目中的初始值均是补码<br>（1）a+b的16进制表示为：OxFFFFFFFFFFFFFFF（16位F），转为2进制为111……111（64位1，每个F-&gt;4位2）。<br>（2）有符号数：是针对二进制来讲的。用最高位作为符号位，“0”代表“+”，“1”代表“-”。所以a+b的结果是一个负数。<br>（3）计算机中负数是以补码的形式保存的，将补码转换成原码的计算方式如下：<br>        ①. 对于正数，原码与补码相同。<br>        ②.对于负数，将补码除符号位之外，按位取反，末位加1，即得到原码。<br>（4）a + b &#x3D; 111……111（64位1）<br>          取反：100……000（1位1，后面63位0）<br>          加一：100……001（中间62位0）<br>      10进制：-1。</p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>代码片段： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> b1=<span class="number">1</span>,b2=<span class="number">2</span>,b3,b6;  </span><br><span class="line"><span class="keyword">final</span> <span class="type">byte</span> b4=<span class="number">4</span>,b5=<span class="number">6</span>;  </span><br><span class="line">b6=b4+b5;  </span><br><span class="line">b3=(b1+b2);  </span><br><span class="line">System.out.println(b3+b6);</span><br></pre></td></tr></table></figure>
<p>关于上面代码片段叙述正确的是（）</p>
<ul>
<li>A 输出结果：13</li>
<li>B 语句：b6&#x3D;b4+b5编译出错</li>
<li>C 语句：b3&#x3D;b1+b2编译出错</li>
<li>D 运行期抛出异常</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>没有final修饰的byte变量相加后会被自动提升为int型，与目标类型byte不相容，需要强制转换（向下转型）。</p>
<h3 id="表达式的数据类型自动提升规则。"><a href="#表达式的数据类型自动提升规则。" class="headerlink" title="表达式的数据类型自动提升规则。"></a>表达式的数据类型自动提升规则。</h3><p>①所有的byte,short,char型的值将被提升为int型；<br>②如果有一个操作数是long型，计算结果是long型；<br>③如果有一个操作数是float型，计算结果是float型；<br>④如果有一个操作数是double型，计算结果是double型；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">byte</span> b4=<span class="number">4</span>,b5=<span class="number">6</span>;</span><br><span class="line">b6=b4+b5;  </span><br></pre></td></tr></table></figure>
<p>声明b4与b5为final常量，不可改变。<br>所以b4+b5的结果为byte类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> b1=<span class="number">1</span>,b2=<span class="number">2</span>;</span><br><span class="line">b3=(b1+b2);  </span><br></pre></td></tr></table></figure>
<p>b1+b2的结果会自动升级为int类型。<br>int类型赋值给低级别byte的需要强制转换。</p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>已知如下的命令执行 java MyTest a b c 请问哪个语句是正确的？ ( )</p>
<ul>
<li>A args[0] &#x3D; “MyTest a b c”</li>
<li>B args[0] &#x3D; “MyTest”</li>
<li>C args[0] &#x3D; “a”</li>
<li>D args[1]&#x3D; “b”</li>
</ul>
<p>正确答案: CD</p>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>对于代码 var a &#x3D; 10.42; 取出 a 的整数部分，以下代码哪些是正确的？</p>
<ul>
<li>A parseInt(a);</li>
<li>B Math.floor(a);</li>
<li>C Math.ceil(a);</li>
<li>D a.split(‘.’)[0];</li>
</ul>
<p>正确答案: AB</p>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><h3 id="Math的ceil-floor-round详解"><a href="#Math的ceil-floor-round详解" class="headerlink" title="Math的ceil floor round详解"></a>Math的ceil floor round详解</h3><ul>
<li>Math.ceil(); ceiling（天花板） 所以向上取整</li>
<li>Math.floor();floor（地板）所以向下取整</li>
<li>Math.round() <ul>
<li>对于正数是四舍五入，</li>
<li>对于负数,<ul>
<li>小数点后的数&lt;&#x3D;5都是舍去，</li>
<li>而大于5是减一</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关于java-10引入的var"><a href="#关于java-10引入的var" class="headerlink" title="关于java 10引入的var"></a>关于java 10引入的var</h3><p>2018年3月20日，Oracle发布java10。java10为java带来了很多新特性，其中包括var关键字的引入。<br>eg：<br>public class Example {<br>    public static void main(String[] args) {<br>        var eg &#x3D; new Example;<br>        eg.emptyFunc();<br>    }<br>    public void emptyFunc() {}<br>}</p>
<h4 id="java对var的要求"><a href="#java对var的要求" class="headerlink" title="java对var的要求"></a>java对var的要求</h4><p>java在var上是有要求的。总结起来，有以下三点很重要：<br>（1）只能用于局部变量上；<br>（2）声明时必须初始化；<br>（3）不能用作方法参数。</p>
<h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>下面关于面向对象的一些理解哪些是错误的(    )</p>
<ul>
<li>A 面向对象的最重要的特性是支持继承、封装和多态</li>
<li>B 系统设计应该遵循开闭原则，系统应该稳定不不可修改，但应支持通过继承、组合等方式进行扩展</li>
<li>C 函数式的语言必然是面向对象的语言</li>
<li>D 面向对象设计时，每个类的职责应该单一，不要再一个类中引入过多的接口</li>
<li>E 过程式语言和面向对象的语言各有其优势，过程式语言更加灵活，面向对象语言更加强调抽象和封装</li>
<li>F Java和C++都是静态类型的面向对象编程语言</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><h3 id="什么是动态类型语言"><a href="#什么是动态类型语言" class="headerlink" title="什么是动态类型语言"></a>什么是动态类型语言</h3><p>动态类型语言是指<strong>在运行期间才去做数据类型检查的语言</strong>，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。</p>
<h3 id="什么是静态类型语言"><a href="#什么是静态类型语言" class="headerlink" title="什么是静态类型语言"></a>什么是静态类型语言</h3><p>静态类型语言与动态类型语言刚好相反，它的<strong>数据类型是在编译其间检查的，也就是说在写程序时要声明所有变量的数据类型</strong>，C&#x2F;C++是静态类型语言的典型代表，其他的静态类型语言还有C#、JAVA等。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月6日 java2</title>
    <url>/exam//7f438246/</url>
    <content><![CDATA[<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            dianping();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.run();</span><br><span class="line">    System.out.print(<span class="string">&quot;dazhong&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dianping</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;dianping&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A dazhongdianping</li>
<li>B dianpingdazhong</li>
<li>C a和b都有可能</li>
<li>D dianping循环输出，dazhong夹杂在中间</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul>
<li>调用run()方法不会创建一个新的线程，也就是现在只有一个main线程，run方法在main线程中执行。</li>
<li>一个线程中的代码执行顺序是固定的，所以先执行run()，在输出dazhong</li>
<li>调用start()方法才会创建线程。</li>
</ul>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>下面有关java object默认的基本方法，说法错误的是？</p>
<ul>
<li>A equals(Object obj) 指示某个其他对象是否与此对象“相等”</li>
<li>B copy() 创建并返回此对象的一个副本</li>
<li>C wait() 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法</li>
<li>D toString() 返回该对象的字符串表示</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>Object中没有copy方法，想不到吧！</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>结构型模式中最体现扩展性的模式是（）</p>
<ul>
<li>A 装饰模式</li>
<li>B 合成模式</li>
<li>C 桥接模式</li>
<li>D 适配器</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><h3 id="什么是结构型模式"><a href="#什么是结构型模式" class="headerlink" title="什么是结构型模式"></a>什么是结构型模式</h3><p>结构型模式是<strong>描述如何将类对象结合在一起，形成一个更大的结构</strong>。<br>结构模式描述两种不同的东西：类与类的实例。故可以分为类结构模式和对象结构模式。</p>
<h3 id="GoF结构型模式"><a href="#GoF结构型模式" class="headerlink" title="GoF结构型模式"></a>GoF结构型模式</h3><p>在GoF设计模式中，结构型模式有：</p>
<h4 id="1-适配器模式-Adapter"><a href="#1-适配器模式-Adapter" class="headerlink" title="1.适配器模式 Adapter"></a>1.适配器模式 Adapter</h4><p>适配器模式是将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>两个成熟的类需要通信，但是接口不同，由于开闭原则，我们不能去修改这两个类的接口，所以就需要一个适配器来完成衔接过程。</p>
<h4 id="2-桥接模式-Bridge"><a href="#2-桥接模式-Bridge" class="headerlink" title="2.桥接模式 Bridge"></a>2.桥接模式 Bridge</h4><p>桥接模式将抽象部分与它的实现部分分离，是它们都可以独立地变化。它很好的支持了开闭原则和组合锯和复用原则。实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这些多角度分离出来让他们独立变化，减少他们之间的耦合。</p>
<h4 id="3-组合模式-Composite"><a href="#3-组合模式-Composite" class="headerlink" title="3.组合模式 Composite"></a>3.组合模式 Composite</h4><p>组合模式将对象组合成树形结构以表示部分-整体的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<h4 id="4-装饰模式-Decorator"><a href="#4-装饰模式-Decorator" class="headerlink" title="4.装饰模式 Decorator"></a>4.装饰模式 Decorator</h4><p>装饰模式动态地给一个对象添加一些额外的职责，就增加功能来说，它比生成子类更灵活。也可以这样说，装饰模式把复杂类中的核心职责和装饰功能区分开了，这样既简化了复杂类，有去除了相关类中重复的装饰逻辑。<br>装饰模式没有通过继承原有类来扩展功能，但却达到了一样的目的，而且比继承更加灵活，所以可以说装饰模式是继承关系的一种替代方案。</p>
<h4 id="5-外观模式-Facade"><a href="#5-外观模式-Facade" class="headerlink" title="5.外观模式 Facade"></a>5.外观模式 Facade</h4><p> 外观模式为子系统中的一组接口提供了同意的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>外观模式中，客户对各个具体的子系统是不了解的，所以对这些子系统进行了封装，对外只提供了用户所明白的单一而简单的接口，用户直接使用这个接口就可以完成操作，而不用去理睬具体的过程，而且子系统的变化不会影响到用户，这样就做到了信息隐蔽。</p>
<h4 id="6-享元模式-Flyweight"><a href="#6-享元模式-Flyweight" class="headerlink" title="6.享元模式 Flyweight"></a>6.享元模式 Flyweight</h4><p> 享元模式为运用共享技术有效的支持大量细粒度的对象。因为它可以通过共享大幅度地减少单个实例的数目，避免了大量非常相似类的开销。享元模式是一个类别的多个对象共享这个类别的一个对象，而不是各自再实例化各自的对象。这样就达到了节省内存的目的。</p>
<h4 id="7-代理模式-Proxy"><a href="#7-代理模式-Proxy" class="headerlink" title="7.代理模式 Proxy"></a>7.代理模式 Proxy</h4><p>为其他对象提供一种代理，并由代理对象控制对原对象的引用，以间接控制对原对象的访问。</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下面有关 java 类加载器,说法正确的是?()</p>
<ul>
<li>A 引导类加载器(bootstrap class loader):它用来加载 Java 的核心库,是用原生代码来实现的</li>
<li>B 扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。</li>
<li>C 系统类加载器(system class loader):它根据 Java 应用的类路径(CLASSPATH)来加载 Java 类</li>
<li>D tomcat 为每个 App 创建一个 Loader,里面保存着此 WebApp 的 ClassLoader。需要加载 WebApp 下的类时,就取出 ClassLoader 来使用</li>
</ul>
<p>正确答案: ABCD</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h3 id="1）Bootstrap-ClassLoader"><a href="#1）Bootstrap-ClassLoader" class="headerlink" title="1）Bootstrap ClassLoader"></a>1）Bootstrap ClassLoader</h3><p>负责加载$JAVA_HOME中jre&#x2F;lib&#x2F;rt.jar里所有的class，由C++实现，不是ClassLoader子类</p>
<h3 id="2）Extension-ClassLoader"><a href="#2）Extension-ClassLoader" class="headerlink" title="2）Extension ClassLoader"></a>2）Extension ClassLoader</h3><p>负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre&#x2F;lib&#x2F;*.jar或-Djava.ext.dirs指定<br>目录下的jar包</p>
<h3 id="3）App-ClassLoader"><a href="#3）App-ClassLoader" class="headerlink" title="3）App ClassLoader"></a>3）App ClassLoader</h3><p>负责记载classpath中指定的jar包及目录中class</p>
<h3 id="4）Custom-ClassLoader"><a href="#4）Custom-ClassLoader" class="headerlink" title="4）Custom ClassLoader"></a>4）Custom ClassLoader</h3><p> 属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader</p>
<h3 id="自底向上检查类是否加载"><a href="#自底向上检查类是否加载" class="headerlink" title="自底向上检查类是否加载"></a>自底向上检查类是否加载</h3><p>加载过程中会先检查类是否被已加载，检查顺序是自底向上，<br>从Custom ClassLoader到BootStrap<br>ClassLoader逐层检查，<br>只要某个classloader已加载就视为已加载此类</p>
<h3 id="加载顺序自顶向下"><a href="#加载顺序自顶向下" class="headerlink" title="加载顺序自顶向下"></a>加载顺序自顶向下</h3><p>而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>Java类Demo中存在方法func0、func1、func2、func3和func4，请问该方法中，哪些是不合法的定义？( )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">　　<span class="type">float</span> <span class="title function_">func0</span><span class="params">()</span></span><br><span class="line">　　&#123;</span><br><span class="line">　　　　<span class="type">byte</span> i=<span class="number">1</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="type">float</span> <span class="title function_">func1</span><span class="params">()</span></span><br><span class="line">　　&#123;</span><br><span class="line">　　　　<span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">　　　　<span class="keyword">return</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="type">float</span> <span class="title function_">func2</span><span class="params">()</span></span><br><span class="line">　　&#123;</span><br><span class="line">　　　　<span class="type">short</span> i=<span class="number">2</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="type">float</span> <span class="title function_">func3</span><span class="params">()</span></span><br><span class="line">　　&#123;</span><br><span class="line">　　　　<span class="type">long</span> i=<span class="number">3</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="type">float</span> <span class="title function_">func4</span><span class="params">()</span></span><br><span class="line">　　&#123;</span><br><span class="line">　　　　<span class="type">double</span> i=<span class="number">4</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A func1</li>
<li>B func2</li>
<li>C func3</li>
<li>D func4</li>
</ul>
<p>正确答案: AD</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>这道题考的是数据类型转换问题。由大到小需要强制转换，由小到大不需要。<br>A：return;   没有返回值，错误<br>B：short 转成 float 无须强制转换，正确<br>C：long 转成 float  无须强制转换（这个最选项容易出错），正确。<br>float占4个字节为什么比long占8个字节大呢，因为底层的实现方式不同。<br>浮点数的32位并不是简单直接表示大小，而是按照一定标准分配的。<br>第1位，符号位，即S<br>接下来8位，指数域，即E。<br>剩下23位，小数域，即M，取值范围为[1 ,2 ) 或[0 , 1)<br>然后按照公式：<br>V&#x3D;(-1)^s * M * 2^E<br>也就是说浮点数在内存中的32位不是简单地转换为十进制，而是通过公式来计算而来</p>
<p>虽然float只有4个字节，但浮点数最大值要比长整型的范围要大。<br>D：double → float 没有强制转换，错误。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月7日 java3</title>
    <url>/exam//e786d9ee/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下列语句：<code>int *p, a = 10;  p = &amp;a</code>.<br>均表示地址的是（）</p>
<ul>
<li>A <code>a , p, &amp;a</code></li>
<li>B <code>&amp;*a,&amp;a,*p</code></li>
<li>C <code>*&amp;p, *p, &amp;a</code></li>
<li>D <code>&amp;a, p, &amp;*p</code></li>
</ul>
<p>正确答案: D</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul>
<li><code>*p</code>表示指针p</li>
<li><code>&amp;a</code>表示取a的内存地址</li>
<li><code>p = &amp;a</code> 表示p等于a的内存地址</li>
<li><code>&amp;*p</code>表示获取指针p的内存地址</li>
<li><code>*&amp;p</code>表示指向P内存地址的一个指针</li>
</ul>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>下面代码的运行结果是（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    String s;</span><br><span class="line">    System.out.println(<span class="string">&quot;s=&quot;</span>+s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 代码编程成功，并输出”s&#x3D;”</li>
<li>B 代码编译成功，并输出”s&#x3D;null”</li>
<li>C 由于String s没有初始化，代码不能编译通过。</li>
<li>D 代码编译成功，但捕获到NullPointException异常</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><h3 id="局部变量没有默认值"><a href="#局部变量没有默认值" class="headerlink" title="局部变量没有默认值"></a>局部变量没有默认值</h3><p>成员变量有初始值，而局部变量没有初始值得。本体中的s定义在方法中所以为局部变量-没有初始值。变量没有初始值就使用了，编译通不过</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>java运行时内存分为“线程共享”和“线程私有”两部分，以下哪些属于“线程共享”部分</p>
<ul>
<li>A 程序计算器</li>
<li>B 方法区</li>
<li>C java虚拟机栈</li>
<li>D java堆</li>
</ul>
<p>正确答案: BD</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><ul>
<li>私有:<ul>
<li>java虚拟机栈，</li>
<li>程序计数器，</li>
<li>本地方法栈</li>
</ul>
</li>
<li>共享:<ul>
<li>java堆，</li>
<li>方法区</li>
</ul>
</li>
</ul>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><code>&quot;abc&quot;</code>在内存中是怎么分配的?</p>
<ul>
<li>A 堆</li>
<li>B 栈</li>
<li>C 字符串常量区</li>
<li>D 寄存器</li>
</ul>
<p>正确答案: AC</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>截止JDK1.8版本,java并发框架支持锁包括?</p>
<ul>
<li>A 读写锁</li>
<li>B 自旋锁</li>
<li>C X锁</li>
<li>D 乐观锁</li>
<li>E 排他锁</li>
</ul>
<p>正确答案: ABD</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>HashSet子类依靠()方法区分重复元素。</p>
<ul>
<li>A toString(),equals()</li>
<li>B clone(),equals()</li>
<li>C hashCode(),equals()</li>
<li>D getClass(),clone()</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值前，会去判断当前Map中是否含有该key对象，内部是先通过key的hashCode，确定有相同的hashCode之后，再通过equals方法判断是否相同。</p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>一个文件中的字符要写到另一个文件中，首先需要（ ）。</p>
<ul>
<li>A 使用标准输出流System.out.println()。</li>
<li>B 建立文件字符输出流。</li>
<li>C 建立文件字符输入流。</li>
<li>D 标准输入流System.in.read()。</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>以下描述错误的一项是（ ）？</p>
<ul>
<li>A 程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行 到了第几行，是线程隔离的</li>
<li>B 原则上讲，所有的对象都是在堆区上分配内存，是线程之间共享的</li>
<li>C 方法区用于存储JVM加载的类信息、常量、静态变量，即使编译器编译后的代码等数据，是线程隔离的</li>
<li>D Java方法执行内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>有空了解一下</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月8日 Java1</title>
    <url>/exam//3942cc4b/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>关于下面代码 int[] x&#x3D;new int[25]; 描述正确的是（）</p>
<ul>
<li>A x[25]存放了数据“\0”。</li>
<li>B x[24] 存放了数据“\0”。</li>
<li>C 若访问x[25]，程序将抛出异常。</li>
<li>D x[1]访问此数组的第一个元素。</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>A:不存在x[25] 索引从0开始到length-1<br>B:x[24]<br>存的是默认值0(java中没有’\0’这一说)<br>C:超出内存 正确<br>D:第二元素</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>以下表达式的类型和值是什么？（注意整数除法）（）<br>-5 + 1&#x2F;4 + 2*-3 + 5.0</p>
<ul>
<li>A int -3</li>
<li>B int -4</li>
<li>C double -5.5</li>
<li>D double -6.0</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>注意题目说整数除法，所以1&#x2F;4 &#x3D; 0</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>下列修饰符中，能够使得某个成员变量可被它所在包访问到和它的子类访问到的是（ ）</p>
<ul>
<li>A protected</li>
<li>B public</li>
<li>C private</li>
<li>D 应不加修饰符</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><h3 id="访问控制符修饰的成员可见范围"><a href="#访问控制符修饰的成员可见范围" class="headerlink" title="访问控制符修饰的成员可见范围"></a>访问控制符修饰的成员可见范围</h3><table>
<thead>
<tr>
<th align="right">位置</th>
<th align="left">public</th>
<th align="left">protected</th>
<th align="left">default</th>
<th align="left">private</th>
</tr>
</thead>
<tbody><tr>
<td align="right">同一个类中</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
</tr>
<tr>
<td align="right">同一个包中</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">✘</td>
</tr>
<tr>
<td align="right">子类中</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">✘</td>
<td align="left">✘</td>
</tr>
<tr>
<td align="right">全局</td>
<td align="left">√</td>
<td align="left">✘</td>
<td align="left">✘</td>
<td align="left">✘</td>
</tr>
</tbody></table>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>内部类（也叫成员内部类）可以有4种访问权限。（  ）</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h3 id="为什么外部类只能public和默认修饰"><a href="#为什么外部类只能public和默认修饰" class="headerlink" title="为什么外部类只能public和默认修饰"></a>为什么外部类只能public和默认修饰</h3><p>外部类的上一级程序单元是包，所以其有两个作用域：同一包内和任何位置。因此只需要2种访问权限：包访问权限和公开访问权限，正好对应的省略访问控制符和public。省略访问控制符是包访问权限，即同一个包内的其他类可以访问省略访问控制符的成员。因此，如果一个外部类不使用任何访问控制符修饰，则只能被同一个包的其他类访问。</p>
<h3 id="为什么内部类可以使用四个访问控制符"><a href="#为什么内部类可以使用四个访问控制符" class="headerlink" title="为什么内部类可以使用四个访问控制符"></a>为什么内部类可以使用四个访问控制符</h3><p>而内部类的上一级程序单元是外部类，它就具有4个作用域：同一个类、同一个包、父子类和任何位置。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>你就把内部类理解成类的成员，成员有4种访问权限吧，内部类也是！分别为private、protected、public以及默认的访问权限</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>以下关于集合类ArrayList、LinkedList、HashMap描述错误的是（）</p>
<ul>
<li>A HashMap实现Map接口，它允许任何类型的键和值对象，并允许将null用作键或值</li>
<li>B ArrayList和LinkedList均实现了List接口</li>
<li>C 添加和删除元素时，ArrayList的表现更佳</li>
<li>D ArrayList的访问速度比LinkedList快</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><ol>
<li><strong>List 是一个有序集合</strong>，可以存放重复的数据 (有序：存进是什么顺序，取出时还是什么顺序)<br>(1).ArrayList 底层是数组适合查询，不适合增删元素。<br>(2).LiskedList 底层是双向链表适合增删元素，不适合查询操作。<br>(3).Vector 底层和ArrayList相同，但是Vector是线程安全的，效率较低很少使用</li>
<li><strong>Set 是一个无序集合</strong>，不允许放重复的数据 (无序可重复，存进和取出的顺序不一样)<br>(1).HashSet 底层是哈希表&#x2F;散列表<br>(2).TreeSet 继承sartedSet接口（无需不可重复，但存进去的元素可以按照元素的大小自动排序）</li>
<li>Map 是一个无序集合，以键值对的方式存放数据，键对象不允许重复，值对象可以重复。<br>(1).HashMap实现不同步，线程不安全。<strong>HashTable线程安全</strong><br>(2).HashMap中的key-value都是存储在Entry中的。<br>(3).HashMap可以存null键和null值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode()方法和equals方法保证键的唯一性<h3 id="数组插入删除效率低"><a href="#数组插入删除效率低" class="headerlink" title="数组插入删除效率低"></a>数组插入删除效率低</h3>数组的插入和删除效率比较低，读取的效率高，因为地址是连续的</li>
</ol>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>以下代码段执行后的输出结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(test());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="keyword">return</span> ++temp;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="keyword">return</span> ++temp;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ++temp;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 1,2,2</li>
<li>B 1,2,3</li>
<li>C 1,3,3</li>
<li>D 1,3,2</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>finally代码块在try语句的return之前执行。try的return的值会被放入临时空间，然后执行finally代码块，如果finally中有return，会刷新临时空间的值，方法结束返回临时空间值，也就是finally中的return会覆盖try中的return。</p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>Hashtable 和 HashMap 的区别是：</p>
<ul>
<li>A Hashtable 是一个哈希表，该类继承了 AbstractMap，实现了 Map 接口</li>
<li>B HashMap 是内部基于哈希表实现，该类继承AbstractMap，实现Map接口</li>
<li>C Hashtable 线程安全的，而 HashMap 是线程不安全的</li>
<li>D Properties 类 继承了 Hashtable 类，而 Hashtable 类则继承Dictionary 类</li>
<li>E HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</li>
</ul>
<p>正确答案: BCDE</p>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>选B、C、D、E。</p>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>（1）Hashtable 是一个<strong>散列表</strong>，它存储的内容是键值对(key-value)映射。<br>（2）Hashtable 的函数都是同步的，这意味着<strong>HashTable是线程安全的</strong>。它的key、value都不可以为null。<br>（3）HashTable直接使用对象的hashCode。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>（1）由<strong>数组+链表</strong>组成的，基于<strong>哈希表</strong>的Map实现，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。<br>（2）<strong>HashMap是线程<code>不</code>安全的</strong>，HashMap可以接受为null的键(key)和值(value)。<br>（3）HashMap重新计算hash值</p>
<h3 id="Hashtable继承Dictionary"><a href="#Hashtable继承Dictionary" class="headerlink" title="Hashtable继承Dictionary"></a>Hashtable继承Dictionary</h3><p>Properties继承关系如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hashtable</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Dictionary</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>
<h3 id="HashMap继承AbstractMap"><a href="#HashMap继承AbstractMap" class="headerlink" title="HashMap继承AbstractMap"></a>HashMap继承AbstractMap</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt;<span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>
<h3 id="Properties继承Hashtable"><a href="#Properties继承Hashtable" class="headerlink" title="Properties继承Hashtable"></a>Properties继承Hashtable</h3><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>下面几个关于Java里queue的说法哪些是正确的（）？</p>
<ul>
<li>A LinkedBlockingQueue是一个可选有界队列，不允许null值</li>
<li>B PriorityQueue，LinkedBlockingQueue都是线程不安全的</li>
<li>C PriorityQueue是一个无界队列，不允许null值，入队和出队的时间复杂度是O（log(n)）</li>
<li>D PriorityQueue，ConcurrentLinkedQueue都遵循FIFO原则</li>
</ul>
<p>正确答案: AC</p>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>A对、LinkedBlockingQueue是一个基于节点链接的<strong>可选是否有界</strong>的阻塞队列，不允许null值。<br>B错、LinkedBlockingQueue是一个<strong>线程安全</strong>的阻塞队列，实现了先进先出等特性。<br>C、PriorityQueue是一个无界队列，不允许null值，入队和出队的时间复杂度是O（log(n)）。<br>D、PriorityQueue是不同于先进先出队列的另一种队列。每次从队列中取出的是具有最高优先权的元素。ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，该队列的元素遵循FIFO原则。</p>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>关于Java的一些概念，下面哪些描述是正确的：(        )</p>
<ul>
<li>A 所有的Java异常和错误的基类都是java.lang.Exception, 包括java.lang.RuntimeException</li>
<li>B 通过try … catch … finally语句，finally中的语句部分无论发生什么异常都会得到执行</li>
<li>C java中所有的数据都是对象</li>
<li>D Java通过垃圾回收回收不再引用的变量，垃圾回收时对象的finallize方法一定会得到执行</li>
<li>E Java是跨平台的语言，无论通过哪个版本的Java编写的程序都能在所有的Java运行平台中运行</li>
<li>F Java通过synchronized进行访问的同步，synchronized作用非静态成员方法和静态成员方法上同步的目标是不同的</li>
</ul>
<p>正确答案: BF</p>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>A:Java中所有错误和异常的父类是java.lang.Throwable<br>C：基本数据类型不是对象，不能用new的方法获取，但是每个基本数据类型都对应着封装类型，这些封装类型为了解决基本数据类型面向对象用的。<br>D:Java垃圾回收器负责回收无用对象占据的内存资源,但对象没有使用new获取了一块特殊区域，这块特殊区域的回收使用finallize（）<br>E：Java跨平台是因为有JVM的存在，Java的三个版本的运行需要各自不同的环境。<br>F: Synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”Synchronized修饰静态方法，实际上是对该类对象加锁，俗称“类锁”。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月8日 java2</title>
    <url>/exam//618ab2f5/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>Which is the return type of the method main()?</p>
<ul>
<li>A int</li>
<li>B void</li>
<li>C Boolean</li>
<li>D static</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>子类A继承父类B, A a &#x3D; new A(); 则父类B构造函数、父类B静态代码块、父类B非静态代码块、子类A构造函数、子类A静态代码块、子类A非静态代码块 执行的先后顺序是？</p>
<ul>
<li>A 父类Ｂ静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;子类Ａ构造函数-&gt;子类Ａ非静态代码块</li>
<li>B 父类Ｂ静态代码块-&gt;父类Ｂ构造函数-&gt;父类Ｂ非静态代码块-&gt;子类Ａ静态代码块-&gt;子类Ａ构造函数-&gt;子类Ａ非静态代码块</li>
<li>C 父类Ｂ静态代码块-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ非静态代码块-&gt;子类Ａ构造函数</li>
<li>D 父类Ｂ构造函数-&gt;父类Ｂ静态代码块-&gt;父类Ｂ非静态代码块-&gt;子类Ａ静态代码块-&gt;子类Ａ构造函数-&gt;子类Ａ非静态代码块</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>当实例化子类对象时，</p>
<ul>
<li>首先要加载父类的class文件进内存，静态代码块是随着类的创建而执行，所以父类静态代码块最先被执行，</li>
<li>子类class文件再被加载，同理静态代码块被先执行；</li>
<li>实例化子类对象要先调用父类的构造方法，而调用父类构造方法前会先执行父类的非静态代码块</li>
</ul>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>有如下代码：请写出程序的输出结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">0</span>; z &lt; <span class="number">5</span>; z++) &#123; </span><br><span class="line">            <span class="keyword">if</span> ((++x &gt; <span class="number">2</span>) &amp;&amp; (++y &gt; <span class="number">2</span>) &amp;&amp; (k++ &gt; <span class="number">2</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                x++;</span><br><span class="line">                ++y;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(x + ”” +y + ”” +k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 432</li>
<li>B 531</li>
<li>C 421</li>
<li>D 523</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>每次循环z,x,y,k对应数值为：<br>0,1,0,0<br>1,2,0,0<br>2,3,1,0<br>3,4,2,0<br>4,5,3,1<br>执行完这次以后，z++为5，不再进入for循环。</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>现有如下代码段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(x&lt;n/<span class="number">2</span>) </span><br><span class="line">       x = <span class="number">2</span>*x;</span><br></pre></td></tr></table></figure>
<p>假设n&gt;&#x3D;0，则其时间复杂度应为（   ）</p>
<ul>
<li>A O(log2(n))</li>
<li>B O(nlog2(n))</li>
<li>C O(n)</li>
<li>D O(n^2)</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = <span class="number">2</span>;       <span class="comment">//①</span></span><br><span class="line">       <span class="keyword">while</span>(x&lt;n/<span class="number">2</span>)</span><br><span class="line">x = <span class="number">2</span>*x;   <span class="comment">// ②</span></span><br></pre></td></tr></table></figure>
<p>语句①的频度是1，设语句2的频度是f(n)，则2^f(n)&lt;&#x3D;n&#x2F;2;f(n)&lt;&#x3D;log2(n&#x2F;2)近似等于f(n)&lt;&#x3D;log2(n)，取最大值f(n)&#x3D;log2(n),T(n)&#x3D;O(log2(n))</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下面关于垃圾收集的说法正确的是</p>
<ul>
<li>A 一旦一个对象成为垃圾，就立刻被收集掉。</li>
<li>B 对象空间被收集掉之后，会执行该对象的finalize方法</li>
<li>C finalize方法和C++的析构函数是完全一回事情</li>
<li>D 一个对象成为垃圾是因为不再有引用指着它，但是线程并非如此</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>对象空间被收集<strong>之前</strong>执行finalize（）方法，而不是对象空间被收集之后再执行</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    System.out.println(a++ + a--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后输出什么？</p>
<ul>
<li>A 19</li>
<li>B 20</li>
<li>C 21</li>
<li>D 22</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><ul>
<li>先取值，后加一</li>
<li>先取值，后减一</li>
</ul>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>哪个正确</p>
<ul>
<li>A abstract类只能用来派生子类，不能用来创建abstract类的对象。</li>
<li>B final类不但可以用来派生子类，也可以用来创建final类的对象。</li>
<li>C abstract不能与final同时修饰一个类。</li>
<li>D abstract类定义中可以没有abstract方法。</li>
</ul>
<p>正确答案: ACD</p>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>1、abstract类不能用来创建abstract类的对象；<br>2、final类不能用来派生子类，因为用final修饰的类不能被继承；<br>3、如2所述，final不能与abstract同时修饰一个类，abstract类就是被用来继承的；<br>4、类中有abstract方法必须用abstract修饰，但abstract类中可以没有抽象方法，接口中也可以有abstract方法。</p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>关于equals和hashCode描述正确的是    ()</p>
<ul>
<li>A 两个obj，如果equals()相等，hashCode()一定相等（符合代码规范的情况下）</li>
<li>B 两个obj，如果hashCode()相等，equals()不一定相等</li>
<li>C 两个不同的obj， hashCode()可能相等</li>
<li>D 其他都不对</li>
</ul>
<p>正确答案: ABC</p>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>运用下列哪个命令能够获取JVM的内存映像</p>
<ul>
<li>A jinfo</li>
<li>B jmap</li>
<li>C jhat</li>
<li>D jstat</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>1、jps：查看本机java进程信息。<br>2、jstack：打印线程的栈信息，制作线程dump文件。<br>3、jmap：打印内存映射，制作堆dump文件<br>4、jstat：性能监控工具<br>5、jhat：内存分析工具<br>6、jconsole：简易的可视化控制台<br>7、jvisualvm：功能强大的控制台</p>
<h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>以下哪一个不是赋值符号？</p>
<ul>
<li>A +&#x3D;</li>
<li>B &lt;&lt;&#x3D;</li>
<li>C &lt;&lt;&lt;&#x3D;</li>
<li>D &gt;&gt;&gt;&#x3D;</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><p>A.很明显是赋值符号<br>B.&lt;&lt;&#x3D;左移赋值<br>C.不是<br>D.&gt;&gt;&gt;&#x3D; 右移赋值，左边空出的位以0填充</p>
<h1 id="考点11"><a href="#考点11" class="headerlink" title="考点11"></a>考点11</h1><p>Java多线程有几种实现方法？</p>
<ul>
<li>A 继承Thread类</li>
<li>B 实现Runnable接口</li>
<li>C 实现Thread接口</li>
<li>D 以上都不正确</li>
</ul>
<p>正确答案: AB</p>
<h2 id="解析-10"><a href="#解析-10" class="headerlink" title="解析"></a>解析</h2><p>多线程一共有三种实现方式<br>方式1：继承Thread类，并重写run()方法<br>方式2：实现Runnable接口，实现run()方法<br>方式3：实现Callable接口，线程结束后可以有返回值，但是该方式是依赖于线程池的。</p>
<h1 id="考点12"><a href="#考点12" class="headerlink" title="考点12"></a>考点12</h1><p>Java中的集合类包括ArrayList、LinkedList、HashMap等类，下列关于集合类描述正确的是（）</p>
<ul>
<li>A ArrayList和LinkedList均实现了List接口</li>
<li>B ArrayList的访问速度比LinkedList快</li>
<li>C 添加和删除元素时，ArrayList的表现更佳</li>
<li>D HashMap实现Map接口，它允许任何类型的键和值对象，并允许将null用作键或值</li>
</ul>
<p>正确答案: ABD</p>
<h2 id="解析-11"><a href="#解析-11" class="headerlink" title="解析"></a>解析</h2><p>ArrayList插入和现有项的删除开销很大,除非在末端<br>LinkedList插入和删除开销很小<br>ArrayList和LinkedList都是实现了List接口<br>HashMap可以用null值和空字符串作为K,不过只能有一个</p>
<h1 id="考点13"><a href="#考点13" class="headerlink" title="考点13"></a>考点13</h1><p>下面的Java赋值语句哪些是有错误的 （）</p>
<ul>
<li>A int i &#x3D;1000;</li>
<li>B float f &#x3D; 45.0;</li>
<li>C char s &#x3D; ‘\u0639’</li>
<li>D Object o &#x3D; ‘f’;</li>
<li>E String s &#x3D; “hello,world\0”;</li>
<li>F Double d &#x3D; 100;</li>
</ul>
<p>正确答案: BF</p>
<h2 id="解析-12"><a href="#解析-12" class="headerlink" title="解析"></a>解析</h2><p>不同的数据类型不能自动装箱拆箱，只有对应类型的数据类型和包装类才能自动装箱拆箱。<br>double类型的才可以自动装箱为Double<br>Double d &#x3D; 100;中100为int类型，只能自动装箱为Integer</p>
<h1 id="考点14"><a href="#考点14" class="headerlink" title="考点14"></a>考点14</h1><p>true、false、null、sizeof、goto、synchronized  哪些是Java关键字？</p>
<ul>
<li>A true</li>
<li>B false</li>
<li>C null</li>
<li>D sizeof</li>
<li>E goto</li>
<li>F synchronized</li>
</ul>
<p>正确答案: EF</p>
<h2 id="解析-13"><a href="#解析-13" class="headerlink" title="解析"></a>解析</h2><ul>
<li>true、false、null是字面量。</li>
<li>goto、const是java保留字和关键字。</li>
</ul>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月9日 java1</title>
    <url>/exam//17418871/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>可以把任何一种数据类型的变量赋给Object类型的变量。</p>
<ul>
<li>A 对</li>
<li>B 错</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul>
<li>引用类型的对象都可以赋值给Object变量；</li>
<li>而八大基础数据类型会先自动装箱成包装类型，然后再赋值给Object，所以编译运行都不会报错。</li>
</ul>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>以下不是修饰符final的作用的是( )。</p>
<ul>
<li>A 修饰常量</li>
<li>B 修饰不可被继承的类</li>
<li>C 修饰不可变类</li>
<li>D 修饰不可覆盖的方法</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>final的作用</p>
<ol>
<li>final修饰的变量是常量，<ul>
<li>如果修饰的是<strong>引用变量</strong>则变量中的引用地址不可变，但是地址中的内容可以变。</li>
<li>如果修饰的是基本类型变量，则基本类型变量的值不可改变。</li>
</ul>
</li>
<li>final修饰的方法不可被<strong>重写</strong>，但是还是可以重载</li>
<li>final修饰的类<strong>不可继承</strong>。</li>
</ol>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>对于abstract声明的类，下面说法正确的是</p>
<ul>
<li>A 可以实例化</li>
<li>B 不可以被继承</li>
<li>C 子类为abstract</li>
<li>D 只能被继承</li>
<li>E 可以被抽象类继承</li>
</ul>
<p>正确答案: E</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>A,抽象类不能实例化，因为有抽象方法未实现<br>B,可以被继承。派生类可以实现抽象方法<br>C，子类可以是抽象的，也可以非抽象的<br>D，只能被继承说法太肯定，不正确<br>E，可以被抽象类继承，也可以被非抽象类继承</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下列程序test 类中的变量c 的最后结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">50</span>) &#123;</span><br><span class="line">b = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line">c = b + a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 10</li>
<li>B 0</li>
<li>C 19</li>
<li>D 编译出错</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p><strong>局部变量不会自动进行初始化</strong>，所以当使用局部变量时，而没有给该局部变量赋值就会产生编译错误。</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下面这段程序的输出结果是（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        split(<span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">split</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (number % <span class="number">2</span> != <span class="number">0</span>) System.out.print(split((number + <span class="number">1</span>) / <span class="number">2</span>));</span><br><span class="line">                System.out.print(split(number / <span class="number">2</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 12136</li>
<li>B 63121</li>
<li>C 61213</li>
<li>D 11236</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>考察方法进栈与出栈的顺序。先进后出<br>有个知识点，方法在出栈的时候，执行的是return语句。因为出栈就意味着方法结束并消费，如果没有return语句，那么方法出栈的时候什么都不执行，就直接销毁。<br>1.执行split（12）时，执行代码System.out.print(split(number &#x2F; 2))<br>    split（12&#x2F;2）进栈，此时number&#x3D;6；<br>2.执行split（6）时，执行代码System.out.print(split(number &#x2F; 2))<br>    split（6&#x2F;2）进栈，此时number&#x3D;3；<br>3.执行split（3）时，<br>第1行 if (number % 2 !&#x3D; 0)<br>第2行          System.out.print(split((number + 1) &#x2F; 2));<br>第3行    System.out.print(split(number &#x2F; 2));<br> 按照顺序执行<br> 先执行第2行<br>            首先split（(3+1)&#x2F;2）进栈，此时number&#x3D;2，<br>            再执行split（2），那么split（2&#x2F;2）进栈，此时number&#x3D;1， 最后return 1，<br>            注意此时第2行代码还没有结束<br>            此时<br>            split（2&#x2F;2）出栈，输出1；<br>            split（(3+1)&#x2F;2）出栈，输出2；<br>   第二行代码结束，再执行第三行，此时number&#x3D;3，执行System.out.print(split(number &#x2F; 2))<br>           split（3&#x2F;2）进栈，number&#x3D;1，return，那么就需要出栈了<br>split（3&#x2F;2）出栈，输出1<br>split（6&#x2F;2）出栈，输出3<br>split（12&#x2F;2）出栈，输出6；<br>最终结果12136；<br>split（number）方法，最终返回的是number这个值，所以split（n）出栈的输出结果就是n<br>整理：<br>split（12&#x2F;2）进栈<br>split（6&#x2F;2）进栈<br>split（(3+1)&#x2F;2）进栈<br>split（2&#x2F;2）进栈<br>       split（2&#x2F;2）出栈，输出1<br>        split（(3+1)&#x2F;2）出栈，输出2<br>split（2&#x2F;2）进栈<br>        split（2&#x2F;2）出栈，输出1<br>split（6&#x2F;2）出栈，输出3<br>split（12&#x2F;2）出栈，输出6</p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>Which statement declares a variable a which is suitable for referring to an array of 50 string objects?（Java）</p>
<ul>
<li>A char a[][];</li>
<li>B String a[];</li>
<li>C String[] a;</li>
<li>D Object a[50];</li>
<li>E String a[50];</li>
<li>F Object a[];</li>
</ul>
<p>正确答案: BCF</p>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2>]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年11月9日 java2</title>
    <url>/exam//8e48d9cb/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下列说法正确的有（ ）</p>
<ul>
<li>A class中的constructor不可省略</li>
<li>B constructor必须与class同名，但方法不能与class同名</li>
<li>C constructor可在一个对象被new时执行</li>
<li>D 一个class只能定义一个constructor</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>a. 类中的构造方法可以省略不写的<br>b. 构造方法必须跟类名相同，普通的类方法能与类同名的，但是要返回一个值。<br>c. 构造方法都在new 对象的时候调用的<br>d. 一个类可以定义多个构造方法的</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String str0=<span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> String str1=<span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line">String str2=str1.substring(<span class="number">5</span>);</span><br><span class="line">String str3=<span class="keyword">new</span> <span class="title class_">String</span>(str2);</span><br><span class="line">String str4=<span class="keyword">new</span> <span class="title class_">String</span>(str3.toCharArray());</span><br><span class="line">str0=<span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>假定str0,…,str4后序代码都是只读引用。<br>Java 7中，以上述代码为基础，在发生过一次FullGC后，上述代码在Heap空间（不包括PermGen）保留的字符数为（）</p>
<ul>
<li>A 5</li>
<li>B 10</li>
<li>C 15</li>
<li>D 20</li>
</ul>
<p>正确答案: C</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>这是一个关于java的垃圾回收机制的题目。<strong>垃圾回收主要针对的是<code>堆区</code>的回收</strong>，因为<strong>栈区的内存是随着线程而释放的</strong>。<br>堆区分为三个区：</p>
<ul>
<li>年轻代(<code>Young Generation</code>)、</li>
<li>年老代(<code>Old Generation</code>)、</li>
<li>永久代(<code>Permanent Generation</code>,也就是方法区)。</li>
</ul>
<p><strong>年轻代</strong>:对象被创建时(<code>new</code>)的对象通常被放在<code>Young</code>(除了一些占据内存比较大的对象),经过一定的<code>Minor GC</code>(针对年轻代的内存回收)还活着的对象会被移动到年老代(一些具体的移动细节省略)。<br><strong>年老代</strong>:就是上述年轻代移动过来的和一些比较大的对象。**<code>Minor GC(Full GC)</code>是针对年老代的回收**<br><strong>永久代</strong>:存储的是<code>final</code>常量,<code>static</code>变量,常量池。</p>
<p><code>str3,str4</code>都是直接<code>new</code>的对象,而<code>substring</code>的源代码其实也是<code>new</code>一个<code>string</code>对象返回。<br>经过<code>full gc</code>之后,年老区的内存回收,则年轻区的占了15个,不算<code>PermGen</code>。所以答案选C</p>
<p><strong>垃圾回收机制这方面了解的比较少，有时间了解一下</strong></p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>运行代码，结果正确的是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(flag = <span class="literal">true</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 编译错误</li>
<li>B TRUE</li>
<li>C FALSE</li>
<li>D 什么也没有输出</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>
正确答案: B

<p>注意 if判断条件flag &#x3D; true是<strong>赋值语句</strong>，返回true 不会执行else里面内容</p>
</details>

<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>从运行层面上来看，从四个选项选出不同的一个。</p>
<ul>
<li>A JAVA</li>
<li>B Python</li>
<li>C objectC</li>
<li>D C#</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>
正确答案: B

<p>A，C，D都是类C语言，B不是<br>Python是解释执行的，其他语言都需要先编译</p>
</details>

<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>有以下一个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataObject</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String word=<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWord</span><span class="params">(String word)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.word=word;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setI</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        Data0bject. i=I;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个如下方式的DataObject: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataObject object=<span class="keyword">new</span> <span class="title class_">DataObject</span> ( );</span><br><span class="line">object.setWord(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">object.setI(<span class="number">2</span>); </span><br></pre></td></tr></table></figure>
<p>将此对象序列化为文件，并在另外一个JVM中读取文件，进行反序列化，请问此时读出的DataObject对象中的word和i的值分别为：</p>
<ul>
<li>A “”, 0</li>
<li>B “”, 2</li>
<li>C “123”, 2</li>
<li>D “123”, 0</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>序列化保存的是<strong>对象的状态</strong>，静态变量属于<strong>类的状态</strong>，因此，<strong>序列化并不保存静态变量</strong>。所以i是没有改变的<br><strong>Java在序列化时不会实例化static变量和transient修饰的变量</strong>，因为static代表类的成员，transient代表对象的临时数据，被声明这两种类型的数据成员不能被序列化</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下面有关java threadlocal说法正确的有？</p>
<ul>
<li>A ThreadLocal存放的值是线程封闭，线程间互斥的，主要用于线程内共享一些数据，避免通过参数来传递</li>
<li>B 线程的角度看，每个线程都保持一个对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收</li>
<li>C 在Thread类中有一个Map，用于存储每一个线程的变量的副本。</li>
<li>D 对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式</li>
</ul>
<p>正确答案: ABCD</p>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p><strong>ThreadLocal类用来提供线程内部的<code>局部变量</code><strong>。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。<br>ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。<br>可以总结为一句话：</strong>ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度</strong>。</p>
<p>ThreadLocal设计的初衷：提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。</p>
<h3 id="ThreadLocal的使用场景"><a href="#ThreadLocal的使用场景" class="headerlink" title="ThreadLocal的使用场景"></a>ThreadLocal的使用场景</h3><p>数据库连接：在多线程中，如果使用懒汉式的单例模式创建Connection对象，由于该对象是共享的，那么必须要使用同步方法保证线程安全，这样当一个线程在连接数据库时，那么另外一个线程只能等待。这样就造成性能降低。<br>如果改为哪里要连接数据库就来进行连接，那么就会频繁的对数据库进行连接，性能还是不高。这时使用ThreadLocal就可以既可以保证线程安全又可以让性能不会太低。但是ThreadLocal的缺点时占用了较多的空间。</p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>对接口的描述正确的是()</p>
<ul>
<li>A 一个类可以实现多个接口</li>
<li>B 接口可以有非静态的成员变量</li>
<li>C 在jdk8之前，接口可以实现方法</li>
<li>D 实现接口的任何类，都需要实现接口的方法</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>A，一个类只能有一个直接父类，但是继承是有传递性的。一个类可以实现多的接口。一个接口可以继承多个类。<br>B，接口中没有普通变量（普通成员变量），<strong>接口的成员变量都是<code>常量</code>，默认修饰符：public static final</strong><br>C，</p>
<ul>
<li><strong>JDK8之前接口中的方法都是默认public abstract的</strong>，抽象方法没有方法体</li>
<li><strong>JDK8时接口中可以有static、default的修饰的方法</strong>，static、default修饰的方法必须有方法。接口中的方法都不能被private和protected修饰。</li>
<li>外部接口、类只能被public修饰或者不写，</li>
<li>内部接口、类可以被四个访问修饰符修饰。</li>
</ul>
<p>D， 实现接口，其实就是需要重写接口中的abstract方法，一旦实现的类没有重写完，那么这个类必须是个抽象类（抽象类中可以没有抽象方法，但是有抽象方法的类必须是抽象类）。</p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>java7后关键字 switch 支不支持字符串作为条件：（）</p>
<ul>
<li>A 支持</li>
<li>B 不支持</li>
</ul>
<p>正确答案: A</p>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>在Java7之前，switch只能支持<br>byte、short、char、int或者其对应的封装类以及Enum类型。<br>在Java7中，呼吁很久的String支持也终于被加上了。</p>
<p>在switch语句中，表达式的值不能是null，否则会在运行时抛出NullPointerException。<br>在case子句中也不能使用null，否则会出现编译错误。<br>同时，case字句的值是不能重复的。对于字符串类型的也一样，但是字符串中可以包含Unicode转义字符。重复值的检查是在Java编译器对Java源代码进行相关的词法转换之后才进行的。也就是说，有些case字句的值虽然在源代码中看起来是不同的，但是经词法转换之后是一样的，就会在成编译错误。比如：“男”和“\u7537”就是一个意思。</p>
<p>可以看出，字符串类型在switch语句中利用hashcode的值与字符串内容的比较来实现的；但是在case字句中对应的语句块中仍然需要使用String的equals方法来进一步比较字符串的内容，这是因为哈希函数在映射的时候可能存在冲突。<br>switch(exp)，在JDK7之前，只能是byte、short、char、int或者对应的包装类，或者枚举常量（内部也是由整型或字符类型实现）。<br>为什么必须是这些呢，因为其实exp只是对int型支持的，其他都是因为可以自动拆卸或者自动向上转型到int，所以才可以。<br>到了JDK7的时候，String被引入了，为什么String能被引入呢？<br>其实本质上还是对int类型值得匹配。<br>原理如下，通过对case后面得String对象调用hashCode方法，得到一个int类型得hash值，然后用这个hash值来唯一标识这个case。那么当匹配时，首先调用exp的hashCode，得到exp的hash值，用这个hash值来匹配所有case，如果没有匹配成功，就说明不存在；如果匹配成功了，接着会调用字符串的equals方法进行匹配。（hash值一致，equals可不一定返回的就是true）。<br>所以，exp不能为null，cas子句使用的字符串也不能为null，不然会出现空指针异常。</p>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>已知如下类定义：<br>class Base {<br> public Base (){<br> &#x2F;&#x2F;…<br> }<br> public Base ( int m ){<br> &#x2F;&#x2F;…<br> }<br> public void fun( int n ){<br> &#x2F;&#x2F;…<br> }<br>}<br>public class Child extends Base{<br> &#x2F;&#x2F; member methods<br>}<br>如下哪句可以正确地加入子类中？</p>
<ul>
<li>A private void fun( int n ){ &#x2F;&#x2F;…}</li>
<li>B void fun ( int n ){ &#x2F;&#x2F;… }</li>
<li>C protected void fun ( int n ) { &#x2F;&#x2F;… }</li>
<li>D public void fun ( int n ) { &#x2F;&#x2F;… }</li>
</ul>
<p>正确答案: D</p>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>方法的重写（override）两同两小一大原则：<br>方法名相同，参数类型相同<br>子类返回类型小于等于父类方法返回类型，<br>子类抛出异常小于等于父类方法抛出异常，<br>子类访问权限大于等于父类方法访问权限。</p>
<h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>如下代码的 结果是什么 ?<br>class Base {<br>    Base() {<br>    System.out.print(“Base”);<br>    }<br>}<br>public class Alpha extends Base {<br>    public static void main( String[] args ) {<br>        new Alpha();<br>        &#x2F;&#x2F;调用父类无参的构造方法<br>        new Base();<br>    }<br>}</p>
<ul>
<li>A Base</li>
<li>B BaseBase</li>
<li>C 编译失败</li>
<li>D 代码运行但没有输出</li>
<li>E 运行时抛出异常</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><h1 id="考点11"><a href="#考点11" class="headerlink" title="考点11"></a>考点11</h1><p>关于下面程序，哪些描述是正确的: (  )<br> public class While {<br>public void loop() {<br>int x&#x3D; 10;<br>while ( x )  {<br>System.out.print(“x minus one is “ + (x - 1));<br>x -&#x3D; 1;<br>}<br>}<br>}</p>
<ul>
<li>A 行1有语法错误</li>
<li>B 行4有语法错误</li>
<li>C 行5有语法错误</li>
<li>D 行6有语法错误</li>
<li>E 行2有语法错误,loop是关键字</li>
<li>F 程序能够正常编译和运行</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-10"><a href="#解析-10" class="headerlink" title="解析"></a>解析</h2><p>while()括号里的参数要是boolean类型，int类型不行</p>
<h1 id="考点12"><a href="#考点12" class="headerlink" title="考点12"></a>考点12</h1><p>假设如下代码中，若t1线程在t2线程启动之前已经完成启动。代码的输出是（）<br>public static void main(String[]args)throws Exception {<br>    final Object obj &#x3D; new Object();<br>    Thread t1 &#x3D; new Thread() {<br>        public void run() {<br>            synchronized (obj) {<br>                try {<br>                    obj.wait();<br>                    System.out.println(“Thread 1 wake up.”);<br>                } catch (InterruptedException e) {<br>                }<br>            }<br>        }<br>    };<br>    t1.start();<br>    Thread.sleep(1000);&#x2F;&#x2F;We assume thread 1 must start up within 1 sec.<br>    Thread t2 &#x3D; new Thread() {<br>        public void run() {<br>            synchronized (obj) {<br>                obj.notifyAll();<br>                System.out.println(“Thread 2 sent notify.”);<br>            }<br>        }<br>    };<br>    t2.start();<br>}</p>
<ul>
<li>A Thread 1 wake up Thread 2 sent notify.</li>
<li>B Thread 2 sent notify. Thread 1 wake up</li>
<li>C A、B皆有可能</li>
<li>D 程序无输出卡死</li>
</ul>
<p>正确答案: B</p>
<h2 id="解析-11"><a href="#解析-11" class="headerlink" title="解析"></a>解析</h2><p>选择B<br>执行obj.wait();时已释放了锁，所以t2可以再次获得锁，然后发消息通知t1执行，但这时t2还没有释放锁，所以肯定是执行t2，然后释放锁，之后t1才有机会执行。</p>
<h1 id="考点13"><a href="#考点13" class="headerlink" title="考点13"></a>考点13</h1><p>对于线程局部存储TLS(thread local storage)，以下表述正确的是</p>
<ul>
<li>A 解决多线程中的对同一变量的访问冲突的一种技术</li>
<li>B TLS会为每一个线程维护一个和该线程绑定的变量的副本</li>
<li>C 每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了</li>
<li>D Java平台的java.lang.ThreadLocal是TLS技术的一种实现</li>
</ul>
<p>正确答案: ABD</p>
<h2 id="解析-12"><a href="#解析-12" class="headerlink" title="解析"></a>解析</h2><p>ThreadLocal可以给一个初始值，而每个线程都会获得这个初始化值的一个副本，这样才能保证不同的线程都有一份拷贝。<br>ThreadLocal<br>不是用于解决共享变量的问题的，不是为了协调线程同步而存在，而是<strong>为了方便每个线程处理自己的状态而引入的一个机制</strong>.<br>ThreadLocal确实是保证了每一个线程都拥有一个变量的副本，而且这个副本的初始值取决于ThreadLoacl中initialValue方法的重写，如果initialValue方法中引用了一个全局的变量的地址，那么其他线程对全局变量的修改还是会影响到此线程中引用变量的内容。</p>
<h1 id="考点14"><a href="#考点14" class="headerlink" title="考点14"></a>考点14</h1><p>哪个是不正确的字符常量？</p>
<ul>
<li>A ”\n”</li>
<li>B ”1”</li>
<li>C ”a”</li>
<li>D ”\101”</li>
</ul>
<p>正确答案: ABCD</p>
<h2 id="解析-13"><a href="#解析-13" class="headerlink" title="解析"></a>解析</h2><ul>
<li>单引号才是字符常量</li>
<li>双引号是字符串常量</li>
</ul>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年12月10日 java1</title>
    <url>/exam//6b20adaa/</url>
    <content><![CDATA[<h1 id="考点1-java包的用途"><a href="#考点1-java包的用途" class="headerlink" title="考点1 java包的用途"></a>考点1 java包的用途</h1><p>进行Java基本的GUI设计需要用到的包是()</p>
<ul>
<li>A <code>java.io</code></li>
<li>B <code>java.sql</code></li>
<li>C <code>java.awt</code></li>
<li>D <code>java.rmi</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>图形用户界面（Graphical User Interface，简称 GUI）是指采用图形方式显示的计算机操作用户界面。<br>java.io提供了全面的IO接口。包括：文件读写、标准设备输出等。<br>java.sql提供使用 Java 编程语言访问并处理存储在数据源中的数据的 API。此 API<br>包括一个框架，凭借此框架可以动态地安装不同驱动程序来访问不同数据源。<br>java.awt是一个软件包，包含用于创建用户界面和绘制图形图像的所有分类。功能：包含用于创建用户界面和绘制图形图像的所有类。<br>java.rmi提供 RMI 包。RMI 指的是<strong>远程方法调用</strong> (Remote Method Invocation)。它是一种机制，能够<strong>让在某个Java虚拟机上的对象调用另一个 Java 虚拟机中的对象上的方法</strong>。</p>
<h1 id="考点2-构造器的修饰符"><a href="#考点2-构造器的修饰符" class="headerlink" title="考点2 构造器的修饰符"></a>考点2 构造器的修饰符</h1><p>Which of the following can be applied to constructors:</p>
<ul>
<li>A <code>final</code></li>
<li>B <code>static</code></li>
<li>C <code>synchronized</code></li>
<li>D <code>native</code></li>
<li>E <code>None of these.</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: E</details>

<p>1.构造器不是通过继承得到的,所以没有必要把它声明为final的。<br>2.同理,一个抽象的构造器将永远不会被实现。(所以也不能声明为abstract的)<br>3.构造器总是关联一个对象而被调用,所以把它声明为static是没有意义的。<br>4.没有实际的需要把构造器定义成同步的,因为它将会在构造的时候锁住该对象,直到所有的构造器完成它们的工作,这个构造的过程对其它线程来说,通常是不可访问的。 (synchronized)<br>5.本地化的方法情况特别复杂，所以JVM调用起来非常麻烦，需要考虑很多种情况，如果构造器使用native关键字的话，JVM实现起来比较困难。</p>
<p>构造器只能被public、private、protected这3个修饰</p>
<h1 id="考点3-抽象"><a href="#考点3-抽象" class="headerlink" title="考点3 抽象"></a>考点3 抽象</h1><p>在jdk1.8之前,下列哪一种叙述是正确的( )</p>
<ul>
<li>A <code>abstract</code>修饰符可修饰字段、方法和类</li>
<li>B 抽象方法的<code>body</code>部分必须用一对大括号{ }包住</li>
<li>C 声明抽象方法,大括号可有可无</li>
<li>D 声明抽象方法不可写出大括号</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<ul>
<li>abstract修饰<strong>方法</strong>和<strong>类</strong>，不能用于修饰成员变量(字段)。</li>
<li>抽象方法没有方法体，有没有方法体看有没有大括号。</li>
</ul>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>根据以下代码段,下列说法中正确的是(    )。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 子类中一定能够继承和覆盖<code>Parent</code>类的<code>m1</code>方法</li>
<li>B 子类中一定能够继承和覆盖<code>Parent</code>类的<code>m2</code>方法</li>
<li>C 子类中一定能够继承和覆盖<code>Parent</code>类的<code>m3</code>方法</li>
<li>D 子类中一定能够继承和覆盖<code>Parent</code>类的<code>m4</code>方法</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h3 id="静态成员与继承无关"><a href="#静态成员与继承无关" class="headerlink" title="静态成员与继承无关"></a>静态成员与继承无关</h3><p>static修饰的成员属于类成员，父类字段或方法只能被子类同名字段或方法遮蔽，父类的静态成员不能被子类覆盖。</p>
<p>4、静态变量或静态方法，在子类中可以写同名的变量和方法，但是仍然各自属于父类或子类，与继承无关，与覆盖（重写）无关；</p>
<p>5、静态变量或静态方法在调用时，各自调用各自的静态的变量或静态方法，不管有没有强转，只取决于调用者是谁；</p>
<h1 id="考点5-图形界面"><a href="#考点5-图形界面" class="headerlink" title="考点5 图形界面"></a>考点5 图形界面</h1><p>容器panel缺省使用的布局编辑策略是( )</p>
<ul>
<li>A <code>Border Layout</code></li>
<li>B <code>Flow Layout</code></li>
<li>C <code>GridLayout</code></li>
<li>D <code>Card Layout</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>默认是流式布局<code>Flow Layout</code>，相当于浏览器，缩小后有滑块，可以滑动查看</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>以下哪个I &#x2F; O类可以附加或更新文件</p>
<ul>
<li>A <code>RandomAccessFile()</code></li>
<li>B <code>OutputStream()</code></li>
<li>C <code>DataOutputStream()</code></li>
<li>D <code>None of the above</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>RandomAccessFile 可以通过 seek(long pos) 方法去移动文件指针进行追加更新写入.</p>
<h1 id="考点7-Java标识符"><a href="#考点7-Java标识符" class="headerlink" title="考点7 Java标识符"></a>考点7 Java标识符</h1><p>下列哪个是合法的 Java 标识符？( )</p>
<ul>
<li>A <code>Tree</code>&amp;<code>Glasses</code></li>
<li>B <code>FirstJavaApplet</code></li>
<li>C <code>First_Applet</code></li>
<li>D 273.5</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<h3 id="Java标识符规则"><a href="#Java标识符规则" class="headerlink" title="Java标识符规则"></a>Java标识符规则</h3><p>标识符只有英文，数字，下划线和$，而且数字不能做开头</p>
<h1 id="考点8-循环语句"><a href="#考点8-循环语句" class="headerlink" title="考点8 循环语句"></a>考点8 循环语句</h1><p>下列关于while循环、do-while循环和for循环说法错误的是</p>
<ul>
<li>A <code>while</code>循环先执行条件判断,<code>do-while</code>循环执行循环体</li>
<li>B <code>do-while</code>循环结束的条件是关键字<code>while</code>后的条件表达式成立</li>
<li>C <code>for</code>循环结构中的3个表达式缺一不可</li>
<li>D <code>while</code>循环能够实现的操作,<code>for</code>循环也能实现</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件) &#123;</span><br><span class="line">    <span class="comment">//执行语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>都可以替换成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;条件;) &#123;</span><br><span class="line">    <span class="comment">//执行语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以D：while循环能够实现的操作，for循环也能实现 是正确的。</p>
<h1 id="考点9-构造器修饰符-native-import"><a href="#考点9-构造器修饰符-native-import" class="headerlink" title="考点9 构造器修饰符 native import"></a>考点9 构造器修饰符 native import</h1><p>关于Java以下描述正确的有(      )</p>
<ul>
<li>A <code>native</code>关键字表明修饰的方法是由其它非<code>Java</code>语言编写的</li>
<li>B 能够出现在<code>import</code>语句前的只有注释语句</li>
<li>C 接口中定义的方法默认是<code>public</code>和<code>static</code>的</li>
<li>D 构造方法只能被修饰为<code>public</code>或者<code>default</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

<p>A:<code>native</code>是由调用本地方法库(如操作系统底层函数),可以由C,C++实现,A正确<br>B:<code>import</code>是用于导包语句,其前面可以出现<code>package</code>,用来声明包的,B错误<br>C:接口方法的修饰符可以是:<code>public</code>,<code>abstract</code>,<code>default</code>,<code>static</code>(后两者需要有{}),C正确<br>D:构造方法可以用<code>private</code>,<code>protected</code>,<code>default</code>,<code>private</code>,D错误</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年12月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年12月10日 java2</title>
    <url>/exam//89601342/</url>
    <content><![CDATA[<h1 id="考点1-正则表达式"><a href="#考点1-正则表达式" class="headerlink" title="考点1 正则表达式"></a>考点1 正则表达式</h1><p>正则表达式中,表示匹配非数字字符的字符是()？</p>
<ul>
<li>A \b</li>
<li>B \d</li>
<li>C \B</li>
<li>D \D</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>元字符描述<br><br>将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\n”匹配\n。“\n”匹配换行符。序列“\”匹配“\”而“(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。<br>^<br>匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。<br>$<br>匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。<br>*<br>匹配前面的子表达式任意次。例如，zo<em>能匹配“z”，也能匹配“zo”以及“zoo”。</em>等价于o{0,}<br>+<br>匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。<br>?<br>匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。<br>{n}<br>n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。<br>{n,}<br>n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o<em>”。<br>{n,m}<br>m和n均为非负整数，其中n&lt;&#x3D;m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o为一组，后三个o为一组。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。<br>?<br>当该字符紧跟在任何一个其他限制符（</em>,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+”将尽可能多的匹配“o”，得到结果[“oooo”]，而“o+?”将尽可能少的匹配“o”，得到结果 [‘o’, ‘o’, ‘o’, ‘o’]<br>.点<br>匹配除“\r\n”之外的任何单个字符。要匹配包括“\r\n”在内的任何字符，请使用像“[\s\S]”的模式。<br>(pattern)<br>匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”。<br>(?:pattern)<br>非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分时很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。<br>(?&#x3D;pattern)<br>非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?&#x3D;95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。<br>(?!pattern)<br>非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。<br>(?&lt;&#x3D;pattern)<br>非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;&#x3D;95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。<br>(?&lt;!pattern)<br>非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题<br>此处用或任意一项都不能超过2位，如“(?&lt;!95|98|NT|20)Windows正确，“(?&lt;!95|980|NT|20)Windows 报错，若是单独使用则无限制，如(?&lt;!2000)Windows 正确匹配<br>x|y<br>匹配x或y。例如，“z|food”能匹配“z”或“food”(此处请谨慎)。“[zf]ood”则匹配“zood”或“food”。<br>[xyz]<br>字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。<br>[^xyz]<br>负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。<br>[a-z]<br>字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。<br>注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身.<br>[^a-z]<br>负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。<br>\b<br>匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。<br>\B<br>匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。<br>\cx<br>匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。<br>\d<br>匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持<br>\D<br>匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持<br>\f<br>匹配一个换页符。等价于\x0c和\cL。<br>\n<br>匹配一个换行符。等价于\x0a和\cJ。<br>\r<br>匹配一个回车符。等价于\x0d和\cM。<br>\s<br>匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。<br>\S<br>匹配任何可见字符。等价于[^ \f\n\r\t\v]。<br>\t<br>匹配一个制表符。等价于\x09和\cI。<br>\v<br>匹配一个垂直制表符。等价于\x0b和\cK。<br>\w<br>匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的”单词”字符使用Unicode字符集。<br>\W<br>匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</p>
<h1 id="考点2-抽象类和接口"><a href="#考点2-抽象类和接口" class="headerlink" title="考点2 抽象类和接口"></a>考点2 抽象类和接口</h1><p>关于抽象类与接口,下列说法正确的有？</p>
<ul>
<li>A 优先选用接口,尽量少用抽象类</li>
<li>B 抽象类可以被声明使用,接口不可以被声明使用</li>
<li>C 抽象类和接口都不能被实例化。</li>
<li>D 以上说法都不对</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>


<ol>
<li>一个子类只能继承一个抽象类,但能实现多个接口</li>
<li>抽象类可以有构造方法,接口没有构造方法</li>
<li>抽象类可以有普通成员变量,接口没有普通成员变量</li>
<li>抽象类和接口都可有静态成员变量,抽象类中静态成员变量访问类型任意,接口只能public static final(默认)</li>
<li>抽象类可以没有抽象方法,抽象类可以有普通方法,接口中都是抽象方法</li>
<li>抽象类可以有静态方法,接口不能有静态方法</li>
<li>抽象类中的方法可以是public、protected;接口方法只有public</li>
</ol>
<h1 id="考点3-java内存区域"><a href="#考点3-java内存区域" class="headerlink" title="考点3 java内存区域"></a>考点3 java内存区域</h1><p>关于Java内存区域下列说法不正确的有哪些</p>
<ul>
<li>A 程序计数器是一块较小的内存空间,它的作用可以看做是当前线程所执行的字节码的信号指示器,每个线程都需要一个独立的程序计数器.</li>
<li>B <code>Java</code>虚拟机栈描述的是<code>java</code>方法执行的内存模型,每个方法被执行的时候都会创建一个栈帧,用于存储局部变量表、类信息、动态链接等信息</li>
<li>C <code>Java</code>堆是<code>java</code>虚拟机所管理的内存中最大的一块,每个线程都拥有一块内存区域,所有的对象实例以及数组都在这里分配内存。</li>
<li>D 方法区是各个线程共享的内存区域,它用于存储已经被虚拟机加载的常量、即时编译器编译后的代码、静态变量等数据。</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<p>有空了解一下<br>A.程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的信号指示器（偏移地址），Java编译过程中产生的字节码有点类似编译原理的指令，程序计数器的内存空间存储的是当前执行的字节码的偏移地址，每一个线程都有一个独立的程序计数器（程序计数器的内存空间是线程私有的），因为当执行语句时，改变的是程序计数器的内存空间，因此它不会发生内存溢出 ，并且程序计数器是jvm虚拟机规范中唯一一个没有规定 OutOfMemoryError 异常 的区域；<br>B.java虚拟机栈：线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。  没有类信息，类信息是在方法区中<br>C.java堆：对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组<br>D.方法区：属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>上面部分内容从下面文章中总结：<br><a href="https://blog.csdn.net/qq_41701956/article/details/81664921">https://blog.csdn.net/qq_41701956/article/details/81664921</a></p>
<h1 id="考点4-Spring依赖注入方式"><a href="#考点4-Spring依赖注入方式" class="headerlink" title="考点4 Spring依赖注入方式"></a>考点4 Spring依赖注入方式</h1><p>下面关于依赖注入(DI)的说法不正确的是()</p>
<ul>
<li>A 只有通过<code>Spring</code>才能实现依赖注入(<code>DI</code>)</li>
<li>B 依赖注入的主要目的是解耦合</li>
<li>C 常见的依赖注入方式有<code>Setter</code>和构造方法</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>Spring依赖注入(DI)的三种方式,分别为:</p>
<ol>
<li>接口注入</li>
<li>Setter方法注入</li>
<li>构造方法注入</li>
</ol>
<h1 id="考点5-整型除法结果为整型"><a href="#考点5-整型除法结果为整型" class="headerlink" title="考点5 整型除法结果为整型"></a>考点5 整型除法结果为整型</h1><p>设三个整型变量 x &#x3D; 1 , y &#x3D; 2 , z &#x3D; 3,则表达式 y+&#x3D;z–&#x2F;++x 的值是(      )。</p>
<ul>
<li>A 3</li>
<li>B 3.5</li>
<li>C 4</li>
<li>D 5</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>整型出发结果只取整数部分，小数部分丢弃，或者说向下取整。</p>
<h1 id="考点6-基本数据类型占用字节数"><a href="#考点6-基本数据类型占用字节数" class="headerlink" title="考点6 基本数据类型占用字节数"></a>考点6 基本数据类型占用字节数</h1><p>以下程序段执行后将有()个字节被写入到文件afile.txt中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;afile.txt&quot;</span>);</span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(fos);</span><br><span class="line">    dos.writeInt(<span class="number">3</span>);</span><br><span class="line">    dos.writeChar(<span class="number">1</span>);</span><br><span class="line">    dos.close();</span><br><span class="line">    fos.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 3</li>
<li>B 5</li>
<li>C 6</li>
<li>D 不确定,与软硬件环境相关</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>int占用4字节</p>
<p>char占用2字节</p>
<h1 id="考点7-jsp页面导入"><a href="#考点7-jsp页面导入" class="headerlink" title="考点7 jsp页面导入"></a>考点7 jsp页面导入</h1><p>java采用的uincode编码，两个字节表示一个字符，因此char型在java中占两个字节<br>给定includel.isp文件代码片段，如下：<br>  &lt;% pageContext.setAttribute(“User”,”HAHA”);%&gt;<br>______ &#x2F;&#x2F; 此处填写代码<br>  给定include2.jsp文件代码片段如下：<br>  &lt;%&#x3D;pageContext.getAttribute(“User”)%&gt;<br>  要求运行include1.jsp时，浏览器上输出：HAHA</p>
<p>A &lt;jsp:include page&#x3D;”include2.jsp” flash&#x3D;”true”&gt;<br>B &lt;%@include file&#x3D;”include2.jsp”%&gt;<br>C &lt;jsp:forward page&#x3D;”include2.jsp”&gt;<br>D &lt;% response.sendRedirect(“include2.jsp”); %&gt;</p>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>B选项是<strong>静态包含</strong>，相当于讲include2.jsp页面内容拷贝到此处，因此可以输出User属性值<br>D选项是<strong>转发重定向</strong>，转发的时候pageContent内的属性值不能被传递，因此得不到User属性值</p>
<h1 id="考点8-queue"><a href="#考点8-queue" class="headerlink" title="考点8 queue"></a>考点8 queue</h1><p>下面几个关于Java里queue的说法哪些是正确的()？</p>
<ul>
<li>A <code>LinkedBlockingQueue</code>是一个可选有界队列,不允许<code>null</code>值</li>
<li>B <code>PriorityQueue,LinkedBlockingQueue</code>都是线程不安全的</li>
<li>C <code>PriorityQueue</code>是一个无界队列,不允许<code>null</code>值,入队和出队的时间复杂度是<code>O(log(n))</code></li>
<li>D <code>PriorityQueue,ConcurrentLinkedQueue</code>都遵循<code>FIFO</code>原则</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

<p>有空了解一下</p>
<h1 id="考点9-字符串-字符"><a href="#考点9-字符串-字符" class="headerlink" title="考点9 字符串 字符"></a>考点9 字符串 字符</h1><p>java中 String str &#x3D; “hello world”下列语句错误的是？</p>
<ul>
<li>A <code>str+=&#39; a&#39;</code></li>
<li>B <code>int strlen = str.length</code></li>
<li>C <code>str=100</code></li>
<li>D <code>str=str+100</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<p>A选项错误:str +&#x3D; ‘a’   和 str +&#x3D;”a”都是对的，单引号表示字符里面，只能放一个字符。只有双引号里面才能写多个字符，表示字符串。所以如果a前面加一个空格，那么只能用双引号了。代表字符串<br>B选项错误:数组才有length属性，字符串是length()方法<br>C选项错误:int 无法直接转成String类型</p>
<h1 id="考点10-异常处理"><a href="#考点10-异常处理" class="headerlink" title="考点10 异常处理"></a>考点10 异常处理</h1><p>以下关于JAVA语言异常处理描述正确的有？</p>
<ul>
<li>A <code>throw</code>关键字可以在方法上声明该方法要抛出的异常。</li>
<li>B <code>throws</code>用于抛出异常对象。</li>
<li>C <code>try</code>是用于检测被包住的语句块是否出现异常,如果有异常,则抛出异常,并执行<code>catch</code>语句。</li>
<li>D <code>finally</code>语句块是不管有没有出现异常都要执行的内容。</li>
<li>E 在<code>try</code>块中不可以抛出异常</li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: CD</details>

<p>throws用于声明要抛出的异常，一般以s结尾的用于声明，比如extens, implements。<br>throw用于抛出异常。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年12月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年12月10日 java3</title>
    <url>/exam//fe6723d4/</url>
    <content><![CDATA[<h1 id="考点1-数组声明"><a href="#考点1-数组声明" class="headerlink" title="考点1 数组声明"></a>考点1 数组声明</h1><p>Which of the following statements are valid array declaration?<br>(A) int number();<br>(B) float average[];<br>(C) double[] marks;<br>(D) counter int[];</p>
<ul>
<li>A (B) &amp; (C)</li>
<li>B (A)</li>
<li>C (A) &amp; (C)</li>
<li>D (D)</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>valid有效的</p>
<h1 id="考点2-异常处理"><a href="#考点2-异常处理" class="headerlink" title="考点2 异常处理"></a>考点2 异常处理</h1><p>try块后必须有catch块。()</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p><code>try</code>的形式有如下三种:</p>
<ul>
<li>try-catch</li>
<li><code>try-finally</code></li>
<li><code>try-catch-finally</code></li>
</ul>
<p>但<code>catch</code>和<code>finally</code>语句不能同时省略</p>
<h1 id="考点3-异常继承树"><a href="#考点3-异常继承树" class="headerlink" title="考点3 异常继承树"></a>考点3 异常继承树</h1><p>有时为了避免某些未识别的异常抛给更高的上层应用,在某些接口实现中我们通常需要捕获编译运行期所有的异常, catch 下述哪个类的实例才能达到目的:()</p>
<ul>
<li>A <code>Error</code></li>
<li>B <code>Exception</code></li>
<li>C <code>RuntimeException</code></li>
<li>D <code>Throwable</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p><code>error</code>是系统出错,<code>catch</code>是无法处理的,难以修复的,<code>RuntimeException</code>不需要程序员进行捕获处理,<br><code>error</code>和<code>exception</code>都是<code>throwable</code>的子类,我们只需要对<code>exception</code>的实例进行捕获即可</p>
<h1 id="考点4-数据表述范围-值传递"><a href="#考点4-数据表述范围-值传递" class="headerlink" title="考点4 数据表述范围 值传递"></a>考点4 数据表述范围 值传递</h1><p>如下代码,执行test()函数后,屏幕打印结果为()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Byte b)</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = b++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        add(++a);</span><br><span class="line">        System.out.print(a + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        add(b);</span><br><span class="line">        System.out.print(b + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 127 127</li>
<li>B 128 127</li>
<li>C 129 128</li>
<li>D 以上都不对</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<ul>
<li>A 127 127</li>
<li>B 128 127</li>
<li>C 129 128</li>
<li>D 以上都不对</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>Byte类型值大小为-128~127之间。<br>add(++a);这里++a会越界，a的值变为-128<br>add(b); 前面说了，add不起任何作用，b还是127<br>add()方法里面的修改值并不会起作用，而add(++a)会使a数值越界成-128，所以输出为-128 127</p>
<h1 id="考点5-设计模式-单例模式"><a href="#考点5-设计模式-单例模式" class="headerlink" title="考点5 设计模式 单例模式"></a>考点5 设计模式 单例模式</h1><p>单例模式中,两个基本要点是</p>
<ul>
<li>A 构造函数私有</li>
<li>B 静态工厂方法</li>
<li>C 以上都不对</li>
<li>D 唯一实例</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details>

<h3 id="懒汉单例模式"><a href="#懒汉单例模式" class="headerlink" title="懒汉单例模式"></a>懒汉单例模式</h3><p>1.懒汉方式。指全局的单例实例在第一次被使用时构建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 INSTANCE=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE!=<span class="literal">null</span>)&#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="饿汉单例模式"><a href="#饿汉单例模式" class="headerlink" title="饿汉单例模式"></a>饿汉单例模式</h3><p>2.饿汉方式。指全局的单例实例在类装载时构建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考点6-final关键字-异常处理"><a href="#考点6-final关键字-异常处理" class="headerlink" title="考点6 final关键字 异常处理"></a>考点6 final关键字 异常处理</h1><p>下列有关JAVA异常处理的叙述中正确的是()</p>
<ul>
<li>A <code>finally</code>是为确保一段代码不管是否捕获异常都会被执行的一段代码</li>
<li>B <code>throws</code>是用来声明一个成员方法可能抛出的各种非运行异常情况</li>
<li>C <code>final</code>用于可以声明属性和方法,分别表示属性的不可变及方法的不可继承</li>
<li>D <code>throw</code>是用来明确地抛出一个异常情况</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>

<p><code>throws</code>用于在方法上声明该方法不需要处理的异常类型,用在方法上后面跟异常类名 可以是多个异常类<br> <code>throw</code>用于抛出具体异常类的对象,用在方法内 后面跟异常对象只能是一个异常类型实体.<br> <code>try</code>块必须和<code>catch</code>块或和<code>finally</code>同在,不能单独存在,二者必须出现一个.<br><code>finally</code>块总会执行,不论是否有错误出现.但是若<code>try</code>语句块或会执行的<code>catch</code>语句块使用了<code>JVM</code>系统退出语句,<code>finally</code>块就不会被执行了.<br>一般我们把关闭资源的代码放在<code>finally</code>里面 保证资源总是能关闭<br>然后再看这一题 A肯定对了，C根本就跟异常处理没有关系，所以不选。就算有关系也错了<br><code>final</code>用于声明属性、方法、类。分别表示</p>
<ul>
<li>属性不可更改、</li>
<li>方法不能被覆盖、</li>
<li>类不能被继承。</li>
</ul>
<p>所以C选项说<code>final</code>方法不能被继承是错误的,<code>final</code>方法可以继承,但是不能覆盖,</p>
<h1 id="考点7-循环-等差数列"><a href="#考点7-循环-等差数列" class="headerlink" title="考点7 循环 等差数列"></a>考点7 循环 等差数列</h1><p>下面是findSum(int m.int n)方法的定义,方法调用findSum(1,5)的返回结果是( )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findSum</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;i&lt;=n;i++)&#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 1</li>
<li>B 5</li>
<li>C 10</li>
<li>D 15</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>1+2+3+4+5&#x3D;(1+5)×5÷2&#x3D;15</p>
<h1 id="考点8-JVM内存分类"><a href="#考点8-JVM内存分类" class="headerlink" title="考点8 JVM内存分类"></a>考点8 JVM内存分类</h1><p>JVM内存不包含如下哪个部分( )</p>
<ul>
<li>A <code>Stacks</code></li>
<li>B <code>PC</code>寄存器</li>
<li>C <code>Heap</code></li>
<li>D <code>Heap Frame</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h3 id="JVM内存五大区域"><a href="#JVM内存五大区域" class="headerlink" title="JVM内存五大区域"></a>JVM内存五大区域</h3><p><img data-src="https://uploadfiles.nowcoder.com/images/20190606/291053_1559812298987_4E467FB794A7AF7967F62555B4F0B6A6" alt="图片"><br>栈有帧堆没帧<br>方法区 堆 pc计数器 本地方法栈 虚拟机栈</p>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>如果一个list初始化为{5,3,1},执行以下代码后,其结果为()？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nums.add(<span class="number">6</span>);</span><br><span class="line">nums.add(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">nums.remove(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>A [5, 3, 1, 6]</li>
<li>B [4, 3, 1, 6]</li>
<li>C [4, 3, 6]</li>
<li>D [5, 3, 6]</li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>list{5,3,1}<br>nums.add(6); &#x2F;&#x2F;往后边加一个6，{5，3，1，6}<br>nums.add(0,4);&#x2F;&#x2F;往下标为0的数加一个4，{4，5，3，1，6}<br>nums.remove(1); &#x2F;&#x2F; 移除下标为1 的元素，{4，3，1，6}</p>
<h1 id="考点10-JVM堆内存"><a href="#考点10-JVM堆内存" class="headerlink" title="考点10 JVM堆内存"></a>考点10 JVM堆内存</h1><p>以下哪个不属于JVM堆内存中的区域()？</p>
<ul>
<li>A <code>survivor</code>区</li>
<li>B 常量池</li>
<li>C <code>eden</code>区</li>
<li>D <code>old</code>区</li>
</ul>
<h2 id="解析-10"><a href="#解析-10" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>堆中的内存可以为了新生代和老年代,新生代由可以分为一个<code>Survivor</code>和两个<code>Eden(From,To)</code>,默认比例8:1:1。<br>其实这个题有问题,从<code>JDK7</code>开始,常量池就从方法区中被移了到了堆(<code>Hotspot</code>叫做永久代),<code>JDK8</code>的时候,永久代被元空间代替。但是这个字符串常量池可是一直都在堆中的。<br>这里先说一下,方法区和永久代只是针对于<code>HotSpot</code>而言,在<code>JDK7</code>之前是一个概念,对于别的虚拟机而言,可没有什么永久代,只有方法区。<br>为什么<code>HotSpot</code>把永久代取消了呢,主要是因为这块地方的<code>GC</code>机制和堆邦定在一起,但是因为它不是堆,所以每一个<code>GC</code>收集器都需要有很大一部分代码去专门实现这个区域的垃圾,其次,每次一开始为永久代分配内存的时候,因为无法估量对象的大小,所以总是很难分配合适的内存,还容易出现<code>OOM</code>,所以取代成了元空间。元空间的话相当于一个内地内存,所以基本不会出现什么<code>OOM</code>,但是内存泄漏还是有的。</p>
<h1 id="考点11-Hibernate"><a href="#考点11-Hibernate" class="headerlink" title="考点11 Hibernate"></a>考点11 Hibernate</h1><p>下面哪一项不属于优化Hibernate所鼓励的？</p>
<ul>
<li>A 使用单向一对多关联,不使用双向一对多</li>
<li>B 不用一对一,用多对一取代</li>
<li>C 配置对象缓存,不使用集合缓存</li>
<li>D 继承类使用显式多态</li>
</ul>
<h2 id="解析-11"><a href="#解析-11" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>优化Hibernate所鼓励的7大措施：<br>1.尽量使用many-to-one，避免使用单项one-to-many<br>2.灵活使用单向one-to-many<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag 多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism&#x3D;”exlicit”<br>避免查处所有对象<br>7.消除大表，使用二级缓存</p>
<p>1、什么是延迟加载？<br>定义：延迟加载(lazy load)是Hibernate3 关联关系对象默认的加载方式，延迟加载机制是为了避免一些无谓的性能开销而提出来的。就是只有当真正需要数据时，才真正的执行数据加载操作。延迟加载是 hibernate 中用于提高查询效率的一种措施，它的对立面是 立即加载。<br>2、如何实现延迟加载？<br>Hibernate 2 实现延迟加载有 2 种方式：<br>实体对象<br>集合<br>Hibernate 3 又引入了一种新的加载方式：属性的延迟加载<br>一般使用load()的方法来实现延迟加载：<br>当调用load方法加载对象时，返回***对象，等到真正用到对象的内容时才发出sql语句<br>3、Hibernate 其他介绍<br>Hibernate 使用 Java 反射机制，而不是字节码增强程序来实现透明性<br>Hibernate 的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。<br>4、优化 Hibernate 所鼓励的 7 大措施<br>1.尽量使用多对一，避免使用单项一对多<br>2.灵活使用单向一对多<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag ，多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism&#x3D;”exlicit” 避免查处所有对象<br>7.消除大表，使用二级缓存</p>
<h1 id="考点12-Struts"><a href="#考点12-Struts" class="headerlink" title="考点12 Struts"></a>考点12 Struts</h1><p>在Struts框架中如果要使用Validation作验证的话,需要使用以下哪个Form？</p>
<ul>
<li>A <code>ActionForm</code></li>
<li>B <code>ValidatorActionForm</code></li>
<li>C <code>ValidatorForm</code></li>
<li>D <code>DynaValidatorActionForm</code></li>
</ul>
<h2 id="解析-12"><a href="#解析-12" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>有空了解一下<br>DynaValidatorActionForm 动态验证表单 Validation 确认的意思</p>
<h1 id="考点13-hibernate-POJO"><a href="#考点13-hibernate-POJO" class="headerlink" title="考点13 hibernate POJO"></a>考点13 hibernate POJO</h1><p>在 hibernate 开发中,关于 POJO 类对象的状态说法正确的是()。</p>
<ul>
<li>A 自由状态(<code>Transient</code>):实体在内存中自由存在,与数据库中的记录无关</li>
<li>B 持久状态(<code>Persistent</code>):实体处于由<code>Hibernate</code>框架所管理的状态,对应了数据库中的一条记录,同时与某个<code>session</code>实例发生了关联</li>
<li>C 游离状态(<code>Detached</code>):在<code>session</code> 关闭之后,可以使对象从持久状态转换到游离状态。</li>
<li>D 不能将对象从游离状态转换成持久态</li>
</ul>
<h2 id="解析-13"><a href="#解析-13" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<p>有空了解一下</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年12月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年12月11日 java2</title>
    <url>/exam//fe6723d4/</url>
    <content><![CDATA[<h1 id="考点1-异常处理-catch顺序"><a href="#考点1-异常处理-catch顺序" class="headerlink" title="考点1 异常处理 catch顺序"></a>考点1 异常处理 catch顺序</h1><p>下列类在多重catch中同时出现时,哪一个异常类应最后一个列出()</p>
<ul>
<li>A <code>ArithmeticException</code></li>
<li>B <code>NumberFormatException</code></li>
<li>C <code>Exception</code></li>
<li>D <code>ArrayIndexOutOfBoundException</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>这是多重catch块的顺序问题，由于异常处理系统就近寻找匹配异常处理程序，应先子类后父类。</p>
<h1 id="考点2-JSP编码"><a href="#考点2-JSP编码" class="headerlink" title="考点2 JSP编码"></a>考点2 JSP编码</h1><p>通过HttpServletRequest. getParameter获取的参数.</p>
<ul>
<li>A 总是采用<code>UTF-8</code>编码</li>
<li>B 总是采用<code>lS08859-1</code>编码</li>
<li>C 由客户端浏览器和<code>Web</code>容器配置共同决定编码</li>
<li>D 由服务器所在的操作系统决定编码</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>编码格式由浏览器决定，浏览器根据html中指定的编码格式进行编码，tomcat根据指定的格式进行解码，另外get请求和post请求对编码格式的处理也是不同的</p>
<h1 id="考点3-异常处理-finally返回值会覆盖try的返回值"><a href="#考点3-异常处理-finally返回值会覆盖try的返回值" class="headerlink" title="考点3 异常处理 finally返回值会覆盖try的返回值"></a>考点3 异常处理 finally返回值会覆盖try的返回值</h1><p>以下代码执行后输出结果为( )<br>public class Test {<br>    public static void main(String[] args) {<br>        System.out.println(“return value of getValue(): “ +<br>        getValue());<br>    }<br>     public static int getValue() {<br>         try {<br>             return 0;<br>         } finally {<br>             return 1;<br>         }<br>     }<br> }</p>
<ul>
<li>A <code>return value of getValue(): 1</code></li>
<li>B <code>return value of getValue(): 0</code></li>
<li>C <code>return value of getValue(): 0return value of getValue(): 1</code></li>
<li>D <code>return value of getValue(): 1return value of getValue(): 0</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>根据官方的JVM规范：<br>如果try语句里有return，返回的是try语句块中变量值。<br>详细执行过程如下：</p>
<ul>
<li>如果try语句块有返回值，就把try的返回值保存到局部变量中；</li>
<li>执行jsr指令跳到finally语句里执行；执行完finally语句后，<ul>
<li>如果finally语句没有返回值，则返回之前保存在局部变量表里的值。</li>
<li>如果finally语句里有return，忽略try的return，而使用finally的return.</li>
</ul>
</li>
</ul>
<h1 id="考点4-重写要求"><a href="#考点4-重写要求" class="headerlink" title="考点4 重写要求"></a>考点4 重写要求</h1><p>根据以下接口和类的定义,要使代码没有语法错误,则类Hero中应该定义方法(    )。<br>interface Action{<br>    void fly();<br>}<br>class Hero implements Action{  &#x2F;&#x2F;……  }</p>
<ul>
<li>A <code>private void fly()</code>{}</li>
<li>B <code>void fly()</code>{}</li>
<li>C <code>protected void fly()</code>{}</li>
<li>D <code>public void fly()</code>{}</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h3 id="继承中方法重写要求"><a href="#继承中方法重写要求" class="headerlink" title="继承中方法重写要求"></a>继承中方法重写要求</h3><ul>
<li>两同 参数列表相同，方法名相同</li>
<li>两小 抛出异常子类小，子类返回值和父类返回值相同或比父类小</li>
<li>一大 访问控制权限子类比父类大或相等</li>
</ul>
<p>接口中的方法默认public abstract修饰 故子类重写时只能用public作为访问控制权限修饰符</p>
<h1 id="考点5-网络编程socket"><a href="#考点5-网络编程socket" class="headerlink" title="考点5 网络编程socket"></a>考点5 网络编程socket</h1><p>socket编程中,以下哪个socket的操作是不属于服务端操作的()？</p>
<ul>
<li>A <code>accept</code></li>
<li>B <code>listen</code></li>
<li>C <code>connect</code></li>
<li>D <code>close</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p><a href="https://uploadfiles.nowcoder.com/images/20180316/8955099_1521189690989_0BB28C2A1ECCC47EC020E89E8A554BBC">图片</a></p>
<h1 id="考点6-Integer缓存"><a href="#考点6-Integer缓存" class="headerlink" title="考点6 Integer缓存"></a>考点6 Integer缓存</h1><p>下面的代码返回结果为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">500</span>;</span><br></pre></td></tr></table></figure>
<p>System.out.print(a &#x3D;&#x3D; b);<br>System.out.print(c &#x3D;&#x3D; d);</p>
<ul>
<li>A <code>true</code>、<code>true</code></li>
<li>B <code>true</code>、<code>false</code></li>
<li>C <code>false</code>、<code>true</code></li>
<li>D <code>false</code>、<code>false</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>Interger的缓存[-128,127]这个范围内的Interger对象，创建在这个范围内的Integer对象时，不会创建新的Interger对象，而是返回缓存好了的对象，所以<br>在[-128,127]范围内比较相等返回为true，<br>超过范围返回false</p>
<h1 id="考点7-queue的实现类"><a href="#考点7-queue的实现类" class="headerlink" title="考点7 queue的实现类"></a>考点7 queue的实现类</h1><p>下面几个关于Java里queue的说法哪些是正确的()？</p>
<ul>
<li>A <code>LinkedBlockingQueue</code>是一个可选有界队列,不允许<code>null</code>值</li>
<li>B <code>PriorityQueue,LinkedBlockingQueue</code>都是线程不安全的</li>
<li>C <code>PriorityQueue</code>是一个无界队列,不允许<code>null</code>值,入队和出队的时间复杂度是<code>O(log(n))</code></li>
<li>D <code>PriorityQueue,ConcurrentLinkedQueue</code>都遵循<code>FIFO</code>原则</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

<p>有空了解一下</p>
<h1 id="考点8-反射"><a href="#考点8-反射" class="headerlink" title="考点8 反射"></a>考点8 反射</h1><p>Java是一门支持反射的语言,基于反射为Java提供了丰富的动态性支持,下面关于Java反射的描述,哪些是错误的:(    )</p>
<ul>
<li>A <code>Java</code>反射主要涉及的类如<code>Class, Method, Filed</code>,等,他们都在<code>java.lang.reflet</code>包下</li>
<li>B 通过反射可以动态的实现一个接口,形成一个新的类,并可以用这个类创建对象,调用对象方法</li>
<li>C 通过反射,可以突破<code>Java</code>语言提供的对象成员、类成员的保护机制,访问一般方式不能访问的成员</li>
<li>D <code>Java</code>反射机制提供了字节码修改的技术,可以动态的修剪一个类</li>
<li>E <code>Java</code>的反射机制会给内存带来额外的开销。例如对永生堆的要求比不通过反射要求的更多</li>
<li>F <code>Java</code>反射机制一般会带来效率问题,效率问题主要发生在查找类的方法和字段对象,因此通过缓存需要反射类的字段和方法就能达到与之间调用类的方法和访问类的字段一样的效率</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ADF</details>

<p>A选项错误:<br>类Class在java.lang包下，<br>类Method、Filed在java.lang.reflet包下<br>D选项错误:<strong>反射的本质就是从字节码中查找，动态获取类的整容结构，包括属性，构造器，动态调用对象的方法</strong>，而不是修剪类，<br>F选项错误:<strong>使用了反射的效率都会降低，就算加了缓存</strong></p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年12月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年12月12日 java1</title>
    <url>/exam//149c92c5/</url>
    <content><![CDATA[<h1 id="考点1-GUI"><a href="#考点1-GUI" class="headerlink" title="考点1 GUI"></a>考点1 GUI</h1><p>AWT 中用来表示文本框的类是 ( )</p>
<ul>
<li>A <code>TextField</code></li>
<li>B <code>Menu</code></li>
<li>C <code>Label</code></li>
<li>D <code>List</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h1 id="考点2-JDBC"><a href="#考点2-JDBC" class="headerlink" title="考点2 JDBC"></a>考点2 JDBC</h1><p>下面哪个不是标准Statement类？</p>
<ul>
<li>A <code>Statement</code></li>
<li>B <code>PreparedStatement</code></li>
<li>C <code>CallableStatement</code></li>
<li>D <code>BatchedStatement</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p><code>Statement</code>在<code>JDBC</code>中相当于<code>SQL</code>语句的载体<br>A,<code>Statement</code>是最基本的用法,采用字符串拼接的方式,存在注入漏洞<br>B,<code>PreparedStatement</code>对<code>Statement</code>中的<code>SQL</code>语句进行预编译,同时检查合法性,效率高<br>C,<code>CallableStatement</code>接口扩展<br><code>PreparedStatement</code>,用来调用存储过程,它提供了对输出和输入&#x2F;输出参数的支持。<code>CallableStatement</code> 接口还具有对<br><code>PreparedStatement</code> 接口提供的输入参数的支持。<br>D,不是标准的<code>Statement</code>类</p>
<h1 id="考点3-EJB"><a href="#考点3-EJB" class="headerlink" title="考点3 EJB"></a>考点3 EJB</h1><p>下列说法正确的是()</p>
<ul>
<li>A <code>WebLogic</code>中开发消息<code>Bean</code>的<code>non</code>－<code>persistent</code> 方式可以保证消息的可靠</li>
<li>B <code>EJB</code>容器发生错误,<code>non</code>－<code>persistent</code>方式下<code>JMS</code>容器仍然会将消息发送</li>
<li>C <code>EJB</code>容器发生错误,<code>persistent</code>方式下<code>JMS</code>容器仍然会将消息发送</li>
<li>D <code>EJB</code>容器发生错误,两种方式下<code>JMS</code>容器仍会在<code>MDB</code>可用的时候将消息发送</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h1 id="考点4-多线程"><a href="#考点4-多线程" class="headerlink" title="考点4 多线程"></a>考点4 多线程</h1><p>假设 a 是一个由线程 1 和线程 2 共享的初始值为 0 的全局变量,则线程 1 和线程 2 同时执行下面的代码,最终 a 的结果不可能是()<br>boolean isOdd &#x3D; false;<br>for(int i&#x3D;1;i&lt;&#x3D;2;++i)<br>{<br>if(i%2&#x3D;&#x3D;1)isOdd &#x3D; true;<br>else isOdd &#x3D; false;<br>a+&#x3D;i*(isOdd?1:-1);<br>}</p>
<ul>
<li>A -1</li>
<li>B -2</li>
<li>C 0</li>
<li>D 1</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<h1 id="考点5-线程生命周期"><a href="#考点5-线程生命周期" class="headerlink" title="考点5 线程生命周期"></a>考点5 线程生命周期</h1><p>在Java线程状态转换时,下列转换不可能发生的有()？</p>
<ul>
<li>A 初始态-&gt;运行态</li>
<li>B 就绪态-&gt;运行态</li>
<li>C 阻塞态-&gt;运行态</li>
<li>D 运行态-&gt;就绪态</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

<p><img data-src="https://uploadfiles.nowcoder.com/images/20180228/8843251_1519785902007_ACED241801E307EE7A39612F85A94EBF" alt="图片"></p>
<h1 id="考点6-标识符命名"><a href="#考点6-标识符命名" class="headerlink" title="考点6 标识符命名"></a>考点6 标识符命名</h1><p>在java中,下列标识符不合法的有( )</p>
<ul>
<li>A <code>new</code></li>
<li>B $<code>Usdollars</code></li>
<li>C 1234</li>
<li>D <code>car.taxi</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details>

<ul>
<li>字母数字下划线美元符</li>
<li>数字不能开头</li>
<li>不能是关键字</li>
</ul>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年12月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年12月13日 java1</title>
    <url>/exam//fb5ef9fb/</url>
    <content><![CDATA[<h1 id="考点1-二维数组的遍历"><a href="#考点1-二维数组的遍历" class="headerlink" title="考点1 二维数组的遍历"></a>考点1 二维数组的遍历</h1><p>下面程序段执行完成后,则变量sum的值是(    )。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  b[][]=&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>,<span class="number">2</span>&#125;, &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;b.length;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;b[i].length;j++) &#123;</span><br><span class="line">        sum+=b[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 32</li>
<li>B 11</li>
<li>C 2</li>
<li>D 3</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>


<h1 id="考点2-main方法的书写"><a href="#考点2-main方法的书写" class="headerlink" title="考点2 main方法的书写"></a>考点2 main方法的书写</h1><p>main 方法是 Java Application 程序执行的入口点,以下描述哪项是合法的()。</p>
<ul>
<li>A <code>public static void main( )</code></li>
<li>B <code>public static void main( String args[] )</code></li>
<li>C <code>public static int main(String [] arg )</code></li>
<li>D <code>public void main(String arg[] )</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>


<h1 id="考点3-数据库-事务隔离级别"><a href="#考点3-数据库-事务隔离级别" class="headerlink" title="考点3 数据库 事务隔离级别"></a>考点3 数据库 事务隔离级别</h1><p>事务隔离级别是由谁实现的？</p>
<ul>
<li>A <code>Java</code>应用程序</li>
<li>B <code>Hibernate</code></li>
<li>C 数据库系统</li>
<li>D <code>JDBC</code>驱动程序</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h1 id="考点4-子类调用父类构造器"><a href="#考点4-子类调用父类构造器" class="headerlink" title="考点4 子类调用父类构造器"></a>考点4 子类调用父类构造器</h1><p>根据以下代码段,执行new Child(“John”, 10); 要使数据域data得到10,则子类空白处应该填写(    )。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">(<span class="type">int</span> d)</span>&#123; data = d; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">(String s, <span class="type">int</span> d)</span>&#123;</span><br><span class="line">        <span class="type">___________________</span></span><br><span class="line">        <span class="variable">name</span> <span class="operator">=</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A <code>data = d;</code></li>
<li>B <code>super.data = d;</code></li>
<li>C <code>Parent(d);</code></li>
<li>D <code>super(d);</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<p>子父类存在<strong>同名成员</strong>时，<strong>子类中默认访问子类的成员</strong>，可通过super指定访问父类的成员，格式：super.xx<br>创建子类对象时，默认会调用父类的无参构造方法，但是，如果父类中提供了带参构造函数，却没有提供无参构造器，则子类构造函数必须显示调用父类带参构造器。</p>
<h1 id="考点5-检查异常"><a href="#考点5-检查异常" class="headerlink" title="考点5 检查异常"></a>考点5 检查异常</h1><p>Thread. sleep()是否会抛出checked exception?</p>
<ul>
<li>A 会</li>
<li>B 不会</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>Thread.sleep() 和 Object.wait(),都可以抛出 InterruptedException。这个异常是不能忽略的,因为它是一个检查异常(checked exception)</p>
<h1 id="考点6-排序-快速排序"><a href="#考点6-排序-快速排序" class="headerlink" title="考点6 排序 快速排序"></a>考点6 排序 快速排序</h1><p>下面程序的输出结果是什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A2</span>&#123; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] a=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    doSomething(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a.length-<span class="number">1</span>;i++)</span><br><span class="line">    System.out.print(a[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&lt;end)&#123;</span><br><span class="line">        <span class="type">int</span> p=core(a,start,end);</span><br><span class="line">        doSomething(a,start,p-<span class="number">1</span>);</span><br><span class="line">        doSomething(a,p+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">core</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> start,<span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x=a[end];</span><br><span class="line">    <span class="type">int</span> i=start;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=start;j&lt;=end-<span class="number">1</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j]&gt;=x)&#123;</span><br><span class="line">            swap(a,i,j);</span><br><span class="line">            i++;<span class="comment">//交换了几次 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//把最大的放到最后</span></span><br><span class="line">    swap(a,i,end);<span class="comment">//把最大的放到i的位置 </span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> i,<span class="type">int</span> j)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp=a[i];</span><br><span class="line">    a[i]=a[j];</span><br><span class="line">    a[j]=tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>A 找到最大值</li>
<li>B 找到最小值</li>
<li>C 从大到小的排序</li>
<li>D 从小到大的排序</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h1 id="考点7-线程"><a href="#考点7-线程" class="headerlink" title="考点7 线程"></a>考点7 线程</h1><p>当我们需要所有线程都执行到某一处,才进行后面的的代码执行我们可以使用？</p>
<ul>
<li>A <code>CountDownLatch</code></li>
<li>B <code>CyclicBarrier</code></li>
<li>C <code>Semaphore</code></li>
<li>D <code>Future</code></li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>CountDownLatch 是等待一组线程执行完，才执行后面的代码。此时这组线程已经执行完。<br>CyclicBarrier 是等待一组线程至某个状态后再同时全部继续执行线程。此时这组线程还未执行完。</p>
<h1 id="考点8-java编译"><a href="#考点8-java编译" class="headerlink" title="考点8 java编译"></a>考点8 java编译</h1><p>下列说法正确的有( )</p>
<ul>
<li>A 环境变量可在编译<code>source code</code>时指定</li>
<li>B 在编译程序时,所能指定的环境变量不包括<code>class path</code></li>
<li>C <code>javac</code>一次可同时编译数个<code>Java</code>源文件</li>
<li>D <code>javac.exe</code>能指定编译结果要置于哪个目录(<code>directory</code>)</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details>

]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年12月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年12月13日 java2</title>
    <url>/exam//6257a841/</url>
    <content><![CDATA[<h1 id="考点1-修饰符混用"><a href="#考点1-修饰符混用" class="headerlink" title="考点1 修饰符混用"></a>考点1 修饰符混用</h1><p>下列关于修饰符混用的说法,错误的是( )</p>
<ul>
<li>A <code>abstract</code>不能与<code>final</code>并列修饰同一个类</li>
<li>B <code>abstract</code>类中不应该有<code>private</code>的成员</li>
<li>C <code>abstract</code>方法必须在<code>abstract</code>类或接口中</li>
<li>D <code>static</code>方法中能直接调用类里的非<code>static</code>的属性</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>abstract类中的确<strong>不应该</strong>有private的成员,但是是可以有的</p>
<h1 id="考点2-求余运算"><a href="#考点2-求余运算" class="headerlink" title="考点2 求余运算"></a>考点2 求余运算</h1><p>以下代码段执行后的输出结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> -<span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> -<span class="number">12</span>;</span><br><span class="line">        System.out.println(y % x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A -1</li>
<li>B 2</li>
<li>C 1</li>
<li>D -2</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>Y(被除数) % X(除数) 当除数与被除数的符号相同时，取余和取模的结果是完全相同的； 当除数与被除数的符号不相同时，结果不同。具体说，<strong>取余结果的符号与%前面的数的符号(被除数)相同</strong>；</p>
<h1 id="考点3-java只有值传递"><a href="#考点3-java只有值传递" class="headerlink" title="考点3 java只有值传递"></a>考点3 java只有值传递</h1><p>关于Java中参数传递的说法,哪个是错误的？</p>
<ul>
<li>A 在方法中,修改一个基础类型的参数不会影响原始参数值</li>
<li>B 在方法中,改变一个对象参数的引用不会影响到原始引用</li>
<li>C 在方法中,修改一个对象的属性会影响原始对象参数</li>
<li>D 在方法中,修改集合和<code>Maps</code>的元素不会影响原始集合参数</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>



<h1 id="考点4-多态-编译看左边-运行看右边"><a href="#考点4-多态-编译看左边-运行看右边" class="headerlink" title="考点4 多态 编译看左边 运行看右边"></a>考点4 多态 编译看左边 运行看右边</h1><p>下列代码输出结果为(      )</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">    public void move()&#123;</span><br><span class="line">        System.out.println(&quot;动物可以移动&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">    public void move()&#123;</span><br><span class="line">        System.out.println(&quot;狗可以跑和走&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void bark()&#123;</span><br><span class="line">        System.out.println(&quot;狗可以吠叫&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestDog&#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        Animal a = new Animal();</span><br><span class="line">        Animal b = new Dog(); </span><br><span class="line">        a.move();</span><br><span class="line">        b.move();</span><br><span class="line">        b.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">动物可以移动</span><br><span class="line">狗可以跑和走</span><br><span class="line">狗可以吠叫</span><br></pre></td></tr></table></figure></li>
<li>B<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">动物可以移动</span><br><span class="line">动物可以移动</span><br><span class="line">狗可以吠叫</span><br></pre></td></tr></table></figure></li>
<li>C 运行错误</li>
<li>D 编译错误</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>假设num已经被创建为一个ArrayList对象,并且最初包含以下整数值:[0,0,4,2,5,0,3,0]。 执行下面的方法numQuest(),最终的输出结果是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; nums;</span><br><span class="line"><span class="comment">//precondition: nums.size() &gt; 0</span></span><br><span class="line"><span class="comment">//nums contains Integer objects</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">numQuest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">zero</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (k &lt; nums.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.get(k).equals(zero))nums.remove(k);</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A [3, 5, 2, 4, 0, 0, 0, 0]</li>
<li>B [0, 0, 0, 0, 4, 2, 5, 3]</li>
<li>C [0, 0, 4, 2, 5, 0, 3, 0]</li>
<li>D [0, 4, 2, 5, 3]</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>List中的 get ( i )指的是获取下标（索引）为 i 的元素，也就是第 i+1 个元素<br>本题：<br>zero&#x3D;&#x3D;0，如果get(k)&#x3D;&#x3D;0,执行remove(k); ;<br> size&#x3D;&#x3D;8 ; k&#x3D;&#x3D;0 , 因此第一次remove(0) ，删除索引为0的元素也就是第一个元素0，然后k++, size()–;<br>此时集合元素为 ：[0，4，2，5，0，3，0]<br> size&#x3D;&#x3D;7; k&#x3D;&#x3D;1，因此get(1)&#x3D;&#x3D;4 !&#x3D;0 , 不执行remove(); k++,因没有删除元素，size()不变，<br>此时集合元素为：[0，4，2，5，0，3，0]<br> size&#x3D;&#x3D;7;k&#x3D;&#x3D;2，k++;<br> size&#x3D;&#x3D;7;k&#x3D;&#x3D;3，k++;<br> size&#x3D;&#x3D;7;k&#x3D;&#x3D;4，get(4)&#x3D;&#x3D;0，remove(4) ; k++, size()–;<br>此时集合元素为： [0，4，2，5，3，0]<br> size&#x3D;&#x3D;6;k&#x3D;&#x3D;5，get(5)&#x3D;&#x3D;0，remove(5)；k++, size()–;<br>此时集合元素为： [0，4，2，5，3]<br> size&#x3D;&#x3D;5; k&#x3D;&#x3D;6 ;退出循环；最终输出此时集合元素为 [0，4，2，5，3] ；<br>一般更改删除集合元素，使用iterator()迭代器，不推荐使用这种；</p>
<p>此方法的目地就是排除重复元素</p>
<h1 id="考点6-Math-round四舍五入-舍变小入变大"><a href="#考点6-Math-round四舍五入-舍变小入变大" class="headerlink" title="考点6 Math.round四舍五入 舍变小入变大"></a>考点6 Math.round四舍五入 舍变小入变大</h1><p>Math.round(11.5) 等于多少 (). Math.round(-11.5) 等于多少 (  ).</p>
<ul>
<li>A 11 ,-11</li>
<li>B 11 ,-12</li>
<li>C 12 ,-11</li>
<li>D 12 ,-12</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>floor : 意为地板,指向下取整,返回不大于它的最大整数<br>ceil : 意为天花板,指向上取整,返回不小于它的最小整数<br>round: 意为大约,表示”四舍五入”,而四舍五入，入是<strong>往数值大数的方向入</strong>。<br>Math.round(11.5)的结果为12,12＞11.5<br>Math.round(-11.5)的结果为-11。-11＞-11.5</p>
<h1 id="考点7-Log4j"><a href="#考点7-Log4j" class="headerlink" title="考点7 Log4j"></a>考点7 Log4j</h1><p>下列语句哪一个是不正确的()</p>
<ul>
<li>A <code>Log4j</code>支持按分钟为间隔生成新的日志文件</li>
<li>B <code>Log4j</code>是一个打印日志用的组件</li>
<li>C <code>Log4j</code>支持按年为间隔生成新的日志文件</li>
<li>D <code>Log4j</code>的日志打印级别可以在运行时重新设置</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>Log4j在运行期间不可重置</p>
<h1 id="考点8-默认构造器"><a href="#考点8-默认构造器" class="headerlink" title="考点8 默认构造器"></a>考点8 默认构造器</h1><p>It is an important feature of the Java language that it always provides a default constructor to a class.</p>
<ul>
<li>A <code>FALSE</code></li>
<li>B <code>TRUE</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>只有在不显示声明构造方法时，系统才提供默认无参构造方法</p>
<h1 id="考点9-线程安全集合"><a href="#考点9-线程安全集合" class="headerlink" title="考点9 线程安全集合"></a>考点9 线程安全集合</h1><p>下面哪些具体实现类可以用于存储键,值对,并且方法调用提供了基本的多线程安全支持:()</p>
<ul>
<li>A <code>java.util.ConcurrentHashMap</code></li>
<li>B <code>java.util.Map</code></li>
<li>C <code>java.util.TreeMap</code></li>
<li>D <code>java.util.SortMap</code></li>
<li>E <code>java.util.Hashtable</code></li>
<li>F <code>java.util.HashMap</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AE</details>

<h3 id="线程安全的map"><a href="#线程安全的map" class="headerlink" title="线程安全的map"></a>线程安全的map</h3><p>HashTable,<br>SynchronizedMap,<br>ConcurrentHashMap</p>
<h1 id="考点10-java内存区域"><a href="#考点10-java内存区域" class="headerlink" title="考点10 java内存区域"></a>考点10 java内存区域</h1><p>关于Java内存区域下列说法不正确的有哪些</p>
<ul>
<li>A 程序计数器是一块较小的内存空间,它的作用可以看做是当前线程所执行的字节码的信号指示器,每个线程都需要一个独立的程序计数器.</li>
<li>B <code>Java</code>虚拟机栈描述的是<code>java</code>方法执行的内存模型,每个方法被执行的时候都会创建一个栈帧,用于存储局部变量表、<code>类信息</code>、动态链接等信息</li>
<li>C <code>Java</code>堆是<code>java</code>虚拟机所管理的内存中最大的一块,每个线程都拥有一块内存区域,所有的对象实例以及数组都在这里分配内存。</li>
<li>D 方法区是各个线程共享的内存区域,它用于存储已经被虚拟机加载的常量、即时编译器编译后的代码、静态变量等数据。</li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<p>B错误. java虚拟机栈没有类信息，<strong>类信息是在方法区</strong>中<br>C错误. java堆<code>线程共享</code>，主要是存放对象实例和数组</p>
<h1 id="考点11-编译原理-循环优化"><a href="#考点11-编译原理-循环优化" class="headerlink" title="考点11 编译原理 循环优化"></a>考点11 编译原理 循环优化</h1><p>下列哪些方法是针对循环优化进行的</p>
<ul>
<li>A 强度削弱</li>
<li>B 删除归纳变量</li>
<li>C 删除多余运算</li>
<li>D 代码外提</li>
</ul>
<h2 id="解析-10"><a href="#解析-10" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>

<p>常见的代码优化技术有:复写传播,删除死代码, 强度削弱,归纳变量删除<br>有空了解一下</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年12月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年12月14日 java1</title>
    <url>/exam//1982e282/</url>
    <content><![CDATA[<h1 id="考点1-进制加权展开"><a href="#考点1-进制加权展开" class="headerlink" title="考点1 进制加权展开"></a>考点1 进制加权展开</h1><p>以下哪个式子有可能在某个进制下成立()？</p>
<ul>
<li>A 13*14&#x3D;204</li>
<li>B 12*34&#x3D;568</li>
<li>C 14*14&#x3D;140</li>
<li>D 1+1&#x3D;3</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<p>（1<em>n+3）</em>(1<em>n+4)&#x3D;2</em>n^2+4;<br>解得:  n&#x3D;-1或n&#x3D;8; 进制不为负数，所以 n&#x3D;8成立</p>
<h1 id="考点2-字符流-字节流"><a href="#考点2-字符流-字节流" class="headerlink" title="考点2 字符流 字节流"></a>考点2 字符流 字节流</h1><p>下面的类哪些可以处理Unicode字符?</p>
<ul>
<li>A <code>InputStreamReader</code></li>
<li>B <code>BufferedReader</code></li>
<li>C <code>Writer</code></li>
<li>D <code>PipedInputStream</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>


<h1 id="考点3-字符集"><a href="#考点3-字符集" class="headerlink" title="考点3 字符集"></a>考点3 字符集</h1><p>在Java语言中,下列关于字符集编码(Character set encoding)和国际化(i18n)的问题,哪些是正确的？</p>
<ul>
<li>A 每个中文字符占用2个字节,每个英文字符占用1个字节</li>
<li>B 假设数据库中的字符是以<code>GBK</code>编码的,那么显示数据库数据的网页也必须是<code>GBK</code>编码的。</li>
<li>C <code>Java</code>的<code>char</code>类型,通常以<code>UTF-16 Big Endian</code>的方式保存一个字符。</li>
<li>D 实现国际化应用常用的手段是利用<code>ResourceBundle</code>类</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: CD</details>

<p>A 显然是错误的，Java一律采用Unicode编码方式，每个字符无论中文还是英文字符都占用2个字节。<br>B 也是不正确的，不同的编码之间是可以转换的，通常流程如下：<br>将字符串S以其自身编码方式分解为字节数组，再将字节数组以你想要输出的编码方式重新编码为字符串。<br>例：String newUTF8Str &#x3D; new<br>String(oldGBKStr.getBytes(“GBK”), “UTF8”);<br>C 是正确的。Java虚拟机中通常使用UTF-16的方式保存一个字符<br>D 也是正确的。ResourceBundle能够依据Local的不同，选择性的读取与Local对应后缀的properties文件，以达到国际化的目的。<br>综上所述，答案是 C 和 D。</p>
<h1 id="考点4-EJB"><a href="#考点4-EJB" class="headerlink" title="考点4 EJB"></a>考点4 EJB</h1><p>下列说法正确的是()</p>
<ul>
<li>A <code>WebLogic</code>中开发消息<code>Bean</code>的<code>non</code>－<code>persistent</code> 方式可以保证消息的可靠</li>
<li>B <code>EJB</code>容器发生错误,<code>non-persistent</code>方式下<code>JMS</code>容器仍然会将消息发送</li>
<li>C <code>EJB</code>容器发生错误,<code>persistent</code>方式下<code>JMS</code>容器仍然会将消息发送</li>
<li>D <code>EJB</code>容器发生错误,两种方式下<code>JMS</code>容器仍会在<code>MDB</code>可用的时候将消息发送</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>weblogic中开发消息Bean时的persistent与non-persisten的差别：<br>persistent方式的MDB可以保证消息传递的可靠性,也就是如果EJB容器出现问题而JMS服务器依然会将消息在此MDB可用的时候发送过来。<br>non-persistent方式的消息将被丢弃。</p>
<h1 id="考点5-中间件"><a href="#考点5-中间件" class="headerlink" title="考点5 中间件"></a>考点5 中间件</h1><p>关于中间件特点的描述.不正确的是()</p>
<ul>
<li>A 中间件运行于客户机&#x2F;服务器的操作系统内核中,提高内核运行效率</li>
<li>B 中间件应支持标准的协议和接口</li>
<li>C 中间件可运行于多种硬件和操作系统平台上</li>
<li>D 跨越网络,硬件,操作系统平台的应用或服务可通过中间件透明交互</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>中间件是一种独立的<strong>系统软件或服务程序</strong>，分布式应用软件借助这种软件在不同的技术之间共享资源。<br><strong>中间件位于</strong>客户机&#x2F;服务器的<strong>操作系统之上</strong>，<strong>应用软件之下</strong>，用来管理计算机资源和网络通讯。是连接两个独立应用程序或独立系统的软件。相连接的系统，即使它们具有不同的接口，但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是信息传递。通过中间件，应用程序可以工作于多平台或OS环境。</p>
<p>（简单来说，中间件并不能提高内核的效率，一般只是负责网络信息的分发处理）</p>
<p>中间件位于操作系统之上，应用软件之下，而不是操作系统内核中</p>
<h1 id="考点6-存根类-适配器模式"><a href="#考点6-存根类-适配器模式" class="headerlink" title="考点6 存根类 适配器模式"></a>考点6 存根类 适配器模式</h1><p>存根(Stub)与以下哪种技术有关</p>
<ul>
<li>A 交换</li>
<li>B 动态链接</li>
<li>C 动态加载</li>
<li>D 磁盘调度</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="什么是存根类"><a href="#什么是存根类" class="headerlink" title="什么是存根类"></a>什么是存根类</h3><p>存根类是一个类，它实现了一个接口，但是实现后的每个方法都是空的。 </p>
<h3 id="存根类的作用"><a href="#存根类的作用" class="headerlink" title="存根类的作用"></a>存根类的作用</h3><p>如果一个接口有很多方法，如果要实现这个接口，就要实现所有的方法。但是一个类从业务来说，可能只需要其中一两个方法。如果直接去实现这个接口，除了实现所需的方法，还要实现其他所有的无关方法。而如果通过继承存根类就实现接口，就免去了这种麻烦</p>
<h1 id="考点7-静态方法"><a href="#考点7-静态方法" class="headerlink" title="考点7 静态方法"></a>考点7 静态方法</h1><p>阅读如下代码。 请问,对语句行 test.hello(). 描述正确的有()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> NowCoder;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Test test=<span class="literal">null</span>;</span><br><span class="line">        test.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 能编译通过,并正确运行</li>
<li>B 因为使用了未初始化的变量,所以不能编译通过</li>
<li>C 以错误的方式访问了静态方法</li>
<li>D 能编译通过,但因变量为null,不能正常运行</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>类方法不依附与对象。所以可以正常运行</p>
<h1 id="考点8-lambda表达式"><a href="#考点8-lambda表达式" class="headerlink" title="考点8 lambda表达式"></a>考点8 lambda表达式</h1><p>下面哪些写法能在 java8 中编译执行()</p>
<ul>
<li>A <code>dir.listFiles((File f)-&gt;f.getName().endsWith(&quot;.Java&quot;));</code></li>
<li>B <code>dir.listFiles((File f)=&gt;f.getName().endsWith(&quot;.Java&quot;));</code></li>
<li>C <code>dir.listFiles((_.getName().endsWith(&quot;.Java&quot;)));</code></li>
<li>D <code>dir.listFiles( f-&gt;f.getName().endsWith(&quot;.Java&quot;));</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details>

<p>Lanbda表达式的主要作用就是代替匿名内部类的繁琐语法, 它由三部分组成:</p>
<ol>
<li>形参列表。<ul>
<li>形参列表<strong>允许省略形参类型</strong>。</li>
<li>如果形参列表中只有一个参数,甚至连<strong>形参列表的圆括号也可以省略</strong>。</li>
</ul>
</li>
<li>箭头(-&gt;)。必须通过英文减法符号和大于符号组成。</li>
<li>代码块。<ul>
<li>如果代码块只包含一条语句,Lambda表达式允许省略代码块的花括号,那么那条语句就不要用花括号表示语句结束。</li>
<li>Lambda代码块只有一条return语句,甚至可以省略return关键字。</li>
<li>Lambda表达式需要返回值,而它的代码块中仅有一条省略了return的语句。Lambda表达式会自动返回这条语句的值。</li>
</ul>
</li>
</ol>
<h1 id="考点9-Servlet过滤器"><a href="#考点9-Servlet过滤器" class="headerlink" title="考点9 Servlet过滤器"></a>考点9 Servlet过滤器</h1><p>在J2EE中,使用Servlet过滤器,需要在web.xml中配置()元素</p>
<ul>
<li>A <code>&lt;filter&gt;</code></li>
<li>B <code>&lt;filter-mapping&gt;</code></li>
<li>C <code>&lt;servlet-filter&gt;</code></li>
<li>D <code>&lt;filter-config&gt;</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AB</details>

<p>Servlet过滤器的配置包括两部分：<br>第一部分是过滤器在Web应用中的定义，由<filter>元素表示，包括<filter-name>和<filter-class>两个必需的子元素<br>第二部分是过滤器映射的定义，由<filter-mapping>元素表示,<br>有<filter-name>和<url-pattern>两个子元素<br>可以将一个过滤器映射到一个或者多个Servlet或JSP文件，也可以采用url-pattern将过滤器映射到任意特征的URL。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 字符编码过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>没有<servlet-filter>和<filter-config></p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年12月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年12月16日 java1</title>
    <url>/exam//1d7732bf/</url>
    <content><![CDATA[<h1 id="考点1-case穿透"><a href="#考点1-case穿透" class="headerlink" title="考点1 case穿透"></a>考点1 case穿透</h1><p>给定代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchTest</span>&#123;<span class="comment">//1</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;<span class="comment">//2</span></span><br><span class="line">		System.out.println(<span class="string">&quot;value=&quot;</span>+switchit(<span class="number">4</span>));<span class="comment">//3</span></span><br><span class="line">	&#125;<span class="comment">//4</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">switchit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">		<span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">switch</span> (x) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:j++;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:j++;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:j++;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:j++;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:j++;</span><br><span class="line">		<span class="keyword">default</span>:j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> j+x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三行将输出什么？</p>
<ul>
<li>A <code>value=6</code></li>
<li>B <code>value=8</code></li>
<li>C <code>value=3</code></li>
<li>D <code>value=5</code></li>
<li>E <code>value=4</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>


<h1 id="考点2-servlet内置对象"><a href="#考点2-servlet内置对象" class="headerlink" title="考点2 servlet内置对象"></a>考点2 servlet内置对象</h1><p>从以下哪一个选项中可以获得Servlet的初始化参数?</p>
<ul>
<li>A <code>Servlet</code></li>
<li>B <code>ServletContext</code></li>
<li>C <code>ServletConfig</code></li>
<li>D <code>GenericServlet</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>通过ServletConfig接口的getInitParameter(java.lang.String name)方法</p>
<h1 id="考点3-运算符优先级"><a href="#考点3-运算符优先级" class="headerlink" title="考点3 运算符优先级"></a>考点3 运算符优先级</h1><p>下面的程序将来打印什么?()<br>public class TestIncr {<br>    public static void main(String args[]) {<br>        int i &#x3D; 0;<br>        i &#x3D; i++ + i;<br>        System.out.println(“I &#x3D;” +i);<br>    }<br>}</p>
<ul>
<li>A <code>I = 1</code></li>
<li>B <code>I = 2</code></li>
<li>C <code>I = 3</code></li>
<li>D 编译出错</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<h1 id="考点4-持久区jvm堆内存溢出"><a href="#考点4-持久区jvm堆内存溢出" class="headerlink" title="考点4 持久区jvm堆内存溢出"></a>考点4 持久区jvm堆内存溢出</h1><p>下面哪种情况会导致持久区jvm堆内存溢出？</p>
<ul>
<li>A 循环上万次的字符串处理</li>
<li>B 在一段代码内申请上百M甚至上G的内存</li>
<li>C 使用<code>CGLib</code>技术直接操作字节码运行,生成大量的动态类</li>
<li>D 不断创建对象</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p><a href="http://blog.csdn.net/sivyer123/article/details/17139443">http://blog.csdn.net/sivyer123/article/details/17139443</a></p>
<h1 id="考点5-CMS垃圾回收器"><a href="#考点5-CMS垃圾回收器" class="headerlink" title="考点5 CMS垃圾回收器"></a>考点5 CMS垃圾回收器</h1><p>CMS垃圾回收器在那些阶段是没用用户线程参与的</p>
<ul>
<li>A 初始标记</li>
<li>B 并发标记</li>
<li>C 重新标记</li>
<li>D 并发清理</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>


<h1 id="考点6-序列化"><a href="#考点6-序列化" class="headerlink" title="考点6 序列化"></a>考点6 序列化</h1><p>transient 变量和下面哪一项有关？   </p>
<ul>
<li>A <code>Cloneable</code></li>
<li>B <code>Serializable</code></li>
<li>C <code>Runnable</code></li>
<li>D <code>Comparable</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>


<h1 id="考点7-网络编程"><a href="#考点7-网络编程" class="headerlink" title="考点7 网络编程"></a>考点7 网络编程</h1><p>关于 Socket 通信编程,以下描述错误的是:( )</p>
<ul>
<li>A 服务器端通过<code>new ServerSocket()</code>创建<code>TCP</code>连接对象</li>
<li>B 服务器端通过<code>TCP</code>连接对象调用<code>accept()</code>方法创建通信的<code>Socket</code>对象</li>
<li>C 客户端通过<code>new Socket()</code>方法创建通信的<code>Socket</code>对象</li>
<li>D 客户端通过<code>new ServerSocket()</code>创建<code>TCP</code>连接对象</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<h1 id="考点8-HashMap"><a href="#考点8-HashMap" class="headerlink" title="考点8 HashMap"></a>考点8 HashMap</h1><p>下面有关java hashmap的说法错误的是？</p>
<ul>
<li>A <code>HashMap</code> 的实例有两个参数影响其性能:”初始容量” 和 “加载因子”。</li>
<li>B <code>HashMap</code> 的实现不是同步的,意味着它不是线程安全的</li>
<li>C <code>HashMap</code>通过开放地址法解决哈希冲突</li>
<li>D <code>HashMap</code>中的<code>key-value</code>都是存储在<code>Entry</code>数组中的</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>解决冲突主要有三种方法：定址法，拉链法，再散列法。HashMap是采用拉链法解决哈希冲突的。 注：<br>链表法是将相同hash值的对象组成一个链表放在hash值对应的槽位；<br>   用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。<br>沿此序列逐个单元地查找，直到找到给定<br>的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。<br>  拉链法解决冲突的做法是： 将所有关键字为同义词的结点链接在同一个单链表中<br>。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数<br>组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。拉链法适合未规定元素的大小。</p>
<h1 id="考点9-补码运算"><a href="#考点9-补码运算" class="headerlink" title="考点9 补码运算"></a>考点9 补码运算</h1><p>变量a是一个64位有符号的整数,初始值用16进制表示为:0Xf000000000000000; 变量b是一个64位有符号的整数,初始值用16进制表示为:0x7FFFFFFFFFFFFFFF。 则a-b的结果用10进制表示为多少？()</p>
<ul>
<li>A 1</li>
<li>B -(2^62+2^61+2^60+1)</li>
<li>C 2^62+2^61+2^60+1</li>
<li>D 2^59+(2^55+2^54+…+2^2+2^1+2^0)</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h1 id="考点10-反射机制"><a href="#考点10-反射机制" class="headerlink" title="考点10 反射机制"></a>考点10 反射机制</h1><p>Java是一门支持反射的语言,基于反射为Java提供了丰富的动态性支持,下面关于Java反射的描述,哪些是错误的:(    )</p>
<ul>
<li>A <code>Java</code>反射主要涉及的类如<code>Class, Method, Filed</code>,等,他们都在<code>java.lang.reflet</code>包下</li>
<li>B 通过反射可以动态的实现一个接口,形成一个新的类,并可以用这个类创建对象,调用对象方法</li>
<li>C 通过反射,可以突破<code>Java</code>语言提供的对象成员、类成员的保护机制,访问一般方式不能访问的成员</li>
<li>D <code>Java</code>反射机制提供了字节码修改的技术,可以动态的修剪一个类</li>
<li>E <code>Java</code>的反射机制会给内存带来额外的开销。例如对永生堆的要求比不通过反射要求的更多</li>
<li>F <code>Java</code>反射机制一般会带来效率问题,效率问题主要发生在查找类的方法和字段对象,因此通过缓存需要反射类的字段和方法就能达到与之间调用类的方法和访问类的字段一样的效率</li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ADF</details>

<ul>
<li>A选项错误，类Class在java.lang包下，类Method、Filed在java.lang.reflet包下。</li>
<li>D选项错误，反射的本质就是从字节码中查找，动态获取类的整容结构，包括属性，构造器，动态调用对象的方法，而<strong>不是修剪类</strong>，</li>
<li>F选项错误，使用了<strong>反射的效率都会降低</strong>，就算加了缓存</li>
</ul>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年12月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年12月17日 java1</title>
    <url>/exam//c8b56ff4/</url>
    <content><![CDATA[<h1 id="考点1-JSP内置对象"><a href="#考点1-JSP内置对象" class="headerlink" title="考点1 JSP内置对象"></a>考点1 JSP内置对象</h1><p>下面有关JSP内置对象的描述,说法错误的是？</p>
<ul>
<li>A <code>session</code>对象:<code>session</code>对象指的是客户端与服务器的一次会话,从客户连到服务器的一个<code>WebApplication</code>开始,直到客户端与服务器断开连接为止</li>
<li>B <code>request</code>对象:客户端的请求信息被封装在<code>request</code>对象中,通过它才能了解到客户的需求,然后做出响应</li>
<li>C <code>application</code>对象:多个<code>application</code>对象实现了用户间数据的共享,可存放全局变量</li>
<li>D <code>response</code>对象:<code>response</code>对象包含了响应客户请求的有关信息</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>application对象是共享的，多个用户共享一个，以此实现数据共享和通信<br>JSP内置对象和属性列举如下：<br>1.request对象<br>客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。<br>2.response对象<br>response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>3.session对象<br>session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.<br>4.out对象<br>out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>5.page对象<br>page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例<br>6.application对象<br>application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。<br>7.exception对象<br>exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象<br>8.pageContext对象<br>pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。<br>9.config对象<br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p>
<h1 id="考点2-集合-异常-接口-继承"><a href="#考点2-集合-异常-接口-继承" class="headerlink" title="考点2 集合 异常 接口 继承"></a>考点2 集合 异常 接口 继承</h1><p>下面叙述那个是正确的？()</p>
<ul>
<li>A <code>java</code>中的集合类(如<code>Vector</code>)可以用来存储任何类型的对象,且大小可以自动调整。但需要事先知道所存储对象的类型,才能正常使用。</li>
<li>B 在<code>java</code>中,我们可以用违例(<code>Exception</code>)来抛出一些并非错误的消息,但这样比直接从函数返回一个结果要更大的系统开销。</li>
<li>C <code>java</code>接口包含函数声明和变量声明。</li>
<li>D <code>java</code>中,子类不可以访问父类的私有成员和受保护的成员。</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="创建对象比方法调用内存开销大"><a href="#创建对象比方法调用内存开销大" class="headerlink" title="创建对象比方法调用内存开销大"></a>创建对象比方法调用内存开销大</h3><p>B选项说的情况就是我们自定义异常的情况，因为函数调用是入栈出栈，栈是在寄存器之下的速度最快，且占的空间少，而自定义异常是存在堆中，肯定异常的内存开销大！所以B对。</p>
<h3 id="接口中只有常量定义-没有变量声明"><a href="#接口中只有常量定义-没有变量声明" class="headerlink" title="接口中只有常量定义 没有变量声明"></a>接口中只有常量定义 没有变量声明</h3><p>C选项说的是接口包含方法声明和变量声明。因为接口中方法默认是<br>abstract public,所以在接口只写函数声明是符合语法规则。但是变量默认是用public<br>final static 修饰的，意思它是<strong>静态常量</strong>，常量不管在接口中还是类中必须在声明时初始化！所以C的后半句是错的，必须在声明时并给出初始化！</p>
<h1 id="考点3-静态成员和普通成员的执行顺序"><a href="#考点3-静态成员和普通成员的执行顺序" class="headerlink" title="考点3 静态成员和普通成员的执行顺序"></a>考点3 静态成员和普通成员的执行顺序</h1><p>以下代码的输出结果是？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">B</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">B</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 静态块 构造块 构造块 构造块</li>
<li>B 构造块 静态块 构造块 构造块</li>
<li>C 构造块 构造块 静态块 构造块</li>
<li>D 构造块 构造块 构造块 静态块</li>
</ul>
<h2 id="解析-多个静态成员按顺序执行"><a href="#解析-多个静态成员按顺序执行" class="headerlink" title="解析 多个静态成员按顺序执行"></a>解析 多个静态成员按顺序执行</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年12月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年12月23日 java1</title>
    <url>/exam//58bca98f/</url>
    <content><![CDATA[<h1 id="考点1-java集合旧类和新类的区别"><a href="#考点1-java集合旧类和新类的区别" class="headerlink" title="考点1 java集合旧类和新类的区别"></a>考点1 java集合旧类和新类的区别</h1><p>ArrayList和Vector主要区别是什么？</p>
<ul>
<li>A <code>Vector</code>与<code>ArrayList</code>一样,也是通过数组实现的,不同的是<code>Vector</code>支持线程的同步</li>
<li>B <code>Vector</code>与<code>ArrayList</code>一样,也是通过数组实现的,不同的是<code>ArrayList</code>支持线程的同步</li>
<li>C <code>Vector</code>是通过链表结构存储数据,<code>ArrayList</code>是通过数组存储数据</li>
<li>D 上述说法都不正确</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h3 id="Vector与ArrayList的主要区别"><a href="#Vector与ArrayList的主要区别" class="headerlink" title="Vector与ArrayList的主要区别"></a>Vector与ArrayList的主要区别</h3><ul>
<li><p>同步性:</p>
<ul>
<li>Vector是线程安全的，也就是说是同步的而</li>
<li>ArrayList是线程序不安全的，不是同步的。</li>
</ul>
</li>
<li><p>数据增长:当需要增长时,</p>
<ul>
<li>Vector默认增长为原来<strong>一倍</strong>。</li>
<li>而ArrayList却是原来的<strong>50%</strong>,这样,ArrayList就有利于节约内存空间。</li>
</ul>
</li>
<li><p>如果涉及到堆栈，队列等操作，应该考虑用Vector，</p>
</li>
<li><p>如果需要快速随机访问元素，应该使用ArrayList 。</p>
</li>
</ul>
<h3 id="Hashtable与HashMap"><a href="#Hashtable与HashMap" class="headerlink" title="Hashtable与HashMap"></a>Hashtable与HashMap</h3><p>Hashtable和HashMap它们的性能方面的比较类似<br>Vector和ArrayList，比如Hashtable的方法是同步的,而HashMap的不是。</p>
<h3 id="ArrayList与LinkedList"><a href="#ArrayList与LinkedList" class="headerlink" title="ArrayList与LinkedList"></a>ArrayList与LinkedList</h3><p>ArrayList的内部实现是基于内部数组Object[],所以从概念上讲,它更象数组，<br>但LinkedList的内部实现是基于一组连接的记录，所以，它更象一个链表结构，所以，它们在性能上有很大的差别：<br>在ArrayList的前面或中间插入数据时,你必须将其后的所有数据相应的后移,这样必然要花费较多时间，所以,当你的操作是在一列数据的后面添加数据而不是在前面或中间,<br>需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能；<br>而访问链表中的某个元素时,就必须从链表的一端开始沿着连接方向一个一个元素地去查找,直到找到所需的元素为止，所以,当你的操作是在一列数据的前面或中间添加或删除数据，并且按照顺序访问其中的元素时，就应该使用LinkedList了。</p>
<h1 id="考点2-java包装类-数据转换"><a href="#考点2-java包装类-数据转换" class="headerlink" title="考点2 java包装类 数据转换"></a>考点2 java包装类 数据转换</h1><p>关于Float,下列说法错误的是()</p>
<ul>
<li>A <code>Float</code>是一个类</li>
<li>B <code>Float</code>在<code>java.lang</code>包中</li>
<li>C <code>Float a=1.0</code>是正确的赋值方法</li>
<li>D <code>Float a= new Float(1.0)</code>是正确的赋值方法</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<ul>
<li>Float是类，float不是类.</li>
<li>查看JDK源码就可以发现Byte，Character，Short，Integer，Long，Float，Double，Boolean都在java.lang包中.</li>
<li>Float正确复制方式是Float f&#x3D;1.0f,若不加f会被识别成double型,double无法向float隐式转换.</li>
<li>Float a&#x3D; new Float(1.0)是正确的赋值方法，但是在1.5及以上版本引入自动装箱拆箱后，会提示这是不必要的装箱的警告，通常直接使用Float f&#x3D;1.0f.</li>
</ul>
<h1 id="考点4-java短路逻辑运算符"><a href="#考点4-java短路逻辑运算符" class="headerlink" title="考点4 java短路逻辑运算符"></a>考点4 java短路逻辑运算符</h1><p>根据下面的代码,<br>String s &#x3D; null;<br>会抛出NullPointerException异常的有()。</p>
<ul>
<li>A if( (s!&#x3D;null) &amp; (s.length()&gt;0) )</li>
<li>B if( (s!&#x3D;null) &amp;&amp; (s.length()&gt;0) )</li>
<li>C if( (s&#x3D;&#x3D;null) | (s.length()&#x3D;&#x3D;0) )</li>
<li>D if( (s&#x3D;&#x3D;null) || (s.length()&#x3D;&#x3D;0) )</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

<ul>
<li>逻辑运算符：&amp;&amp;和|| 是按照“短路”方式求值的。如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了</li>
<li>位移运算符：&amp;和| 运算符应用于布尔值，得到的结果也是布尔值，不按“短路”方式计算。即在得到计算结果之前，一定要计算两个操作数的值。</li>
</ul>
<h1 id="考点5-javaEE-JSP生命周期"><a href="#考点5-javaEE-JSP生命周期" class="headerlink" title="考点5 javaEE JSP生命周期"></a>考点5 javaEE JSP生命周期</h1><p>关于JSP生命周期的叙述,下列哪些为真?</p>
<ul>
<li>A <code>JSP</code>会先解释成<code>Servlet</code>源文件,然后编译成<code>Servlet</code>类文件</li>
<li>B 每当用户端运行<code>JSP</code>时,<code>jsp init()</code>方法都会运行一次</li>
<li>C 每当用户端运行<code>JSP</code>时,<code>jsp service()</code>方法都会运行一次</li>
<li>D 每当用户端运行<code>JSP</code>时,<code>jsp destroy()</code>方法都会运行一次</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

<p>B:init方法:负责初始化Servlet对象。在Servlet的整个生命周期类,init()方法只被调用一次。<br>D:destroy方法:销毁Servlet对象,释放占用的资源,Servlet要被卸载时调用</p>
<h1 id="考点6-常用的final类"><a href="#考点6-常用的final类" class="headerlink" title="考点6 常用的final类"></a>考点6 常用的final类</h1><p>以下类型为Final类型的为()</p>
<ul>
<li>A <code>HashMap</code></li>
<li>B <code>StringBuffer</code></li>
<li>C <code>String</code></li>
<li>D <code>Hashtable</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<p>StringBuilder , StringBuffer ,String 都是 final 的</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年12月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年12月24日 java1</title>
    <url>/exam//ba60b2f6/</url>
    <content><![CDATA[<h1 id="考点1-java数组声明"><a href="#考点1-java数组声明" class="headerlink" title="考点1 java数组声明"></a>考点1 java数组声明</h1><p>以下二维数组声明合法的是( )</p>
<ul>
<li>A <code>char[2][3] ch = new char[][]</code></li>
<li>B <code>char[2][] ch = new char[][3]</code></li>
<li>C <code>char[][] ch = new char[2][3]</code></li>
<li>D <code>char[][] ch = new [2]char[3]</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>定义数组，等号左边不能出现数字，也就是数组的不管什么大小   不能出现在左边</p>
<h1 id="考点2-java类加载器"><a href="#考点2-java类加载器" class="headerlink" title="考点2 java类加载器"></a>考点2 java类加载器</h1><p>下面有关java classloader说法错误的是?</p>
<ul>
<li>A <code>Java</code>默认提供的三个<code>ClassLoader</code>是<code>BootStrap ClassLoader,Extension ClassLoader,App ClassLoader</code></li>
<li>B <code>ClassLoader</code>使用的是双亲委托模型来搜索类的</li>
<li>C <code>JVM</code>在判定两个<code>class</code>是否相同时,只用判断类名相同即可,和类加载器无关</li>
<li>D <code>ClassLoader</code>就是用来动态加载<code>class</code>文件到内存当中用的</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h1 id="考点3-java抽象类方法默认访问权限"><a href="#考点3-java抽象类方法默认访问权限" class="headerlink" title="考点3 java抽象类方法默认访问权限"></a>考点3 java抽象类方法默认访问权限</h1><p>抽象类方法的访问权限默认都是public。(  )</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>JDK 1.8以前，抽象类的方法默认访问权限为protected<br>JDK 1.8时，抽象类的方法默认访问权限变为default<br>JDK 1.8以前，接口中的方法必须是public的<br>JDK 1.8时，接口中的方法可以是public的，也可以是default的<br>JDK 1.9时，接口中的方法可以是private的</p>
<h1 id="考点4-排序算法复杂度"><a href="#考点4-排序算法复杂度" class="headerlink" title="考点4 排序算法复杂度"></a>考点4 排序算法复杂度</h1><p>在各自最优条件下,对N个数进行排序,哪个算法复杂度最低的是? ()</p>
<ul>
<li>A 插入排序</li>
<li>B 快速排序</li>
<li>C 堆排序</li>
<li>D 归并排序</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>插入排序：最佳O（N）<br>快速排序：最佳O（NlogN）<br>堆    排序：最佳O（NlogN）<br>归并排序：最佳O（NlogN）<br>因此选择插入排序。<br><img data-src="https://uploadfiles.nowcoder.com/images/20190727/5227440_1564208997208_C0C78CE31C2575E39A0EE7AE31E20FB8" alt="排序算法复杂度"></p>
<h1 id="考点5-类的修饰符"><a href="#考点5-类的修饰符" class="headerlink" title="考点5 类的修饰符"></a>考点5 类的修饰符</h1><p>若需要定义一个类,下列哪些修饰符是允许被使用的？( )</p>
<ul>
<li>A <code>static</code></li>
<li>B <code>package</code></li>
<li>C <code>private</code></li>
<li>D <code>public</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details>

<p>普通类(外部类):只能用<code>public</code>、<code>default</code>(不写)、<code>abstract</code>、<code>final</code>修饰。<br>(成员)内部类:可理解为外部类的成员,所以修饰类成员的<code>public</code>、<code>protected</code>、<code>default</code>、<code>private</code>、<code>static</code>等关键字都能使用。<br>局部内部类:出现在方法里的类,不能用上述关键词来修饰。<br>匿名内部类:给的是直接实现,类名都没有,没有修饰符。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年12月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年12月25日 java1</title>
    <url>/exam//55a2d9c8/</url>
    <content><![CDATA[<h1 id="考点1-表达式运算"><a href="#考点1-表达式运算" class="headerlink" title="考点1 表达式运算"></a>考点1 表达式运算</h1><p>如果定义一种表达式结构:(+ 6 3)的值为9,(- 6 3)的值为3,(* 6 3)的值为18,(&#x2F; 6 3)的值为2;那么对于表达式(* (- 16 (* 3 2 2 )) (+ 5 (&#x2F; 6 (- 5 3))))输出的结果为____。</p>
<ul>
<li>A 44</li>
<li>B 40</li>
<li>C 40</li>
<li>D 32</li>
<li>E 24</li>
<li>F 21</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<h1 id="考点2-java集合List常用方法"><a href="#考点2-java集合List常用方法" class="headerlink" title="考点2 java集合List常用方法"></a>考点2 java集合List常用方法</h1><p>如果一个list初始化为{5,3,1},执行以下代码后,其结果为()？<br>nums.add(6);<br>nums.add(0,4);<br>nums.remove(1);</p>
<ul>
<li>A [5, 3, 1, 6]</li>
<li>B [4, 3, 1, 6]</li>
<li>C [4, 3, 6]</li>
<li>D [5, 3, 6]</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>boolean add(E e)</code></td>
<td align="left">将指定的元素追加到此列表的<strong>末尾</strong>(可选操作)。</td>
</tr>
<tr>
<td align="left"><code>void add(int index, E element)</code></td>
<td align="left">将指定的元素插入此列表中的index指定位置(可选操作)。</td>
</tr>
<tr>
<td align="left"><code>E remove(int index)</code></td>
<td align="left">删除该列表中指定位置的元素(可选操作)。</td>
</tr>
</tbody></table>
<h1 id="考点3-java位运算-按位与"><a href="#考点3-java位运算-按位与" class="headerlink" title="考点3 java位运算 按位与"></a>考点3 java位运算 按位与</h1><p>Java表达式”13 &amp; 17”的结果是什么?()</p>
<ul>
<li>A 30</li>
<li>B 13</li>
<li>C 17</li>
<li>D 1</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>&amp;运算符：两个数都转为二进制，然后从两个数的最高位进行与运算，两个都为真（1），结果才为真（1），否则为假（0）</p>
<table>
<thead>
<tr>
<th align="left">十进制</th>
<th align="left">二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="left">13</td>
<td align="left">01101</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left">10001</td>
</tr>
<tr>
<td align="left">按位与结果:1</td>
<td align="left">00001</td>
</tr>
</tbody></table>
<h1 id="考点4-计算机网络-远程方法调用"><a href="#考点4-计算机网络-远程方法调用" class="headerlink" title="考点4 计算机网络 远程方法调用"></a>考点4 计算机网络 远程方法调用</h1><p>默认RMI采用的是什么通信协议？</p>
<ul>
<li>A <code>HTTP</code></li>
<li>B <code>UDP/IP</code></li>
<li>C <code>TCP/IP</code></li>
<li>D <code>Multicast</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p><code>RMI(Remote MethodInvocation)</code>远程方法调用是一种计算机之间利用远程对象互相调用实现双方通讯的一种通讯机制。使用这种机制，某一台计算机上的对象可以调用另外一台计算机上的对象来获取远程数据。<code>RMI</code>是<code>EnterpriseJavaBeans</code>的支柱，是建立分布式<code>Java</code>应用程序的方便途径。在过去，<code>TCP/IP</code>套接字通讯是远程通讯的主要手段，但此开发方式没有使用面向对象的方式实现开发，在开发一个如此的通讯机制时往往令程序员感觉到乏味，对此<code>RPC(RemoteProcedureCall</code>）应运而生，它使程序员更容易地调用远程程序，但在面对复杂的信息传讯时，<code>RPC</code>依然未能很好的支持，而且<code>RPC</code>未能做到面向对象调用的开发模式。针对<code>RPC</code>服务遗留的问题，<code>RMI</code>出现在世人面前，它被设计成一种面向对象的通讯方式，允许程序员使用远程对象来实现通信，并且支持多线程的服务，这是一次远程通讯的***，为远程通信开辟新的里程碑。<code>RMI</code>的开发步骤先创建远程接口及声明远程方法，注意这是实现双方通讯的接口，需要继承<code>Remote</code>开发一个类来实现远程接口及远程方法，值得注意的是实现类需要继承<code>UnicastRemoteObject</code>通过<code>javac</code>命令编译文件，通过<code>java -server</code> 命令注册服务，启动远程对象最后客户端查找远程对象，并调用远程方法所以选C</p>
<h1 id="考点5-java垃圾收集器的区别"><a href="#考点5-java垃圾收集器的区别" class="headerlink" title="考点5 java垃圾收集器的区别"></a>考点5 java垃圾收集器的区别</h1><p>下列哪项不属于jdk1.6垃圾收集器？</p>
<ul>
<li>A <code>Serial</code>收集器</li>
<li>B <code>parNew</code>收集器</li>
<li>C <code>CMS</code>收集器</li>
<li>D <code>G1</code>收集器</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p><img data-src="https://uploadfiles.nowcoder.com/images/20170223/6741161_1487851243302_B9F7B4500368A60BFE23DC6CC3C3F153"></p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年12月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年12月30日 java1</title>
    <url>/exam//7205cd4c/</url>
    <content><![CDATA[<h1 id="考点1-JSP内置session对象"><a href="#考点1-JSP内置session对象" class="headerlink" title="考点1 JSP内置session对象"></a>考点1 JSP内置session对象</h1><p>要在session对象中保存属性,可以使用以下哪个语句(      )</p>
<ul>
<li>A <code>session.getAttribute(&quot;key&quot;,&quot;value&quot;)</code></li>
<li>B <code>session.setAttribute(&quot;key&quot;,&quot;value&quot;)</code></li>
<li>C <code>session.setAttribute(&quot;key&quot;)</code></li>
<li>D <code>session.getAttribute(&quot;key&quot;)</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>session.setAttribute()和session.getAttribute()配对使用，作用域是整个会话期间，在所有的页面都使用这些数据的时候使用。<br>设置<br>session.getAttribute(“key”,”value”)<br>获取<br>session.getAttribute(“key”)<br>移除<br>session.removeAttribute(“key”)</p>
<p>request.getAttribute()表示从request范围取得设置的属性，必须要先setAttribute设置属性，才能通过getAttribute来取得，设置与取得的为Object对象类型。其实表单控件中的Object的 name与value是存放在一个哈希表中的，所以在这里给出Object的name会到哈希表中找出对应它的value。setAttribute()的参数是String和Object。</p>
<h1 id="考点2-表达式运算"><a href="#考点2-表达式运算" class="headerlink" title="考点2 表达式运算"></a>考点2 表达式运算</h1><p>如果定义一种表达式结构:(+ 6 3)的值为9,(- 6 3)的值为3,(* 6 3)的值为18,(&#x2F; 6 3)的值为2;那么对于表达式(* (- 16 (* 3 2 2 )) (+ 5 (&#x2F; 6 (- 5 3))))输出的结果为____。</p>
<ul>
<li>A 44</li>
<li>B 40</li>
<li>C 40</li>
<li>D 32</li>
<li>E 24</li>
<li>F 21</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>从括号最多的地方开始算</p>
<h1 id="考点3-短路或"><a href="#考点3-短路或" class="headerlink" title="考点3 短路或"></a>考点3 短路或</h1><p>如下语句通过算术运算和逻辑运算之后i和 j的结果是( )<br>int i&#x3D;0;<br>int j&#x3D;0;<br>if((++i&gt;0)||(++j&gt;0))<br>{<br>&#x2F;&#x2F;打印出i和j的值。<br>}</p>
<ul>
<li>A i&#x3D;0;j&#x3D;0</li>
<li>B i&#x3D;1;j&#x3D;1</li>
<li>C i&#x3D;0;j&#x3D;1</li>
<li>D i&#x3D;1;j&#x3D;0</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>在运行时,由java解释器自动引入,而不用import语句引入的包是()。</p>
<ul>
<li>A <code>java.lang</code></li>
<li>B <code>java.system</code></li>
<li>C <code>java.io</code></li>
<li>D <code>java.util</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>java.lang包是java语言的核心包，lang是language的缩写<br>java.lang包定义了一些基本的类型，包括Integer,String之类的，是java程序必备的包，有解释器自动引入，无需手动导入</p>
<h1 id="考点5-线程安全的操作"><a href="#考点5-线程安全的操作" class="headerlink" title="考点5 线程安全的操作"></a>考点5 线程安全的操作</h1><p>以下多线程对int型变量x的操作,哪个不需要进行同步()</p>
<ul>
<li>A ++x</li>
<li>B x&#x3D;y</li>
<li>C x++</li>
<li>D x&#x3D;1</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>原子操作:只进行一次的操作。</p>
<p>前三个都至少需要<strong>先读取</strong>，<strong>再操作</strong>，是非原子操作<br>x++,需要先读取x的值，然后加一，然后再写入x<br>++x,同理<br>x&#x3D;y，需要先读取y的值，然后写入x<br>D选项:<br>x&#x3D;1,1是直接量，不许需要读取，直接写入即可<br>直接赋值只需要一次写入操作即可完成</p>
<h1 id="考点6-逻辑运算符短路或"><a href="#考点6-逻辑运算符短路或" class="headerlink" title="考点6 逻辑运算符短路或"></a>考点6 逻辑运算符短路或</h1><p>Given the following code:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Boolean <span class="title function_">methodB</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        j += k;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> b;</span><br><span class="line">        b = i &lt; <span class="number">10</span> | methodB(<span class="number">4</span>);</span><br><span class="line">        b = i &lt; <span class="number">10</span> || methodB(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        methodA(<span class="number">0</span>);</span><br><span class="line">        System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>What is the result?</p>
<ul>
<li>A The program prints”0”</li>
<li>B The program prints”4”</li>
<li>C The program prints”8”</li>
<li>D The program prints”12”</li>
<li>E The code does not complete.</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>


<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>关于对象成员占用内存的说法哪个正确？( )</p>
<ul>
<li>A 同一个类的对象共用同一段内存</li>
<li>B 同一个类的对象使用不同的内存段,但静态成员共享相同的内存空间</li>
<li>C 对象的方法不占用内存</li>
<li>D 以上都不对</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p><img data-src="https://uploadfiles.nowcoder.com/images/20170928/6947119_1506597426551_C616C50E6EC7C120A5C060F65822D6FA" alt="java成员内存"></p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年12月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年12月8日 java2</title>
    <url>/exam//1deb972e/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>假设一个 list初始化为{2,9,5,4,8,1}。 在第一次冒泡排序后,list变成了()?</p>
<ul>
<li>A 2, 9, 5, 4, 8, 1</li>
<li>B 2, 9, 5, 4, 1, 8</li>
<li>C 2, 5, 9, 4, 8, 1</li>
<li>D 2, 5, 4, 8, 1, 9</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>冒泡排序：将最大值放到末尾，一直缩小范围到第一位<br>第一次排序后最大的数,转移到数组最后</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>要求匹配以下16进制颜色值，正则表达式可以为：  #ffbbad  #Fc01DF  #FFF  #ffE</p>
<ul>
<li>A &#x2F;#([0-9a-f]{6}|[0-9a-fA-F]{3})&#x2F;g</li>
<li>B &#x2F;#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})&#x2F;g</li>
<li>C &#x2F;#([0-9a-fA-F]{3}|[0-9a-f]{6})&#x2F;g</li>
<li>D &#x2F;#([0-9A-F]{3}|[0-9a-fA-F]{6})&#x2F;g</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>


<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>对于如下代码段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> A <span class="title function_">foo</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="built_in">this</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> A <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    _______</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以放入到横线位置,使程序正确编译运行,而且不产生错误的选项是( )</p>
<ul>
<li>A <code>public void foo()</code>{}</li>
<li>B <code>public int foo()</code>{<code>return 1;</code>}</li>
<li>C <code>public A foo(B b)</code>{<code>return b;</code>}</li>
<li>D <code>public A foo()</code>{<code>return A;</code>}</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h3 id="重写-要求"><a href="#重写-要求" class="headerlink" title="重写 要求"></a>重写 要求</h3><p>两同两小一大原则， </p>
<ul>
<li>方法名相同，</li>
<li>参数列表相同，</li>
<li>子类返回类型小于等于父类方法返回类型， </li>
<li>子类抛出异常小于等于父类方法抛出异常， </li>
<li>子类访问权限大于等于父类方法访问权限。</li>
</ul>
<p>［注意：这里的返回类型必须要在有继承关系的前提下比较］</p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>两同一不同</p>
<ul>
<li>同一个类中</li>
<li>方法名必须相同，</li>
<li>参数类型必须不同，</li>
</ul>
<p>再来说说这道题 A B 都是方法名和参数相同，是重写，但是<strong>返回类型没与父类返回类型有继承关系</strong>，</p>
<p>D语法错误，要返回一个对象，不能返回一个类</p>
<p>c的参数类型与父类不同，所以不是重写，可以理解为广义上的重载访问权限小于父类，都会显示错误</p>
<p>虽然题目没点明一定要重载或者重写，但是<strong>当你的方法名与参数类型与父类相同时，已经是重写了</strong>，这时候如果返回类型或者异常类型比父类大，或者访问权限比父类小都会编译错误</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>URL u &#x3D;new URL(“<a href="http://www.123.com&quot;);.如果www.123.com不存在,则返回______./">http://www.123.com&quot;);。如果www.123.com不存在,则返回______。</a></p>
<ul>
<li>A <code>http://www.123.com</code></li>
<li>B “”</li>
<li>C <code>null</code></li>
<li>D 抛出异常</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>new URL()时必须捕获检查异常，但这个异常是由于字符串格式和URL不符导致的，与网址是否存在无关。URL的toString方法返回字符串，无论网址是否存在<br>有空了解一下</p>
<h1 id="考点5-考点-子类构造器调用父类构造器-已提供构造器则系统不提供默认无参构造器"><a href="#考点5-考点-子类构造器调用父类构造器-已提供构造器则系统不提供默认无参构造器" class="headerlink" title="考点5 考点:子类构造器调用父类构造器 已提供构造器则系统不提供默认无参构造器"></a>考点5 考点:子类构造器调用父类构造器 已提供构造器则系统不提供默认无参构造器</h1><p>以下程序的输出结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Derived</span> <span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Derived</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A <code>BD</code></li>
<li>B <code>DB</code></li>
<li>C C</li>
<li>D 编译错误</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>子类构造方法在调用时必须先调用父类的构造器，由于父类没有无参构造构造器，必须在子类中显式调用，修改子类构造方法如下即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Derived</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;s&quot;</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>以下哪些jvm的垃圾回收方式采用的是复制算法回收</p>
<ul>
<li>A 新生代串行收集器</li>
<li>B 老年代串行收集器</li>
<li>C 并行收集器</li>
<li>D 新生代并行回收收集器</li>
<li>E 老年代并行回收收集器</li>
<li>F <code>cms</code>收集器</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details>

<p>有空了解一下<br>两个最基本的java回收算法：复制算法和标记清理算法<br>复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法<br>标记清理：一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出<br>标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象<br>两个概念：新生代和年老代<br>新生代：初始对象，生命周期短的<br>永久代：长时间存在的对象<br>整个java的垃圾回收是新生代和年老代的协作，这种叫做分代回收。<br>P.S：Serial New收集器是针对新生代的收集器，采用的是复制算法<br>Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理<br>Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法<br>Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理<br>Parallel Old（并行）收集器，针对老年代，标记整理<br>CMS收集器，基于标记清理<br>G1收集器：整体上是基于标记 整理 ，局部采用复制</p>
<p>综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。</p>
<p>有空了解一下</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2019年12月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年08月09日 java</title>
    <url>/exam//32f75ed4/</url>
    <content><![CDATA[<h1 id="考点1-基本类型的表示范围-float小数初始化-long整数初始化"><a href="#考点1-基本类型的表示范围-float小数初始化-long整数初始化" class="headerlink" title="考点1:基本类型的表示范围 float小数初始化 long整数初始化"></a>考点1:基本类型的表示范围 float小数初始化 long整数初始化</h1><p>以下的变量定义语句中,合法的是()</p>
<ul>
<li>A <code>byte=128</code></li>
<li>B <code>boolean=null</code></li>
<li>C <code>long a=123L</code></li>
<li>D <code>double=0.9239d</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>byte能表示的范围[-128,127]<br>boolean的取值只能是true或 false<br>整数默认是int类型，如果要转为long类型，需要在整数后面加上L<br>小数默认类型是double,如果要转为float类型，需要在小数后面加上字母F</p>
<h1 id="考点2-final类-String"><a href="#考点2-final类-String" class="headerlink" title="考点2:final类 String"></a>考点2:final类 String</h1><p>有以下代码片段:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str2=<span class="string">&quot;he&quot;</span>+ <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;llo&quot;</span>);</span><br><span class="line">System.out.println(str1==str2);</span><br></pre></td></tr></table></figure>
<p>请问输出的结果是:</p>
<ul>
<li>A <code>true</code></li>
<li>B 都不对</li>
<li>C <code>null</code></li>
<li>D <code>false</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>这里的str1指的是方法区中的字符串常量池中的“hello”,编译时期就知道的</p>
<p>String是fina1类,这意味着String不能被继承，在Java中被final修饰的类是不允许被继承的，并且final类的成员方法都默认是final方法.<br>String类底层是char数组来保存字符串的。</p>
<h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p>在class件中有一部分用来存储编译期间生成的字面常量以及符号引用，这部分做<strong>class文件常量池</strong>，</p>
<p>在运行期间对应着方法区的<strong>运行时常量池</strong>。</p>
<p>借鉴之前关于 Stringi拼接的一个总结:1、常量和常量拼接,结果在常量池中且常를池中不存在相同内容的常量。2、只要有一个变星,结果就在堆中。3、如果拼接的结果调用了<br>tem()方法,返回值会在常量池中。补充一点,还有fna修饰时,拼接也会在常量池中.</p>
<h1 id="考点3-try-catch-finally"><a href="#考点3-try-catch-finally" class="headerlink" title="考点3:try catch finally"></a>考点3:try catch finally</h1><p>能单独和finally语句一起使用的块是(  )</p>
<ul>
<li>A <code>try</code></li>
<li>B <code>catch</code></li>
<li>C <code>throw</code></li>
<li>D <code>throws</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>注意细节:使用try…catch块捕天时可以没有 catch块,但当没<br>用 catch块的时候必须得有 finallyt块</p>
<p>使用try…catch捕获异常的时候,若没有catch块时，一定要写上<br>finally</p>
<h1 id="考点4-transient关键字"><a href="#考点4-transient关键字" class="headerlink" title="考点4:transient关键字"></a>考点4:transient关键字</h1><p>以下哪个不能用来处理线程安全</p>
<ul>
<li>A <code>synchronized</code>关键字</li>
<li>B <code>volatile</code>关键字</li>
<li>C <code>Lock</code>类</li>
<li>D <code>transient</code>关键字</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>




<p>transient,变量修饰符,如果用 transient声明一个实例变<br>量,当对象存储时,它的值不需要维持。当一个变量不希望<br>被持久化的时候,比如说一些账号密码,就<strong>可以用transient<br>关键字来表示亥变量不参与序列化过程</strong></p>
<p>volatile修饰一个变量时,可以保证当前线程对亥变量操作的<br>可见性。当前线程有改变变量时,其他线程保存的副本将失<br>效,其他线程会从主内存中重新读取。 <strong>volatile只保证对它修<br>饰的变量的读写操作具有原子性</strong></p>
<p>单纯使用 volatile关键字是不能保证线程安全的<br>volatile只提供了一种弱的同步机制,用来确保将变量的更新操作通知到其他线程。<br>volatile语义是禁用CPU缓存,直接从主内存读、写变量。表现为:更新 volatile变量时,JVM会把线程对应的本地内存中的共享变星值刷新到主内存中;读volatile变量时,JVM会把线程对应的本地内存设置为无效,直<br>接从主内存中读取共享变量.<br>当把变量声明为 volatile类型后,JM增加内存屏章,禁<br>止CPU进行指令重。</p>
<p>实现,继承都具有遗传性,实现了serializable的类的子类也实现 serializable<br>基本类型,包装类, String默认实现serializable。</p>
<p>一个类实现serializable接口时，要保证其成员变量都要实现serializable。</p>
<p>transient修饰成员变量使其不被序列化。</p>
<p>volatile关键字：<br>1.保证了不同线程对该变量操作的内存可见性(当一个线程修改了变量其他使用次变量的线程可以立即知道<br>这一修改)。<br>2.禁止了指令重排序</p>
<p>Lock接口提供了与 synchronized关键字类似的同步功能,但<br>需要在使用时手动获取锁和释放锁。</p>
<p>transient-关键字简单地说,就是让某些被修饰的成员属性变<br>量不被序列化</p>
<p>synchrozied关键字称作同步,主要用来给方法、代码块加<br>锁,被加锁的代码段,同一时间内多线程同时访问同一对象<br>的加锁方法代码块时,只能有一个线程执行能执行方法代码<br>块中的代码,其余线程必须等待当前线程执行完以后才执行<br>该方法代码块。</p>
<h1 id="考点5-ASCII码-向上转型"><a href="#考点5-ASCII码-向上转型" class="headerlink" title="考点5:ASCII码 向上转型"></a>考点5:ASCII码 向上转型</h1><p>执行语句”<code>int a= &#39;2&#39;</code>“后,a的值是( )</p>
<ul>
<li>A 2</li>
<li>B 50</li>
<li>C 49</li>
<li>D 0</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>一个简便的记忆法:0:48，A:65,a:97</p>
<p>48 65 97</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6:"></a>考点6:</h1><p>在JAVA中,假设A有构造方法A(int a),则在类A的其他构造方法中调用该构造方法和语句格式应该为()</p>
<ul>
<li>A <code>this.A(x)</code></li>
<li>B <code>this(x)</code></li>
<li>C <code>super(x)</code></li>
<li>D <code>A(x)</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>this的作用其中一个就是在一个构造方法中调用另一个构造方<br>法,格式为<code>this(参数)</code>。</p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7:"></a>考点7:</h1><p>下面程序运行完之后,t2与t3的关系为()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">List aList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">List bList=<span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line"><span class="type">long</span> t1=System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50000</span>;i++)&#123;</span><br><span class="line">    aList.add(<span class="number">0</span>,obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> t2=System.currentTimeMillis()-t1;</span><br><span class="line">t1=System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50000</span>;i++)&#123;</span><br><span class="line">    bList.add(<span class="number">0</span>,obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> t3=System.currentTimeMillis()-t1; </span><br></pre></td></tr></table></figure>

<ul>
<li>A <code>t2</code></li>
<li>B <code>t2=t3</code></li>
<li>C 不确定</li>
<li>D <code>t2&gt;t3</code></li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>Arraylist内部是动态数组实现,在增加空间时会复制全部数据到扩容后的新数组中。<br>Linkedlist内部为双向链表,可以按需分配空间,扩展时不需要批量赋值，因此Linkedlist用时少。</p>
<h3 id="Arraylist-增删慢-查询快。"><a href="#Arraylist-增删慢-查询快。" class="headerlink" title="Arraylist:增删慢,查询快。"></a>Arraylist:增删慢,查询快。</h3><ul>
<li>由于是数据组实现,需要连续的内存空间,如果删除数组中间的值,为了保证下标的有效性,需要将后面的数据往前移,所以删除馒。</li>
<li>当插入A对象到B对象的前面时,需要将B对象和B对象之后的所有对象后移一位,再插入A对象。所以插入慢。</li>
<li>数组的大小是固定的,如果数组满了,需要重新分配空间,new一个新数组，然后copy旧数据到新数组中，最后再增加新数据,所以增加慢。</li>
<li>因为是连续内存空间,可以通过下标查询数据,所以查询快。</li>
</ul>
<h3 id="Linkedlist-增删快-查询慢。"><a href="#Linkedlist-增删快-查询慢。" class="headerlink" title="Linkedlist:增删快,查询慢。"></a>Linkedlist:增删快,查询慢。</h3><ul>
<li>由于是链表实现,当前节点的nex指向下一个节点,prev指向上一个节点,不需要连续的内存空间。增加或删除时只需要修改指针即可，不需要移动。所以增删快</li>
<li>因为不是连续内存空间,所以不能使用下标查询,只能通过next遍历来查找,所以查询馒。</li>
</ul>
<p>ArrayList容量不够需要扩容,<strong>依次扩容1.5倍</strong>,并且插入数据需要用到数组的copy,<br>Linklist不需要扩容,插入仅需要链表擅长的插入操作即可,故Linklisth的操作时间低.</p>
<p>但是如果讲究尾部插入的话,数据量小的情況下可难分伯仲,但是在插入数据量大的倩况下, ArrayList怕的效率是要<br>高于Linkliste的。<br>因为,数据量大之后,扩容不是很烦繁,仅需要尾部插入即可,但是Linklist需要每次进行链表节点指针的指向调整操作。<br>所以大量数据的尾部面入, ArrayList的效率是要高于Linkliste的,下图是数据量较大时的比较。</p>
<p><img data-src="https://uploadfiles.nowcoder.com/images/20201208/563768122_1607402413753/3866854F08EEB04B3BE47EBDDF6C23B4" alt="这里有一张图片"></p>
<h1 id="考点8-volatile关键字"><a href="#考点8-volatile关键字" class="headerlink" title="考点8:volatile关键字"></a>考点8:volatile关键字</h1><p>volatile关键字的说法错误的是</p>
<ul>
<li>A 能保证线程安全</li>
<li>B <code>volatile</code>关键字用在多线程同步中,可保证读取的可见性</li>
<li>C <code>JVM</code>保证从主内存加载到线程工作内存的值是最新的</li>
<li>D <code>volatile</code>能禁止进行指令重排序</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>出于运行速率的考虑,java编译器会把经常经常访问的变量放到缓存(严格讲应该是工作内存)中,<br>读取变量则从缓存中读。<br>但是在多线程编程中,内存中的值和缓存中的值可能会出现不一致。 </p>
<p><strong>volatile用于限定变量只能从内存中读取,保证对所有线程而言,值都是一致的</strong>。但是 <strong>volatile不能保证原子性,也就不能保证线程安全</strong></p>
<h3 id="1-java的内存模型"><a href="#1-java的内存模型" class="headerlink" title="1.java的内存模型"></a>1.java的内存模型</h3><p>java内存模型规定了所有的变量都存储在主内存中,<br>但是每个线程会有自己的工作内存,<br>线程的工作内存保存了该线程中使用了的变量(从主内存中拷贝的),<br>线程对变量的操作都必须在工作内存中进行,<br>不同线程之间无法直接访问对方工作内存中的变量,<br>线程间变量值从传递都要经过主内存完成</p>
<p><img data-src="https://uploadfiles.nowcoder.com/images/20180827/9780880_1535335958506_5721C0ED3C89479FA5F09D1F8E722D00" alt="img"></p>
<h3 id="2-什么是原子性"><a href="#2-什么是原子性" class="headerlink" title="2.什么是原子性"></a>2.什么是原子性</h3><p><strong>一个操作是不可中断的,要么全部执行成功要么全部执行失败</strong>,比如银行转账</p>
<h3 id="3-什么是可见性"><a href="#3-什么是可见性" class="headerlink" title="3.什么是可见性"></a>3.什么是可见性</h3><p>当多个线程访问同一变量时,一个线程修改了这个变量的值,其他线程就能够立即看到修改的值。</p>
<h3 id="4-什么是有序性"><a href="#4-什么是有序性" class="headerlink" title="4.什么是有序性"></a>4.什么是有序性</h3><p>程序执行的顺序按照代码的先后顺序执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">0</span>;<span class="comment">//1</span></span><br><span class="line"><span class="type">int</span> b=<span class="number">2</span>;<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>像这2句代码,1会比2先执行,但是JVM在真正执行时不一定是1在2之前,这里渉及一个概念叫做指令重排,</p>
<h4 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h4><p>处理器为了提高程序运行效率,可能会对输入代码进行优化,它不保证程序中各个语句的执行先后顺序同代码中的顺序一致,但是它会保证程序最终执行结果和代码序执行的结果是一致的。</p>
<p>比如上面的代码语句1和语句2谁先执行对最终的程序结果并没有影响。那么就有可能在执行过程中,语句2先执行而语句1后执行</p>
<p>在指令重排时会考虑指令之间的数据依赖性,比如2依赖了1的数值,那么处理器会保证1在2之前执行。</p>
<p>但是在多线程的情况下,指令重排就会有影响了。</p>
<h3 id="5-volatile到底做了什么"><a href="#5-volatile到底做了什么" class="headerlink" title="5.volatile到底做了什么"></a>5.volatile到底做了什么</h3><ul>
<li>禁止了指令重排</li>
<li>保证了不同线程对这个变量进行操作时的可见性,即一个线程修改了某个变量值,这个新值对其他线程是立即可见的</li>
<li>不保证原子性(线程不安全)</li>
</ul>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9:"></a>考点9:</h1><p>以下哪种JAVA的变量表达式使得变量a和变量b具有相同的内存引用地址(  )</p>
<ul>
<li>A <code>String a = &quot;hello&quot;; String b = &quot;hello&quot;;</code></li>
<li>B <code>Integer a; Integer b = a;</code></li>
<li>C <code>int a = 1; Integer b = new Integer(1);</code></li>
<li>D <code>int a = 1; Integer b = 1;</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AB</details>

<p>1 Integer与int比较时, Integer会有拆箱的过程,我们可以看看拆箱的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inValue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接返回的就是value,因此int a;与Integer b;以及new Integer(a);进行&#x3D;&#x3D;比较时结果都是true。</p>
<p>解析混乱，我就不记下来了。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年08月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年08月09日 java</title>
    <url>/exam//32f75ed4/</url>
    <content><![CDATA[<h1 id="考点1-基本类型的表示范围-float小数初始化-long整数初始化"><a href="#考点1-基本类型的表示范围-float小数初始化-long整数初始化" class="headerlink" title="考点1:基本类型的表示范围 float小数初始化 long整数初始化"></a>考点1:基本类型的表示范围 float小数初始化 long整数初始化</h1><p>以下的变量定义语句中,合法的是()</p>
<ul>
<li>A <code>byte=128</code></li>
<li>B <code>boolean=null</code></li>
<li>C <code>long a=123L</code></li>
<li>D <code>double=0.9239d</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>byte能表示的范围[-128,127]<br>boolean的取值只能是true或 false<br>整数默认是int类型，如果要转为long类型，需要在整数后面加上L<br>小数默认类型是double,如果要转为float类型，需要在小数后面加上字母F</p>
<h1 id="考点2-final类-String"><a href="#考点2-final类-String" class="headerlink" title="考点2:final类 String"></a>考点2:final类 String</h1><p>有以下代码片段:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str2=<span class="string">&quot;he&quot;</span>+ <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;llo&quot;</span>);</span><br><span class="line">System.out.println(str1==str2);</span><br></pre></td></tr></table></figure>
<p>请问输出的结果是:</p>
<ul>
<li>A <code>true</code></li>
<li>B 都不对</li>
<li>C <code>null</code></li>
<li>D <code>false</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>这里的str1指的是方法区中的字符串常量池中的“hello”,编译时期就知道的</p>
<p>String是fina1类,这意味着String不能被继承，在Java中被final修饰的类是不允许被继承的，并且final类的成员方法都默认是final方法.<br>String类底层是char数组来保存字符串的。</p>
<h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p>在class件中有一部分用来存储编译期间生成的字面常量以及符号引用，这部分做<strong>class文件常量池</strong>，</p>
<p>在运行期间对应着方法区的<strong>运行时常量池</strong>。</p>
<p>借鉴之前关于 Stringi拼接的一个总结:1、常量和常量拼接,结果在常量池中且常를池中不存在相同内容的常量。2、只要有一个变星,结果就在堆中。3、如果拼接的结果调用了<br>tem()方法,返回值会在常量池中。补充一点,还有fna修饰时,拼接也会在常量池中.</p>
<h1 id="考点3-try-catch-finally"><a href="#考点3-try-catch-finally" class="headerlink" title="考点3:try catch finally"></a>考点3:try catch finally</h1><p>能单独和finally语句一起使用的块是(  )</p>
<ul>
<li>A <code>try</code></li>
<li>B <code>catch</code></li>
<li>C <code>throw</code></li>
<li>D <code>throws</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>注意细节:使用try…catch块捕天时可以没有 catch块,但当没<br>用 catch块的时候必须得有 finallyt块</p>
<p>使用try…catch捕获异常的时候,若没有catch块时，一定要写上<br>finally</p>
<h1 id="考点4-transient关键字"><a href="#考点4-transient关键字" class="headerlink" title="考点4:transient关键字"></a>考点4:transient关键字</h1><p>以下哪个不能用来处理线程安全</p>
<ul>
<li>A <code>synchronized</code>关键字</li>
<li>B <code>volatile</code>关键字</li>
<li>C <code>Lock</code>类</li>
<li>D <code>transient</code>关键字</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>




<p>transient,变量修饰符,如果用 transient声明一个实例变<br>量,当对象存储时,它的值不需要维持。当一个变量不希望<br>被持久化的时候,比如说一些账号密码,就<strong>可以用transient<br>关键字来表示亥变量不参与序列化过程</strong></p>
<p>volatile修饰一个变量时,可以保证当前线程对亥变量操作的<br>可见性。当前线程有改变变量时,其他线程保存的副本将失<br>效,其他线程会从主内存中重新读取。 <strong>volatile只保证对它修<br>饰的变量的读写操作具有原子性</strong></p>
<p>单纯使用 volatile关键字是不能保证线程安全的<br>volatile只提供了一种弱的同步机制,用来确保将变量的更新操作通知到其他线程。<br>volatile语义是禁用CPU缓存,直接从主内存读、写变量。表现为:更新 volatile变量时,JVM会把线程对应的本地内存中的共享变星值刷新到主内存中;读volatile变量时,JVM会把线程对应的本地内存设置为无效,直<br>接从主内存中读取共享变量.<br>当把变量声明为 volatile类型后,JM增加内存屏章,禁<br>止CPU进行指令重。</p>
<p>实现,继承都具有遗传性,实现了serializable的类的子类也实现 serializable<br>基本类型,包装类, String默认实现serializable。</p>
<p>一个类实现serializable接口时，要保证其成员变量都要实现serializable。</p>
<p>transient修饰成员变量使其不被序列化。</p>
<p>volatile关键字：<br>1.保证了不同线程对该变量操作的内存可见性(当一个线程修改了变量其他使用次变量的线程可以立即知道<br>这一修改)。<br>2.禁止了指令重排序</p>
<p>Lock接口提供了与 synchronized关键字类似的同步功能,但<br>需要在使用时手动获取锁和释放锁。</p>
<p>transient-关键字简单地说,就是让某些被修饰的成员属性变<br>量不被序列化</p>
<p>synchrozied关键字称作同步,主要用来给方法、代码块加<br>锁,被加锁的代码段,同一时间内多线程同时访问同一对象<br>的加锁方法代码块时,只能有一个线程执行能执行方法代码<br>块中的代码,其余线程必须等待当前线程执行完以后才执行<br>该方法代码块。</p>
<h1 id="考点5-ASCII码-向上转型"><a href="#考点5-ASCII码-向上转型" class="headerlink" title="考点5:ASCII码 向上转型"></a>考点5:ASCII码 向上转型</h1><p>执行语句”<code>int a= &#39;2&#39;</code>“后,a的值是( )</p>
<ul>
<li>A 2</li>
<li>B 50</li>
<li>C 49</li>
<li>D 0</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>一个简便的记忆法:0:48，A:65,a:97</p>
<p>48 65 97</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6:"></a>考点6:</h1><p>在JAVA中,假设A有构造方法A(int a),则在类A的其他构造方法中调用该构造方法和语句格式应该为()</p>
<ul>
<li>A <code>this.A(x)</code></li>
<li>B <code>this(x)</code></li>
<li>C <code>super(x)</code></li>
<li>D <code>A(x)</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>this的作用其中一个就是在一个构造方法中调用另一个构造方<br>法,格式为<code>this(参数)</code>。</p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7:"></a>考点7:</h1><p>下面程序运行完之后,t2与t3的关系为()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">List aList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">List bList=<span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line"><span class="type">long</span> t1=System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50000</span>;i++)&#123;</span><br><span class="line">    aList.add(<span class="number">0</span>,obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> t2=System.currentTimeMillis()-t1;</span><br><span class="line">t1=System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50000</span>;i++)&#123;</span><br><span class="line">    bList.add(<span class="number">0</span>,obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> t3=System.currentTimeMillis()-t1; </span><br></pre></td></tr></table></figure>

<ul>
<li>A <code>t2</code></li>
<li>B <code>t2=t3</code></li>
<li>C 不确定</li>
<li>D <code>t2&gt;t3</code></li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>Arraylist内部是动态数组实现,在增加空间时会复制全部数据到扩容后的新数组中。<br>Linkedlist内部为双向链表,可以按需分配空间,扩展时不需要批量赋值，因此Linkedlist用时少。</p>
<h3 id="Arraylist-增删慢-查询快。"><a href="#Arraylist-增删慢-查询快。" class="headerlink" title="Arraylist:增删慢,查询快。"></a>Arraylist:增删慢,查询快。</h3><ul>
<li>由于是数据组实现,需要连续的内存空间,如果删除数组中间的值,为了保证下标的有效性,需要将后面的数据往前移,所以删除馒。</li>
<li>当插入A对象到B对象的前面时,需要将B对象和B对象之后的所有对象后移一位,再插入A对象。所以插入慢。</li>
<li>数组的大小是固定的,如果数组满了,需要重新分配空间,new一个新数组，然后copy旧数据到新数组中，最后再增加新数据,所以增加慢。</li>
<li>因为是连续内存空间,可以通过下标查询数据,所以查询快。</li>
</ul>
<h3 id="Linkedlist-增删快-查询慢。"><a href="#Linkedlist-增删快-查询慢。" class="headerlink" title="Linkedlist:增删快,查询慢。"></a>Linkedlist:增删快,查询慢。</h3><ul>
<li>由于是链表实现,当前节点的nex指向下一个节点,prev指向上一个节点,不需要连续的内存空间。增加或删除时只需要修改指针即可，不需要移动。所以增删快</li>
<li>因为不是连续内存空间,所以不能使用下标查询,只能通过next遍历来查找,所以查询馒。</li>
</ul>
<p>ArrayList容量不够需要扩容,<strong>依次扩容1.5倍</strong>,并且插入数据需要用到数组的copy,<br>Linklist不需要扩容,插入仅需要链表擅长的插入操作即可,故Linklisth的操作时间低.</p>
<p>但是如果讲究尾部插入的话,数据量小的情況下可难分伯仲,但是在插入数据量大的倩况下, ArrayList怕的效率是要<br>高于Linkliste的。<br>因为,数据量大之后,扩容不是很烦繁,仅需要尾部插入即可,但是Linklist需要每次进行链表节点指针的指向调整操作。<br>所以大量数据的尾部面入, ArrayList的效率是要高于Linkliste的,下图是数据量较大时的比较。</p>
<p><img data-src="https://uploadfiles.nowcoder.com/images/20201208/563768122_1607402413753/3866854F08EEB04B3BE47EBDDF6C23B4" alt="这里有一张图片"></p>
<h1 id="考点8-volatile关键字"><a href="#考点8-volatile关键字" class="headerlink" title="考点8:volatile关键字"></a>考点8:volatile关键字</h1><p>volatile关键字的说法错误的是</p>
<ul>
<li>A 能保证线程安全</li>
<li>B <code>volatile</code>关键字用在多线程同步中,可保证读取的可见性</li>
<li>C <code>JVM</code>保证从主内存加载到线程工作内存的值是最新的</li>
<li>D <code>volatile</code>能禁止进行指令重排序</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>出于运行速率的考虑,java编译器会把经常经常访问的变量放到缓存(严格讲应该是工作内存)中,<br>读取变量则从缓存中读。<br>但是在多线程编程中,内存中的值和缓存中的值可能会出现不一致。 </p>
<p><strong>volatile用于限定变量只能从内存中读取,保证对所有线程而言,值都是一致的</strong>。但是 <strong>volatile不能保证原子性,也就不能保证线程安全</strong></p>
<h3 id="1-java的内存模型"><a href="#1-java的内存模型" class="headerlink" title="1.java的内存模型"></a>1.java的内存模型</h3><p>java内存模型规定了所有的变量都存储在主内存中,<br>但是每个线程会有自己的工作内存,<br>线程的工作内存保存了该线程中使用了的变量(从主内存中拷贝的),<br>线程对变量的操作都必须在工作内存中进行,<br>不同线程之间无法直接访问对方工作内存中的变量,<br>线程间变量值从传递都要经过主内存完成</p>
<p><img data-src="https://uploadfiles.nowcoder.com/images/20180827/9780880_1535335958506_5721C0ED3C89479FA5F09D1F8E722D00" alt="img"></p>
<h3 id="2-什么是原子性"><a href="#2-什么是原子性" class="headerlink" title="2.什么是原子性"></a>2.什么是原子性</h3><p><strong>一个操作是不可中断的,要么全部执行成功要么全部执行失败</strong>,比如银行转账</p>
<h3 id="3-什么是可见性"><a href="#3-什么是可见性" class="headerlink" title="3.什么是可见性"></a>3.什么是可见性</h3><p>当多个线程访问同一变量时,一个线程修改了这个变量的值,其他线程就能够立即看到修改的值。</p>
<h3 id="4-什么是有序性"><a href="#4-什么是有序性" class="headerlink" title="4.什么是有序性"></a>4.什么是有序性</h3><p>程序执行的顺序按照代码的先后顺序执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">0</span>;<span class="comment">//1</span></span><br><span class="line"><span class="type">int</span> b=<span class="number">2</span>;<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>像这2句代码,1会比2先执行,但是JVM在真正执行时不一定是1在2之前,这里渉及一个概念叫做指令重排,</p>
<h4 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h4><p>处理器为了提高程序运行效率,可能会对输入代码进行优化,它不保证程序中各个语句的执行先后顺序同代码中的顺序一致,但是它会保证程序最终执行结果和代码序执行的结果是一致的。</p>
<p>比如上面的代码语句1和语句2谁先执行对最终的程序结果并没有影响。那么就有可能在执行过程中,语句2先执行而语句1后执行</p>
<p>在指令重排时会考虑指令之间的数据依赖性,比如2依赖了1的数值,那么处理器会保证1在2之前执行。</p>
<p>但是在多线程的情况下,指令重排就会有影响了。</p>
<h3 id="5-volatile到底做了什么"><a href="#5-volatile到底做了什么" class="headerlink" title="5.volatile到底做了什么"></a>5.volatile到底做了什么</h3><ul>
<li>禁止了指令重排</li>
<li>保证了不同线程对这个变量进行操作时的可见性,即一个线程修改了某个变量值,这个新值对其他线程是立即可见的</li>
<li>不保证原子性(线程不安全)</li>
</ul>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9:"></a>考点9:</h1><p>以下哪种JAVA的变量表达式使得变量a和变量b具有相同的内存引用地址(  )</p>
<ul>
<li>A <code>String a = &quot;hello&quot;; String b = &quot;hello&quot;;</code></li>
<li>B <code>Integer a; Integer b = a;</code></li>
<li>C <code>int a = 1; Integer b = new Integer(1);</code></li>
<li>D <code>int a = 1; Integer b = 1;</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AB</details>

<p>1 Integer与int比较时, Integer会有拆箱的过程,我们可以看看拆箱的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inValue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接返回的就是value,因此int a;与Integer b;以及new Integer(a);进行&#x3D;&#x3D;比较时结果都是true。</p>
<p>解析混乱，我就不记下来了。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年08月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年08月10日 java2</title>
    <url>/exam//a6c2ab94/</url>
    <content><![CDATA[<h1 id="考点1-构造方法"><a href="#考点1-构造方法" class="headerlink" title="考点1:构造方法"></a>考点1:构造方法</h1><p>以下不属于构造方法特征的是()</p>
<ul>
<li>A 构造方法名与类名相同</li>
<li>B 构造方法不返回任何值,也没有返回类型</li>
<li>C 构造方法在创建对象时调用,其他地方不能显式地直接调用</li>
<li>D 每一个类只能有一个构造方法</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<h1 id="考点2-类定义"><a href="#考点2-类定义" class="headerlink" title="考点2:类定义"></a>考点2:类定义</h1><p>有以下程序片段,下列哪个选项不能插入到第一行 。( )。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span></span><br><span class="line"><span class="number">2.</span> <span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="number">3.</span> <span class="comment">//do sth</span></span><br><span class="line"><span class="number">4.</span> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A <code>public class MainClass&#123; &#125;</code></li>
<li>B <code>package mine;</code></li>
<li>C <code>class ANotherClass&#123; &#125;</code></li>
<li>D <code>import java.util.*;</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>Java一个源程序只能有一个public类存在,且类名与文件名相同。<br>Java程序是从main方法开始执行的,public为类加载器提供入口,然后找到public类中的main方法开始执行。<br>如果存在多个public类,程序将不知道该从哪里执行。<br>注意,内部类可以是 public的,因为内部类是作为外部类的成员存在的</p>
<h1 id="考点3-可信数据"><a href="#考点3-可信数据" class="headerlink" title="考点3:可信数据"></a>考点3:可信数据</h1><p>后端获取数据,向前端输出过程中,以下描述正确的是</p>
<ul>
<li>A 对于前端过滤过的参数,属于可信数据,可以直接输出到前端页面</li>
<li>B 对于从数据库获得的数据,属于可信数据,可以直接输出到前端页面</li>
<li>C 对于从用户上传的<code>Excel</code>等文件解析出的数据,属于可信数据,可以直接输出到前端页面</li>
<li>D 其它选项都不属于可信数据,输出前应该采用信息安全部发布的<code>XSSFilter</code>做进行相应编码</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<h1 id="考点4-线程-线程执行体-run-，start-，join-方法"><a href="#考点4-线程-线程执行体-run-，start-，join-方法" class="headerlink" title="考点4:线程 线程执行体 run()，start()，join()方法"></a>考点4:线程 线程执行体 run()，start()，join()方法</h1><p>以下哪个方法用于定义线程的执行体？ ()</p>
<ul>
<li>A <code>start()</code></li>
<li>B <code>join()</code></li>
<li>C <code>run()</code></li>
<li>D <code>synchronized()</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<p>run()方法是用来定义这个线程在启动的时候需要做什么,但是,直接调用线程的run()方法只会执行一遍函数体,而不会开辟线程,必须使用star()来启动线程。</p>
<p><code>线程B.join()</code>方法是停止当前正在运行的线程,先转去<strong>运行调用join()方法的线程B</strong>,直到线程B运行结束后。再返回运行当前线程。</p>
<h1 id="考点5-抽象类-abstract，final，static关键字"><a href="#考点5-抽象类-abstract，final，static关键字" class="headerlink" title="考点5:抽象类 abstract，final，static关键字"></a>考点5:抽象类 abstract，final，static关键字</h1><p>以下关于 abstract 关键字的说法,正确的是()</p>
<ul>
<li>A <code>abstract</code> 可以与<code>final</code> 并列修饰同一个类。</li>
<li>B <code>abstract</code> 类中不可以有<code>private</code>的成员。</li>
<li>C <code>abstract</code> 类中必须全部是<code>abstract</code>方法。</li>
<li>D <code>abstract</code> 方法必须在<code>abstract</code>类或接口中。</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<blockquote>
<ol>
<li>abstract类不能与final,static使用。final修饰方法，子类可以调用，但不能覆盖。 </li>
<li>抽象类可以有private成员，但最好不要有private,因为私有和抽象放在一起，子类如果想重写父类的私有方法根本继承不过来，也就无法重写 </li>
<li><strong>抽象类中可以有非抽象方法</strong> </li>
<li>抽象类中可以都是非抽象的，但是<strong>抽象方法一定要在类和接口</strong>中</li>
</ol>
</blockquote>
<blockquote>
<ul>
<li>abstract类是需要被继承使用的，所以它不能被final使用，所以A错，</li>
<li>也可以有private属性，B错，</li>
<li>也可以有普通方法 甚至所有都可以是普通方法，当然这样也就失去了abstract类的意义，C错，</li>
<li>interface属于特殊的abstract类，也是abstract类，所以D对</li>
</ul>
</blockquote>
<ol>
<li>abstract类不能使用final,static修饰。<ul>
<li>abstract类就是要被继承实现。</li>
<li>final修饰的类不能被继承，所以abstract不能和final共同修饰一个类<ul>
<li>final修饰方法，子类可以调用，但不能覆盖。 </li>
<li>final修饰的变量不能修改，既是常量。</li>
</ul>
</li>
<li><strong>static修饰的类只能是内部类</strong>，<strong>static不能修饰外部类</strong><ul>
<li>抽象类是不能实例化的，即不能被分配内存；</li>
</ul>
</li>
<li>static修饰的方法在类实例化之前就已经别分配了内存，这样一来矛盾就出现了。所以abstract不能和static共同修饰同一个类，在abstract类里面，可以不能定义static内部类</li>
</ul>
</li>
<li>最好不要有private因为私有和抽象放在一起，子类如果想重写父类的私有方法根本继承不过来，也就无法重写 。但是抽象类中是可以有私有的成员。 </li>
<li>抽象类中可以有非抽象方法 </li>
<li>抽象类中可以都是非抽象的，但是<strong>抽象方法一定要在抽象类和接口</strong>中。普通类可以被实例化，而抽象方法本身不能被调用，如果普通类有抽象方法，那么该方法被调用就会出错。</li>
</ol>
<h3 id="static不能修饰外部类"><a href="#static不能修饰外部类" class="headerlink" title="static不能修饰外部类"></a>static不能修饰外部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Illegal modifier for the class A; only public, abstract &amp; final are permitted</span><br></pre></td></tr></table></figure>
<h4 id="外部类只能是public-abstract-或者final修饰"><a href="#外部类只能是public-abstract-或者final修饰" class="headerlink" title="外部类只能是public,abstract,或者final修饰"></a>外部类只能是public,abstract,或者final修饰</h4><h3 id="abstract和static不能共同修饰方法"><a href="#abstract和static不能共同修饰方法" class="headerlink" title="abstract和static不能共同修饰方法"></a>abstract和static不能共同修饰方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The abstract method method in type B can only set a visibility modifier, one of public or protected</span><br></pre></td></tr></table></figure>
<h4 id="abstract方法只能被public或protected修饰"><a href="#abstract方法只能被public或protected修饰" class="headerlink" title="abstract方法只能被public或protected修饰"></a>abstract方法只能被public或protected修饰</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The abstract method method in type B can only set a visibility modifier, one of public or protected</span><br></pre></td></tr></table></figure>

<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6:"></a>考点6:</h1><p>下面关于JAVA的垃圾回收机制,正确的是( )</p>
<ul>
<li>A 当调用”<code>System.gc()</code>“来强制回收时,系统会立即回收垃圾</li>
<li>B 垃圾回收不能确定具体的回收时间</li>
<li>C 程序可明确地标识某个局部变量的引用不再被使用</li>
<li>D 程序可以显式地立即释放对象占有的内存</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>


<p>java提供了一个系统级的线程，即垃圾回收器线程。用来对每一个分配出去的内存空间进行跟踪。当JVM空闲时，自动回收每块可能被回收的内存，GC是完全自动的，不能被强制执行。程序员最多只能用System.gc()来建议执行垃圾回收器回收内存，但是具体的回收时间，是不可知的。当对象的引用变量被赋值为null，可能被当成垃圾。 </p>
<h1 id="考点7-hibernate延迟加载"><a href="#考点7-hibernate延迟加载" class="headerlink" title="考点7:hibernate延迟加载"></a>考点7:hibernate延迟加载</h1><p>下面有个hibernate延迟加载,说法错误的是？</p>
<ul>
<li>A Hibernate2延迟加载实现:a)实体对象 b)集合(Collection)</li>
<li>B <code>Hibernate3</code> 提供了属性的延迟加载功能</li>
<li>C <code>get</code>支持延迟加载,<code>load</code>不支持延迟加</li>
<li>D <code>hibernate</code>使用<code>Java</code>反射机制,而不是字节码增强程序来实现透明性</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p> Hibernate 中 get()和load() 的区别： </p>
<p>get是立即加载，load是延迟加载。<br>get()采用立即加载方式，当get()执行的时候会立即向数据库发出查询语句，如果没有对应的记录，返回null，而load()采用延迟加载，执行此方法的时候返回的是一个***，只有等真正使用该对象属性的时候，才会发出SQL语句进行查询，若没有，则出现异常ObjectNotFoundException</p>
<h1 id="考点8-IO流支持Unicode的IO流"><a href="#考点8-IO流支持Unicode的IO流" class="headerlink" title="考点8:IO流支持Unicode的IO流"></a>考点8:IO流支持Unicode的IO流</h1><p>哪个类可用于处理Unicode?</p>
<ul>
<li>A <code>InputStreamReader</code></li>
<li>B <code>BufferedReader</code></li>
<li>C <code>Writer</code></li>
<li>D <code>PipedInputStream</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<p>InputStreamReader可以指定字符编码格式<br>InputStreamReader是转换流，将字节流转换成字符流。</p>
<p>BufferedReader只是起到了装饰的作用，就是不用每次都new一个数组了，增加了缓冲区，缓冲区有和没有都一样，只是读取的快慢不同，真正实现功能的是InputStreamReader</p>
<p>看API就知道了。<br> A、 InputStreanReader的构造函数：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>InputStreamReader(InputStream in)</code></td>
<td align="left">Creates an InputStreamReader that uses the default charset.</td>
</tr>
<tr>
<td align="left"><code>InputStreamReader(InputStream in, String charsetName)</code></td>
<td align="left">Creates an InputStreamReader that uses the named charset.</td>
</tr>
<tr>
<td align="left"><code>InputStreamReader(InputStream in, Charset cs)</code></td>
<td align="left">Creates an InputStreamReader that uses the given charset.</td>
</tr>
<tr>
<td align="left"><code>InputStreamReader(InputStream in, CharsetDecoder dec)</code></td>
<td align="left">Creates an InputStreamReader that uses the given charset decoder.</td>
</tr>
</tbody></table>
<p> B、BufferedReader的构造函数：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>BufferedReader(Reader in)</code></td>
<td align="left">Creates a buffering character-input stream that uses a default-sized input buffer.</td>
</tr>
<tr>
<td align="left"><code>BufferedReader(Reader in, int sz)</code></td>
<td align="left">Creates a buffering character-input stream that uses an input buffer of the specified size.</td>
</tr>
</tbody></table>
<p> D、PipedInputStream的构造函数：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>PipedInputStream()</code></td>
<td align="left">Creates a PipedInputStream so that it is not yet connected.</td>
</tr>
<tr>
<td align="left"><code>PipedInputStream(int pipeSize)</code></td>
<td align="left">Creates a PipedInputStream so that it is not yet connected and uses the specified pipe size for the pipe’s buffer.</td>
</tr>
<tr>
<td align="left"><code>PipedInputStream(PipedOutputStream src)</code></td>
<td align="left">Creates a PipedInputStream so that it is connected to the piped output stream src.</td>
</tr>
<tr>
<td align="left"><code>PipedInputStream(PipedOutputStream src, int pipeSize)</code></td>
<td align="left">Creates a PipedInputStream so that it is connected to the piped output stream src and uses the specified pipe size for the pipe’s buffer.</td>
</tr>
</tbody></table>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9:"></a>考点9:</h1><p>以下代码定义了一个变量,如何输出这个变量的值？<br><img data-src="https://uploadfiles.nowcoder.com/images/20161123/5918115_1479891741965_E3A349EA0FAFB7A49B99084AB8BF7860" alt="这里有一张图片"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean:define</span> <span class="attr">id</span>=<span class="string">&quot;stringBean&quot;</span> <span class="attr">value</span>=<span class="string">&quot;helloWorld&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>A <code>&lt;% String myBean = (String)pageContext.getAttribute(&quot;stringBean&quot;,PageContext.PAGE_SCOPE); %&gt; &lt;%=myBean%&gt;</code></li>
<li>B <code>&lt;bean:write name=&quot;helloworld&quot;/&gt;</code></li>
<li>C <code>&lt;bean:write name=&quot;stringBean&quot;/&gt;</code></li>
<li>D <code>&lt;%=stringBean%&gt;</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details>

<p><strong>—————看完秒懂—————————</strong> </p>
<ul>
<li>A选项： <ul>
<li>通过 pageContext（PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问） 获取stringBean 的值，赋给 String 类型的变量 myBean，然后通过 Jsp 表达式 处理该值。</li>
</ul>
</li>
<li>bean:define <ul>
<li>题目中的 Struts 的bean:define 标签定义了一个字符串变量 stringBean ,它的值为 helloworld。</li>
</ul>
</li>
<li>bean:write <ul>
<li>bean:write相当于 <code>&lt;%=request.getAttribute(&quot;something&quot;)%&gt;</code> 其中 something 是属性的名字。所以 B 错，C对。</li>
</ul>
</li>
<li>D选项： <ul>
<li>通过Jsp 表达式 获取变量 stringBean 的值</li>
</ul>
</li>
</ul>
<h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10:"></a>考点10:</h1><p>下面有关值类型和引用类型描述正确的是()？</p>
<ul>
<li>A 值类型的变量赋值只是进行数据复制,创建一个同值的新对象,而引用类型变量赋值,仅仅是把对象的引用的指针赋值给变量,使它们共用一个内存地址。</li>
<li>B 值类型数据是在栈上分配内存空间,它的变量直接包含变量的实例,使用效率相对较高。而引用类型数据是分配在堆上,引用类型的变量通常包含一个指向实例的指针,变量通过指针来引用实例。</li>
<li>C 引用类型一般都具有继承性,但是值类型一般都是封装的,因此值类型不能作为其他任何类型的基类。</li>
<li>D 值类型变量的作用域主要是在栈上分配内存空间内,而引用类型变量作用域主要在分配的堆上。</li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<div class="post-content"><p> 我的理解（有错麻烦大家指正，谢谢！） </p> <p> 值类型：基本数据类型（int、double、boolean ...）<br> 引用类型：reference类型，通过它可以直接或间接的查找到对象在java堆中数据存放的起始地址或索引（对象在java堆中的哪个位置） </p> <div> 先来两个例子，变量的赋值在内存中是怎么样的： </div> <div> 先上一张运行时数据区的网图 </div> <div> <img data-src="https://uploadfiles.nowcoder.com/images/20210403/295024425_1617425679179/ED4A39D7A4730633FAFF15C2833D36EF"> </div> <div> 局部变量表、操作数栈在虚拟机栈中<br> </div> <p> <strong>一：基本变量的赋值</strong> </p> <pre class="prettyprint lang-java">public void method() {<br> int a = 1;<br> int b = a;<br>}<br><br>该方法的字节码：<br> 0 iconst_1 // 将 int 型 1 推送至操作数栈栈顶<br> 1 istore_1 // 将操作数栈栈顶 int 型值存入第二个本地变量<br> 2 iload_1 // 将第二个int型本地变量推送至操作数栈顶<br> 3 istore_2 // 将操作数栈栈顶 int 型值存入第三个本地变量<br> 4 return // 方法返回<br></pre> <p> <img alt="图片说明" data-src="https://uploadfiles.nowcoder.com/images/20210403/295024425_1617423311067/E233F218A90B7A00B94B7F533A98C0A2" title="图片标题"> </p> <p> <strong>二：基本变量的赋值</strong> </p> <pre class="prettyprint lang-java">public void method2() {<br> Object a = new Object();<br> Object b = a;<br>}<br><br>该方法的字节码：<br> 0 new #15 &lt;java/lang/Object&gt; // 创建一个对象，并将其引用压入栈顶<br> 3 dup // 复制栈顶引用类型数据并将其值压入栈顶<br> 4 invokespecial #1 &lt;java/lang/Object.&lt;init&gt;&gt; // 执行对象构造方法（使用了栈顶引用类型）<br> 7 astore_1 // 将操作数栈栈顶引用类型数据值存入第二个本地变量 a<br> 8 aload_1 // 将第二个引用类型本地变量推送至栈顶<br> 9 astore_2 // 将栈顶引用类型数值存入第三个本地变量b<br> 10 return // 方法返回</pre> <p> <img alt="图片说明" data-src="https://uploadfiles.nowcoder.com/images/20210403/295024425_1617423324866/1A8F685C15FEEF92820538FEA13FF231" title="图片标题"> </p> <p> 再看选项 </p> <ul> <li> <p> A<span>(✔)</span>：<strong>值类型</strong>的和<strong>引用类型</strong>的变量赋值就像上面一样，先把局部变量表中 a 的数值存入操作数栈，再取出来放入 b，不过区别在于： </p> <ul> <li> 前者在局部变量表中存放的数值<strong>是真正意义上的 a 代表的数据</strong>，所以说赋值操作是“复制（iload_1、istore_2）”一份出来再给 b </li><li> 后者在局部变量表中存放的数值<strong>不是真正意义上 a 代表的数据</strong>，只是<strong>指向堆中对象的指针</strong>（指向 a 真正代表的数据）。赋值操作只是把 a 中数值即<strong>指针复制</strong>给 b ，<strong>堆中a代表正真的数据即对象(0x11)并没有被复制</strong> </li></ul> </li><li> <p> B<span>(✔)</span>： </p> <ul> <li> "值类型数据是在<strong>栈（指虚拟机栈）上分配</strong>内存空间，它的变量直接包含变量的实例，使用效率相对较高。" ：<strong>局部变量表（在虚拟机栈中）</strong>中存放数值的就是真正意义上的数据，不用访问堆，效率较高 </li><li> “而引用类型数据是分配在<strong>堆</strong>上，引用类型的变量通常包含一个<strong>指向实例</strong>（指向堆中对象）的指针，变量通过指针来引用实例。” ：局部变量表中存放的数值是指向<strong>堆</strong>中数据（对象）的指针 </li></ul> </li><li> <p> C(✔)：类可以继承，基本数据类型不能继承 </p> </li><li> <div> D(X)：“值类型变量的作用域主要是在栈上分配内存空间内”：如果是跟上诉一致在方法内定义的基本变量，它的作用域就在栈中；如果是在类中定义的成员变量例如 Class A 中有成员变量 int val，这个类的实例在堆中，那么 val 作用域也在堆中 </div> </li></ul> <div> <br> </div> <div> <br> </div> <div> 题外话：操作数栈深度在编译期就已经决定 </div></div>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年08月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年08月23日 java1</title>
    <url>/exam//4d1e272c/</url>
    <content><![CDATA[<h1 id="考点1-Java编程单元"><a href="#考点1-Java编程单元" class="headerlink" title="考点1:Java编程单元"></a>考点1:Java编程单元</h1><p>Java中基本的编程单元为:</p>
<ul>
<li>A 类</li>
<li>B 函数</li>
<li>C 变量</li>
<li>D 数据</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>java的基本编程单元是类，基本存储单元是变量。</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2:"></a>考点2:</h1><p>下列说法正确的是</p>
<ul>
<li>A 在类方法中可用<code>this</code>来调用本类的类方法</li>
<li>B 在类方法中调用本类的类方法可直接调用</li>
<li>C 在类方法中只能调用本类的类方法</li>
<li>D 在类方法中绝对不能调用实例方法</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>


<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3:"></a>考点3:</h1><p>语句:char foo&#x3D;’中’,是否正确？(假设源文件以GB2312编码存储,并且以javac – encoding GB2312命令编译)</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5:"></a>考点5:</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//point X</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">java</span>.io.OutputStreamWriter(System.out), <span class="literal">true</span>);</span><br><span class="line">        out.printIn(<span class="string">&quot;Hello&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面哪个选项放在poinx X这里可以正确执行？</p>
<ul>
<li>A <code>import java.io.PrintWriter;</code></li>
<li>B <code>include java.io.PrintWriter;</code></li>
<li>C <code>import java.io.OutputStreamWriter;</code></li>
<li>D <code>include java.io.OutputStreamWriter;</code></li>
<li>E <code>no statement is needed.</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>java中没有include关键字，导包用import<br>由于代码中使用了printWriter 类，所以要导入此类Import java.io.PrintWriter; </p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6:"></a>考点6:</h1><p>下列语句中,正确的是</p>
<ul>
<li>A <code>float x=0.0</code></li>
<li>B <code>boolean b=3&gt;5</code></li>
<li>C <code>char c=&quot;A&quot;</code></li>
<li>D <code>double =3.14</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>A小数默认double,float x&#x3D;0.0f<br>C字符串不能赋值给字符<br>D没有变量名</p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7:"></a>考点7:</h1><p>1.将下列(A、B、C、D)哪个代码替换下列程序中的【代码】不会导致编译错误？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Com</span>&#123;</span><br><span class="line">    <span class="type">int</span> M=<span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImpCom</span> <span class="keyword">implements</span> <span class="title class_">Com</span>&#123;</span><br><span class="line">    【代码】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A <code>public int f()&#123;return 100+M;&#125;</code></li>
<li>B <code>int f()&#123;return 100;&#125;</code></li>
<li>C <code>public double f()&#123;return 2.6;&#125;</code></li>
<li>D <code>public abstract int f();</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>C: The return type is incompatible with Com.f()<br>D：The abstract method f in type ImpCom can only be defined by an abstract class</p>
<h3 id="必须实现接口的所有方法-方法原型要一致"><a href="#必须实现接口的所有方法-方法原型要一致" class="headerlink" title="必须实现接口的所有方法 方法原型要一致"></a>必须实现接口的所有方法 方法原型要一致</h3><p><strong>1、必须实现接口中所有的方法。</strong><br>在实现类中实现接口时，<strong>方法的名字、返回值类型、参数的个数及类型</strong>必须与接口中的完全一致，并且<strong>必须实现接口中的所有方法。</strong> </p>
<h3 id="访问权限要更低"><a href="#访问权限要更低" class="headerlink" title="访问权限要更低"></a>访问权限要更低</h3><p><strong>2、接口实现类相当于子类，子类的访问权限是不能比父类小的。</strong></p>
<h3 id="实现的接口方法都是public"><a href="#实现的接口方法都是public" class="headerlink" title="实现的接口方法都是public"></a>实现的接口方法都是public</h3><p><strong>接口中所有方法默认都是public</strong>，至于为什么要是public，原因在于如果不是public，那么只能在同个包下被实现，可访问权限就降低很多了，那么在实现类中，实现的类相当于子类，子类的访问权限是不能比父类小的，而在java中一个类如果没有权限的修饰符，默认是friendly(同一个包内的其它类才可访问)，所以在<strong>接口的实现类重写的方法中一定要写public</strong> </p>
<h3 id="两同两小一大"><a href="#两同两小一大" class="headerlink" title="两同两小一大"></a>两同两小一大</h3><p>接口中的抽象方法默认的修饰符是public abstract,后重写，<strong>两同两小一大</strong>可知，前边修饰符应该是public</p>
<h3 id="接口的成员特点是"><a href="#接口的成员特点是" class="headerlink" title="接口的成员特点是:"></a>接口的成员特点是:</h3><ol>
<li>成员变量修饰符 默认 public static final </li>
<li>成员方法修饰符 默认 public abstract</li>
</ol>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8:"></a>考点8:</h1><p>下面哪些接口直接继承自Collection接口()</p>
<ul>
<li>A <code>List</code></li>
<li>B <code>Map</code></li>
<li>C <code>Set</code></li>
<li>D <code>Iterator</code></li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

<h3 id="集合继承树"><a href="#集合继承树" class="headerlink" title="集合继承树"></a>集合继承树</h3><p><img data-src="https://uploadfiles.nowcoder.com/images/20171008/4154422_1507446427676_B79947F5D1E4CD7AAB65620127350E13" alt="这里有一张图片"></p>
<p><img data-src="https://uploadfiles.nowcoder.com/images/20170817/6577016_1502936071145_236678ED840D4B66889A095C455D1A00" alt="这里有一张图片"></p>
<p><img data-src="https://uploadfiles.nowcoder.com/images/20190426/317867636_1556251137650_3CD35CAB76746F3EC273E712CD317FE8" alt="这里有一张图片"></p>
<p><img data-src="https://uploadfiles.nowcoder.com/images/20181220/498582_1545274273176_1ED0ED9EEE430F4BA241A72B30A3F7AA" alt="这里有一张图片"></p>
<p> Iterator接口 不继承任何接口！ </p>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9:"></a>考点9:</h1><p>抽象类和接口的区别,以下说法错误的是</p>
<ul>
<li>A 接口是公开的,里面不能有私有的方法或变量,是用于让别人使用的,而抽象类是可以有私有方法或私有变量的。</li>
<li>B <code>abstract class</code> 在 <code>Java</code> 语言中表示的是一种继承关系,一个类只能使用一次继承关系。但是,一个类却可以实现多个<code>interface</code>,实现多重继承。接口还有标识(里面没有任何方法,如<code>Remote</code>接口)和数据共享(里面的变量全是常量)的作用。</li>
<li>C 在<code>abstract class</code> 中可以有自己的数据成员,也可以有非<code>abstarct</code>的成员方法,而在<code>interface</code>中,只能够有静态的不能被修改的数据成员(也就是必须是 <code>static final</code>的,不过在 <code>interface</code>中一般不定义数据成员),所有的成员方法默认都是 <code>public abstract</code> 类型的。</li>
</ul>
<p>-D <code>abstract class</code>和<code>interface</code>所反映出的设计理念不同。其实<code>abstract class</code>表示的是<code>has-a</code>关系,<code>interface</code>表示的是<code>is-a</code>关系。</p>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details>


<p> 抽象类：在Java中被abstract关键字修饰的类称为抽象类，被abstract关键字修饰的方法称为抽象方法，抽象方法只有方法的声明，没有方法体。抽象类的特点： a、抽象类不能被实例化只能被继承； b、包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法； c、抽象类中的抽象方法的修饰符只能为public或者protected，默认为public； d、一个子类继承一个抽象类，则子类必须实现父类抽象方法，否则子类也必须定义为抽象类； e、抽象类可以包含属性、方法、构造方法，但是构造方法不能用于实例化，主要用途是被子类调用。 接口：Java中接口使用interface关键字修饰，特点为: a、接口可以包含变量、方法；变量被隐士指定为public static final，方法被隐士指定为public abstract（JDK1.8之前）； b、接口支持多继承，即一个接口可以extends多个接口，间接的解决了Java中类的单继承问题； c、一个类可以实现多个接口； d、JDK1.8中对接口增加了新的特性：  （1）、默认方法（default method）：JDK 1.8允许给接口添加非抽象的方法实现，但必须使用default关键字修饰；定义了default的方法可以不被实现子类所实现，但只能被实现子类的对象调用；如果子类实现了多个接口，并且这些接口包含一样的默认方法，则子类必须重写默认方法；  （2）、静态方法（static method）：JDK 1.8中允许使用static关键字修饰一个方法，并提供实现，称为接口静态方法。接口静态方法只能通过接口调用（接口名.静态方法名）。     注意：<strong>jdk1.9是允许接口中出现private修饰的默认方法和静态方法</strong>。</p>
<p> 解析：<br> A：jdk1.9是允许接口中出现private修饰的默认方法和静态方法，A错误；<br> 抽象类可以有私有的变量和方法。 B：正确<br> C：抽象类可以有抽象和非抽象的方法；jdk1.8接口中可以有默认方法和静态方法，C错误。<br> D：强调继承关系，is-a，如果A is-a B，那么B就是A的父类；<br> 代表组合关系，like-a，接口，如果A like a B，那么B就是A的接口。 ；<br> 强调从属关系，has-a，如果A has a B，那么B就是A的组成部分。<br> D项错误。 </p>
<p>is a是继承（抽象类），has a是组合（接口）</p>
<p>在JDK9后，接口中可以有私有静态方法和私有普通方法</p>
<h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10:"></a>考点10:</h1><p>下面的Java赋值语句哪些是有错误的 ()</p>
<ul>
<li>A int i &#x3D;1000;</li>
<li>B float f &#x3D; 45.0;</li>
<li>C char s &#x3D; ‘\u0639’</li>
<li>D Object o &#x3D; ‘f’;</li>
<li>E String s &#x3D; “hello,world\0”;</li>
<li>F Double d &#x3D; 100;</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BCF</details>

<p>选项F是自动装箱， 装箱过程中调用的是Double类的valueOf(double d)方法， 而这里是100为int型， 所以编译会“cannot convert from int to Double”。</p>
<p>最后一个选项F项，很多人都没解释清楚。 首先，double d &#x3D;100; 是不会错的，double是8个字节64位，int 是4个字节，32位。所以int转double，32位转64位，肯定是不会错的。</p>
<p>那F项错在哪里？仔细看是Double 不是double哦，所以这道题考的是java自动装箱，对于Integer和Double的自动装箱，只能装对应的数据类型，不对应就会报错。java中100默认是int型,而不是byte，short和long;100.0默认是double，而不是float。想了解int装箱，请大家仔细阅读这篇文章：<a href="https://blog.csdn.net/zhangjin1120/article/details/116329647" target="_blank">关于int装箱更多问题</a>。而装箱远比这个复杂，看下面。 </p>
<pre>
Integer i=100;//没有问题
Integer i2=100.0;//报红杠，因为默认是double
Integer i3=(byte)100;//报红杠
Short s = (byte) 100;//没有问题，是不是很神奇？说明上面的规律对Short不适用
Double d=100; //报红杠
Double d=100.0;//没有问题
Double d=100.0f;//报红杠
double d=100;//没有问题，100是int类型，自动转换为double.
Double d=Double.valueOf("100"); //正确
Double d=Double.valueOf(100);//正确
Double d=new Double(100);//正确
</pre> 
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年08月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年08月24日 java2</title>
    <url>/exam//36cb6def/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1:"></a>考点1:</h1><p>队列(Queue)是先进先出的。(  )</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>举个栗子，可以这样理解： 1.队列：先进先出。很好理解就是排队。 2.栈：后进先出。就像堆放在桌子上的一碟碟盘子，最后放的，肯定是最先拿的。</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2:"></a>考点2:</h1><p>关于AOP错误的是？</p>
<ul>
<li>A <code>AOP</code>将散落在系统中的”方面”代码集中实现</li>
<li>B <code>AOP</code>有助于提高系统可维护性</li>
<li>C <code>AOP</code>已经表现出将要替代面向对象的趋势</li>
<li>D <code>AOP</code>是一种设计模式,<code>Spring</code>提供了一种实现</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h3 id="AOP和OOP的区别"><a href="#AOP和OOP的区别" class="headerlink" title="AOP和OOP的区别"></a>AOP和OOP的区别</h3><h4 id="1-面向方面编程-AOP"><a href="#1-面向方面编程-AOP" class="headerlink" title="1.面向方面编程 AOP"></a>1.面向方面编程 AOP</h4><p>偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。</p>
<h4 id="2-面向对象编程-OOP"><a href="#2-面向对象编程-OOP" class="headerlink" title="2.面向对象编程 (OOP)"></a>2.面向对象编程 (OOP)</h4><p>则是对业务分析中抽取的实体进行方法和属性的封装。</p>
<p><strong>也可以说AOP是面向业务中的动词领域，OOP面向名词领域。</strong><br>AOP的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了AOP组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态proxy模式。</p>
<p>AOP与OOP是面向不同领域的两种设计思想。 OOP（面向对象编程）针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。  AOP（面向切面编程）是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。 这两种设计思想在目标上有着本质的差异。</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3:"></a>考点3:</h1><p>非抽象类实现接口后,必须实现接口中的所有抽象方法,除了abstract外,方法头必须完全一致.</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>


<h3 id="两同两小一大"><a href="#两同两小一大" class="headerlink" title="两同两小一大"></a>两同两小一大</h3><p>实际上这道题考查的是<strong>两同两小一大</strong>原则： </p>
<ul>
<li>方法名相同，</li>
<li>参数类型相同 </li>
<li>子类返回类型小于等于父类方法返回类型， </li>
<li>子类抛出异常小于等于父类方法抛出异常， </li>
<li>子类访问权限大于等于父类方法访问权限。</li>
</ul>
<p>方法头指：修饰符+返回类型+方法名（形参列表） </p>
<h3 id="什么是方法头方法体方法签名"><a href="#什么是方法头方法体方法签名" class="headerlink" title="什么是方法头方法体方法签名"></a>什么是方法头方法体方法签名</h3><p>方法由方法头(Method Header)和方法体(Method Body)组成，</p>
<blockquote>
<p><a href="https://blog.csdn.net/tgvincent/article/details/97516256">https://blog.csdn.net/tgvincent/article/details/97516256</a><br>方法头: 包括方法的修饰符、返回值类型、方法名、形式参数(最后两项是方法签名)<br>方法体: 在Java语言中方法体一个方法中用大括号{}括起来的部分<br>方法签名: <strong>方法名称+参数列表</strong>(包括参数的类型和顺序)<br>注意，签名不包括方法的访问修饰符、返回类型</p>
</blockquote>
<p>应用场景-重载和重写:</p>
<p>重载(Override): 一个类中，定义的多个<strong>方法名相同</strong>但是<strong>参数列表不同</strong>的方法（签名不同）<br>重写(Overlode): 子父类中，子类定义了与父类方法签名相同的方法。<br>注意：必须是从父类继承而来的方法。父类中的private方法，子类没有权限继承，因而重写不了。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法头：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span></span><br></pre></td></tr></table></figure>
<p>方法体：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法签名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main(String[])</span><br></pre></td></tr></table></figure>


<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4:"></a>考点4:</h1><p>下面代码的运行结果是( )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Arraytest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String arg[] )</span> &#123;</span><br><span class="line">        System.out.println ( a[<span class="number">0</span>] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A <code>null</code></li>
<li>B 0</li>
<li>C 编译出错</li>
<li>D 运行出错</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h3 id="静态成员不能访问非静态成员"><a href="#静态成员不能访问非静态成员" class="headerlink" title="静态成员不能访问非静态成员"></a>静态成员不能访问非静态成员</h3><p>在java中静态方法中不能使用非静态方法和非静态变量。但非静态方法中可以使用静态变量。</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5:"></a>考点5:</h1><p>下面哪些类实现或继承了 Collection 接口？</p>
<ul>
<li>A <code>HashMap</code></li>
<li>B <code>ArrayList</code></li>
<li>C <code>Vector</code></li>
<li>D <code>Iterator</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<p><img data-src="https://uploadfiles.nowcoder.com/images/20180504/8109535_1525415510089_FBD604850FC78A76D544D9EC79389452" alt="这里有一张图片"></p>
<p><img data-src="https://uploadfiles.nowcoder.com/images/20171003/1962128_1507000616630_57BB9E163074EF81F11E0E8765A78088" alt="这里有一张图片"></p>
<p><img data-src="https://uploadfiles.nowcoder.com/images/20170610/7757447_1497087490308_6BBAA4657798F59F5FDA6918C53E38D4" alt="这里有一张图片"></p>
<p><img data-src="https://uploadfiles.nowcoder.com/images/20200304/8940520_1583310558159_C6008D620CD4E9CDC6F5FDA872FD3AFE" alt="这里有一张图片"></p>
<p><img data-src="https://uploadfiles.nowcoder.com/images/20180905/914738902_1536132696446_094A52914DF2D0A2098BC80ED41830B5" alt="这里有一张图片"></p>
<p><img data-src="https://uploadfiles.nowcoder.com/images/20180724/3807435_1532400945434_BC39C88E110DD0C8EDEEBC191A1B63C5" alt="这里有一张图片"></p>
<p>Collection下有三个子接口List,Set,Queue。<br>Map下有两个子接口AbstractMap,SortedMap,<br>所以看到：</p>
<ul>
<li>一个类名属于什么什么List,Set,Queue就是实现了Collection接口,</li>
<li>一个类名属于什么什么Map就是实现了Map接口</li>
</ul>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6:"></a>考点6:</h1><p>实现或继承了Collection接口的是()</p>
<ul>
<li>A <code>Map</code></li>
<li>B <code>List</code></li>
<li>C <code>Vector</code></li>
<li>D <code>Iterator</code></li>
<li>E <code>Set</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BCE</details>

<p><img data-src="http://uploadfiles.nowcoder.com/images/20150928/458054_1443399626006_AA40C8919CE65157D5F251E7622A75FB" alt="这里有一张图片"></p>
<p>在java.util包中提供了一些集合类，常用的有List、Set和Map类，其中List类和Set类继承了Collection接口。这些集合类又称为容器，长度是可变的，数组用来存放基本数据类型的数据，集合用来存放类对象的引用。<br>List接口、Set接口、Map接口以及Collection接口的主要特征如下： </p>
<p>1.Collection接口是List接口和Set接口的父接口，通常情况下不被直接使用。<br>2.List接口继承了Collection接口，List接口允许存放重复的对象，排序方式为按照对象的插入顺序。<br>3.Set接口继承了Collection接口，Set接口不允许存放重复的对象，排序方式为按照自身内部的排序规则。<br>4.Map接口以键值对（key—value）的形式存放对象，其中键（key）对象不可以重复，值（value）对象可以重复，排序方式为按照自身内部的规则。</p>
<p>C：Vector实现了List接口，即间接实现Collection接口<br>D：Iterator是Java迭代器最简单的实现，没有实现Collection接口</p>
<p><img data-src="https://uploadfiles.nowcoder.com/images/20180927/3810354_1538050685934_9F2D93CFED52C5BE1357008F81B4D46A" alt="这里有一张图片"></p>
<p><img data-src="https://uploadfiles.nowcoder.com/images/20190902/3300579_1567429946894_BA430658612F4F9B6F640DCB9D931562" alt="这里有一张图片"></p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7:"></a>考点7:</h1><p>下面关于Applet的说法是正确的是</p>
<ul>
<li>A <code>Applet</code>可以在带有<code>Java</code>解释器的浏览器中运行</li>
<li>B <code>Applet</code>类必须继承<code>java.applet.Applet</code></li>
<li>C <code>Applet</code>可以访问本地文件</li>
<li>D <code>Applet</code>是<code>Object</code>类的子类</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>

]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年08月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年08月25日 java1</title>
    <url>/exam//4000576b/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1:"></a>考点1:</h1><p>一个以”. java”为后缀的源文件,哪些说法是正确的？</p>
<ul>
<li>A 只能包含一个类,类名必须与文件名相同</li>
<li>B 只能包含与文件名相同的类,以及其中的内部类</li>
<li>C 只能有一个与文件名相同的类,可以包含其他类</li>
<li>D 可以包含任意类</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>一个java文件可以包含多个java类，但是只能包含一个public类，并且public类的类名必须与java文件名相同。</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2:"></a>考点2:</h1><p>默认RMI采用的是什么通信协议？</p>
<ul>
<li>A <code>HTTP</code></li>
<li>B <code>UDP/IP</code></li>
<li>C <code>TCP/IP</code></li>
<li>D <code>Multicast</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p> RMI(Remote Method Invocation)远程方法调用是一种计算机之间利用远程对象互相调用实现双方通讯的一种通讯机制。 而TCP&#x2F;IP是远程通讯的主要手段。 </p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3:"></a>考点3:</h1><p>下面有关java final的基本规则,描述错误的是？</p>
<ul>
<li>A <code>final</code>修饰的类不能被继承</li>
<li>B <code>final</code>修饰的成员变量只允许赋值一次,且只能在类方法赋值</li>
<li>C <code>final</code>修饰的局部变量即为常量,只能赋值一次。</li>
<li>D <code>final</code>修饰的方法不允许被子类覆盖</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>


<h1 id="考点3-1"><a href="#考点3-1" class="headerlink" title="考点3:"></a>考点3:</h1><p>下面有关java final的基本规则,描述错误的是？</p>
<ul>
<li>A <code>final</code>修饰的类不能被继承</li>
<li>B <code>final</code>修饰的成员变量只允许赋值一次,且只能在类方法赋值</li>
<li>C <code>final</code>修饰的局部变量即为常量,只能赋值一次。</li>
<li>D <code>final</code>修饰的方法不允许被子类覆盖</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p> 答案为：B </p>
<p>final修饰的成员变量为基本数据类型是，在赋值之后无法改变。<br>当final修饰的成员变量为引用数据类型时，在赋值后其指向地址无法改变，但是对象内容还是可以改变的。<br>final修饰的成员变量在赋值时可以有三种方式。<br>1、在声明时直接赋值。<br>2、在构造器中赋值。<br>3、在初始代码块中进行赋值。 </p>
<p>final修饰的方法，不允许被子类覆盖。<br>final修饰的类，不能被继承。<br>final修饰的变量，不能改变值。<br>final修饰的引用类型，不能再指向别的东西，但是可以改变其中的内容。 </p>
<p>final所修饰的成员变量只能赋值一次，<br>可以在类方法中赋值，<br>也可以在声明的时候直接赋值，</p>
<p>而final修饰的局部变量可以在声明的时候初始化，也可以在第一次使用时，通过方法或者表达式给它赋值。 </p>
<h3 id="final修饰的成员的赋值方式"><a href="#final修饰的成员的赋值方式" class="headerlink" title="final修饰的成员的赋值方式"></a>final修饰的成员的赋值方式</h3><p> 第一种：修饰成员变量时有3种初始化方式：<br> 1，在定义变量时直接赋值<br> 2，声明完变量后在构造方法中为其赋值<br> 3，声明完变量后在构造代码块中为其赋值 ｛ ｝ </p>
<p> 第二种：修饰类变量(静态变量)<br> 1，在定义类变量时直接赋值 </p>
<p> 2，在静态代码块中赋值 </p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4:"></a>考点4:</h1><p>以下程序执行的结果是:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line">    Y y=<span class="keyword">new</span> <span class="title class_">Y</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">X</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Y</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Y&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Z</span> <span class="keyword">extends</span> <span class="title class_">X</span>&#123;</span><br><span class="line">    Y y=<span class="keyword">new</span> <span class="title class_">Y</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Z</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Z</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A <code>ZYXX</code></li>
<li>B <code>ZYXY</code></li>
<li>C <code>YXYZ</code></li>
<li>D <code>XYZX</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h3 id="类初始化顺序"><a href="#类初始化顺序" class="headerlink" title="类初始化顺序"></a>类初始化顺序</h3><p>涉及继承：<br>a.初始化父类中的静态成员变量和静态代码块<br>b.初始化子类中的静态成员变量和静态代码块<br>c.初始化父类的普通成员变量和构造代码块(按次序)，再执行父类的构造方法<br>d.初始化子类的普通成员变量和构造代码块(按次序)，再执行子类的构造方法</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5:"></a>考点5:</h1><p>下面程序输出结果为():</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String [] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lx</span> <span class="operator">=</span> <span class="string">&quot;LeXin&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">nb</span> <span class="operator">=</span> lx;</span><br><span class="line">        lx = <span class="string">&quot;Fenqile&quot;</span>;</span><br><span class="line">        System.out.println(nb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 程序异常,编译不通过</li>
<li>B 程序编写正常,可正常运行</li>
<li>C 程序输出值为”<code>LeXin</code>“</li>
<li>D 程序输出值为”<code>Fenqile</code>“</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>


<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6:"></a>考点6:</h1><p>JDK1.7版本之前,接口和抽象类描述正确的有( )</p>
<ul>
<li>A 抽象类没有构造函数。</li>
<li>B 接口没有构造函数。</li>
<li>C 抽象类不允许多继承。</li>
<li>D 接口中的方法可以有方法体。</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<p><strong>A.抽象类可以有构造方法,只是不能直接创建抽象类的实例对象而已</strong><br><strong>B.在接口中 不可以有构造方法,在接口里写入构造方法时，编译器提示：Interfaces cannot have constructors。</strong><br><strong>C.Java不允许类多重继承</strong><br><strong>D.jdk1.8后接口中的方法可以有方法体，jdk1.8之前不可以有方法体</strong></p>
<p>JDK1.8后，接口中可以有静态方法，静态方法必须有方法体。</p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7:"></a>考点7:</h1><p>根据下面这个程序的内容,判断哪些描述是正确的:( )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;tommy&quot;</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> s;</span><br><span class="line">        sayHello(o); <span class="comment">//语句1</span></span><br><span class="line">        sayHello(s); <span class="comment">//语句2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String to)</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;Hello, %s&quot;</span>, to)); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(Object to)</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;Welcome, %s&quot;</span>, to));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 这段程序有编译错误</li>
<li>B 语句1输出为:<code>Hello, tommy</code></li>
<li>C 语句2输出为:<code>Hello, tommy</code></li>
<li>D 语句1输出为:<code>Welcome, tommy</code></li>
<li>E 语句2输出为:<code>Welcome, tommy</code></li>
<li>F 根据选用的<code>Java</code>编译器不同,这段程序的输出可能不同</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: CD</details>

<p>Java语言是静态多分派，动态单分派的。 如果是重载方法之间的选择，则是使用静态类型。 如果是父类与子类之间的重写方法的选择，则是使用动态类型。 如A a &#x3D; new B(); 会使用类型B去查找重写的方法，使用类型A去查找重载的方法。 所以此题的输出分别为 </p>
<pre>Welcome, tommy
Hello, tommy</pre> 


<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8:"></a>考点8:</h1><p>错误的有：</p>
<ul>
<li>A <code>public abstract final class Test &#123; abstract void method(); &#125;</code></li>
<li>B <code>public abstract class Test &#123; abstract final void method(); &#125;</code></li>
<li>C <code>public abstract class Test &#123; abstract void method() &#123; &#125; &#125;</code></li>
<li>D <code>public class Test &#123; final void method() &#123; &#125; &#125;</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<p>A、final修饰的类为终态类，不能被继承，而抽象类是必须被继承的才有其意义的，因此，<strong>final是不能用来修饰抽象类的</strong>。<br>B、final修饰的方法为终态方法，不能被重写。而继承抽象类，必须重写其方法。因此，<strong>final不能修饰抽象方法</strong><br>C、抽象方法是仅声明，并不做实现的方法。也就是不能带有方法体：<code>&#123; &#125;</code></p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年08月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年08月26日 java1</title>
    <url>/exam//ab37ec68/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1:"></a>考点1:</h1><p>java 中哪个关键字可以对对象加互斥锁？</p>
<ul>
<li>A <code>transient</code></li>
<li>B <code>synchronized</code></li>
<li>C <code>serialize</code></li>
<li>D <code>static</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>transient修饰符是指字段不会被序列化。<br>synchronized修饰符是指对象锁. 用来给对象和方法或者代码块加锁，<strong>当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这个段代码</strong>。<br>serialize序列化.</p>
<p>volatile：用来确保将变量的跟新操作通知到其他线程，当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。然而，在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比 synchronized关键字更轻量级的同步机制。</p>
<ul>
<li><strong>static 修饰符</strong>，用来创建类方法和类变量。</li>
<li><strong>final 修饰符</strong>，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</li>
<li><strong>abstract 修饰符</strong>，用来创建抽象类和抽象方法。</li>
<li><strong>synchronized</strong> 用于多线程的同步。用来给对象和方法或者代码块加锁，各线程互斥访问。</li>
<li><strong>volatile</strong> 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</li>
<li><strong>transient：</strong>序列化的对象包含被 transient 修饰的实例变量时，java</li>
<li>虚拟机(JVM)跳过该特定的变量。</li>
</ul>
<p><strong>A、transient，反序列化修饰符，序列化的时候，类中的属性都会被复制，但是被transient和static修饰的属性不会被复制。</strong></p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2:"></a>考点2:</h1><p>在Web应用程序的文件与目录结构中,web.xml是放置在(    )中。</p>
<ul>
<li>A <code>WEB-INF</code>目录</li>
<li>B <code>conf</code>目录</li>
<li>C <code>lib</code>目录</li>
<li>D <code>classes</code>目录</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h3 id="Java-Web应用程序目录结构"><a href="#Java-Web应用程序目录结构" class="headerlink" title="Java Web应用程序目录结构"></a>Java Web应用程序目录结构</h3><p>web.xml文件是用来初始化配置信息，web.xml是放置在WEB-INF目录中</p>
<p>Web工程的目录结构如图所示<br><img data-src="https://uploadfiles.nowcoder.com/images/20171018/2069737_1508288171888_B6C31D01D41C9E1714958F9C56D01D8F"> </p>
<p>（1）&#x2F;WEB-INF&#x2F;web.xml 是部署描述文件<br>（2）&#x2F;WEB-INF&#x2F;classes 用来放置应用程序用到的自定义类(.class)，必须包括包(package)结构。<br>（3）&#x2F;WEB-INF&#x2F;lib 用来放置应用程序用到的JAR文件。 </p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3:"></a>考点3:</h1><p>java语言中的数组元素下标总是从0开始,下标可以是整数或整型表达式。()</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>例如平时有这样的用法 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    a[i+<span class="number">1</span>]=a[i];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这个i+1就是整数型表达式  或者a[5+3]就是a[8] </p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4:"></a>考点4:</h1><p>类A1和类A2在同一包中,类A2有个protected的方法testA2,类A1不是类A2的子类(或子类的子类),类A1可以访问类A2的方法testA2。(  )</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h3 id="访问控制符作用范围"><a href="#访问控制符作用范围" class="headerlink" title="访问控制符作用范围"></a>访问控制符作用范围</h3><table>
<thead>
<tr>
<th align="left">作用域</th>
<th align="left">当前类</th>
<th align="left">同一package</th>
<th align="left">子孙类</th>
<th align="left">其他package</th>
</tr>
</thead>
<tbody><tr>
<td align="left">public</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
</tr>
<tr>
<td align="left">protected</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">×</td>
</tr>
<tr>
<td align="left">default</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">×</td>
<td align="left">×</td>
</tr>
<tr>
<td align="left">private</td>
<td align="left">√</td>
<td align="left">×</td>
<td align="left">×</td>
<td align="left">×</td>
</tr>
</tbody></table>
 <table> <thead> <tr> <th>@</th> <th>public</th> <th>protected</th> <th>default</th> <th>private</th> </tr> </thead> <tbody><tr> <td>当前类</td> <td>y</td> <td>y</td> <td>y</td> <td>y</td> </tr> <tr> <td>同包中</td> <td>y</td> <td>y</td> <td>y</td> <td>n</td> </tr> <tr> <td>子类</td> <td>y</td> <td>y</td> <td>n</td> <td>n</td> </tr> <tr> <td>其它</td> <td>y</td> <td>n</td> <td>n</td> <td>n</td> </tr> </tbody></table>

 
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5:"></a>考点5:</h1><p>下面对静态数据成员的描述中,正确的是</p>
<ul>
<li>A 静态数据成员可以在类体内进行初始化</li>
<li>B 静态数据成员不可以被类的对象调用</li>
<li>C 静态数据成员不受<code>private</code>控制符的作用</li>
<li>D 静态数据成员可以直接用类名调用</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>静态数据成员可以直接用类名调用，前提是访问权限修饰符为public。<br>本类的私有静态数据成员,无法被其他类调用。</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6:"></a>考点6:</h1><p>将下列哪个代码(A、B、C、D)放入程序中标注的【代码】处将导致编译错误？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getNum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    【代码】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A <code>public float getNum()&#123;return 4.0f&#125;</code></li>
<li>B <code>public void getNum()&#123;&#125;</code></li>
<li>C <code>public void getNum(double d)&#123;&#125;</code></li>
<li>D <code>public double getNum(float d)&#123;return 4.0d&#125;</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>A是重写<br>B是重写，但是返回值类型不对<br>C是重载<br>D是重载</p>
<h3 id="方法重写-两同两小一大"><a href="#方法重写-两同两小一大" class="headerlink" title="方法重写 两同两小一大"></a>方法重写 两同两小一大</h3><p>方法重写要遵循“两同两小一大”规则，</p>
<ul>
<li>“两同”即<strong>方法名相同、形参列表相同</strong>；</li>
<li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li>
<li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li>
</ul>
<p>并且，覆盖方法和被覆盖方法要么都是类方法，要么都是实例方法，不能一个是类方法一个是实例方法。</p>
<h3 id="方法重载-两同一不同"><a href="#方法重载-两同一不同" class="headerlink" title="方法重载 两同一不同"></a>方法重载 两同一不同</h3><p>方法重载的要求就是“两同一不同”:</p>
<ul>
<li>同一个类中</li>
<li>方法名相同,</li>
<li><strong>形参列表不同</strong>。</li>
</ul>
<h3 id="子类重载方法：参数列表不同"><a href="#子类重载方法：参数列表不同" class="headerlink" title="子类重载方法：参数列表不同"></a>子类重载方法：参数列表不同</h3><p>什么时候发生子类方法和父类方法的重载?<br>如果子类定义了一个与父类方法有<strong>相同的方法名</strong>,但<strong>参数列表</strong>不同的方法,就会形成父类方法和子类方法的重载,</p>
<h3 id="如何区分重载和重写"><a href="#如何区分重载和重写" class="headerlink" title="如何区分重载和重写"></a>如何区分重载和重写</h3><p>看参数列表，<br>如果参数列表相同，就认定为重写。<br>如果参数列表不同，就认定为重载。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年08月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年08月28日 java1</title>
    <url>/exam//b5fedcdb/</url>
    <content><![CDATA[<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2:"></a>考点2:</h1><p>以下语句的执行结果是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>+<span class="string">&quot;10&quot;</span>+<span class="number">3</span>+<span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>A “11032”</li>
<li>B “16”</li>
<li>C 16</li>
<li>D “32101”</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="number">1</span>+<span class="string">&quot;10&quot;</span>+<span class="number">3</span>+<span class="string">&quot;2&quot;</span>);<span class="comment">//11032</span></span><br><span class="line">System.out.println(<span class="number">1</span>+<span class="number">2</span>+<span class="string">&quot;10&quot;</span>+<span class="number">3</span>+<span class="string">&quot;2&quot;</span>);<span class="comment">//31032</span></span><br><span class="line">System.out.println(<span class="number">1</span>+<span class="string">&quot;10&quot;</span>+<span class="number">3</span>+<span class="number">1</span>+<span class="string">&quot;2&quot;</span>);<span class="comment">//110312</span></span><br></pre></td></tr></table></figure>
<p>注意“+”的两边的类型</p>
<p>相当于按顺序从左向右+，以2个为一个单元，例如<br>System.out.println(3+5+”12”+3+3);<br>前两个是3+5，值为8，这时变为<br>System.out.println(8+”12”+3+3);<br>前两个是8+”12”,值为”812”，然后”812”+3&#x3D;”8123”，故最后值为”81233”。 </p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3:"></a>考点3:</h1><p>以下程序的运行结果是:(    )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Integer&gt;();</span><br><span class="line">TreeSet&lt;Integer&gt; subSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">606</span>;i&lt;<span class="number">613</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        set.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">subSet = (TreeSet)set.subSet(<span class="number">608</span>,<span class="literal">true</span>,<span class="number">611</span>,<span class="literal">true</span>);</span><br><span class="line">set.add(<span class="number">629</span>);</span><br><span class="line">System.out.println(set+<span class="string">&quot; &quot;</span>+subSet);</span><br></pre></td></tr></table></figure>
<ul>
<li>A 编译失败</li>
<li>B 发生运行时异常</li>
<li>C [606, 608, 610, 612, 629] [608, 610]</li>
<li>D [606, 608, 610, 612, 629] [608, 610,629]</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h3 id="Set的subset方法"><a href="#Set的subset方法" class="headerlink" title="Set的subset方法"></a>Set的subset方法</h3><p>subset方法是求set的范围内的子集，两个true是表示是否包含端点（608和611），故subSet的值为[608,610]</p>
<p><code>subset(form，true，to，true)</code>是Treeset的非静态方法，该方法返回从form元素到to元素的一个set集合，两个boolean类型是确认是否包含边境值用的。<br><a href="https://blog.csdn.net/yingpaixiaochuan/article/details/49019131">https://blog.csdn.net/yingpaixiaochuan/article/details/49019131</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set=[606, 608, 610, 612, 629]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">s1 = (TreeSet)set.subSet(<span class="number">608</span>, <span class="literal">true</span>,<span class="number">611</span>,<span class="literal">true</span>); <span class="comment">//表示从set数组中取出从from到to的值</span></span><br><span class="line">s2 = (TreeSet)set.subSet(<span class="number">608</span>, <span class="literal">false</span>,<span class="number">611</span>,<span class="literal">true</span>);<span class="comment">//表示从set数组取出from到to（不包含from）的值</span></span><br><span class="line">s3 = (TreeSet)set.subSet(<span class="number">608</span>, <span class="literal">true</span>,<span class="number">611</span>,<span class="literal">false</span>);<span class="comment">//表示从set数组取出从from到to（不包含to）的值</span></span><br><span class="line"><span class="comment">/** 输出：</span></span><br><span class="line"><span class="comment"> * s1=[608, 610, 612]</span></span><br><span class="line"><span class="comment"> * s2=[610, 612]</span></span><br><span class="line"><span class="comment"> * s3=[608, 610]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>总结：subset()就是截取from到to的值。其中截取的值是否包含边境由fromInclusive、toInclusive的boolean值的变化决定。</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4:"></a>考点4:</h1><p>下面有关java的一些细节问题,描述错误的是？</p>
<ul>
<li>A 构造方法不需要同步化</li>
<li>B 一个子类不可以覆盖掉父类的同步方法</li>
<li>C 定义在接口中的方法默认是<code>public</code>的</li>
<li>D 容器保存的是对象的引用</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>





<p> A构造方法都是构造出新的对象，所以不需要同步 </p>
<p> B synchronized关键字不能被继承。虽然可以用synchronized来定义方法，但是synchronized却并不属于方法定义的一部分，所以synchronized关键字并不能被继承。如果父类中的某个方法使用了synchronized关键字，而子类中也覆盖了这个方法，默认情况下子类中的这个方法并不是同步的，必须显示的在子类的这个方法中加上synchronized关键字才可 </p>
<p> C接口里面的变量其实际是常量，常用public static final修饰 ；接口里面的方法其实际是抽象方法，常用public abstrac修饰 </p>
<p> D容器保存的是对象的引用 而非对象本身 </p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5:"></a>考点5:</h1><p>以下哪个式子有可能在某个进制下成立()？</p>
<ul>
<li>A 13*14&#x3D;204</li>
<li>B 12*34&#x3D;568</li>
<li>C 14*14&#x3D;140</li>
<li>D 1+1&#x3D;3</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h3 id="按权展开，然后相乘"><a href="#按权展开，然后相乘" class="headerlink" title="按权展开，然后相乘"></a>按权展开，然后相乘</h3><p>我们假设是x进制，然后带入算式计算即可： A选项：<code>13*14=204</code>； </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1*x^1+3*x^0) *( 1*x^1+4*x^0)= 2*x^2+4*x^0 </span><br><span class="line">==&gt;(x+3)*(x+4)=2x^2+4 </span><br><span class="line">==&gt;(x-8)(x+1)=0 </span><br><span class="line">==&gt;x=8或x=-1 </span><br></pre></td></tr></table></figure>
<p>A选项有答案，为八进制时，可成功匹配，所以A答案正确。<br>B选项：12*34&#x3D;568； </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1*x^1+2*x^0)*(3*x^1+4*x^0)=5*x^2+6*x^1+8*x^0 </span><br><span class="line">==&gt;(x+2)(3x+4)=5x^2+6x+8 </span><br><span class="line">==&gt;x=2 </span><br></pre></td></tr></table></figure>
<p>B选项也有答案，为二进制，但是却是错误的，因为就像在16进制中一样，不能出现比15（也就是F）更大的数，到了16就会进位了。所以在二进制中，不能出现比1更大的数，到了2就会进位了。而B选项的等式中，出现了3,4,5,6,8都比1更大，所以肯定不是二进制数，所以也是错误的。 </p>
<p>C,D选项也是类似规则 </p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6:"></a>考点6:</h1><p>Java语言中,方法的重写(Overriding)和重载(Overloading)是多态性的不同表现。下边哪些说法是对的？</p>
<ul>
<li>A 重写是父类与子类之间多态性的一种表现</li>
<li>B 重写是一个类中多态性的一种表现</li>
<li>C 重载是一个类中多态性的一种表现</li>
<li>D 重载是父类与子类之间多态性的一种表现</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>


<p>重写<strong>Overriding</strong>是父类与子类之间多态性的一种表现，重载<strong>Overloading</strong>是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和<strong>参数</strong>，我们说该方法被重写<br>(<strong>Overriding</strong>)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。</p>
<p>如果在一个类中定义了多个同名的方法，它们或<strong>有不同的参数个数</strong>或<strong>有不同的参数类型</strong>，则称为方法的重载(<strong>Overloading</strong>)。 </p>
<p><strong>Overloaded</strong>的方法是可以改变返回值的类型。 </p>
<p>重写是子类继承父类方法并对其进行修改，可选择调用父类方法或子类重写后的同名方法<br>重载是在一个类可以存在同名但<strong>参数列表不同</strong>的方法，可根据传入的参数调用相应的方法 </p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7:"></a>考点7:</h1><p>以下 json 格式数据,错误的是</p>
<ul>
<li>A <code>&#123;company:4399&#125;</code></li>
<li>B <code>&#123;&quot;company&quot;:&#123;&quot;name&quot;:[4399,4399,4399]&#125;&#125;</code></li>
<li>C <code>&#123;[4399,4399,4399]&#125;</code></li>
<li>D <code>&#123;&quot;company&quot;:[4399,4399,4399]&#125;</code></li>
<li>E <code>&#123;&quot;company&quot;:&#123;&quot;name&quot;:4399&#125;&#125;</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

<ol>
<li>必须有键 和 值 </li>
<li>键和值必须用双引号 </li>
<li>值中可以嵌套 JSON 元素</li>
</ol>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8:"></a>考点8:</h1><p>关于OutOfMemoryError,下面说法正确的是()？</p>
<ul>
<li>A <code>java.lang.OutOfMemoryError: PermGen space</code> 增加<code>-XX:MaxPermSize</code>这个参数的值的话,这个问题通常会得到解决。</li>
<li>B <code>java.lang.OutOfMemoryError: Requested array size exceeds VM limit</code>当你正准备创建一个超过虚拟机允许的大小的数组时,这条错误将会出现</li>
<li>C <code>java.lang.OutOfMemoryError: Java heap space</code> 一般情况下解决这个问题最快的方法就是通过<code>-Xmx</code>参数来增加堆的大小</li>
<li>D <code>java.lang.OutOfMemoryError: nativeGetNewTLA</code>这个异常只有在<code>jRockit</code>虚拟机时才会碰到</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<p>关于此题，《深入理解java虚拟机》有关于OOM（OutOfMemory）问题的解释 A：属于运行时常量池导致的溢出，设置-XX：MaxPermSize可以解决这个问题， B：属于堆空间不足导致的错误，问题比较少见，解决方式和C相同， C：属于java堆内存问题，一般的手段是通过内存映像分析工具，对Dump出来的堆转储存快照进行分析，重点是确认内存中的对象是否是有必要的，也就是要判断是出现了内存泄漏，还是出现了内存溢出，如果是内存列楼，通过工具检查泄露对象打GC Roots的引用链信息，可以准确的确定出泄露代码的位置，不存在泄露，就应该检查虚拟机的堆参数，如果可以继续调大，可以设置-Xmx解决问题 D：java.lang.OutOfMemoryError: nativeGetNewTLA指当虚拟机不能分配新的线程本地空间(Thread Local Area）的时候错误信息，此错误是线程申请一个新的TLA时产生的，这个异常一般只会发生在jRockit虚拟机，只有过于绝对。 </p>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9:"></a>考点9:</h1><p>如下哪些是 java 中有效的关键字()</p>
<ul>
<li>A <code>native</code></li>
<li>B <code>NULL</code></li>
<li>C <code>false</code></li>
<li>D <code>this</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details>


<h3 id="true-false-null都是常量而不是关键字"><a href="#true-false-null都是常量而不是关键字" class="headerlink" title="true false null都是常量而不是关键字"></a>true false null都是常量而不是关键字</h3><p>const和goto是保留关键字。<br>true和false看起来像关键字，但严格来说，它们是boolean常量；<br>null看起来也像关键字，但严格来说，它是null常量。</p>
<p>综上，true,false,null不是关键字。而是常量。</p>
<blockquote> 
<a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.9" target="_blank">点击查看 java se 8 官方解释</a>
</blockquote>

<p><img data-src="https://uploadfiles.nowcoder.com/images/20190112/750751650_1547298484712_99DA418AA5BA59AF729454B5727507D4" alt="这里有一张图片"></p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年08月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月01日 java</title>
    <url>/exam//14201dba/</url>
    <content><![CDATA[<h1 id="考点1-try-catch-finally执行流程"><a href="#考点1-try-catch-finally执行流程" class="headerlink" title="考点1:try-catch-finally执行流程"></a>考点1:try-catch-finally执行流程</h1><p>分析以下代码,说法正确的是()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(val());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">val</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        num = num / <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        num = <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        num = <span class="number">15</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 运行时报错</li>
<li>B 程序正常运行,输出值为5</li>
<li>C 程序正常运行,输出值为10</li>
<li>D 程序正常运行,输出值为15</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>第7行出现<strong>除零异常</strong>，然后执行catch块，最后执行finally块。</p>
<h1 id="考点2-数据类型"><a href="#考点2-数据类型" class="headerlink" title="考点2:数据类型"></a>考点2:数据类型</h1><p>若所用变量都已正确定义,以下选项中,非法的表达式是()</p>
<ul>
<li>A <code>a!= 4||b==1</code></li>
<li>B <code>&#39;a&#39; % 3</code></li>
<li>C <code>&#39;a&#39; = 1/3</code></li>
<li>D <code>&#39;A&#39; + 32</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>‘a’是个常数，不能赋值</p>
<h1 id="考点3-自动类型提升"><a href="#考点3-自动类型提升" class="headerlink" title="考点3:自动类型提升"></a>考点3:自动类型提升</h1><p>若有定义语句: int a&#x3D;10 ; double b&#x3D;3.14 ; 则表达式 ‘A’+a+b 值的类型是()</p>
<ul>
<li>A <code>char</code></li>
<li>B <code>int</code></li>
<li>C <code>double</code></li>
<li>D <code>float</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h3 id="类型自动提升"><a href="#类型自动提升" class="headerlink" title="类型自动提升"></a>类型自动提升</h3><p><code>char &lt; short &lt; int &lt; float &lt; double</code>不同类型运算结果类型向右边靠齐。<br><strong>类型大的与类型小的进行运算，强制转换为大类型</strong><br>自动转换，精度小的自动转换为精度大的 因此统一转换为double类型。如果是要精度大的转化为精度小的 则需要进行强制类型转换</p>
<h1 id="考点4-检查异常和非检查异常"><a href="#考点4-检查异常和非检查异常" class="headerlink" title="考点4:检查异常和非检查异常"></a>考点4:检查异常和非检查异常</h1><p>下列哪种异常是检查型异常,需要在编写程序时声明？</p>
<ul>
<li>A <code>NullPointerException</code></li>
<li>B <code>ClassCastException</code></li>
<li>C <code>FileNotFoundException</code></li>
<li>D <code>IndexOutOfBoundsException</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>java中的异常通常分为编译时异常和运行异常。编译时异常需要我们手动的进行捕捉处理，也就是我们用try….catch块进行捕捉处理。<br>对于运行时异常只有在编译器在编译运行时才会出现，这些不需要我们手动进行处理。对于A、<br>B、 D来说都是运行时异常，因此答案为C</p>
<h3 id="Java异常族谱"><a href="#Java异常族谱" class="headerlink" title="Java异常族谱"></a>Java异常族谱</h3><p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/09/20210902092027.jpg" alt="214250_1444467985224_6A144C1382BBEF1BE30E9B91BC2973C8"></p>
<ol>
<li>粉红色的是受检查的异常(checked exceptions),其必须被try{}catch语句块所捕获,或者在方法签名里通过throws子句声明.受检查的异常必须在编译时被捕捉处理,命名为 Checked Exception 是因为Java编译器要进行检查,Java虚拟机也要进行检查,以确保这个规则得到遵守.</li>
<li>绿色的异常是运行时异常(runtime exceptions),需要程序员自己分析代码决定是否捕获和处理,比如空指针,被0除…</li>
<li>而声明为Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕捉。</li>
</ol>
<p>Java异常</p>
<ul>
<li>检查型异常（编译时异常 checked exceptions）</li>
<li>需要在编写程序时声明</li>
<li>需要我们手动的进行捕捉处理，也就是我们用try….catch块进行捕捉处理。或者在方法签名里通过throws子句声明</li>
<li>Throwable、Exception、IOException、ClassNotFoundException、CloneNotSupportedException、EOFException、FileNotFoundException、MalformedURLException、UnknownHostException</li>
<li>运行异常（runtime exceptions）</li>
<li>只有在编译器在编译运行时才会出现，这些不需要我们手动进行处理</li>
<li>需要程序员自己分析代码决定是否捕获和处理,比如 空指针,被0除…</li>
<li>RuntimeException、ArithmeticException、ClassCastException、IllegalArgumentException、IllegalStateException、IndexOutOfBoundsException、NoSuchElementException、NullPointerException</li>
<li>Error</li>
<li>属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕捉。</li>
</ul>
<p>1、Java 基本上除了 File、SQL 相关的异常外，都是运行时异常</p>
<h1 id="考点5-Object方法"><a href="#考点5-Object方法" class="headerlink" title="考点5:Object方法"></a>考点5:Object方法</h1><p>以下 _____ 不是 Object 类的方法</p>
<ul>
<li>A <code>clone()</code></li>
<li>B <code>finalize()</code></li>
<li>C <code>toString()</code></li>
<li>D <code>hasNext()</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>这种类型的题一般考察点有两个：<br>1.Object中没有hasNext（） 方式，这个方法是迭代器中的<br>2.Object没有copy方法，但是有clone()方法， 用于创建并返回该对象的一个副本</p>
<h3 id="hasNext一般为迭代器方法"><a href="#hasNext一般为迭代器方法" class="headerlink" title="hasNext一般为迭代器方法"></a>hasNext一般为迭代器方法</h3><p>hasNext() 一般是迭代器(Iterater)的方法，表示是否存在下一个元素，用next()方法取到下一个元素。</p>
<h3 id="Object方法"><a href="#Object方法" class="headerlink" title="Object方法"></a>Object方法</h3><p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html</a></p>
<table>
<thead>
<tr>
<th align="left">java.lang.Object方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>protected Object clone()</code></td>
<td align="left">Creates and returns a copy of this object.</td>
</tr>
<tr>
<td align="left"><code>boolean equals(Object obj)</code></td>
<td align="left">Indicates whether some other object is “equal to” this one.</td>
</tr>
<tr>
<td align="left"><code>protected void finalize()</code></td>
<td align="left"><strong>Deprecated</strong>. The finalization mechanism is inherently problematic.</td>
</tr>
<tr>
<td align="left"><code>Class&lt;?&gt; getClass()</code></td>
<td align="left">Returns the runtime class of this Object.</td>
</tr>
<tr>
<td align="left"><code>int hashCode()</code></td>
<td align="left">Returns a hash code value for the object.</td>
</tr>
<tr>
<td align="left"><code>void notify()</code></td>
<td align="left">Wakes up a single thread that is waiting on this object’s monitor.</td>
</tr>
<tr>
<td align="left"><code>void notifyAll()</code></td>
<td align="left">Wakes up all threads that are waiting on this object’s monitor.</td>
</tr>
<tr>
<td align="left"><code>String toString()</code></td>
<td align="left">Returns a string representation of the object.</td>
</tr>
<tr>
<td align="left"><code>void wait()</code></td>
<td align="left">Causes the current thread to wait until it is awakened, typically by being notified or interrupted.</td>
</tr>
<tr>
<td align="left"><code>void wait(long timeoutMillis)</code></td>
<td align="left">Causes the current thread to wait until it is awakened, typically by being notified or interrupted, or until a certain amount of real time has elapsed.</td>
</tr>
<tr>
<td align="left"><code>void wait(long timeoutMillis, int nanos)</code></td>
<td align="left">Causes the current thread to wait until it is awakened, typically by being notified or interrupted, or until a certain amount of real time has elapsed.</td>
</tr>
</tbody></table>
<h1 id="考点6-值传递引用传递问题"><a href="#考点6-值传递引用传递问题" class="headerlink" title="考点6:值传递引用传递问题"></a>考点6:值传递引用传递问题</h1><p>指出下来程序运行的结果是</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/09/20210902150108.png" alt="4819419_1512815363858_050A1C016A89DF3247F32E71DC8461D3"></p>
<ul>
<li>A <code>good and abc</code></li>
<li>B <code>good and gbc</code></li>
<li>C <code>tst ok and abc</code></li>
<li>D <code>tst ok and gbc</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h3><ul>
<li>基本数据类型都是值传递</li>
<li>类，数组，接口是引用传递。 由于String对象本身的特殊性，导致它值传递的特征</li>
</ul>
<h1 id="考点7-abstract和final"><a href="#考点7-abstract和final" class="headerlink" title="考点7:abstract和final"></a>考点7:abstract和final</h1><p>关于抽象类与最终类,下列说法错误的是？</p>
<ul>
<li>A 抽象类能被继承,最终类只能被实例化。</li>
<li>B 抽象类和最终类都可以被声明使用</li>
<li>C 抽象类中可以没有抽象方法,最终类中可以没有最终方法</li>
<li>D 抽象类和最终类被继承时,方法可以被子类覆盖</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>最终类就是被final修饰的类，最终方法就是被final修饰的方法。最终类不能被继承，最终方法不能被重写。</p>
<p>1，抽象类中可以有抽象方法，也可以没有抽象方法。<br>2，抽象类当然可以被继承，因为它就是用来继承的，<br>3，继承抽象类，若有抽象方法，则子类必须将其抽象方法实现，<br>4，抽象类中的非抽象方法可以被重写。</p>
<p>最终类和抽象类正好相反<br>5，加上final的类就叫最终类，加上final的方法就叫最终方法，<br>6，最终类中可以有最终方法也可以没有<br>7，最终类不能有子类，最终方法不能被重写</p>
<h3 id="抽象类和最终类的区别"><a href="#抽象类和最终类的区别" class="headerlink" title="抽象类和最终类的区别"></a>抽象类和最终类的区别</h3><p>1.抽象类可以被继承，并且触创建抽象类就是为了被继承，但是最终类只能实例化；<br>2.抽象类和最终类都可以被声明使用。<br>3.抽象类可以没有抽象方法，最终类中可以没有最终方法。<br>4.最终类不能被继承，子类继承非最终类时，子类可以继承该类的最终方法，但不能重写父类的最终方法。<br>5.抽象类是不能实例化的，实例化必将加载类，然后根本不知道抽象方法的方法体大小，所以不能实例化。</p>
<h3 id="然后是抽象类和接口的区别"><a href="#然后是抽象类和接口的区别" class="headerlink" title="然后是抽象类和接口的区别"></a>然后是抽象类和接口的区别</h3><p>类中只要含有一个抽象方法，该类就是抽象类；抽象类中可以包含一个或多个抽象方法，也可以不含有抽象方法，直接在类声明时候加上abstract<br>，该类就是抽象类，但是这种情况没有意义。</p>
<p><strong>Java7</strong>之前接口中的方法只有声明，没有实现，类似抽象方法，</p>
<p>接口方法默认public abstract修饰；<br>接口中的变量默认是public static final修饰的；</p>
<p>接口定义时候，如果不声明为public的接口，那么该接口只有包访问权限。</p>
<p>一个子类只能继承一个抽象类（虚类），但能实现多个接口；<br>一个抽象类可以有构造方法，接口没有构造方法；<br>一个抽象类中的方法不一定是抽象方法，即其中的方法可以有实现（有方法体），<br>接口中的方法都是抽象方法，不能有方法体，只有声明；</p>
<p>一个抽象类可以是public、private、protected、default,<br>接口只有public;</p>
<p>一个抽象类中的方法可以是public、private、protected、default<br>接口中的方法只能是public和default。</p>
<h1 id="考点8-异常处理"><a href="#考点8-异常处理" class="headerlink" title="考点8:异常处理"></a>考点8:异常处理</h1><p>对于Java中异常的描述正确的是( )</p>
<ul>
<li>A 用<code>throws</code>定义了方法可能抛出的异常,那么调用此方法时一定会抛出此异常。</li>
<li>B 如果<code>try</code>块中没有抛出异常,<code>finally</code>块中的语句将不会被执行。</li>
<li>C 抛出异常意味着程序发生运行时错误,需要调试修改</li>
<li>D <code>Java</code>中的可不检测(<code>unchecked</code>)异常可能来自<code>RuntimeException</code>类或其子类。</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>A错 在调用此方法的时候 也可以再次申明以将异常交由更高一级处理。<br>B错 finally块中的语句一定会被执行。除非catch块中有<code>System.exit(0)</code>。<br>C错 抛出异常不一定是运行时异常，也有可能是编译时异常。<br>D对 运行时异常的特点是Java编译器不会检查它。</p>
<h3 id="Exception（异常）"><a href="#Exception（异常）" class="headerlink" title="Exception（异常）"></a>Exception（异常）</h3><p>是程序本身可以处理的异常。主要包含RuntimeException等运行时异常和IOException，SQLException等非运行时异常。</p>
<h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><p>包括：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p>
<h5 id="编译器不会检查运行时异常"><a href="#编译器不会检查运行时异常" class="headerlink" title="编译器不会检查运行时异常"></a>编译器不会检查运行时异常</h5><p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p>
<h4 id="非运行时异常（编译异常）"><a href="#非运行时异常（编译异常）" class="headerlink" title="非运行时异常（编译异常）"></a>非运行时异常（编译异常）</h4><p>包括：RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常</p>
<h1 id="考点9-线程安全的集合"><a href="#考点9-线程安全的集合" class="headerlink" title="考点9:线程安全的集合"></a>考点9:线程安全的集合</h1><p>下面哪些具体实现类可以用于存储键,值对,并且方法调用提供了基本的多线程安全支持:()</p>
<ul>
<li>A <code>java.util.ConcurrentHashMap</code></li>
<li>B <code>java.util.Map</code></li>
<li>C <code>java.util.TreeMap</code></li>
<li>D <code>java.util.SortMap</code></li>
<li>E <code>java.util.Hashtable</code></li>
<li>F <code>java.util.HashMap</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AE</details>

<h3 id="Hashtable线程安全"><a href="#Hashtable线程安全" class="headerlink" title="Hashtable线程安全"></a>Hashtable线程安全</h3><p>Hashtable的方法都是synchrnized修饰的，所以线程安全.</p>
<figure class="highlight java"><figcaption><span>java.util.Hashtable.java</span></figcaption><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object value)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;...&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h3 id="ConcurrentXxx线程安全"><a href="#ConcurrentXxx线程安全" class="headerlink" title="ConcurrentXxx线程安全"></a>ConcurrentXxx线程安全</h3><p>ConcurrentHashMap并发容器，JDK7采用分段锁，JDK8采用CAS算法，线程安全，建议使用，</p>
<p><a href="https://blog.csdn.net/xuefeng0707/article/details/40834595">https://blog.csdn.net/xuefeng0707/article/details/40834595</a><br><a href="https://www.jianshu.com/p/863542dcbd5b">https://www.jianshu.com/p/863542dcbd5b</a></p>
<h3 id="Connections-synchrnizedMap-map-非线程安全的Map包装成线程安全的Map"><a href="#Connections-synchrnizedMap-map-非线程安全的Map包装成线程安全的Map" class="headerlink" title="Connections.synchrnizedMap(map)非线程安全的Map包装成线程安全的Map"></a>Connections.synchrnizedMap(map)非线程安全的Map包装成线程安全的Map</h3><p>Connections工具类提供了一个方法synchrnizedMap可以把Map同步，本质就是给每一个方法加上synchrnized关键字进行同步</p>
<h1 id="考点10-Servlet族谱"><a href="#考点10-Servlet族谱" class="headerlink" title="考点10:Servlet族谱"></a>考点10:Servlet族谱</h1><p>下面有关servlet的层级结构和常用的类,说法正确的有?</p>
<ul>
<li>A <code>GenericServlet</code>类:抽象类,定义一个通用的、独立于底层协议的<code>Servlet</code>。</li>
<li>B 大多数<code>Servlet</code>通过从<code>GenericServlet</code>或<code>HttpServlet</code>类进行扩展来实现</li>
<li>C <code>ServletConfig</code>接口定义了在<code>Servlet</code>初始化的过程中由<code>Servlet</code>容器传递给<code>Servlet</code>得配置信息对象</li>
<li>D <code>HttpServletRequest</code>接口扩展<code>ServletRequest</code>接口,为<code>HTTP Servlet</code>提供<code>HTTP</code>请求信息</li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/09/20210902164128.png" alt="1562929_1495091266467_AA89EDF1B0D43CAA9A893C73A1615398"></p>
<h3 id="GenericServlet抽象类"><a href="#GenericServlet抽象类" class="headerlink" title="GenericServlet抽象类"></a>GenericServlet抽象类</h3><p>GenericServlet是个抽象类，必须给出子类才能实例化。它给出了设计servlet的一些骨架，定义了servlet生命周期，还有一些得到名字、配置、初始化参数的方法，其设计的是和应用层协议无关的，也就是说 你有可能用非http协议实现它。</p>
<h3 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h3><p>HttpServlet是GenericServlet的子类，当然就具有GenericServlet的一切特性，还添加了doGet, doPost, doDelete,doPut, doTrace等方法对应处理http协议里的命令的请求响应过程。</p>
<p>一般没有特殊需要，自己写的Servlet都扩展HttpServlet 。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年09月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月03日 java</title>
    <url>/exam//3ad6353c/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1:"></a>考点1:</h1><p>下列说法哪个正确(    )</p>
<ul>
<li>A 不需要定义类,就能创建对象</li>
<li>B 对象中必须有数据域和方法</li>
<li>C 数据域可以是基本类型变量,也可以是一个对象</li>
<li>D 数据域必须是基本类型变量</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>数据域，也就是个成员变量(类的属性)，不包括成员方法。成员变量可以是基本数据类型的变量，也可以是引用数据类型的变量（既可以说一个类的引用，如String str）</p>
<h1 id="考点2-成员变量的初始化"><a href="#考点2-成员变量的初始化" class="headerlink" title="考点2:成员变量的初始化"></a>考点2:成员变量的初始化</h1><p>程序Demo.java编译运行后输出的结果是:( )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> z=<span class="number">2</span>;</span><br><span class="line">        Demo t=<span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        System.out.println(t.x+t.y+z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 3</li>
<li>B 12</li>
<li>C 1</li>
<li>D 5</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h3 id="成员变量有默认初始化"><a href="#成员变量有默认初始化" class="headerlink" title="成员变量有默认初始化"></a>成员变量有默认初始化</h3><p><strong>成员变量和静态变量是有默认值的。</strong></p>
<p>成员变量为int类型可以不初始化，默认值为0</p>
<h3 id="局部变量必须初始化"><a href="#局部变量必须初始化" class="headerlink" title="局部变量必须初始化"></a>局部变量必须初始化</h3><p>局部变量为int类型必须初始化，没有默认值</p>
<p>这题考的是默认初始化问题，但是可以引出另外一个问题：<br><strong>局部变量参与运算前是必须要初始化的</strong>，比如下面的代码就会编译出错，提示y必须要初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器错误提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The local variable y may not have been initialized</span><br></pre></td></tr></table></figure>

<h1 id="考点3-static-访问控制符"><a href="#考点3-static-访问控制符" class="headerlink" title="考点3:static 访问控制符"></a>考点3:static 访问控制符</h1><p>在java中,在同一包内,类Cat里面有个公有方法sleep(),该方法前有static修饰,则可以直接用Cat.sleep()。( )</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>如果是private,则在其他类中<br> 但并且在其他类就不能这么直接用了</p>
<h3 id="访问控制符修饰的成员可见范围"><a href="#访问控制符修饰的成员可见范围" class="headerlink" title="访问控制符修饰的成员可见范围"></a>访问控制符修饰的成员可见范围</h3><table>
<thead>
<tr>
<th align="right">位置</th>
<th align="left">public</th>
<th align="left">protected</th>
<th align="left">default</th>
<th align="left">private</th>
</tr>
</thead>
<tbody><tr>
<td align="right">同一个类中</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
</tr>
<tr>
<td align="right">同一个包中</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">✘</td>
</tr>
<tr>
<td align="right">子类中</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">✘</td>
<td align="left">✘</td>
</tr>
<tr>
<td align="right">全局</td>
<td align="left">√</td>
<td align="left">✘</td>
<td align="left">✘</td>
<td align="left">✘</td>
</tr>
</tbody></table>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4:"></a>考点4:</h1><p>下列表述错误的是？()</p>
<ul>
<li>A <code>int</code>是基本类型,直接存数值,<code>Integer</code>是对象,用一个引用指向这个对象。</li>
<li>B 在子类构造方法中使用<code>super()</code>显示调用父类的构造方法,<code>super()</code>必须写在子类构造方法的第一行,否则编译不通过</li>
<li>C 封装的主要作用在于对外隐藏内部实现细节,可以增强程序的安全性</li>
<li>D <code>final</code>是<code>java</code>中的修饰符,可以修饰类、接口、抽象类、方法和属性。</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h3 id="abstract和final矛盾"><a href="#abstract和final矛盾" class="headerlink" title="abstract和final矛盾"></a>abstract和final矛盾</h3><p>抽象类：子类可以继承和重写；<br>final：类不允许被重写；<br>故，final不能修饰抽象类，否则自相矛盾。</p>
<h1 id="考点5-访问控制符"><a href="#考点5-访问控制符" class="headerlink" title="考点5:访问控制符"></a>考点5:访问控制符</h1><p>下列哪个修饰符可以使在一个类中定义的成员变量只能被同一包中的类访问？</p>
<ul>
<li>A <code>private</code></li>
<li>B 无修饰符</li>
<li>C <code>public</code></li>
<li>D <code>protected</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="访问控制符修饰的成员可见范围-1"><a href="#访问控制符修饰的成员可见范围-1" class="headerlink" title="访问控制符修饰的成员可见范围"></a>访问控制符修饰的成员可见范围</h3><table>
<thead>
<tr>
<th align="right">位置</th>
<th align="left">public</th>
<th align="left">protected</th>
<th align="left">无修饰符</th>
<th align="left">private</th>
</tr>
</thead>
<tbody><tr>
<td align="right">同一个类中</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
</tr>
<tr>
<td align="right">同一个包中</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">✘</td>
</tr>
<tr>
<td align="right">子类中</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">✘</td>
<td align="left">✘</td>
</tr>
<tr>
<td align="right">全局</td>
<td align="left">√</td>
<td align="left">✘</td>
<td align="left">✘</td>
<td align="left">✘</td>
</tr>
</tbody></table>
<img data-src="http://uploadfiles.nowcoder.com/images/20150921/458054_1442766565525_E93E59ACFE1791E0A5503384BEBDC544">

<h4 id="包访问权限"><a href="#包访问权限" class="headerlink" title="包访问权限"></a>包访问权限</h4><p><strong>无修饰符</strong>就是<strong>默认权限</strong>，也叫<strong>包访问权限</strong>，只能被同一包内的类访问。</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6:"></a>考点6:</h1><p>已知如下类说明:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> f=<span class="number">1.0f</span>;</span><br><span class="line">    <span class="type">int</span> m=<span class="number">12</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> n=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        Test t=<span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在main方法中</strong>如下哪些使用是正确的()</p>
<ul>
<li>A <code>t.f = 1.0</code></li>
<li>B <code>this.n</code></li>
<li>C <code>Test.m</code></li>
<li>D <code>Test.n</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<p>A. 1.0默认为double类型，float f &#x3D; 1.0编译出错，如果是float f&#x3D; 1或者float f&#x3D;1.0f就可以通过<br>编译器报错如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Type mismatch: cannot convert from double to float</span><br></pre></td></tr></table></figure>
<p>B. main方式是static修饰的，main方法存在时，当前对象还没有初始化，也就是没有this引用。<br>编译器报错如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cannot use this in a static context</span><br></pre></td></tr></table></figure>
<p>C. m不是static的，需要依附于对象存在，不能通过类名调用。<br>编译器报错如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cannot make a static reference to the non-static field Test.m</span><br></pre></td></tr></table></figure>



<h1 id="考点7-访问控制符"><a href="#考点7-访问控制符" class="headerlink" title="考点7:访问控制符"></a>考点7:访问控制符</h1><p>访问权限控制从最大权限到最小权限依次为:public、 包访问权限、protected和private 。(   )</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="访问控制符从大到小"><a href="#访问控制符从大到小" class="headerlink" title="访问控制符从大到小"></a>访问控制符从大到小</h3><table>
<thead>
<tr>
<th align="right">位置</th>
<th align="left">public</th>
<th align="left">protected</th>
<th align="left">无修饰符</th>
<th align="left">private</th>
</tr>
</thead>
<tbody><tr>
<td align="right">同一个类中</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
</tr>
<tr>
<td align="right">同一个包中</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">✘</td>
</tr>
<tr>
<td align="right">子类中</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">✘</td>
<td align="left">✘</td>
</tr>
<tr>
<td align="right">全局</td>
<td align="left">√</td>
<td align="left">✘</td>
<td align="left">✘</td>
<td align="left">✘</td>
</tr>
</tbody></table>
<h1 id="考点8-哪个式子有可能在某个进制下成立"><a href="#考点8-哪个式子有可能在某个进制下成立" class="headerlink" title="考点8:哪个式子有可能在某个进制下成立"></a>考点8:哪个式子有可能在某个进制下成立</h1><p>以下哪个式子有可能在某个进制下成立()？</p>
<ul>
<li>A 13*14&#x3D;204</li>
<li>B 12*34&#x3D;568</li>
<li>C 14*14&#x3D;140</li>
<li>D 1+1&#x3D;3</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h3 id="N进制按权展开"><a href="#N进制按权展开" class="headerlink" title="N进制按权展开"></a>N进制按权展开</h3><h4 id="A选项"><a href="#A选项" class="headerlink" title="A选项"></a>A选项</h4><p>$$<br>13 \times 14&#x3D;204<br>$$</p>
<p>设在$x$​进制下该式子成立，按$x$​展开得到：</p>
<p>$$<br>\begin{aligned}<br>(1\times x^1+3\times x^0)\times (1\times x^1+4\times x^0)&amp;&#x3D;2\times x^2+0\times x^1+4\times x^0\\<br>(x+3)\times(x+4)&amp;&#x3D;2x^2+4\\<br>x^2+7x+12&amp;&#x3D;2x^2+4\\<br>7x+8&amp;&#x3D;x^2\\<br>x^2-7x-8&amp;&#x3D;0<br>\end{aligned}<br>$$</p>
<p>这是个一元二次方程，使用韦达定理</p>
<p>$$<br>x &#x3D;{-b \pm \sqrt{b^2-4ac}\over 2a}<br>$$</p>
<p>来求解：</p>
<p>$$<br>\sqrt{b^2-4ac}&#x3D;\sqrt{(-7)^2-4\times 1\times(-8)}&#x3D;\sqrt{81}&#x3D;9<br>$$</p>
<p>$$<br>x_1 &#x3D;{-b + \sqrt{b^2-4ac}\over 2a}<br>&#x3D;\frac{-(-7)+9}{2\times 1}<br>&#x3D;\frac{16}{2}&#x3D;8<br>$$</p>
<p>$$<br>x_2&#x3D;{-b - \sqrt{b^2-4ac}\over 2a}<br>&#x3D;\frac{-(-7)-9}{2\times 1}<br>&#x3D;\frac{-2}{2}<br>&#x3D;-1<br>$$</p>
<p>得到 $x_1&#x3D;8$​​ , $x_2&#x3D;-1$​​,</p>
<p>没有$-1$进制，排除$x_2$​​.</p>
<p>所以在$8$​​进制下，这个式子成立。A选项正确</p>
<h4 id="B选项"><a href="#B选项" class="headerlink" title="B选项"></a>B选项</h4><p>$$<br>12\times 34&#x3D;568<br>$$</p>
<p>设在x进制下，这个式子成立，则：</p>
<p>$$<br>\begin{aligned}<br>(x+2)(3x+4)&amp;&#x3D;5x^2+6x+8\\<br>3x^2+4x+6x+8&amp;&#x3D;5x^2+6x+8\\<br>3x^2+4x&amp;&#x3D;5x^2\\<br>4x&amp;&#x3D;2x^2\\<br>2x&amp;&#x3D;x^2\\<br>x^2-2x&amp;&#x3D;0\\<br>x(x-2)&amp;&#x3D;0\\<br>\end{aligned}<br>$$</p>
<p>解得</p>
<p>$$<br>x_1&#x3D;0,x_2&#x3D;2<br>$$</p>
<p>没有0进制，$x_1$​排除,</p>
<p>$N$​进制的最大的数为$N-1$​</p>
<p>2进制的最大的数为1，式子$12\times 34&#x3D;568$中2,3,4,5,6,8都大于2进制的数1.</p>
<p>$x_2$​​排除所以式子不成立，<strong>B选项错误</strong></p>
<h4 id="C选项"><a href="#C选项" class="headerlink" title="C选项"></a>C选项</h4><p>$$<br>\begin{aligned}<br>(x+4)(x+4)&amp;&#x3D;x^2+4x\\<br>x^2+4x+4x+16&amp;&#x3D;x^2+4x\\<br>4x+16&amp;&#x3D;0\\<br>\end{aligned}<br>$$</p>
<p>解得$x&#x3D;-4$。没有$-4$进制，C选项错误</p>
<h4 id="D选项"><a href="#D选项" class="headerlink" title="D选项"></a>D选项</h4><p>$$\begin{aligned}<br>1\times x^0+1\times x^0&amp;&#x3D;3\times x^0\\<br>2 \times x^0&amp;&#x3D;3\times x^0\\<br>0&amp;&#x3D;1\times x^0\\<br>0&amp;&#x3D;1\times 1\\<br>\end{aligned}<br>$$</p>
<p>得到<br>$$<br>0&#x3D;1<br>$$<br>实际上，<strong>0不等于1</strong>，<strong>D选项错误</strong></p>
<h1 id="考点9-线程安全"><a href="#考点9-线程安全" class="headerlink" title="考点9:线程安全"></a>考点9:线程安全</h1><p>下列那些方法是线程安全的(所调用的方法都存在)</p>
<ul>
<li><code>A public class MyServlet implements Servlet &#123; public void service (ServletRequest req, ServletResponse resp) &#123; BigInteger I = extractFromRequest(req); encodeIntoResponse(resp,factors); &#125; &#125;</code></li>
<li>B <code>public class MyServlet implements Servlet &#123; private long count =0; public long getCount() &#123; return count; &#125; public void service (ServletRequest req, ServletResponse resp) &#123; BigInteger I = extractFromRequest(req); BigInteger[] factors = factor(i); count ++; encodeIntoResponse(resp,factors); &#125; &#125;</code></li>
<li>C <code>public class MyClass &#123; private int value; public synchronized int get() &#123; return value; &#125; public synchronized void set (int value) &#123; this.value = value; &#125; &#125;</code></li>
<li>D <code>public class Factorizer implements Servlet &#123; private volatile MyCache cache = new MyCache(null,null); public void service(ServletRequest req, ServletResponse resp) &#123; BigInteger i = extractFromRequest(req); BigInteger[] factors = cache.getFactors(i); if (factors == null) &#123; factors = factor(i); cache = new MyCache(i,factors); &#125; encodeIntoResponse(resp,factors); &#125;</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details>

<p>这种题排版真变态：<br>A</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span> <span class="params">(ServletRequest req, ServletResponse resp)</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">I</span> <span class="operator">=</span> extractFromRequest(req); encodeIntoResponse(resp,factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCount</span><span class="params">()</span> &#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span> <span class="params">(ServletRequest req, ServletResponse resp)</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">I</span> <span class="operator">=</span> extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = factor(i);</span><br><span class="line">        count ++;</span><br><span class="line">        encodeIntoResponse(resp,factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">set</span> <span class="params">(<span class="type">int</span> value)</span> &#123; <span class="built_in">this</span>.value = value; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>D</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factorizer</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">MyCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCache</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = cache.getFactors(i);</span><br><span class="line">        <span class="keyword">if</span> (factors == <span class="literal">null</span>) &#123;</span><br><span class="line">            factors = factor(i);</span><br><span class="line">            cache = <span class="keyword">new</span> <span class="title class_">MyCache</span>(i, factors);</span><br><span class="line">        &#125;</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义Servlet时尽量不要定义成员变量，多线程环境下定义的成员变量会成为线程共享变量，导致数据不一致问题。<br>A 无状态的，天然线程安全<br>B 存在静态条件变量count<br>C 涉及写的set方法使用了synchronize关键字，线程安全<br>D 使用了volatile关键字和null的判断，可能不存在重排序的问题，不懂这个 欢迎指正，说的可能不对。</p>
<h3 id="怎样做到线程安全"><a href="#怎样做到线程安全" class="headerlink" title="怎样做到线程安全"></a>怎样做到线程安全</h3><p><strong>一个对象是否安全取决于它是否被多个线程访问</strong>（访问时访问对象的方式）。<br>要使对象线程安全，那么需要采用同步的机制来协同对对象可变状态的访问。（java这边采用synchronized，其他还有volatile类型的变量，显式锁以及原子变量）</p>
<p>当某个多线程访问同一个可变状态时候没有同步，则会出现错误，解决办法：</p>
<p>1、不在线程之间共享该变量<br>2、将该变量修改为不可变变量<br>3、访问状态时候使用同步</p>
<h4 id="安全性的解释："><a href="#安全性的解释：" class="headerlink" title="安全性的解释："></a>安全性的解释：</h4><p>当多线程访问某个类时，这个类始终能表现出正确的行为（不管运行时采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同），那么这个类安全的。</p>
<ul>
<li>无状态对象一定是线程安全的。</li>
<li>在实际情况下，尽可能使用户现有的线程安全对象，比如用Vector而不是ArrayList。</li>
</ul>
<h4 id="原子性-可见性-有序性"><a href="#原子性-可见性-有序性" class="headerlink" title="原子性 可见性 有序性"></a>原子性 可见性 有序性</h4><p>要想并发程序正确地执行，必须要保证“原子性”、“可见性”以及“有序性”。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>
<h1 id="考点10-CMS垃圾回收器"><a href="#考点10-CMS垃圾回收器" class="headerlink" title="考点10:CMS垃圾回收器"></a>考点10:CMS垃圾回收器</h1><p>CMS垃圾回收器在那些阶段是没用用户线程参与的</p>
<ul>
<li>A 初始标记</li>
<li>B 并发标记</li>
<li>C 重新标记</li>
<li>D 并发清理</li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年09月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月04日 java</title>
    <url>/exam//5eb758f5/</url>
    <content><![CDATA[<h1 id="考点1-访问控制权限修饰符"><a href="#考点1-访问控制权限修饰符" class="headerlink" title="考点1:访问控制权限修饰符"></a>考点1:访问控制权限修饰符</h1><p>下列修饰符中与访问控制权限无关的是？( )</p>
<ul>
<li>A <code>private</code></li>
<li>B <code>public</code></li>
<li>C <code>protected</code></li>
<li>D <code>final</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h3 id="java常见修饰符"><a href="#java常见修饰符" class="headerlink" title="java常见修饰符"></a>java常见修饰符</h3><h4 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h4><p>private: 修饰私有变量<br>默认修饰符default（不用把default写出来）： 比private限制更少，但比protected限制更多<br>protected: 修饰受保护变量<br>public: 修饰公有变量 </p>
<h4 id="状态修饰符"><a href="#状态修饰符" class="headerlink" title="状态修饰符"></a>状态修饰符</h4><p>final 最终变量（final修饰类，该类不能被继承，final修饰方法，该方法不能被重写，final修饰变量，该变量不能被重新赋值（相当于常量））<br>static 静态变量（随着类的加载而加载，优先于对象存在，被所有对象所共享，可以通过类名调用）</p>
<h4 id="抽象修饰符"><a href="#抽象修饰符" class="headerlink" title="抽象修饰符"></a>抽象修饰符</h4><p>abstract 抽象类&amp;抽象方法（抽象类不能被实例化，抽象类中不一定有抽象方法，但有抽象方法的类必须定义为抽象类）</p>
<h1 id="考点2-main方法"><a href="#考点2-main方法" class="headerlink" title="考点2:main方法"></a>考点2:main方法</h1><p>Java Application 中的主类需包含main方法,以下哪项是main方法的正确形参？(    )</p>
<ul>
<li>A <code>String args</code></li>
<li>B <code>String[] args</code></li>
<li>C <code>Char arg</code></li>
<li>D <code>StringBuffer[] args</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>


<h1 id="考点3-重载"><a href="#考点3-重载" class="headerlink" title="考点3:重载"></a>考点3:重载</h1><p>类 ABC 定义如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABC</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将以下哪个方法插入行 3 是不合法的。()</p>
<ul>
<li>A <code>public float max(float a, float b, float c)&#123; &#125;</code></li>
<li>B <code>public double max (double c, double d)&#123; &#125;</code></li>
<li>C <code>public float max(float a, float b)&#123; &#125;</code></li>
<li>D <code>private int max(int a, int b, int c)&#123; &#125;</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="重载要求：两同一不同"><a href="#重载要求：两同一不同" class="headerlink" title="重载要求：两同一不同"></a>重载要求：两同一不同</h3><p><strong>重载要求方法的参数列表需要不一样</strong>（个数，或者参数类型），修改参数名或者修改返回值以及访问权限并没有用</p>
<h1 id="考点4-异常try-catch-finally执行流程"><a href="#考点4-异常try-catch-finally执行流程" class="headerlink" title="考点4:异常try-catch-finally执行流程"></a>考点4:异常try-catch-finally执行流程</h1><p>AccessViolationException异常触发后,下列程序的输出结果为(      )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Main</span><span class="params">(string[] args)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">try</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccessViolationException</span>();  </span><br><span class="line">        Console.WriteLine(<span class="string">&quot;error1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">catch</span> (Exception e)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Console.WriteLine(<span class="string">&quot;error2&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;error3&quot;</span>);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>A <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error2</span><br><span class="line">error3</span><br></pre></td></tr></table></figure></li>
<li>B <code>error3</code></li>
<li>C <code>error2</code></li>
<li>D <code>error1</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h1 id="考点5-集合HashMap的key和value可以为null-放入时如果key相同-则新value覆盖旧的value"><a href="#考点5-集合HashMap的key和value可以为null-放入时如果key相同-则新value覆盖旧的value" class="headerlink" title="考点5:集合HashMap的key和value可以为null,放入时如果key相同,则新value覆盖旧的value"></a>考点5:集合HashMap的key和value可以为null,放入时如果key相同,则新value覆盖旧的value</h1><p>以下java程序代码,执行后的结果是()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.HashMap map=<span class="keyword">new</span> <span class="title class_">java</span>.util.HashMap();</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">System.out.println(map.size());</span><br></pre></td></tr></table></figure>
<ul>
<li>A 0</li>
<li>B <code>null</code></li>
<li>C 1</li>
<li>D 2</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<ul>
<li>HashMap可以插入null的key或value。</li>
<li>插入的时候，检查是否已经存在相同的key，<ul>
<li>如果不存在，则直接插入，</li>
<li>如果存在，则用新的value替换旧的value。<br>在本题中，第一条put语句，会将key&#x2F;value对插入HashMap，而第二条put，因为已经存在一个key为name的项，所以会用新的value替换旧的value，<br>因此，两条put之后，HashMap中只有一个key&#x2F;value键值对。那就是（name，jack）。所以，size为1.</li>
</ul>
</li>
</ul>
<h1 id="考点6-boolean变量只能和boolean变量比较"><a href="#考点6-boolean变量只能和boolean变量比较" class="headerlink" title="考点6:boolean变量只能和boolean变量比较"></a>考点6:boolean变量只能和boolean变量比较</h1><p>已知<code>boolean result = false</code>,则下面哪个选项是合法的:</p>
<ul>
<li>A <code>result=1</code></li>
<li>B <code>result=true;</code></li>
<li>C <code>if(result!=0) &#123;//so something…&#125;</code></li>
<li>D <code>if(result) &#123;//do something…&#125;</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BD</details>


<p>1、boolean类型只有两个直接量值:true和false.<br>2、除成员变量会有默认初始值外，其他变量必须在第一次使用之前初始化</p>
<p>boolean类型的默认值是false;</p>
<h3 id="基本数据类型的默认值（成员变量）"><a href="#基本数据类型的默认值（成员变量）" class="headerlink" title="基本数据类型的默认值（成员变量）"></a>基本数据类型的默认值（成员变量）</h3><p>其余的7种基本类型默认值：<br>byte是 (byte)0；<br>short是 (short)0；<br>int是 0；<br>long是 0L；<br>float 是0.0f；<br>double 是0.0d；<br>char是 \u0000.<br>String是null.</p>
<h1 id="考点7-java关键字和常量"><a href="#考点7-java关键字和常量" class="headerlink" title="考点7:java关键字和常量"></a>考点7:java关键字和常量</h1><p>下列不是 Java 关键字的是 ( )</p>
<ul>
<li>A <code>abstract</code></li>
<li>B <code>false</code></li>
<li>C <code>native</code></li>
<li>D <code>sizeof</code></li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BD</details>


<h3 id="Java中的关键字有哪些"><a href="#Java中的关键字有哪些" class="headerlink" title="Java中的关键字有哪些"></a>Java中的关键字有哪些</h3><p>答：1）48个关键字：<code>abstract</code>、<code>assert</code>、<code>boolean</code>、<code>break</code>、<code>byte</code>、<code>case</code>、<code>catch</code>、<code>char</code>、<code>class</code>、<code>continue</code>、<code>default</code>、<code>do</code>、<code>double</code>、<code>else</code>、<code>enum</code>、<code>extends</code>、<code>final</code>、<code>finally</code>、<code>float</code>、<code>for</code>、<code>if</code>、<code>implements</code>、<code>import</code>、<code>int</code>、<code>interface</code>、<code>instanceof</code>、<code>long</code>、<code>native</code>、<code>new</code>、<code>package</code>、<code>private</code>、<code>protected</code>、<code>public</code>、<code>return</code>、<code>short</code>、<code>static</code>、<code>strictfp</code>、<code>super</code>、<code>switch</code>、<code>synchronized</code>、<code>this</code>、<code>throw</code>、<code>throws</code>、<code>transient</code>、<code>try</code>、<code>void</code>、<code>volatile</code>、<code>while</code>。 </p>
<h3 id="Java保留字"><a href="#Java保留字" class="headerlink" title="Java保留字"></a>Java保留字</h3><p>2）2个保留字（现在没用以后可能用到作为关键字）：<code>goto</code>、<code>const</code>。</p>
<h3 id="Java特殊直接量-Java常量"><a href="#Java特殊直接量-Java常量" class="headerlink" title="Java特殊直接量 Java常量"></a>Java特殊直接量 Java常量</h3><p>3）3个特殊直接量：<code>true</code>、<code>false</code>、<code>null</code>。</p>
<h1 id="考点8-暂时不懂：Jvm垃圾回收"><a href="#考点8-暂时不懂：Jvm垃圾回收" class="headerlink" title="考点8:暂时不懂：Jvm垃圾回收"></a>考点8:暂时不懂：Jvm垃圾回收</h1><p>以下哪些jvm的垃圾回收方式采用的是复制算法回收</p>
<ul>
<li>A 新生代串行收集器</li>
<li>B 老年代串行收集器</li>
<li>C 并行收集器</li>
<li>D 新生代并行回收收集器</li>
<li>E 老年代并行回收收集器</li>
<li>F <code>cms</code>收集器</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details>



<p>答案AD<br>新生代串行收集&#x2F;并行回收器：复制算法；<br>老年代串行收集&#x2F;并行回收器：标记-压缩算法；<br>并行收集器：将串行收集器多线程化，回收策略和串行收集器一致，因此该收集器是新生代为复制算法，老年代为标记-压缩算法。<br>CMS收集器：Concurrent Mark Sweep,从名字就能知道使用的是多线程的标记-清除算法。</p>
<p>在垃圾的分代回收机制中<br>新生代一般采用“复制”算法：因为新生代每次都有大批量对象死去，就以少量对象的复制成本完成收集<br>老年代一般采用“标记-整理&#x2F;清除”算法：因为对象存活率高，且没有额外内存，故采用“标记-整理”或者“标记-清除”</p>
<h3 id="两个最基本的java回收算法：复制算法和标记清理算法"><a href="#两个最基本的java回收算法：复制算法和标记清理算法" class="headerlink" title="两个最基本的java回收算法：复制算法和标记清理算法"></a>两个最基本的java回收算法：复制算法和标记清理算法</h3><p>复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为<strong>新生代最常用的算法</strong><br>标记清理：一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出 标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象</p>
<h3 id="两个概念：新生代和年老代"><a href="#两个概念：新生代和年老代" class="headerlink" title="两个概念：新生代和年老代"></a>两个概念：新生代和年老代</h3><p>新生代：初始对象，生命周期短的<br>永久代：长时间存在的对象</p>
<p>整个java的垃圾回收是新生代和年老代的协作，这种叫做<strong>分代回收</strong>。<br>P.S：Serial New收集器是针对新生代的收集器，采用的是复制算法<br>Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理<br>Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法<br>Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理<br>Parallel Old（并行）收集器，针对老年代，标记整理 CMS收集器，基于标记清理<br>G1收集器：整体上是基于标记 整理 ，局部采用复制</p>
<p><strong>综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理</strong>。</p>
<h1 id="考点9-int赋值给Integer时自动装箱-Integer自动装箱时-128-127范围内使用缓存数组中的值-Integer和int比较时自动拆箱然后比较值"><a href="#考点9-int赋值给Integer时自动装箱-Integer自动装箱时-128-127范围内使用缓存数组中的值-Integer和int比较时自动拆箱然后比较值" class="headerlink" title="考点9:int赋值给Integer时自动装箱 Integer自动装箱时-128~+127范围内使用缓存数组中的值 Integer和int比较时自动拆箱然后比较值"></a>考点9:int赋值给Integer时自动装箱 Integer自动装箱时-128~+127范围内使用缓存数组中的值 Integer和int比较时自动拆箱然后比较值</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a1=<span class="number">17</span>,b2=<span class="number">17</span>;</span><br><span class="line">Integer b1=<span class="number">2017</span>,b2=<span class="number">2017</span>;</span><br><span class="line">Integer c1=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">17</span>);</span><br><span class="line">Integer c2=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">17</span>);</span><br><span class="line">Integer d1=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2017</span>);</span><br><span class="line"><span class="type">int</span> d2=<span class="number">2017</span>;</span><br></pre></td></tr></table></figure>
<p>以下语句返回值为 true 的2是()</p>
<ul>
<li>A <code>a1==a2</code></li>
<li>B <code>d1==d2</code></li>
<li>C <code>b1==b2</code></li>
<li>D <code>c1==c2</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AB</details>

<h3 id="Integer缓存-128到-127"><a href="#Integer缓存-128到-127" class="headerlink" title="Integer缓存-128到+127"></a>Integer缓存-128到+127</h3><p>选<strong>A,B</strong>. Integer a1 &#x3D; 17; 语句执行的是valueOf()方法</p>
<figure class="highlight java"><figcaption><span>G:\java\java8\jdk-8u221\src.zip!\java\lang\Integer.java</span></figcaption><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p><strong>对于-128到127之间的数, Integer直接从数组中取</strong>, 故a1, a2指向的是同一个对象, A正确. </p>
<p>其余都是new出来的对象, 显然地址都不相同.</p>
<h3 id="int与Integer比较时-只比较值"><a href="#int与Integer比较时-只比较值" class="headerlink" title="int与Integer比较时 只比较值"></a>int与Integer比较时 只比较值</h3><p>int类型与Integer类型比较时, 先将Integer拆箱, 再比较值, 故B正确.</p>
<h1 id="考点10-正则表达式身份证号"><a href="#考点10-正则表达式身份证号" class="headerlink" title="考点10:正则表达式身份证号"></a>考点10:正则表达式身份证号</h1><p>关于身份证号,以下正确的正则表达式为(      )</p>
<ul>
<li>A <code>isIDCard=/^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$/;</code></li>
<li>B <code>isIDCard=/^[1-9]\d&#123;7&#125;((9\d)|(1[0-2]))(([0|1|2]\d)|3[9-1])\d&#123;3&#125;$/;</code></li>
<li>C <code>isIDCard=/^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;4&#125;$/;</code></li>
<li>D <code>isIDCard=/^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((9\d)|(1[9-2]))(([0|1|2]\d)|3[9-1])\d&#123;4&#125;$/;</code></li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

<p>正确选项<br>A选项：<code>isIDCard=/^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$/</code><br>C选项：<code>isIDCard=/^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;4&#125;$/</code></p>
<h3 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h3><p><code>^</code>：起始符号，<code>^x</code>表示以x开头<br><code>$</code>：结束符号，<code>x$</code>表示以x结尾<br><code>[n-m]</code>：表示从n到m的数字<br><code>\d</code>：表示数字，等同于<code>[0-9]</code><br><code>X&#123;m&#125;</code>：表示由m个X字符构成，<code>\d&#123;4&#125;</code>表示4位数字</p>
<h3 id="身份证构成-15位-18位"><a href="#身份证构成-15位-18位" class="headerlink" title="身份证构成 15位 18位"></a>身份证构成 15位 18位</h3><p>15位身份证的构成：六位出生地区码+六位出身日期码+三位顺序码<br>18位身份证的构成：六位出生地区码+八位出生日期码+三位顺序码+一位校验码</p>
<p>C选项的构成：<br><code>[1-9]\d&#123;5&#125;</code>：六位出生地区码，出生地区码没有以0开头，因此第一位为<code>[1-9]</code>。<br><code>[1-9]\d&#123;3</code>}：八位出生日期码的四位年份，同样年份没有以0开头。<br><code>((0\d)|(1[0-2]))</code>：八位出生日期码的两位月份，<code>|</code> 表示或者，月份的形式为<code>0\d</code>或者是<code>10</code>、<code>11</code>、<code>12</code>。<br><code>(([0|1|2]\d)|3[0-1])</code>：八位出生日期码的两位日期，日期由01至31。<br><code>\d&#123;4&#125;</code>：三位顺序码+一位校验码，共四位。</p>
<p>A选项的构成：<br><code>[1-9]\d&#123;7&#125;</code>：六位出生地区码+两位出生日期码的年份，这里的年份指后两位，因此没有第一位不能为0的限制，所以合并了。<br>后面的与C选项类似了。<br>好吧其实我也是第一次知道身份证还有15位的。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年09月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月04日 java2</title>
    <url>/exam//80497ddb/</url>
    <content><![CDATA[<h1 id="考点1-java常识"><a href="#考点1-java常识" class="headerlink" title="考点1:java常识"></a>考点1:java常识</h1><p>下列描述中,错误的是( )</p>
<ul>
<li>A <code>java</code>要求编程者管理内存</li>
<li>B <code>java</code>的安全性体现在多个层次上</li>
<li>C <code>java</code>中没有指针机制</li>
<li>D <code>java</code>有多线程机制</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<p>Java与C++的区别在于：Java去除了指针的概念，使用引用，并且Java的内存管理不需要程序员来管理，由Java虚拟机来完成对内存的管理</p>
<h1 id="考点2-abstract-final-static-native"><a href="#考点2-abstract-final-static-native" class="headerlink" title="考点2:abstract final static native"></a>考点2:abstract final static native</h1><p>若在某一个类定义中定义有如下的方法: abstract void performDial( ); 该方法属于()</p>
<ul>
<li>A 本地方法</li>
<li>B 最终方法</li>
<li>C 解态方法</li>
<li>D 抽象方法</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<ul>
<li><strong>本地方法</strong>：简单地讲，一个native Method就是<strong>一个java调用非java代码的接口</strong>；native方法表示该方法要<strong>用另外一种依赖平台的编程语言实现。</strong></li>
<li><strong>最终方法</strong>：<u><strong>final void B(){}</strong></u>,这样定义的方法就是最终方法，最终方法在子类中不可以被重写，也就是说，如果有个子类继承了这个最终方法所在的类，那么这个子类中不能出现void B(){}这样的方法。</li>
<li>最终类：**final class A {},**这样定义的类就是最终类，最终类不能被继承。</li>
<li><strong>abstract</strong>修饰抽象类</li>
</ul>
<p>A.v<strong>JAVA中有两种方法：JAVA方法和本地方法。</strong> JAVA方法是由JAVA编写的，编译成字节码，存储在class文件中； 本地方法是由其它语言编写的，编译成和处理器相关的机器代码，本地方法保存在<strong>动态链接库</strong>中，即<code>.dll</code>(windows系统)文件中，格式是各个平台专有的。<br>JAVA方法是与平台无关的，但是本地方法不是。<br>B.<strong>final void A() {}，这样定义的方法就是最终方法，最终方法在子类中不可以被重写。</strong> 也就是说，如果有个子类继承这个最终方法所在的类，那么这个子类中就不能再出现void A() {}这样的方法了。<br>C.不存在解态方法这种东西，应该是笔误打错了，是静态方法。 <strong>静态方法的使用完全独立于该类的任何对象</strong>。 在类中使用static修饰的静态方随着类的定义而被分配和装载入内存中；而非静态方法属于对象的具体实例，只有在类的对象创建时在对象的内存中才有这个方法的代码段。</p>
<h1 id="考点3-GUI"><a href="#考点3-GUI" class="headerlink" title="考点3:GUI"></a>考点3:GUI</h1><p>在委托事件模型中,源生成事件并把它发送给一个或多个监听器,每个监听器必须向事件源注册。</p>
<ul>
<li>A T</li>
<li>B F</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<h1 id="考点4-实例变量-局部变量-final变量"><a href="#考点4-实例变量-局部变量-final变量" class="headerlink" title="考点4:实例变量 局部变量 final变量"></a>考点4:实例变量 局部变量 final变量</h1><p>下面有关java实例变量,局部变量,类变量和final变量的说法,错误的是？</p>
<ul>
<li>A 实例变量指的是类中定义的变量,即成员变量,如果没有初始化,会有默认值。</li>
<li>B 局部变量指的是在方法中定义的变量,如果没有初始化,会有默认值</li>
<li>C 类变量指的是用<code>static</code>修饰的属性</li>
<li>D <code>final</code>变量指的是用<code>final</code> 修饰的变量</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="局部变量必须初始化"><a href="#局部变量必须初始化" class="headerlink" title="局部变量必须初始化"></a>局部变量必须初始化</h3><p>定义在类中的变量是类的成员变量，可以不进行初始化，Java会自动进行初始化，如果是引用类型默认初始化为null,如果是基本类型例如int则会默认初始化为0<br><strong>局部变量是定义在方法中的变量，必须要进行初始化，否则不同通过编译</strong><br>被static关键字修饰的变量是静态的，静态变量随着类的加载而加载，所以也被称为类变量<br>被final修饰发变量是常量</p>
<h3 id="为什么局部变量不会默认初始化"><a href="#为什么局部变量不会默认初始化" class="headerlink" title="为什么局部变量不会默认初始化"></a>为什么局部变量不会默认初始化</h3><p><strong>局部变量是指类方法中的变量，必须初始化</strong>。局部变量运行时被分配在栈中，量大，生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值。</p>
<h3 id="变量分类"><a href="#变量分类" class="headerlink" title="变量分类"></a>变量分类</h3><p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/09/20210904224736.png" alt="image-20210904224728900"></p>
<h1 id="考点5-集合-Collection和Collections"><a href="#考点5-集合-Collection和Collections" class="headerlink" title="考点5:集合 Collection和Collections"></a>考点5:集合 Collection和Collections</h1><p>对Collection和Collections描述正确的是</p>
<ul>
<li>A <code>Collection</code>是<code>java.util</code>下的类,它包含有各种有关集合操作的静态方法</li>
<li>B <code>Collection</code>是<code>java.util</code>下的接口,它是各种集合结构的父接口</li>
<li>C <code>Collections</code>是<code>java.util</code>下的接口,它是各种集合结构的父接口</li>
<li>D <code>Collections</code>是<code>java.util</code>下的类,它包含有各种有关集合操作的静态方法</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BD</details>

<p>java.util.Collection<br>是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java<br>类库中有很多具体的实现。Collection接口的意义是<strong>为各种具体的集合提供了最大化的统一操作方式</strong>。</p>
<ul>
<li>Collection是单列集合的顶层接口,</li>
<li>Map是双列集合的顶层接口</li>
<li>Collections是一个集合的工具类，提供了排序、查找等操作集合的一些常用方法</li>
</ul>
<h1 id="考点6-java构造函数"><a href="#考点6-java构造函数" class="headerlink" title="考点6:java构造函数"></a>考点6:java构造函数</h1><p>下列有关java构造函数叙述正确的是()</p>
<ul>
<li>A 构造器的返回值为<code>void</code>类型</li>
<li>B 如果一个源文件中有多个类,那么构造器必须与公共类同名</li>
<li>C 构造器可以有0个,1个或一个以上的参数</li>
<li>D 每个类可以有一个以上的构造器</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: CD</details>


<h1 id="考点7-has-a-is-a-子类通过继承得到父类的成员"><a href="#考点7-has-a-is-a-子类通过继承得到父类的成员" class="headerlink" title="考点7:has-a is-a 子类通过继承得到父类的成员"></a>考点7:has-a is-a 子类通过继承得到父类的成员</h1><p>Gadget has-a Sprocket and Gadget has-a Spring and Gadget is-a Widget and Widget has-<br>a Sprocket</p>
<p>以下哪两段代码可以表示这个关系? (选择两项) (    )</p>
<ul>
<li>A <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; Sprocket s; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gadget</span> <span class="keyword">extends</span> <span class="title class_">Widget</span> &#123; Spring s; &#125;</span><br></pre></td></tr></table></figure></li>
<li>B<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gadget</span> <span class="keyword">extends</span> <span class="title class_">Widget</span> &#123; Spring s1; Sprocket s2; &#125;</span><br></pre></td></tr></table></figure></li>
<li>C<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; Sprocket s1; Spring s2; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gadget</span> <span class="keyword">extends</span> <span class="title class_">Widget</span> &#123; &#125;</span><br></pre></td></tr></table></figure></li>
<li>D<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Gadget</span> &#123; Spring s; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> <span class="keyword">extends</span> <span class="title class_">Gadget</span>&#123; Sprocket s; &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

<p>is-a表示继承：Gadget is-a Widget就表示Gadget 继承 Widget；<br>has-a表示从属：Gadget has-a Sprocket就表示Gadget中有Sprocket的引用，Sprocket是Gadget的组成部分；<br>like-a表示组合：如果A like-a B，那么B就是A的接口</p>
<p>从题目中可以得出以下几个结论：</p>
<ul>
<li><p>Gadget中有对Sprocket的引用。</p>
</li>
<li><p>Gadget中有对Spring的引用。</p>
</li>
<li><p>Gadget继承了Widget。</p>
</li>
<li><p>Widget中有对Sprocket的引用。</p>
</li>
<li><p>A <pre>class Widget { Sprocket s; }<br>class Gadget extends Widget { Spring s; }</pre> 完全符合要求，这里的结论1虽然没有明确表明，但是因为结论3（Gadget继承了Widget）的存在，即父类中的非私有成员（Sprocket）子类都默认拥有。故结论都成立。</p>
</li>
<li><p>B <pre>class Widget { }<br>class Gadget extends Widget { Spring s1; Sprocket s2; }</pre> 结论123成立，但是没有表明结论4。</p>
</li>
<li><p>C <pre>class Widget { Sprocket s1; Spring s2; }<br>class Gadget extends Widget { }</pre> 完全符合要求，这里的结论12虽然没有明确表明，但是因为结论3（Gadget继承了Widget）的存在，即父类中的非私有成员（Sprocket和Spring）子类都默认拥有。故结论都成立。</p>
</li>
<li><p>D <pre>class Gadget { Spring s; }<br>class Widget extends Gadget{ Sprocket s; }</pre> 结论24成立，但是结论13没有表明。这里只是表明了Widget继承了Gadget，并且Widget具有对Spring的引用。</p>
</li>
</ul>
<p>这道题主要考查我们的Java类与类之间的关系。 类与类之间有三种关系：<br>（1）is-a 包括了继承（类）和实现（接口）关系；<br>（2）has-a包括了关联、聚合、组合关系；<br>（3）use-a包括了依赖关系； </p>
<h1 id="考点8-JVM垃圾回收算法"><a href="#考点8-JVM垃圾回收算法" class="headerlink" title="考点8:JVM垃圾回收算法"></a>考点8:JVM垃圾回收算法</h1><p>以下哪些jvm的垃圾回收方式采用的是复制算法回收</p>
<ul>
<li>A 新生代串行收集器</li>
<li>B 老年代串行收集器</li>
<li>C 并行收集器</li>
<li>D 新生代并行回收收集器</li>
<li>E 老年代并行回收收集器</li>
<li>F <code>cms</code>收集器</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details>

<p>两个最基本的java回收算法：复制算法和标记清理算法<br>复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法<br>标记清理：一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出<br>标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象<br>两个概念：新生代和年老代<br>新生代：初始对象，生命周期短的<br>永久代：长时间存在的对象<br>整个java的垃圾回收是新生代和年老代的协作，这种叫做分代回收。<br>P.S：Serial New收集器是针对新生代的收集器，采用的是复制算法<br>Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理<br>Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法<br>Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理<br>Parallel Old（并行）收集器，针对老年代，标记整理 CMS收集器，基于标记清理<br>G1收集器：整体上是基于标记 整理 ，局部采用复制</p>
<p><b>综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。</b></p>
<h1 id="考点9-super关键字-this关键字"><a href="#考点9-super关键字-this关键字" class="headerlink" title="考点9:super关键字 this关键字"></a>考点9:super关键字 this关键字</h1><p>在使用super和this关键字时,以下描述错误的是()</p>
<ul>
<li>A 在子类构造方法中使用<code>super()</code>显示调用父类的构造方法,<code>super()</code>必须写在子类构造方法的第一行,否则编译不通过</li>
<li>B <code>super()</code>和<code>this()</code>不一定要放在构造方法内第一行</li>
<li>C <code>this()</code>和<code>super()</code>可以同时出现在一个构造函数中</li>
<li>D <code>this()</code>和<code>super()</code>可以在<code>static</code>环境中使用,包括<code>static</code>方法和<code>static</code>语句块</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details>

<p>1、super()表示调用父类构造函数、this()调用自己的构造函数，而<strong>自己的构造函数第一行默认会使用super()调用父类的构造函数</strong>，所以这俩不能在一个构造函数中会出现重复引用的情况<br>2、super()和this()必须在构造函数第一行，所以这一点也表明他俩不能在一个构造函数中<br>3、this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块(里面不能使用非static类型的)。</p>
<p>super()和this()不能同时在构造方法中使用，因为会导致重复实例化两次，而且这俩函数也不能放入static中，因为静态中不能操作实例对象</p>
<p>在构造器B中，使用this()调用其他构造器A时，构造器A的第一行会默认调用super()。</p>
<p>假设this()和super()能同时放在一起，则super()会被调用两次，初始化父类两次。<br>现实中父类只需要初始化一次就够了，所以this()和super()不能同时出现。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年09月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月05日 java3</title>
    <url>/exam//4f99546e/</url>
    <content><![CDATA[<h1 id="考点1-Java内存结构图"><a href="#考点1-Java内存结构图" class="headerlink" title="考点1:Java内存结构图"></a>考点1:Java内存结构图</h1><p>定义:<code>String s1 = &quot;uml&quot;; String s2 = &quot;uml&quot;; String s3= new String(&quot;uml&quot;); String s4= new String(&quot;uml&quot;);那么,s1==s2;s3 == s4;s1.equals(s3);</code>判断正确与否</p>
<ul>
<li>A <code>T,F,T</code></li>
<li>B <code>F,T,F</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>该题考察的是<strong>String类创建的对象在JVM中的内存分配</strong>和<strong>“<strong><strong>e</strong></strong>quals”与“&#x3D;&#x3D;”的区别</strong>。</p>
<ul>
<li><p>“&#x3D;&#x3D;”比较的是<strong>地址和值</strong>。</p>
</li>
<li><p>“equals”比较的是<strong>值</strong>。</p>
</li>
<li><img data-src="https://uploadfiles.nowcoder.com/images/20190701/300975041_1561974792932_428A93CE2102F1DFD863C72B9733057F">
</li>
<li><p>s1&#x3D;&#x3D;s2，比较的是比较的是地址和值，由上图得知两个引用指向的是同一个地址，<strong>所以返回true.</strong></p>
</li>
<li><p>s3 &#x3D;&#x3D; s4，比较的是两个new出来开辟的空间对象地址，所以地址不同，<strong>返回false.</strong></p>
</li>
<li><p>s1.equals(s3)，比较的是内容,<strong>返回true</strong>。</p>
</li>
</ul>
<p>&#x3D;&#x3D;：比较两个引用的地址和值<br>equals：比较两个引用的值<br>1、s1&#x3D;&#x3D;s2  true  s1和s2指向字符串常量池中同一个地址<br>2、s3 和 s4 都显示使用了new，是不同的对象，  当然不相等<br>3、s1 和 s3 的值都是 “uml”，当然相等<br><img data-src="https://uploadfiles.nowcoder.com/images/20190701/918861942_1561968854891_59B2900AA03CB2182A51CDB520B535B6"></p>
<h1 id="考点2-Applet"><a href="#考点2-Applet" class="headerlink" title="考点2:Applet"></a>考点2:Applet</h1><p>在 Applet 中,方法执行的顺序是 ?( )</p>
<ul>
<li>A <code>init(), start(), paint(),stop(),destroy().</code></li>
<li>B <code>init(),paint(),start(),stop(),destroy().</code></li>
<li>C <code>paint(),start(),stop(),destroy().</code></li>
<li>D <code>init(), start(),stop(),destroy(),paint().</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<h1 id="考点3-abstract和final矛盾"><a href="#考点3-abstract和final矛盾" class="headerlink" title="考点3:abstract和final矛盾"></a>考点3:abstract和final矛盾</h1><p>abstract和final可以同时作为一个类的修饰符。(  )</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>1、abstract期待子类扩展<br>2、final禁止扩展</p>
<h3 id="abstract和final矛盾"><a href="#abstract和final矛盾" class="headerlink" title="abstract和final矛盾"></a>abstract和final矛盾</h3><p>abstract修饰的类需要被继承，而final修饰的类不可被继承，自相矛盾。<br>拓展：<br>一、抽象类的使用原则如下：<br>（1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public；<br>（2）抽象类不能直接实例化，需要依靠子类采用向上转型的方式处理；<br>（3）抽象类必须有子类，使用extends继承，一个子类只能继承一个抽象类；<br>（4）子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。<br>二、final关键字：<br>（1）修饰变量 ： 变量不可修改；<br>（1）修饰方法 ： 方法不可重写；<br>（1）修饰类 ：类不可继承。</p>
<h1 id="考点4-常识"><a href="#考点4-常识" class="headerlink" title="考点4:常识"></a>考点4:常识</h1><p>Web客户端的编程语言JavaScript源自Java,其功能是Java SE的子集。</p>
<ul>
<li>A 对</li>
<li>B 错</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>


<h1 id="考点5-一切皆对象"><a href="#考点5-一切皆对象" class="headerlink" title="考点5:一切皆对象"></a>考点5:一切皆对象</h1><p>以下说法错误的是()</p>
<ul>
<li>A 数组是一个对象</li>
<li>B 数组不是一种原生类</li>
<li>C 数组的大小可以任意改变</li>
<li>D 在<code>Java</code>中,数组存储在堆中连续内存空间里</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p><strong>Java中数组是对象，不是基本数据类型（原生类），大小不可变且连续存储，因为是对象所以存在堆中。</strong></p>
<ol>
<li><strong>数组的创建使用了new关键字，所以数组是一个对象</strong></li>
<li>java数据类型分为基本数据类型（又叫原生类、内置类）和引用数据类型，数组是后者</li>
<li>数组在new的时候内存空间就已经分配好了，不允许改变</li>
<li>数组是一个对象，对象在内存中如何存放同样适用于数组</li>
</ol>
<p>原生类有8种：int 、double、 boolean 、float 、byte、 short 、long、 char 。数组是引用数据类型，不属于原生类。<br>数组长度在定义数组的时候就确定了，长度不可变，数组扩容需要使用函数ArrayCopy复制一个新数组<br>数组是对象，所以存在堆内存中。</p>
<h1 id="考点6-Hibernate"><a href="#考点6-Hibernate" class="headerlink" title="考点6:Hibernate"></a>考点6:Hibernate</h1><p>下面关于hibernate核心接口说明错误的是？</p>
<ul>
<li>A <code>Configuration</code> 接口:配置<code>Hibernate</code>,根据其启动<code>hibernate</code>,创建<code>SessionFactory</code> 对象</li>
<li>B <code>SessionFactory</code> 接口:负责保存、更新、删除、加载和查询对象,是线程不安全的,避免多个线程共享同一个<code>session</code>,是轻量级、一级缓存</li>
<li>C <code>Query</code> 和<code>Criteria</code> 接口:执行数据库的查询</li>
<li>D <code>Transaction</code> 接口:管理事务</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>B选项中应该是Session接口而不是SessionFactory接口<br>1，Configuration接口：配置Hibernate，根据其启动Hibernate，创建SessionFactory对象；<br>2，SessionFactory接口：初始化Hibernate，充当数据存储源的***，创建session对象，SessionFactory是<br>线程安全的，意味着它的同一个实例可以被应用的多个线程共享，是重量级二级缓存；<br>3，session接口：负责保存、更新、删除、加载和查询对象，是一个非线程安全的，避免多个线程共享一个session，是轻量级，一级缓存。<br>4，Transaction接口：管理事务。可以对事务进行提交和回滚；<br>5，Query和Criteria接口：执行数据库的查询。</p>
<h1 id="考点7-final成员变量不会默认初始化，必须手动初始化"><a href="#考点7-final成员变量不会默认初始化，必须手动初始化" class="headerlink" title="考点7:final成员变量不会默认初始化，必须手动初始化"></a>考点7:final成员变量不会默认初始化，必须手动初始化</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(++j + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>的输出是？</p>
<ul>
<li>A 0</li>
<li>B 1</li>
<li>C 2</li>
<li>D 不能执行,因为编译有错</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h3 id="final成员变量的初始化"><a href="#final成员变量的初始化" class="headerlink" title="final成员变量的初始化"></a>final成员变量的初始化</h3><p>final作为对象成员存在时，必须初始化；<br>1、定义时就初始化<br>2、先定义，后初始化。先定义，然后在构造函数中初始化话，或者在代码块中初始化。</p>
<figure class="highlight java"><figcaption><span>E:\dev2\workspace\NiKeTest\src\finaltest\FinalTest.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> finaltest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalTest</span> &#123;</span><br><span class="line">    <span class="comment">// final成员变量，定义的时候就赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 先定义，后赋值。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> num2;</span><br><span class="line">    <span class="comment">// 先定义，后赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> num3;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在代码块中初始化</span></span><br><span class="line">        num3 = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalTest</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="comment">// 在构造函数中初始化</span></span><br><span class="line">        <span class="built_in">this</span>.num2 = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FinalTest</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalTest</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">FinalTest</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalTest</span>(<span class="number">100</span>);</span><br><span class="line">        System.out.println(f1.num1);</span><br><span class="line">        System.out.println(f1.num2);</span><br><span class="line">        System.out.println(f1.num3);</span><br><span class="line">        System.out.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">        System.out.println(f2.num1);</span><br><span class="line">        System.out.println(f2.num2);</span><br><span class="line">        System.out.println(f2.num3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">============================</span><br><span class="line">1</span><br><span class="line">100</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h4 id="final成员先定义后赋值的优点-不同的对象的final成员可以不一样"><a href="#final成员先定义后赋值的优点-不同的对象的final成员可以不一样" class="headerlink" title="final成员先定义后赋值的优点: 不同的对象的final成员可以不一样"></a>final成员先定义后赋值的优点: 不同的对象的final成员可以不一样</h4><p>从上面的代码中可以看出，定义final成员变量时不初始化，而在构造器中初始化的好处就在于。这个final成员的值是可变的。<br>如果在定义的时候就初始化，或者在代码块中初始化话。<br>所有的对象的这个final成员都是一样的，做不到不同的对象的final变量不一样这样的功能。</p>
<p>如果定义的时候没有赋值，并且没有构造器，则会在变量处显示错误提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The blank final field num2 may not have been initialized</span><br></pre></td></tr></table></figure>
<p>如果定义时，没有赋值，并且有构造器，则会在构造器处显示错误提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The blank final field num4 may not have been initialized</span><br></pre></td></tr></table></figure>


<h1 id="考点8-JDK1-7之前的抽象类和接口特性"><a href="#考点8-JDK1-7之前的抽象类和接口特性" class="headerlink" title="考点8:JDK1.7之前的抽象类和接口特性"></a>考点8:JDK1.7之前的抽象类和接口特性</h1><p>在jdk 1.7中,以下说法正确的是(    )。</p>
<ul>
<li>A <code>Java</code>中所有的非抽象方法都必须在类内定义</li>
<li>B <code>Java</code>中主方法可以不在类内定义,其他方法都必须定义在类内</li>
<li>C <code>Java</code>中主方法必须定义在类内,其他方法可以不必定义在类内</li>
<li>D <code>Java</code>中所有方法都不必在类内定义</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>我想这题纯粹是想考察JDK1.8和1.9的接口新特性（因为其提到JDK1.7）<br>JDK1.8接口可以定义default方法和static方法；<br>JDK1.9接口中可以定义私有方法。<br>因此在JDK1.7中，接口只能定义抽象方法，既Java中所有的非抽象方法都必须在类内定义。</p>
<h1 id="考点9-volatile关键字"><a href="#考点9-volatile关键字" class="headerlink" title="考点9:volatile关键字"></a>考点9:volatile关键字</h1><p>volatile关键字的说法错误的是</p>
<ul>
<li>A 能保证线程安全</li>
<li>B <code>volatile</code>关键字用在多线程同步中,可保证读取的可见性</li>
<li>C <code>JVM</code>保证从主内存加载到线程工作内存的值是最新的</li>
<li>D <code>volatile</code>能禁止进行指令重排序</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>出于运行速率的考虑，java编译器会把经常经常访问的变量放到缓存（严格讲应该是工作内存）中，读取变量则从缓存中读。但是在多线程编程中,内存中的值和缓存中的值可能会出现不一致。<br><strong>volatile用于限定变量只能从内存中读取，保证对所有线程而言，值都是一致的</strong>。<br><strong>但是volatile不能保证原子性，也就不能保证线程安全</strong>。</p>
<h3 id="1-java的内存模型"><a href="#1-java的内存模型" class="headerlink" title="1.java的内存模型"></a>1.java的内存模型</h3><p>java 内存模型规定了所有的变量都存储在主内存中，但是每个线程会有自己的工作内存，线程的工作内存保存了该线程中使用了的变量（从主内存中拷贝的），线程对变量的操作都必须在工作内存中进行，不同线程之间无法直接访问对方工作内存中的变量，线程间变量值从传递都要经过主内存完成</p>
 <img alt="图片说明" data-src="https://uploadfiles.nowcoder.com/images/20180827/9780880_1535335958506_5721C0ED3C89479FA5F09D1F8E722D00" title="图片标题">
 
<h3 id="2-什么是原子性"><a href="#2-什么是原子性" class="headerlink" title="2.什么是原子性"></a>2.什么是原子性</h3><p>一个操作是不可中断的，要么全部执行成功要么全部执行失败，比如银行转账</p>
<h3 id="3-什么是可见性"><a href="#3-什么是可见性" class="headerlink" title="3.什么是可见性"></a>3.什么是可见性</h3><p>当多个线程访问同一变量时，一个线程修改了这个变量的值，其他线程就能够立即看到修改的值</p>
<h3 id="4-什么是有序性"><a href="#4-什么是有序性" class="headerlink" title="4.什么是有序性"></a>4.什么是有序性</h3><p>程序执行的顺序按照代码的先后顺序执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>像这2句代码1会比2先执行，但是jvm在正真执行时不一定是1在2之前，</p>
<p>这里涉及一个概念叫做指令重排，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>
<p>比如上面的代码语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。<br>在指令重排时会考虑指令之间的数据依赖性，比如2依赖了1的数值，那么处理器会保证1在2之前执行。</p>
<p>但是在多线程的情况下，指令重排就会有影响了。</p>
<h3 id="5-volatile功能-volatile到底做了什么"><a href="#5-volatile功能-volatile到底做了什么" class="headerlink" title="5.volatile功能 volatile到底做了什么"></a>5.volatile功能 volatile到底做了什么</h3><ul>
<li>禁止了指令重排</li>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量值，这个新值对其他线程是立即可见的</li>
<li>不保证原子性（线程不安全）</li>
</ul>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年09月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月07日 java1</title>
    <url>/exam//a562e57f/</url>
    <content><![CDATA[<h1 id="考点1-java基础知识-boolean表达式"><a href="#考点1-java基础知识-boolean表达式" class="headerlink" title="考点1:java基础知识 boolean表达式"></a>考点1:java基础知识 boolean表达式</h1><p>设有定义 int a&#x3D;3 ,b&#x3D;4,c&#x3D;5; 则以下的表达式中 , 值为 false 的是 ()</p>
<ul>
<li>A <code>a &lt; b &amp;&amp; b &lt; c</code></li>
<li>B <code>a &lt;= b</code></li>
<li>C <code>a &lt; ( b + c )</code></li>
<li>D <code>! ( a &lt; b )</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<h3 id="拓展：单与和双与的区别"><a href="#拓展：单与和双与的区别" class="headerlink" title="拓展：单与和双与的区别"></a>拓展：单与和双与的区别</h3><ul>
<li><code>&amp;</code>和<code>&amp;&amp;</code>都是<strong>逻辑运算符</strong>，都是判断<strong>两边同时真则为真，否则为假;</strong><ul>
<li>但是<code>&amp;&amp;</code>当第一个条件不成之后，后面的条件都不执行了，而<code>&amp;</code>则还是继续执行，直到整个条件语句执行完为止。</li>
</ul>
</li>
<li><code>||</code>和<code>|</code>都是逻辑<code>或</code>，<strong>只要两个数任意一个为真，条件就为真。</strong><ul>
<li>同上，<code>||</code>也具有短路效果。</li>
</ul>
</li>
</ul>
<p><strong>双与有短路功能，单与可以进行位运算</strong></p>
<h1 id="考点2-java基础知识-Object类"><a href="#考点2-java基础知识-Object类" class="headerlink" title="考点2:java基础知识 Object类"></a>考点2:java基础知识 Object类</h1><p>Java中所有类的父类是( )。</p>
<ul>
<li>A <code>Father</code></li>
<li>B <code>Dang</code></li>
<li>C <code>Exception</code></li>
<li>D <code>Object</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<ul>
<li>java中Object是所有类的父亲,</li>
<li>所有类的对象都是Class的实例。</li>
</ul>
<h1 id="考点3-实现多个接口的正确写法"><a href="#考点3-实现多个接口的正确写法" class="headerlink" title="考点3:实现多个接口的正确写法"></a>考点3:实现多个接口的正确写法</h1><p>在java中,已定义两个接口B和C,要定义一个实现这两个接口的类,以下语句正确的是()</p>
<ul>
<li>A <code>interface A extends B,C</code></li>
<li>B <code>interface A eimplements B,C</code></li>
<li>C <code>class A implements B,C</code></li>
<li>D <code>class A implements B,implements C</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h3 id="实现多个接口时只需要写一个implements"><a href="#实现多个接口时只需要写一个implements" class="headerlink" title="实现多个接口时只需要写一个implements"></a>实现多个接口时只需要写一个implements</h3><p>类实现多个接口的时候，只需要一个implements，多个接口通过逗号进行隔开，</p>
<p>先继承类,再实现接口</p>
<h1 id="考点4-Servlet生命周期"><a href="#考点4-Servlet生命周期" class="headerlink" title="考点4:Servlet生命周期"></a>考点4:Servlet生命周期</h1><p>J2EE中,当把来自客户机的HTTP请求委托给servlet时,会调用HttpServlet的( )方法</p>
<ul>
<li>A <code>service</code></li>
<li>B <code>doget</code></li>
<li>C <code>dopost</code></li>
<li>D <code>init</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h3 id="HttpServlet容器响应Web请求流程"><a href="#HttpServlet容器响应Web请求流程" class="headerlink" title="HttpServlet容器响应Web请求流程"></a>HttpServlet容器响应Web请求流程</h3><p>HttpServlet容器响应Web客户请求流程如下：<br>1）Web客户向Servlet容器发出Http请求；<br>2）Servlet容器解析Web客户的Http请求；<br>3）Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息；<br>4）Servlet容器创建一个HttpResponse对象；<br>5）Servlet容器调用HttpServlet的service方法，这个方法中会根据request的Method来判断具体是执行doGet还是doPost，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象；<br>6）HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息；<br>7）HttpServlet调用HttpResponse的有关方法，生成响应数据；<br>8）Servlet容器把HttpServlet的响应结果传给Web客户。</p>
<p>doGet()<br>或<br>doPost()<br>是创建HttpServlet时需要覆盖的方法.</p>
<h3 id="Servlet生命周期三个阶段"><a href="#Servlet生命周期三个阶段" class="headerlink" title="Servlet生命周期三个阶段"></a>Servlet生命周期三个阶段</h3><p>1.初始化阶段，调用init()方法<br>2.响应客户请求阶段，调用service()方法<br>3.终止阶段，调用destroy()方法</p>
<h1 id="考点5-类的加载顺序-父类静态块-子类静态块-main方法-父类构造块-父类构造器-子类构造块-子类构造器"><a href="#考点5-类的加载顺序-父类静态块-子类静态块-main方法-父类构造块-父类构造器-子类构造块-子类构造器" class="headerlink" title="考点5:类的加载顺序 父类静态块 子类静态块 main方法 父类构造块 父类构造器 子类构造块 子类构造器"></a>考点5:类的加载顺序 父类静态块 子类静态块 main方法 父类构造块 父类构造器 子类构造块 子类构造器</h1><p>关于以下application,说法正确是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> x=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;x+=<span class="number">5</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="comment">//4</span></span><br><span class="line">        &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;x=&quot;</span>+x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;x/=<span class="number">3</span>;&#125;;</span><br><span class="line">&#125;<span class="comment">//9</span></span><br></pre></td></tr></table></figure>
<ul>
<li>A 4行与9行不能通过编译,因为缺少方法名和返回类型</li>
<li>B 编译通过,执行结果是:<code>x=5</code></li>
<li>C 编译通过,执行结果是:<code>x=3</code></li>
<li>D 9行不能通过编译,因为只能有一个静态初始化器</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="类的初始化顺序"><a href="#类的初始化顺序" class="headerlink" title="类的初始化顺序"></a>类的初始化顺序</h3><figure class="highlight java"><figcaption><span>G:\dev2\idea_workspace\MyJavaTools\RunableTools\src\base\test\B.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类 静态 代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类 构造 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类 初始化 代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类 静态 代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类 构造 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类 初始化 代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法 执行&quot;</span>);</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main方法 代码块1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main方法 代码块2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父类 静态 代码块</span><br><span class="line">子类 静态 代码块</span><br><span class="line">main方法 执行</span><br><span class="line">main方法 代码块1</span><br><span class="line">父类 初始化 代码块</span><br><span class="line">父类 构造 方法</span><br><span class="line">子类 初始化 代码块</span><br><span class="line">子类 构造 方法</span><br><span class="line">main方法 代码块2</span><br></pre></td></tr></table></figure>

<p><strong>静态代码块先于 主方法执行，静态代码块之间遵从代码顺序执行</strong>。<br>所以：先初始化静态变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x=10；//x=10</span><br></pre></td></tr></table></figure>
<p>执行第一个静态代码块，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x=x+5; //x=15</span><br></pre></td></tr></table></figure>
<p>执行第二静态代码块 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x=x/3; //x=5</span><br></pre></td></tr></table></figure>
<p>执行主方法： 输出x&#x3D;5</p>
<p>拓展一下，在类中定义的{}之间被称为构造块，构造块相对于构造方法先执行，构造块之间按照代码编译顺序执行</p>
<p>此外还有普通代码块，存在于方法之中。<br>贴出参考文章：<a href="http://www.cnblogs.com/sophine/p/3531282.html" target="_blank">http://www.cnblogs.com/sophine/p/3531282.html</a></p>
<h1 id="考点6-还没了解hibernate"><a href="#考点6-还没了解hibernate" class="headerlink" title="考点6:还没了解hibernate"></a>考点6:还没了解hibernate</h1><p>下面关于hibernate核心接口说明错误的是？</p>
<ul>
<li>A <code>Configuration</code> 接口:配置<code>Hibernate</code>,根据其启动<code>hibernate</code>,创建<code>SessionFactory</code> 对象</li>
<li>B <code>SessionFactory</code> 接口:负责保存、更新、删除、加载和查询对象,是线程不安全的,避免多个线程共享同一个<code>session</code>,是轻量级、一级缓存</li>
<li>C <code>Query</code> 和<code>Criteria</code> 接口:执行数据库的查询</li>
<li>D <code>Transaction</code> 接口:管理事务</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>B选项中应该是Session接口而不是SessionFactory接口<br>1，Configuration接口：配置Hibernate，根据其启动Hibernate，创建SessionFactory对象；<br>2，SessionFactory接口：初始化Hibernate，充当数据存储源的，创建session对象，SessionFactory是线程安全的，意味着它的同一个实例可以被应用的多个线程共享，是重量级二级缓存；<br>3，<strong>session接口：负责保存、更新、删除、加载和查询对象，是一个非线程安全的，避免多个线程共享一个session，是轻量级，一级缓存。</strong><br>4，Transaction接口：管理事务。可以对事务进行提交和回滚；<br>5，Query和Criteria接口：执行数据库的查询。</p>
<h1 id="考点7-堆外内存-off-heap-还没学到"><a href="#考点7-堆外内存-off-heap-还没学到" class="headerlink" title="考点7:堆外内存 off-heap 还没学到"></a>考点7:堆外内存 off-heap 还没学到</h1><p>off-heap是指那种内存()</p>
<ul>
<li>A <code>JVM GC</code>能管理的内存</li>
<li>B <code>JVM</code>进程管理的内存</li>
<li>C 在<code>JVM</code>老年代内存区</li>
<li>D 在<code>JVM</code>新生代内存</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h3><p>off-heap叫做堆外内存，将你的对象从堆中脱离出来序列化，然后存储在一大块内存中，这就像它存储到磁盘上一样，但它仍然在RAM中。对象在这种状态下不能直接使用，它们必须首先反序列化，也不受垃圾收集。<br>序列化和反序列化将会影响部分性能（所以可以考虑使用FST-serialization）使用堆外内存能够降低GC导致的暂停。<br>堆外内存不受垃圾收集器管理，也不属于老年代，新生代。</p>
<h1 id="考点8-Servlet生命周期"><a href="#考点8-Servlet生命周期" class="headerlink" title="考点8:Servlet生命周期"></a>考点8:Servlet生命周期</h1><p>servlet周期包含哪些:</p>
<ul>
<li>A 初始化</li>
<li>B 销毁</li>
<li>C 请求处理</li>
<li>D 开始</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>


<h3 id="Servlet生命周期3个阶段"><a href="#Servlet生命周期3个阶段" class="headerlink" title="Servlet生命周期3个阶段"></a>Servlet生命周期3个阶段</h3><p>1）初始化阶段：调用init方法<br>2）响应客户请求：调用service<br>3）终止：调用destory方法</p>
<h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p>在下列时刻servlet容器装载servlet<br>1 servlet容器启动时，自动装载某些servlet<br>2 在servlet容器启动后，客户首次向servlet发送请求<br>3 servlet类文件被更新之后，重新装载servlet</p>
<p>Servlet被装载之后，servlet容器创建一个servlet对象并调用servlet的init方法，在servlet生命周期内，init方法只能被调用一次。</p>
<h5 id="servlet工作原理"><a href="#servlet工作原理" class="headerlink" title="servlet工作原理"></a>servlet工作原理</h5><p>客户端发起一个请求，servlet调用service方法时请求进行响应，service对请求的方式进行了匹配，选择调用doPost或者doGet等这些方法，然后进入对应方法中调用逻辑层的方法，实现对客户的响应。</p>
<h4 id="响应客户请求"><a href="#响应客户请求" class="headerlink" title="响应客户请求"></a>响应客户请求</h4><p>对于用户到达servlet的请求，servlet容器会创建特定于该请求的ServletRequest和ServletResponse对象，然后调用servlet的service方法，service方法从ServletRequest对象中获取客户请求的信息，处理该请求，并且通过ServletResponse对象向客户端返回响应信息。</p>
<h4 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h4><p>当web应用终止或者servlet容器终止或servlet容器重新装载servlet新实例时，servlet容器会调用servlet对象的destory方法，在destory方法中可以释放servlet占用的资源</p>
<h1 id="考点9-类的加载顺序-静态块-main-构造块-构造器"><a href="#考点9-类的加载顺序-静态块-main-构造块-构造器" class="headerlink" title="考点9:类的加载顺序 静态块 main 构造块 构造器"></a>考点9:类的加载顺序 静态块 main 构造块 构造器</h1><p>关于以下代码的说明,正确的是( )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticStuff</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> x=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123; x+=<span class="number">5</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[ ])</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;x=&quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123; x/=<span class="number">3</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 4行与9行不能通过编译,因为缺少方法名和返回类型</li>
<li>B 9行不能通过编译,因为只能有一个静态初始化器</li>
<li>C 编译通过,执行结果为:x&#x3D;5</li>
<li>D 编译通过,执行结果为:x&#x3D;3</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p><strong>同上第5题</strong></p>
<h1 id="考点10-JVM相关-还没学到"><a href="#考点10-JVM相关-还没学到" class="headerlink" title="考点10:JVM相关 还没学到"></a>考点10:JVM相关 还没学到</h1><p>关于OutOfMemoryError,下面说法正确的是()？</p>
<ul>
<li>A <code>java.lang.OutOfMemoryError: PermGen space</code> 增加<code>-XX:MaxPermSize</code>这个参数的值的话,这个问题通常会得到解决。</li>
<li>B <code>java.lang.OutOfMemoryError: Requested array size exceeds VM limit</code>当你正准备创建一个超过虚拟机允许的大小的数组时,这条错误将会出现</li>
<li>C <code>java.lang.OutOfMemoryError: Java heap space</code> 一般情况下解决这个问题最快的方法就是通过<code>-Xmx</code>参数来增加堆的大小</li>
<li>D <code>java.lang.OutOfMemoryError: nativeGetNewTLA</code>这个异常只有在<code>jRockit</code>虚拟机时才会碰到</li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<p>关于此题，《深入理解java虚拟机》有关于OOM（OutOfMemory）问题的解释<br>A：属于运行时常量池导致的溢出，设置-XX：MaxPermSize可以解决这个问题，<br>B：属于堆空间不足导致的错误，问题比较少见，解决方式和C相同，<br>C：属于java堆内存问题，一般的手段是通过内存映像分析工具，对Dump出来的堆转储存快照进行分析，重点是确认内存中的对象是否是有必要的，也就是要判断是出现了内存泄漏，还是出现了内存溢出，如果是内存列楼，通过工具检查泄露对象打GC Roots的引用链信息，可以准确的确定出泄露代码的位置，不存在泄露，就应该检查虚拟机的堆参数，如果可以继续调大，可以设置-Xmx解决问题<br>D：java.lang.OutOfMemoryError: nativeGetNewTLA指当虚拟机不能分配新的线程本地空间(Thread Local Area）的时候错误信息，此错误是线程申请一个新的TLA时产生的，这个异常一般只会发生在jRockit虚拟机，只有过于绝对。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年09月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月08日 java1</title>
    <url>/exam//5469bef2/</url>
    <content><![CDATA[<h1 id="考点1-Java常识"><a href="#考点1-Java常识" class="headerlink" title="考点1:Java常识"></a>考点1:Java常识</h1><p>以下关于构造函数的描述错误的是 （ ）</p>
<ul>
<li>A 每个类有且只能有一个构造函数。</li>
<li>B 构造函数是类的一种特殊函数，它的方法名必须与类名相同</li>
<li>C 构造函数的主要作用是完成对类的对象的初始化工作</li>
<li>D 一般在创建新对象时，系统会自动调用构造函数</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h1 id="考点2-异常"><a href="#考点2-异常" class="headerlink" title="考点2:异常"></a>考点2:异常</h1><p>代码<code>String str=”123456a”；int i=Integer.parseInt(str);</code>会报异常的是（）</p>
<ul>
<li>A <code>java.lang.NullPoninterException</code></li>
<li>B <code>java.lang.NumberFormatException</code></li>
<li>C <code>java.lang.RuntimeException</code></li>
<li>D <code>java.lang.ArrayindexOutOfBoundsException</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p><code>java.lang.NullPoninterException</code>：变量未被初始化、对象未赋值、对象为空（俗称的空指针异常）<br><code>java.lang.NumberFormatException</code>：数据格式转换失败（<code>integer</code>的取值范围为：-127-128，超过范围都会访问<code>false</code>）<br><code>java.lang.RuntimeException</code>：运行时异常<br><code>java.lang.ArrayindexOutOfBoundsException</code>：数组下标越界</p>
<h1 id="考点3-常识"><a href="#考点3-常识" class="headerlink" title="考点3:常识"></a>考点3:常识</h1><p>下列关于Java类中方法的定义，正确的是（）</p>
<ul>
<li>A 若代码执行到return语句，则将当前值返回，而且继续执行return语句后面的语句。</li>
<li>B 只需要对使用基本数据类型定义的属性使用getter和setter，体现类的封装性。</li>
<li>C 方法的返回值只能是基本数据类型。</li>
<li>D 在同一个类中定义的方法，允许方法名称相同而形参列表不同。</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p><strong>选D</strong><br><strong>A、一旦执行到return，就不再执行后续的代码。</strong><br><strong>B、类的封装性可不是这么体现的，数据域和方法都可以被封装。数据域可以是基本数据类型也可以是引用类型。</strong><br><strong>C、方法的返回值可以是引用类型。</strong><br><strong>D、这是重载，同一个类中，方法名相同，形参列表不同。</strong></p>
<h2 id="封装是通过访问控制符实现的"><a href="#封装是通过访问控制符实现的" class="headerlink" title="封装是通过访问控制符实现的"></a>封装是通过访问控制符实现的</h2><p><a href="https://www.runoob.com/java/java-encapsulation.html">https://www.runoob.com/java/java-encapsulation.html</a></p>
<p>封装性仅仅有get，set方法是不够的，要是成员变量是public的，那么外界就可以随意访问该成员变量。<br>所以封装要求 成员变量私有，然后提供公有的getter和setter方法来访问成员变量。</p>
<h1 id="考点4-浮点数转整数"><a href="#考点4-浮点数转整数" class="headerlink" title="考点4:浮点数转整数"></a>考点4:浮点数转整数</h1><p>下列语句序列执行后，输出结果是（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ex</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">13</span>;</span><br><span class="line">        a=a/<span class="number">5</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 1</li>
<li>B 2</li>
<li>C 3</li>
<li>D 4</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>整数相除之后还是整数，会丢失掉小数部分的数值。</p>
<h2 id="浮点数转整数：丢弃小数部分"><a href="#浮点数转整数：丢弃小数部分" class="headerlink" title="浮点数转整数：丢弃小数部分"></a>浮点数转整数：丢弃小数部分</h2><p>a是int类型,13&#x2F;5得到一个浮点类型,浮点类型转成整数类型的原则是,不四舍五入,只取整数部分，小数部分直接丢弃。.</p>
<figure class="highlight java"><figcaption><span>G:\dev2\idea_workspace\MyJavaTools\RunableTools\src\base\Test.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">double</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1.0</span>; i &lt; <span class="number">2.2</span>; i = i + <span class="number">0.1000000000000000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;double(&quot;</span> + i + <span class="string">&quot;) \tto int(&quot;</span> + (<span class="type">int</span>) i+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double(1.0)	to int(1)</span><br><span class="line">double(1.1)	to int(1)</span><br><span class="line">double(1.2000000000000002)	to int(1)</span><br><span class="line">double(1.3000000000000003)	to int(1)</span><br><span class="line">double(1.4000000000000004)	to int(1)</span><br><span class="line">double(1.5000000000000004)	to int(1)</span><br><span class="line">double(1.6000000000000005)	to int(1)</span><br><span class="line">double(1.7000000000000006)	to int(1)</span><br><span class="line">double(1.8000000000000007)	to int(1)</span><br><span class="line">double(1.9000000000000008)	to int(1)</span><br><span class="line">double(2.000000000000001)	to int(2)</span><br><span class="line">double(2.100000000000001)	to int(2)</span><br></pre></td></tr></table></figure>
<p>可以看到，double转int的时候，只保留浮点数中的整数部分，小数部分全部丢弃。</p>
<h1 id="考点5-面向对象的三大特征"><a href="#考点5-面向对象的三大特征" class="headerlink" title="考点5:面向对象的三大特征"></a>考点5:面向对象的三大特征</h1><p>面向对象的基本特征是（）</p>
<ul>
<li>A 封装</li>
<li>B 继承</li>
<li>C 重载</li>
<li>D 多态</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>

<h2 id="三大基本特征：封装、继承、多态"><a href="#三大基本特征：封装、继承、多态" class="headerlink" title="三大基本特征：封装、继承、多态"></a>三大基本特征：封装、继承、多态</h2><p>1、封装<br>2、继承<br>3、多态</p>
<h2 id="五大基本原则"><a href="#五大基本原则" class="headerlink" title="五大基本原则"></a>五大基本原则</h2><p>1、单一职责原则（SRP）<br>2、开放封闭原则（OCP）<br>3、里氏替换原则（LSP）<br>4、依赖倒置原则（DIP）<br>5、接口隔离原则（ISP）</p>
<h3 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1.单一职责原则"></a>1.单一职责原则</h3><p>就一个类而言，应该仅有一个引起它变化的原因。</p>
<h3 id="2-开放-封闭原则"><a href="#2-开放-封闭原则" class="headerlink" title="2.开放-封闭原则"></a>2.开放-封闭原则</h3><p>一个软件实体应当对扩展开放，对修改关闭</p>
<h3 id="3-里氏代换原则"><a href="#3-里氏代换原则" class="headerlink" title="3.里氏代换原则"></a>3.里氏代换原则</h3><p>子类型(subtype)必须能够替换它们的基（父）类型</p>
<h3 id="4-依赖倒转（置）原则"><a href="#4-依赖倒转（置）原则" class="headerlink" title="4.依赖倒转（置）原则"></a>4.依赖倒转（置）原则</h3><p>要依赖于抽象，不要依赖于具体</p>
<h3 id="5-接口隔离原则"><a href="#5-接口隔离原则" class="headerlink" title="5.接口隔离原则"></a>5.接口隔离原则</h3><p>使用多个专门的接口比使用单一的总接口总要好</p>
<h1 id="考点6-标识符规则"><a href="#考点6-标识符规则" class="headerlink" title="考点6:标识符规则"></a>考点6:标识符规则</h1><p>下面哪些标识符是正确的？</p>
<ul>
<li>A <code>MyWorld</code></li>
<li>B <code>parseXML</code></li>
<li>C <code>–value</code></li>
<li>D <code>&amp;maybe</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: AB</details>

<h2 id="Java中标识符规则"><a href="#Java中标识符规则" class="headerlink" title="Java中标识符规则"></a>Java中标识符规则</h2><ul>
<li>由<strong>字母</strong>、<strong>数字</strong>、<code>美元符号$</code>、**下划线_**4种组成，</li>
<li>不能以数字开头，</li>
<li>不能是保留字和关键字</li>
<li>不能是true,false,null等引用常量</li>
</ul>
<h2 id="C语言标识符规则"><a href="#C语言标识符规则" class="headerlink" title="C语言标识符规则"></a>C语言标识符规则</h2><ul>
<li>标识符由字母（A-Z，a-z）、数字（0-9）、下划线“_”组成，</li>
<li>首字符不能是数字，但可以是字母或者下划线</li>
<li>不能是保留字和关键字</li>
</ul>
<p>Java标识符字符构成比C语言的多了一个美元符$</p>
<h1 id="考点7-java有哪些包装类"><a href="#考点7-java有哪些包装类" class="headerlink" title="考点7:java有哪些包装类"></a>考点7:java有哪些包装类</h1><p>下面属于java包装类的是？</p>
<ul>
<li>A String</li>
<li>B Long</li>
<li>C Character</li>
<li>D Short</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details>

<h2 id="基本数据类型及其包装类对照表"><a href="#基本数据类型及其包装类对照表" class="headerlink" title="基本数据类型及其包装类对照表"></a>基本数据类型及其包装类对照表</h2><table>
<thead>
<tr>
<th align="left">基本数据类型</th>
<th align="left">包装类</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte</td>
<td align="left">Byte</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">Boolean</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">Short</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">Character</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">Integer</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">Long</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">Float</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">Double</td>
</tr>
</tbody></table>
<p>String既不是包装类，也不是基本类型</p>
<h1 id="考点8-反射机制能做什么"><a href="#考点8-反射机制能做什么" class="headerlink" title="考点8:反射机制能做什么"></a>考点8:反射机制能做什么</h1><p>JAVA反射机制主要提供了以下哪些功能？</p>
<ul>
<li>A 在运行时判断一个对象所属的类</li>
<li>B 在运行时构造一个类的对象</li>
<li>C 在运行时判断一个类所具有的成员变量和方法</li>
<li>D 在运行时调用一个对象的方法</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>

<p>A: Class.isInstance();<br>B: Class.newInstance();<br>C: Class.getMethod(); Class.getField();<br>D: Method.invoke();</p>
<h2 id="Class类方法"><a href="#Class类方法" class="headerlink" title="Class类方法"></a>Class类方法</h2><p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html#method.summary">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html#method.summary</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#method.summary">https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#method.summary</a></p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/09/20210908162524.png" alt="image-20210908162522801"></p>
<h1 id="考点9-常识-面向对象程序设计优点"><a href="#考点9-常识-面向对象程序设计优点" class="headerlink" title="考点9:常识 面向对象程序设计优点"></a>考点9:常识 面向对象程序设计优点</h1><p>面向对象程序设计方法的优点包含：</p>
<ul>
<li>A 可重用性</li>
<li>B 可扩展性</li>
<li>C 易于管理和维护</li>
<li>D 简单易懂</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年09月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月08日 java2</title>
    <url>/exam//cd60ef48/</url>
    <content><![CDATA[<h1 id="考点1-Java标识符"><a href="#考点1-Java标识符" class="headerlink" title="考点1:Java标识符"></a>考点1:Java标识符</h1><p>在JAVA中， 下列标识符合法的是（）</p>
<ul>
<li>A 3kyou</li>
<li>B @163</li>
<li>C name</li>
<li>D while</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h2 id="Java中标识符规则"><a href="#Java中标识符规则" class="headerlink" title="Java中标识符规则"></a>Java中标识符规则</h2><ul>
<li>由<strong>字母</strong>、<strong>数字</strong>、<code>美元符号$</code>、**下划线_**4种组成，</li>
<li>不能以数字开头，</li>
<li>不能是保留字和关键字</li>
<li>不能是true,false,null等引用常量</li>
</ul>
<h2 id="C语言标识符规则"><a href="#C语言标识符规则" class="headerlink" title="C语言标识符规则"></a>C语言标识符规则</h2><ul>
<li>标识符由字母（A-Z，a-z）、数字（0-9）、下划线“_”组成，</li>
<li>首字符不能是数字，但可以是字母或者下划线</li>
<li>不能是保留字和关键字</li>
</ul>
<p>Java标识符字符构成比C语言的多了一个美元符$</p>
<h1 id="考点2-java常识-局部变量-成员变量"><a href="#考点2-java常识-局部变量-成员变量" class="headerlink" title="考点2:java常识 局部变量 成员变量"></a>考点2:java常识 局部变量 成员变量</h1><p>局部变量能否和成员变量重名？</p>
<ul>
<li>A 可以，局部变量可以与成员变量重名，这时可用“this”来指向成员变量</li>
<li>B 可以，这时可用“local”关键字来指向局部变量</li>
<li>C 不能，局部变量不能与成员变量重名</li>
<li>D 不能，在一个类中不能有重名变量，不管是成员变量还是函数中的局部变量</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h2 id="java访问变量采用就近原则"><a href="#java访问变量采用就近原则" class="headerlink" title="java访问变量采用就近原则"></a>java访问变量采用就近原则</h2><p>JAVA访问变量采用就近原则，局部变量与成员变量重名时，局部变量比较近，使用局部变量。</p>
<p>java采用局部优先的思想。局部变量可以和成员变量相同，使用标识符调用时，优先使用局部变量。在实例方法中出现变量名相同时，可以使用this关键字来调用实例变量。</p>
<h1 id="考点3-Java常识"><a href="#考点3-Java常识" class="headerlink" title="考点3:Java常识"></a>考点3:Java常识</h1><p>有以下程序片段且Interesting不是内部类，下列哪个选项不能插入到行1。（    ）</p>
<pre>
1.
2. public class Interesting{
3. // 省略代码
4. }
</pre>

<ul>
<li>A import java.awt.*;</li>
<li>B package mypackage;</li>
<li>C class OtherClass{ }</li>
<li>D public class MyClass{ }</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h2 id="一个-java文件中只能有一个public外部类"><a href="#一个-java文件中只能有一个public外部类" class="headerlink" title="一个.java文件中只能有一个public外部类"></a>一个.java文件中只能有一个public外部类</h2><p>在同一个java原文件中，可以有多个class类，但是只有有一个公共的 public class</p>
<p>一个.java文件中，可以有多个类，包括内部类和外部类。</p>
<p>考虑到内部类的原因，一个.java文件可以中可以有多个public类。</p>
<p><strong>但是对于<code>外部类</code>而言，一个.java文件必须只能有一个public类，同时这个类的类名必须和.java的文件名一致（包括大小写）</strong>。</p>
<h1 id="考点4-内存泄漏"><a href="#考点4-内存泄漏" class="headerlink" title="考点4:内存泄漏"></a>考点4:内存泄漏</h1><p>java程序内存泄露的最直接表现是（ ）</p>
<ul>
<li>A 频繁FullGc</li>
<li>B jvm崩溃</li>
<li>C 程序抛内存控制的Exception</li>
<li>D java进程异常消失</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>java是自动管理内存的，通常情况下程序运行到稳定状态，内存大小也达到一个 基本稳定的值<br>但是内存泄露导致Gc不能回收泄露的垃圾，内存不断变大.<br>最终超出内存界限，抛出OutOfMemoryExpection。</p>
<p>答案 C，依次解释一下相关选项</p>
<h2 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h2><p>首先理解一下内存泄漏的概念，<strong>内存泄漏就是对象引用消失了，对象内存却没有被回收</strong>。</p>
<p>A 答案：FullGC 是老年代内存空间不足的时候，才会触发的，老年代一般是生命周期较长的对象或者大对象，频繁的 FullGC不会可能会影响程序性能（因为内存回收需要消耗CPU等资源），但是并不会直接导致内存泄漏。<br>B 答案：JVM奔溃的可能是内存溢出引起的，也可能是其他操作导致JVM崩溃，例如设置了错误的JVM参数等。<br>C 答案：内存异常，最常见的 就是 StackOverFlow了把，内存溢出，<strong>其实内存泄漏的最终结果就是内存溢出</strong>。所以，基本上C是对的答案。<br>D 答案：Java 进程异常消失，这个明显不对的。</p>
<p>题目有问题:<br>“程序抛内存控制的Exception”<br><strong>java只有OutOfMemoryError</strong>，是Error。<br>java没有OutOfMemoryException。<br>C#倒是有OutOfMemoryException。</p>
<h1 id="考点5-Java关键字-Java非法标识符"><a href="#考点5-Java关键字-Java非法标识符" class="headerlink" title="考点5:Java关键字 Java非法标识符"></a>考点5:Java关键字 Java非法标识符</h1><p>以下为 java 语法保留不能作为类名和方法名使用的是</p>
<ul>
<li>A default</li>
<li>B int</li>
<li>C implements</li>
<li>D throws</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>

<p>Java8关键字default也被使用了，所以正确答案应该全选<br>implements《注意有s结尾》是java实现接口的关键字，而implement则是普通单词，<br>default是保留字，<br>throws是抛出异常的关键字，所以正确答案是ABD</p>
<h1 id="考点6-Java常见数据类型"><a href="#考点6-Java常见数据类型" class="headerlink" title="考点6:Java常见数据类型"></a>考点6:Java常见数据类型</h1><p><code>int，String，*point，union</code>哪些不是 Java 的数据类型？</p>
<ul>
<li>A <code>int</code></li>
<li>B <code>String</code></li>
<li>C <code>*point</code></li>
<li>D <code>union</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: CD</details>

<p>*point是指针，java中没有这种类型<br>union是C系的类型，java中没有</p>
<h1 id="考点7-栈"><a href="#考点7-栈" class="headerlink" title="考点7:栈"></a>考点7:栈</h1><p>如果进栈序列为e1，e2，e3，e4，则可能的出栈序列是()<br>注：一个元素进栈后可以马上出栈，不用等全部进栈</p>
<ul>
<li>A e3，e1，e4，e2</li>
<li>B e2，e4，e3，e1</li>
<li>C e2，e3，e4，e1</li>
<li>D 任意顺序都有可能</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<p>A选项e3先出栈。那么e1,e2,e3进栈，e3出栈，如果e1想要出栈必须要e2先出栈，所以A是不可能的。</p>
<p>B选项<br>    入栈顺序：e1进，e2进去又出来，e3进，e4进<br>    出栈：e2、e4、e3、e1<br>C选项<br>    入栈顺序：e1进，e2进去又出来，e3进去又出来，e4进<br>    出栈：e2、e3、e4、e1</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年09月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月10日 java1</title>
    <url>/exam//863021c6/</url>
    <content><![CDATA[<h1 id="考点1-HashMap源码"><a href="#考点1-HashMap源码" class="headerlink" title="考点1:HashMap源码"></a>考点1:HashMap源码</h1><p>HashMap的数据结构是怎样的？</p>
<ul>
<li>A 数组</li>
<li>B 链表</li>
<li>C 数组+链表</li>
<li>D 二叉树</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的<br>JDK8及其以后版本，HashMap的数据结构是数组+链表+红黑树</p>
<p>HashMap内部包含了一个默认大小为 16 Entry 类型的数组 table,其中每个Entry 是一个链表，当链表长度大于等于 8 时会将链表转换为红黑树。</p>
<h2 id="JDK1-7中HashMap存储结构"><a href="#JDK1-7中HashMap存储结构" class="headerlink" title="JDK1.7中HashMap存储结构"></a>JDK1.7中HashMap存储结构</h2><p>jdk1.7 中使用个 Entry 数组来存储数据，用key的 hashcode 取模来决定key会被放到数组里的位置，如果 hashcode 相同，或者 hashcode 取模后的结果相同（ hash collision ），那么这些 key 会被定位到 Entry 数组的同一个格子里，这些 key 会形成一个链表。在 hashcode 特别差的情况下，比方说所有key的 hashcode 都相同，这个链表可能会很长，那么 put&#x2F;get 操作都可能需要遍历这个链表，也就是说时间复杂度在最差情况下会退化到 O(n)</p>
<h2 id="JDK1-8中HashMap存储结构"><a href="#JDK1-8中HashMap存储结构" class="headerlink" title="JDK1.8中HashMap存储结构"></a>JDK1.8中HashMap存储结构</h2><p>jdk1.8 中使用一个 Node 数组来存储数据，但这个 Node 可能是链表结构，也可能是红黑树结构，如果插入的 key 的 hashcode 相同，那么这些key也会被定位到 Node 数组的同个格子里。如果同一个格子里的key不超过8个，使用链表结构存储。如果超过了8个，那么会调用 treeifyBin 函数，将链表转换为红黑树。那么即使 hashcode 完全相同，由于红黑树的特点，查找某个特定元素，也只需要O(log n)的开销也就是说put&#x2F;get的操作的时间复杂度最差只有 O(log n)，但是真正想要利用 JDK1.8 的好处，有一个限制：key的对象，必须正确的实现了 Compare 接口</p>
<p>HashMap在Node数组中进行哈希查找,<br>使用链接法处理冲突,<br>冲突较少时使用链表,<br>目前版本当冲突的键达到8时,<br>会把链表转换为红黑树.</p>
<p>1、HashMap 底层的数据是数组被成为哈希桶（默认的初始值为 16 ），每个桶存放的是链表，链表中的每个节点，就是 HashMap 中的每个元素。<br>2、在 JDK 8 当链表长度大于等于 8 时，就会转成红黑树的数据结构，以提升查询和插入的效率。</p>
<h1 id="考点2-不用编码的java文件编译命令-javac-encoding"><a href="#考点2-不用编码的java文件编译命令-javac-encoding" class="headerlink" title="考点2:不用编码的java文件编译命令 javac -encoding"></a>考点2:不用编码的java文件编译命令 javac -encoding</h1><p>语句：<code>char foo=&#39;中&#39;</code>，是否正确？（假设源文件以GB2312编码存储，并且以<code>javac -encoding GB2312</code>命令编译）</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> base.ecoding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span> foo=<span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">        System.out.println(foo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个应该和系统的编码有关，保存为GB2312时，直接使用<code>javac -d . Test.java</code>可以正常编译，因为我的Windows简体中文系统使用的是GBK编码。<br>所以可以正常编译，但是如果把上面的文件保存为UTF-8编码，再次使用<code>javac -d . Test.java</code>就无法编译，报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS G:\dev2\idea_workspace\MyJavaTools\RunableTools\src\base\ecoding&gt; javac -d . .\Test.java</span><br><span class="line">.\Test.java:5: 错误: 编码 GBK 的不可映射字符 (0xAD)</span><br><span class="line">        char foo=&#x27;涓?&#x27;;</span><br><span class="line">                   ^</span><br><span class="line">.\Test.java:5: 错误: 未结束的字符文字</span><br><span class="line">        char foo=&#x27;涓?&#x27;;</span><br><span class="line">                 ^</span><br><span class="line">.\Test.java:5: 错误: 未结束的字符文字</span><br><span class="line">        char foo=&#x27;涓?&#x27;;</span><br><span class="line">                    ^</span><br><span class="line">3 个错误</span><br><span class="line">PS G:\dev2\idea_workspace\MyJavaTools\RunableTools\src\base\ecoding&gt;</span><br></pre></td></tr></table></figure>
<p>正确的编译命令为：<code>javac -d . -encoding UTF-8 .\Test.java</code>，运行也是正常的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS G:\dev2\idea_workspace\MyJavaTools\RunableTools\src\base\ecoding&gt; javac -d . -encoding UTF-8 .\Test.java</span><br><span class="line">PS G:\dev2\idea_workspace\MyJavaTools\RunableTools\src\base\ecoding&gt; java base.ecoding.Test</span><br><span class="line">中</span><br><span class="line">PS G:\dev2\idea_workspace\MyJavaTools\RunableTools\src\base\ecoding&gt;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>编译java文件时，如果不指定编码时，javac会使用默认的编码，也就是操作系统的编码，如果操作系统的编码和java文件的编码不一致时，就会编译错误。</p>
<p>所以使用javac编译时，都指定文件的编码，这样就不会失败。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac -encoding 文件编码 xxx.java</span><br></pre></td></tr></table></figure>
<p>即使java文件的编码和操作系统的相同，也指定编码。因为这样必然会成功。</p>
<h1 id="考点3-异常处理-运行时异常非运行时异常"><a href="#考点3-异常处理-运行时异常非运行时异常" class="headerlink" title="考点3:异常处理 运行时异常非运行时异常"></a>考点3:异常处理 运行时异常非运行时异常</h1><p>下列关于异常处理的描述中，错误的是()。</p>
<ul>
<li>A 程序运行时异常由<code>Java</code>虚拟机自动进行处理</li>
<li>B 使用<code>try-catch-finally</code>语句捕获异常</li>
<li>C 可使用<code>throw</code>语句抛出异常</li>
<li>D 捕获到的异常只能在当前方法中处理，不能在其他方法中处理</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h2 id="运行时异常不需要显示处理"><a href="#运行时异常不需要显示处理" class="headerlink" title="运行时异常不需要显示处理"></a>运行时异常不需要显示处理</h2><p>运行时异常可以不处理。当出现这样的异常时，总是由虚拟机接管。<br>比如我们从来没有人去处理过NullPointerException异常，它就是运行时异常，并且这种异常还是最常见的异常之一。<br>出现运行时异常后，系统会把异常一直往上层抛，一直遇到处理代码。如果没有处理块，到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。<br>抛出之后，如果是线程，这个线程也就退出了。<br>如果是主程序抛出的异常，整个程序也就退出了。<br>运行时异常是Exception的子类，也有一般异常的特点，是可以被Catch块处理的。只不过往往不对它处理罢了。<br>也就是说，如果不对运行时异常进行处理，那么出现运行时异常之后，要么是线程中止，要么是主程序终止。</p>
<h2 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h2><p>C：throw关键字：语句抛出异常  throws关键字：声明异常（方法抛出一个异常）</p>
<p>1.编译时异常必须显示处理，运行时异常交给虚拟机自行处理。</p>
<h1 id="考点4-HashMap源码"><a href="#考点4-HashMap源码" class="headerlink" title="考点4:HashMap源码"></a>考点4:HashMap源码</h1><p>下面有关java hashmap的说法错误的是？</p>
<ul>
<li>A HashMap的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。</li>
<li>B HashMap的实现不是同步的，意味着它不是线程安全的</li>
<li>C HashMap通过开放地址法解决哈希冲突</li>
<li>D HashMap中的key-value都是存储在Entry数组中的</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h2 id="Java8之前HashMap使用链地址法"><a href="#Java8之前HashMap使用链地址法" class="headerlink" title="Java8之前HashMap使用链地址法"></a>Java8之前HashMap使用链地址法</h2><p>1.在Java 8 之前，HashMap和其他基于map的类都是通过<strong>链地址法解决冲突</strong>，它们使用单向链表来存储相同索引值的元素。在最坏的情况下，这种方式会将HashMap的get方法的性能从O(1)降低到O(n)。</p>
<h2 id="Java8-HashMap"><a href="#Java8-HashMap" class="headerlink" title="Java8 HashMap"></a>Java8 HashMap</h2><p>为了解决在频繁冲突时hashmap性能降低的问题，<strong>Java 8中使用平衡树来替代链表存储冲突的元素</strong>。这意味着我们可以将最坏情况下的性能从O(n)提高到O(logn)。</p>
<p>在Java 8中使用常量TREEIFY_THRESHOLD来控制是否切换到平衡树来存储。HashMap一开始使用链表，并在冲突的元素数量超过TREEIFY_THRESHOLD时用平衡二叉树替换链表。目前，这个常量值是8。</p>
<p>不过这一特性在所有基于hash table的类中并没有，例如Hashtable和WeakHashMap。</p>
<h2 id="1-关于HashMap的一些说法："><a href="#1-关于HashMap的一些说法：" class="headerlink" title="1. 关于HashMap的一些说法："></a>1. 关于HashMap的一些说法：</h2><p>a) HashMap实际上是一个“<strong>链表散列</strong>”的数据结构，即数组和链表的结合体。HashMap的底层结构是一个数组，数组中的每一项是一条链表。<br>b) HashMap的实例有俩个参数影响其性能： “<strong>初始容量</strong>” 和 <strong>装填因子</strong>。<br>c) HashMap实现不同步，<strong>线程不安全</strong>。 HashTable线程安全<br>d) HashMap中的key-value都是存储在<strong>Entry</strong>中的。<br>e) HashMap<strong>可以存</strong>null键和null值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode()方法和equals()方法保证键的唯一性</p>
<h2 id="解决冲突的三种方法"><a href="#解决冲突的三种方法" class="headerlink" title="解决冲突的三种方法"></a>解决冲突的三种方法</h2><p>f) 解决冲突主要有<strong>三种</strong>方法：<strong>定址法，拉链法，再散列法</strong>。<br>HashMap是采用<strong>拉链法</strong>解决哈希冲突的。 注： 链表法是将相同hash值的对象组成一个链表放在hash值对应的槽位；</p>
<h3 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h3><p>用<strong>开放定址法</strong>解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。 沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。</p>
<h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p><strong>拉链法</strong>解决冲突的做法是： 将所有关键字为同义词的结点链接在同一个单链表中 。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。拉链法适合未规定元素的大小。</p>
<h2 id="2-Hashtable和HashMap的区别："><a href="#2-Hashtable和HashMap的区别：" class="headerlink" title="2. Hashtable和HashMap的区别："></a>2. Hashtable和HashMap的区别：</h2><h3 id="a-继承不同"><a href="#a-继承不同" class="headerlink" title="a) 继承不同"></a>a) 继承不同</h3><pre>
    public class Hashtable extends <mark>Dictionary</mark> implements Map
    public class HashMap extends <mark>AbstractMap</mark> implements Map
</pre>

<h3 id="b-线程安全不同"><a href="#b-线程安全不同" class="headerlink" title="b) 线程安全不同"></a>b) 线程安全不同</h3><p>Hashtable中的方法是同步的，<br>而HashMap中的方法在缺省情况下是非同步的。</p>
<p>在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。</p>
<h3 id="c-key和value能有null不同"><a href="#c-key和value能有null不同" class="headerlink" title="c) key和value能有null不同"></a>c) key和value能有null不同</h3><p>Hashtable中，key和value都不允许出现null值。<br>在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示HashMap中没有该键，也可以表示该键所对应的值为null。</p>
<p>因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键，而应该用containsKey()方法来判断。</p>
<h3 id="d-遍历方式不同"><a href="#d-遍历方式不同" class="headerlink" title="d) 遍历方式不同"></a>d) 遍历方式不同</h3><p>两个遍历方式的<strong>内部实现上不同</strong>。Hashtable、HashMap都使用了Iterator。<br>而由于历史原因，Hashtable还使用了Enumeration的方式 。</p>
<h3 id="e-哈希值的使用不同"><a href="#e-哈希值的使用不同" class="headerlink" title="e) 哈希值的使用不同"></a>e) 哈希值的使用不同</h3><p><strong>哈希值的使用不同</strong>，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</p>
<h3 id="f-内部实现方式的数组的初始大小和扩容的方式。"><a href="#f-内部实现方式的数组的初始大小和扩容的方式。" class="headerlink" title="f) 内部实现方式的数组的初始大小和扩容的方式。"></a>f) 内部实现方式的数组的初始大小和扩容的方式。</h3><p>Hashtable中hash数组默认大小是11，<br>增加的方式是old*2+1。</p>
<p>HashMap中hash数组的默认大小是16，而且一定是2的指数。 </p>
<h4 id="HashMap有子类HashSet"><a href="#HashMap有子类HashSet" class="headerlink" title="HashMap有子类HashSet"></a>HashMap有子类HashSet</h4><p>注： HashSet子类依靠hashCode()和equal()方法来区分重复元素。</p>
<p>HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，<strong>这也是HashSet中元素不能重复的原因</strong>。而Map中保存key值的,会去判断当前Map中是否含有该Key对象，内部是先通过key的hashCode,确定有相同的hashCode之后，再通过equals方法判断是否相同。</p>
<h1 id="考点5-HashMap源码"><a href="#考点5-HashMap源码" class="headerlink" title="考点5:HashMap源码"></a>考点5:HashMap源码</h1><p>在Java中，关于HashMap类的描述，以下正确的是 ()</p>
<ul>
<li>A HashMap使用键&#x2F;值得形式保存数据</li>
<li>B HashMap能够保证其中元素的顺序</li>
<li>C HashMap允许将null用作键</li>
<li>D HashMap允许将null用作值</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details>


<table>
<thead>
<tr>
<th align="left">Map集合类</th>
<th align="left">key</th>
<th align="left">value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HashMap</td>
<td align="left">允许为null</td>
<td align="left">允许为null</td>
</tr>
<tr>
<td align="left">TreeMap</td>
<td align="left">不允许为null</td>
<td align="left">允许为null</td>
</tr>
<tr>
<td align="left">ConcurrentMap</td>
<td align="left">不允许为null</td>
<td align="left">不允许为null</td>
</tr>
<tr>
<td align="left">Hashtable</td>
<td align="left">不允许为null</td>
<td align="left">不允许为null</td>
</tr>
</tbody></table>
<p>HashMap 不按插入顺序排序，按照哈希值排序。所以无序。<br>但是不增删改键的情况下，输出是按照一定顺序不变的</p>
<p>HashMap允许一个key为null，多个value为null，而Hashtable不允许有null值</p>
<p>我们常说的Map是无序的，其实这里的描述是不清楚的，我们所说的无序通常是指HashMap无序，因为TreeMap按自然顺序排序，LinkedHashMap按添加元素顺序排序</p>
<h1 id="考点6-常见final类"><a href="#考点6-常见final类" class="headerlink" title="考点6:常见final类"></a>考点6:常见final类</h1><p>下面哪些类可以被继承？ Java.lang.Thread、java.lang.Number、java.lang.Double、java.lang.Math、 java.lang.ClassLoader</p>
<ul>
<li>A Thread</li>
<li>B Number</li>
<li>C Double</li>
<li>D Math</li>
<li>E ClassLoader</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABE</details>

<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>Thread可以被继承，用于创建新的线程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Thread extends Object implements Runnable</span><br></pre></td></tr></table></figure>

<h2 id="Number是抽象类，可以被继承"><a href="#Number是抽象类，可以被继承" class="headerlink" title="Number是抽象类，可以被继承"></a>Number是抽象类，可以被继承</h2><p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Number.html">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Number.html</a></p>
<pre>
public abstract class Numberextends Object implements Serializable
</pre>

<blockquote>
<p>Direct Known Subclasses:<br>AtomicInteger, AtomicLong, BigDecimal, BigInteger, <strong>Byte</strong>, <strong>Double</strong>, DoubleAccumulator, DoubleAdder, <strong>Float</strong>, <strong>Integer</strong>, <strong>Long</strong>, LongAccumulator, LongAdder, Short</p>
</blockquote>
<p>Number类可以被继承，Integer，Float，Double等都继承自Number类</p>
<h2 id="包装类是final修饰的，无法继承"><a href="#包装类是final修饰的，无法继承" class="headerlink" title="包装类是final修饰的，无法继承"></a>包装类是final修饰的，无法继承</h2><pre>
public <mark>final</mark> class Double extends Number implements Comparable&lt;Double&gt;
</pre>

<h2 id="Math类是final类"><a href="#Math类是final类" class="headerlink" title="Math类是final类"></a>Math类是final类</h2><p>Math类的声明为</p>
<pre>
public <mark>final</mark> class Mathextends Object
</pre>

<h2 id="ClassLoader是抽象类"><a href="#ClassLoader是抽象类" class="headerlink" title="ClassLoader是抽象类"></a>ClassLoader是抽象类</h2><p>ClassLoader可以被继承，用户可以自定义类加载器</p>
<pre>
public <mark>abstract</mark> class ClassLoader extends Object
</pre>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年09月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月11日 java1</title>
    <url>/exam//69f24af8/</url>
    <content><![CDATA[<h1 id="考点1-抽象类和接口的区别"><a href="#考点1-抽象类和接口的区别" class="headerlink" title="考点1:抽象类和接口的区别"></a>考点1:抽象类和接口的区别</h1><p>下列对接口的说法，正确的是( )</p>
<ul>
<li>A 接口与抽象类是相同的概念</li>
<li>B 若要实现一个接口为普通类则必须实现接口的所有抽象方法</li>
<li>C 接口之间不能有继承关系</li>
<li>D 一个类只能实现一个接口</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>A 接口与抽象类是不同的概念。抽象类是用于捕捉子类的通用特性，接口是抽象方法的集合；<br>B 实现接口必须实现接口的所有方法；<br>C 接口可以继承一个或多个接口，抽象类只能继承一个类或者实现多个接口；<br>D 一个类只能继承一个类，但是可以实现多个接口。</p>
<p>自jdk8之后,实现类不必实现接口的所有方法!此题需要添加限制条件!!!!!因为jdk8之后为了引入steam(),增加了default关键字!<br>java8之后，对接口进行了增强，新增了default和static方法，这两种是不用子类去实现的</p>
<h1 id="考点2-HashSet"><a href="#考点2-HashSet" class="headerlink" title="考点2:HashSet"></a>考点2:HashSet</h1><p>有这样一段程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>&#123; </span><br><span class="line">        List list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>(); </span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Set set=<span class="keyword">new</span> <span class="title class_">HashSet</span>(); </span><br><span class="line">        set.add(<span class="string">&quot;a&quot;</span>); </span><br><span class="line">        set.add(<span class="string">&quot;b&quot;</span>); </span><br><span class="line">        set.add(<span class="string">&quot;a&quot;</span>); </span><br><span class="line">        System.out.println(list.size()+<span class="string">&quot;,&quot;</span>+set.size()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请问运行主要的程序会打印出的是什么（）</p>
<ul>
<li>A 2,2</li>
<li>B 2,3</li>
<li>C 3,2</li>
<li>D 3,3</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>list有序可重复，set无序不可重复</p>
<p>HashSet不能添加重复的元素，当调用add(Object)方法时候，<br>首先会调用Object的hashCode方法判hashCode是否已经存在，如不存在则直接插入元素；<br>如果已存在则调用Object对象的equals方法判断是否返回true， 如果为true则说明元素已经存在，如为false则插入元素</p>
<h1 id="考点3-字符串和整数的连接操作"><a href="#考点3-字符串和整数的连接操作" class="headerlink" title="考点3:字符串和整数的连接操作"></a>考点3:字符串和整数的连接操作</h1><p>下面这三条语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;is &quot;</span>+ <span class="number">100</span> + <span class="number">5</span>)；</span><br><span class="line">System.out.println(<span class="number">100</span> + <span class="number">5</span> +<span class="string">&quot; is&quot;</span>)；</span><br><span class="line">System.out.println(<span class="string">&quot;is &quot;</span>+ (<span class="number">100</span> + <span class="number">5</span>))；</span><br></pre></td></tr></table></figure>
<p>的输出结果分别是？ ( )</p>
<ul>
<li>A <code>is 1005, 1005 is, is 1005</code></li>
<li>B <code>is 105, 105 is, is 105</code></li>
<li>C <code>is 1005, 1005 is, is 105</code></li>
<li>D <code>is 1005, 105 is, is 105</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>1.”is”说明后面的内容都会被强制转换为string，所以是最后结果是拼接起来的<br>2.100+5先得到105，然后与is拼接<br>3.先算括号内的</p>
<p>在java中，“+” 和 “+&#x3D;” 是经过重载的运算符，而java不允许程序员进行运算符的重载。<br>如果 “+”之前是String，那么此时，“+” 的作用就是连接两个字符串；<br>若此时 “+” 后面是基本数据类型的话，可以直接进行连接，若是引用数据类型的话，则会调用该对象的toString()方法。</p>
<p>关键看顺序<br>String先出现，则其后的int统一当作String来拼接<br>若两个int先出现，则int会先执行运算<br>如果有括号，括优先级高于运算符</p>
<h1 id="考点4-start方法才是启动线程"><a href="#考点4-start方法才是启动线程" class="headerlink" title="考点4:start方法才是启动线程"></a>考点4:start方法才是启动线程</h1><p>下面程序的运行结果是：（    ）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">pong();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">t.run();</span><br><span class="line">System.out.print(<span class="string">&quot;ping&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pong</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.print(<span class="string">&quot;pong&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A pingpong</li>
<li>B pongping</li>
<li>C pingpong和pongping都有可能</li>
<li>D 都不输出</li>
<li>E pong</li>
<li>F ping</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>t.run是调用的Thead类中的run()方法，t.start才是执行线程，<br>所以这题就是执行普通run()方法，先输出pong，在输出ping。</p>
<h1 id="考点5-等价类-无效等价类"><a href="#考点5-等价类-无效等价类" class="headerlink" title="考点5:等价类 无效等价类"></a>考点5:等价类 无效等价类</h1><p>某程序要求每次输入只能是正整数，并且每次输入的数值要求必须是100的倍数且小于等于500，则下列哪个是正确的无效等价类(        )</p>
<ul>
<li>A （0，100）、（100，200）、（200，300）、（300，400）、（400，500）、（500，+∞）;</li>
<li>B （500，+∞）</li>
<li>C （500，+∞）、任意大于0小于500的非100倍数的整数；</li>
<li>D （-∞，100）、（100，200）、（200，300）、（300，400）、（400，500）、（500，+∞）;</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<p>无效等价类和有效等价类相反，即<strong>不满足程序输入要求或者无效的输入数据构成的集合</strong>。</p>
<h2 id="什么是有效等价类"><a href="#什么是有效等价类" class="headerlink" title="什么是有效等价类"></a>什么是有效等价类</h2><blockquote>
<p><a href="https://baike.baidu.com/item/%E6%97%A0%E6%95%88%E7%AD%89%E4%BB%B7%E7%B1%BB">https://baike.baidu.com/item/%E6%97%A0%E6%95%88%E7%AD%89%E4%BB%B7%E7%B1%BB</a><br>有效等价类指输入完全满足程序输入的规格说明，有效、有意义的输入数据所构成的集合。利用有效等价类可以检验程序是否满足规格说明所规定的功能和性能。 </p>
</blockquote>
<h2 id="什么是无效等价类"><a href="#什么是无效等价类" class="headerlink" title="什么是无效等价类"></a>什么是无效等价类</h2><p>无效等价类和有效等价类相反，即不满足程序输入要求或者无效的输入数据构成的集合。使用无效等价类，可以鉴别程序异常情况的处理。</p>
<p>在程序设计中，不但要保证所有有效地数据输入能产生正确的输出，同时需要保障在输入错误或者空输入的时候能有异常保护，这样的测试才能保证软件的可靠性。</p>
<p>等价类（满足条件的集合）：</p>
<p>$ {100,200,300,400,500}$​</p>
<p>无效等价类：</p>
<p>$(-\infty,100) \bigcup (100,200) \bigcup (200,300) \bigcup (300,400) \bigcup(400,500) \bigcup(500,+\infty)$</p>
<h1 id="考点6-对象流-序列化"><a href="#考点6-对象流-序列化" class="headerlink" title="考点6:对象流 序列化"></a>考点6:对象流 序列化</h1><p>以下关于对象序列化描述正确的是</p>
<ul>
<li>A 使用FileOutputStream可以将对象进行传输</li>
<li>B 使用PrintWriter可以将对象进行传输</li>
<li>C 使用transient修饰的变量不会被序列化</li>
<li>D 对象序列化的所属类需要实现Serializable接口</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: CD</details>

<p>使用ObjectOutputStream和ObjectInputStream可以将对象进行传输.<br>声明为static和transient类型的成员数据不能被串行化。<br>因为static代表类的状态， transient代表对象的临时数据。</p>
<h1 id="考点7-抽象类和接口的区别"><a href="#考点7-抽象类和接口的区别" class="headerlink" title="考点7:抽象类和接口的区别"></a>考点7:抽象类和接口的区别</h1><p>jdk1.8中，下面有关java 抽象类和接口的区别，说法错误的是？</p>
<ul>
<li>A 抽象类可以有构造方法，接口中不能有构造方法</li>
<li>B 抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法</li>
<li>C 一个类可以实现多个接口，但只能继承一个抽象类</li>
<li>D 接口中可以有普通成员变量，抽象类中没有普通成员变量</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: BD</details>

<ol>
<li>接口中不能有构造方法，抽象类中可以有。<ol>
<li>抽象类中构造方法作用：用于初始化抽象类的成员；</li>
<li><strong>抽象类的构造方法不能像普通类那样直接调用</strong>，抽象类的构造方法一般由为继承它的子类使用super调用，或者创建抽象类匿名内部类子类是调用。</li>
</ol>
</li>
<li>接口中方法默认是public abstract（只能是这两个关键字，或其中一个或都省略）</li>
<li>接口中的变量默认是public static final（只能是这三个关键字，或其中两个&#x2F;一个或都省略）</li>
</ol>
<p>Ps : java中一个类只能继承一个类，但一个接口可以继承多个接口</p>
<h2 id="不能通过调用抽象类的构造器来创建对象"><a href="#不能通过调用抽象类的构造器来创建对象" class="headerlink" title="不能通过调用抽象类的构造器来创建对象"></a>不能通过调用抽象类的构造器来创建对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> base.abstractandinterface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractTest</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">protected</span> String b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractTest</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractTest</span><span class="params">(<span class="type">int</span> a, String b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractTest</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">AbstractTest</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类的构造器</span></span><br><span class="line">        <span class="built_in">super</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> a, String b)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类的构造器</span></span><br><span class="line">        <span class="built_in">super</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;int Class A ...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a + <span class="string">&quot;,b=&quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        AbstractTest abstractTest;</span><br><span class="line">        <span class="comment">// 抽象类不能直接调用构造器进行初始化</span></span><br><span class="line">        abstractTest = <span class="keyword">new</span> <span class="title class_">AbstractTest</span>();</span><br><span class="line">        <span class="comment">// abstractTest = new AbstractTest(20, &quot;helloworld&quot;);</span></span><br><span class="line">        abstractTest = <span class="keyword">new</span> <span class="title class_">A</span>(<span class="number">20</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">        abstractTest.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;AbstractTest&#x27; is abstract; cannot be instantiated</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">abstractTest = <span class="keyword">new</span> <span class="title class_">AbstractTest</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在匿名内部类方式实现的子类中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">abstractTest.show();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在匿名内部类方式实现的子类中</span><br></pre></td></tr></table></figure>

<h2 id="接口没有构造器"><a href="#接口没有构造器" class="headerlink" title="接口没有构造器"></a>接口没有构造器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InterfaceTest</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>报错如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Not allowed in interface</span><br></pre></td></tr></table></figure>

<h1 id="考点8-Java基础知识"><a href="#考点8-Java基础知识" class="headerlink" title="考点8:Java基础知识"></a>考点8:Java基础知识</h1><p>下面有关Java的说法正确的是（    ）</p>
<ul>
<li>A 一个类可以实现多个接口</li>
<li>B 抽象类必须有抽象方法</li>
<li>C protected成员在子类可见性可以修改</li>
<li>D 通过super可以调用父类构造函数</li>
<li>E final的成员方法实现中只能读取类的成员变量</li>
<li>F String是不可修改的，且java运行环境中对string对象有一个对象池保存</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ACDF</details>

<p>解释一下c选项，意思是父类中的protected方法子类在重写的时候访问权限可以修改，其实就是重写的要素之一，换了个说法而已<br>抽象类可以不具有抽象方法! 抽象类可以不具有抽象方法! 抽象类可以不具有抽象方法! 重要的事情说三遍</p>
<h1 id="考点9-HttpServletRequest方法"><a href="#考点9-HttpServletRequest方法" class="headerlink" title="考点9:HttpServletRequest方法"></a>考点9:HttpServletRequest方法</h1><p>以下哪些方法可以取到http请求中的cookie值（）?</p>
<ul>
<li>A <code>request.getAttribute</code></li>
<li>B <code>request.getHeader</code></li>
<li>C <code>request.getParameter</code></li>
<li>D <code>request.getCookies</code><br>&#96;<details><summary>显示答案/隐藏答案</summary>正确答案: BD</details></li>
</ul>
<p>下面的方法可用在 Servlet 程序中读取 HTTP 头。这些方法通过 HttpServletRequest 对象可用：</p>
<p> 1）Cookie[] getCookies()<br> 返回一个数组，包含客户端发送该请求的所有的 Cookie 对象。</p>
<p> 2）Object getAttribute(String name)<br> 以对象形式返回已命名属性的值，如果没有给定名称的属性存在，则返回 null。</p>
<p> 3）String getHeader(String name)<br> 以字符串形式返回指定的请求头的值。<strong>Cookie也是头的一种</strong>；</p>
<p> 4）String getParameter(String name)<br> 以字符串形式返回请求参数的值，或者如果参数不存在则返回 null。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年09月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月14日 java1</title>
    <url>/exam//d8cef3a1/</url>
    <content><![CDATA[<h1 id="考点1-局部变量没有默认值，必须初始化"><a href="#考点1-局部变量没有默认值，必须初始化" class="headerlink" title="考点1:局部变量没有默认值，必须初始化"></a>考点1:局部变量没有默认值，必须初始化</h1><p>下列代码中的错误原因是（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">(<span class="number">2</span>)   &#123;</span><br><span class="line">(<span class="number">3</span>)       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span></span><br><span class="line">(<span class="number">4</span>)       &#123;</span><br><span class="line">(<span class="number">5</span>)           <span class="type">int</span> i;</span><br><span class="line">(<span class="number">6</span>)           i+=<span class="number">1</span>;</span><br><span class="line">(<span class="number">7</span>)       &#125;</span><br><span class="line">(<span class="number">8</span>)   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A 非法的表达式 i+&#x3D;1</li>
<li>B 找不到符号i</li>
<li>C 类不应为public</li>
<li>D 尚未初始化变量i</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>成员变量的基本数据类型可以不初始化，有默认值<br>局部变量的基本数据类型必须初始化，没有默认值</p>
<h1 id="考点2-String常量"><a href="#考点2-String常量" class="headerlink" title="考点2:String常量"></a>考点2:String常量</h1><p>针对下面的代码块,哪个equal为true:（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;xiaopeng&quot;</span> ;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;xiaopeng&quot;</span> ;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">String</span> (s1);</span><br></pre></td></tr></table></figure>

<ul>
<li>A s1 &#x3D;&#x3D; s2</li>
<li>B s1 &#x3D; s2</li>
<li>C s2 &#x3D;&#x3D; s3</li>
<li>D 都不正确</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>string是final修饰的，会将创建的变量放入字符串常量池，当再创建同样的字符串时，发现常量池中有则直接使用</p>
<h1 id="考点3-成员变量有默认初始值，可以不初始化"><a href="#考点3-成员变量有默认初始值，可以不初始化" class="headerlink" title="考点3:成员变量有默认初始值，可以不初始化"></a>考点3:成员变量有默认初始值，可以不初始化</h1><p>当你编译和运行下面的代码时，会出现下面选项中的哪种情况？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pvf</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> Paddy;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        System.out.println(Paddy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A 编译时错误</li>
<li>B 编译通过并输出结果false</li>
<li>C 编译通过并输出结果true</li>
<li>D 编译通过并输出结果null</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>类中声明的变量有默认初始值；方法中声明的变量没有默认初始值，必须在定义时初始化，否则在访问该变量时会出错。<br>boolean类型默认值是false。</p>
<h1 id="考点4-HashMap添加元素时key相同新value覆盖旧value"><a href="#考点4-HashMap添加元素时key相同新value覆盖旧value" class="headerlink" title="考点4:HashMap添加元素时key相同新value覆盖旧value"></a>考点4:HashMap添加元素时key相同新value覆盖旧value</h1><p>以下java程序代码，执行后的结果是（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.HashMap map=<span class="keyword">new</span> <span class="title class_">java</span>.util.HashMap();</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">System.out.println(map.size());</span><br></pre></td></tr></table></figure>
<ul>
<li>A 0</li>
<li>B null</li>
<li>C 1</li>
<li>D 2</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<p>HashMap可以插入null的key或value，插入的时候，检查是否已经存在相同的key，如果不存在，则直接插入，如果存在，则用新的value替换旧的value，在本题中，第一条put语句，会将key&#x2F;value对插入HashMap，而第二条put，因为已经存在一个key为name的项，所以会用新的value替换旧的vaue，因此，两条put之后，HashMap中只有一个key&#x2F;value键值对。那就是（name，jack）。所以，size为1.</p>
<h1 id="考点5-访问控制符"><a href="#考点5-访问控制符" class="headerlink" title="考点5:访问控制符"></a>考点5:访问控制符</h1><p>类A1和类A2在同一包中，类A2有个protected的方法testA2，类A1不是类A2的子类（或子类的子类），类A1可以访问类A2的方法testA2。（  ）</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h1 id="考点6-TreeSet的subSet方法"><a href="#考点6-TreeSet的subSet方法" class="headerlink" title="考点6:TreeSet的subSet方法"></a>考点6:TreeSet的subSet方法</h1><p>以下程序的运行结果是：(    )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Integer&gt;();</span><br><span class="line">TreeSet&lt;Integer&gt; subSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">606</span>;i&lt;<span class="number">613</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">set.add(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">subSet = (TreeSet)set.subSet(<span class="number">608</span>,<span class="literal">true</span>,<span class="number">611</span>,<span class="literal">true</span>);</span><br><span class="line">set.add(<span class="number">629</span>);</span><br><span class="line">System.out.println(set+<span class="string">&quot; &quot;</span>+subSet);</span><br></pre></td></tr></table></figure>

<ul>
<li>A 编译失败</li>
<li>B 发生运行时异常</li>
<li>C [606, 608, 610, 612, 629] [608, 610]</li>
<li>D [606, 608, 610, 612, 629] [608, 610,629]</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>subset方法是求set的范围内的子集，两个true是表示是否包含端点（608和611），故subSet的值为[608,610]<br>subset的两个boo是是否是边界值</p>
<h1 id="考点7-Object方法"><a href="#考点7-Object方法" class="headerlink" title="考点7:Object方法"></a>考点7:Object方法</h1><p>下面有关java object默认的基本方法，说法错误的是？</p>
<ul>
<li>A equals(Object obj) 指示某个其他对象是否与此对象“相等”</li>
<li>B copy() 创建并返回此对象的一个副本</li>
<li>C wait() 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法</li>
<li>D toString() 返回该对象的字符串表示</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>Object中没有copy方法<br>Object的其中clone()创建并返回此对象的一个副本。没有copy()这个方法。<br>Object默认9方法：getClass(),hashCode(), equals(), clone(), toString(),notify(), notifyAll()wait(), finalize()。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>protected Object clone()</code></td>
<td align="left">Creates and returns a copy of this object.</td>
</tr>
<tr>
<td align="left"><code>boolean equals(Object obj)</code></td>
<td align="left">Indicates whether some other object is “equal to” this one.</td>
</tr>
<tr>
<td align="left"><code>protected void finalize()</code></td>
<td align="left"><strong>Deprecated</strong>. The finalization mechanism is inherently problematic.</td>
</tr>
<tr>
<td align="left"><code>Class&lt;?&gt; getClass()</code></td>
<td align="left">Returns the runtime class of this Object.</td>
</tr>
<tr>
<td align="left"><code>int hashCode()</code></td>
<td align="left">Returns a hash code value for the object.</td>
</tr>
<tr>
<td align="left"><code>void notify()</code></td>
<td align="left">Wakes up a single thread that is waiting on this object’s monitor.</td>
</tr>
<tr>
<td align="left"><code>void notifyAll()</code></td>
<td align="left">Wakes up all threads that are waiting on this object’s monitor.</td>
</tr>
<tr>
<td align="left"><code>String toString()</code></td>
<td align="left">Returns a string representation of the object.</td>
</tr>
<tr>
<td align="left"><code>void wait()</code></td>
<td align="left">Causes the current thread to wait until it is awakened, typically by being notified or interrupted.</td>
</tr>
<tr>
<td align="left"><code>void wait(long timeoutMillis)</code></td>
<td align="left">Causes the current thread to wait until it is awakened, typically by being notified or interrupted, or until a certain amount of real time has elapsed.</td>
</tr>
<tr>
<td align="left"><code>void wait(long timeoutMillis, int nanos)</code></td>
<td align="left">Causes the current thread to wait until it is awakened, typically by being notified or interrupted, or until a certain amount of real time has elapsed.</td>
</tr>
</tbody></table>
<h1 id="考点8-ASCII码和ANSI码"><a href="#考点8-ASCII码和ANSI码" class="headerlink" title="考点8:ASCII码和ANSI码"></a>考点8:ASCII码和ANSI码</h1><p>关于ASCII码和ANSI码，以下说法不正确的是（）？</p>
<ul>
<li>A 标准ASCII只使用7个bit</li>
<li>B 在简体中文的Windows系统中，ANSI就是GB2312</li>
<li>C ASCII码是ANSI码的子集</li>
<li>D ASCII码都是可打印字符</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>A、标准ASCII只使用7个bit，扩展的ASCII使用8个bit。<br>B、ANSI通常使用 0x00<del>0x7f 范围的1 个字节来表示 1 个英文字符。超出此范围的使用0x80</del>0xFFFF来编码，即扩展的ASCII编码。不同 ANSI 编码之间互不兼容。在简体中文Windows操作系统中，ANSI 编码代表 GBK 编码；在繁体中文Windows操作系统中，ANSI编码代表Big5；在日文Windows操作系统中，ANSI 编码代表 Shift_JIS 编码。<br>C、ANSI通常使用 0x00~0x7f 范围的1 个字节来表示 1 个英文字符，即ASCII码<br>D、ASCII码包含一些特殊空字符</p>
<p>ASCII表上的数字 0–31 分配给了<strong>控制字符</strong>，用于控制像打印机等一些外围设备。</p>
<p>我看下面一些评论对ANSI编码解释都有些许错误，现在解释一下ANSI编码：不同的国家和地区制定了不同的标准，由此产生了 GB2312、GBK、Big5、Shift_JIS 等各自的编码标准。这些使用 1 至 4 个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码。在简体中文Windows操作系统中，ANSI 编码代表 GBK 编码；在日文Windows操作系统中，ANSI 编码代表 Shift_JIS 编码。 不同 ANSI 编码之间互不兼容，当信息在国际间交流时，无法将属于两种语言的文字，存储在同一段 ANSI 编码的文本中。 当然对于ANSI编码而言，0x00~0x7F之间的字符，依旧是1个字节代表1个字符。这一点是ANSI编码与Unicode编码之间最大也最明显的区别。</p>
<h1 id="考点9-Java标识符规则"><a href="#考点9-Java标识符规则" class="headerlink" title="考点9:Java标识符规则"></a>考点9:Java标识符规则</h1><p>下列可作为java语言标识符的是（）</p>
<ul>
<li>A <code>a1</code></li>
<li>B <code>$1</code></li>
<li>C <code>_1</code></li>
<li>D <code>11</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<p>Java标识符由数字，字母和下划线（_），美元符号（$）或人民币符号（￥）组成。在Java中是区分大小写的，而且还要求首位不能是数字。最重要的是，Java关键字不能当作Java标识符。</p>
<ol>
<li>标识符的组成元素是字母（<code>a-z</code>，<code>A-Z</code>），数字（<code>0~9</code>），下划线（<code>_</code>）和美元符号（<code>$</code>）。</li>
<li>标识符不能以数字开头。</li>
<li>java的标识符是严格区分大小写的。</li>
<li>标识符的长度可以是任意的。</li>
<li>关键字以及引用类型常量null、boolean常量true、false不能用于自定义的标识符。</li>
</ol>
<h1 id="考点10-x3D-会自动类型转换（自动装箱）-x3D-不会自动类型转换"><a href="#考点10-x3D-会自动类型转换（自动装箱）-x3D-不会自动类型转换" class="headerlink" title="考点10:+&#x3D;会自动类型转换（自动装箱）&#x3D;不会自动类型转换"></a>考点10:+&#x3D;会自动类型转换（自动装箱）&#x3D;不会自动类型转换</h1><p>以下那些代码段能正确执行</p>
<ul>
<li>A <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">b = a + b;</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>B <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">126</span>;</span><br><span class="line">b = a + b;</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>C <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">a+=b;</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>D <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">a+=b;</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details><summary>显示答案/隐藏答案</summary>正确答案: CD</details></li>
</ul>
<p>char、byte、short相加时会自动转换为int类型，所以：<br>A、B选项需要加强转(byte)<br>C、D选项中的+&#x3D;会自动进行强转，相当于加了(byte)；<br>D选项中的越界问题，由于byte的最大值与最小值是首尾相接的（不知道这样描述准不准确，byte范围是-128-127，也就是说byte b1&#x3D;(byte)128;System.out.println(b1);打印出来的实际是-128），由于加了强转，所以不会受到越界的影响。<br>有错误之处欢迎指出！</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年09月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月15日 java2</title>
    <url>/exam//f910bb38/</url>
    <content><![CDATA[<h1 id="考点1-catch先捕获子类异常再捕获父类异常"><a href="#考点1-catch先捕获子类异常再捕获父类异常" class="headerlink" title="考点1:catch先捕获子类异常再捕获父类异常"></a>考点1:catch先捕获子类异常再捕获父类异常</h1><p>在异常处理中，若try中的代码可能产生多种异常则可以对应多个catch语句，若catch中的参数类型有父类子类关系，此时应该将父类放在后面，子类放在前面。</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>如果将父类放在前面的话，异常将被父类完全捕获，子类永远不能捕获异常</p>
<h1 id="考点2-自动拆箱"><a href="#考点2-自动拆箱" class="headerlink" title="考点2:自动拆箱"></a>考点2:自动拆箱</h1><p>有如下4条语句：()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i01=<span class="number">59</span>;</span><br><span class="line"><span class="type">int</span> i02=<span class="number">59</span>;</span><br><span class="line">Integer i03=Integer.valueOf(<span class="number">59</span>);</span><br><span class="line">Integer i04=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">59</span>);</span><br></pre></td></tr></table></figure>
<p>以下输出结果为false的是:</p>
<ul>
<li>A System.out.println(i01&#x3D;&#x3D;i02);</li>
<li>B System.out.println(i01&#x3D;&#x3D;i03);</li>
<li>C System.out.println(i03&#x3D;&#x3D;i04);</li>
<li>D System.out.println(i02&#x3D;&#x3D;i04);</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h2 id="int和Integer比较时-Integer会自动拆箱取出值来和int进行比较"><a href="#int和Integer比较时-Integer会自动拆箱取出值来和int进行比较" class="headerlink" title="int和Integer比较时 Integer会自动拆箱取出值来和int进行比较"></a>int和Integer比较时 Integer会自动拆箱取出值来和int进行比较</h2><p>A选项，i01&#x3D;&#x3D;i02，i02是int类型的，i01是Integer类型的，int类型的i02和Integer类型i01比较时，会给i02自动拆箱，取出里面的值59和i01的值59进行比较，59&#x3D;&#x3D;59为true<br>D选项，A选项一样，i02是int类型，i04是Integer类型的，比较值，59&#x3D;&#x3D;59，得到true<br>Integer有默认缓存<code>[-128,+127]</code></p>
<p><code>Integer i01=59;</code>会自动装箱，实际上调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i01=Integer.valueOf(<span class="number">59</span>);</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i03=Integer.valueOf(<span class="number">59</span>);</span><br></pre></td></tr></table></figure>
<p>59在区间<code>[-128,+127]</code>内，所以是同一个对象。</p>
<p>B选项，i01&#x3D;&#x3D;i03，i01是Integer的引用变量名，i02是Integer引用变量，两个引用变量使用<code>==</code>比较时比较的是地址。<br>因为i01和i03引用的都是区间<code>[-128,+127]</code>内事先创建好的<code>59</code>，所以是同一个对象。所以得到true</p>
<p>C选项，i03&#x3D;&#x3D;i04,i03引用的是缓存内的59，i04引用的是新创建的59对象。这两个对象不是同一个对象，所以得到false。</p>
<h1 id="考点3-JVM参数-不懂-待学"><a href="#考点3-JVM参数-不懂-待学" class="headerlink" title="考点3:JVM参数 不懂 待学"></a>考点3:JVM参数 不懂 待学</h1><p>假如某个JAVA进程的JVM参数配置如下：<br>-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize&#x3D;64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio&#x3D;3,<br>请问eden区最终分配的大小是多少？</p>
<ul>
<li>A 64M</li>
<li>B 500M</li>
<li>C 300M</li>
<li>D 100M</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>这是网易2016年在线笔试题中的一道选择题。<br>先分析一下里面各个参数的含义：<br>-Xms：1G ， 就是说初始堆大小为1G<br>-Xmx：2G ， 就是说最大堆大小为2G<br>-Xmn：500M ，就是说<strong>年轻代大小是500M（包括一个Eden和两个Survivor）</strong><br>-XX:MaxPermSize：64M ， 就是说设置持久代最大值为64M<br>-XX:+UseConcMarkSweepGC ， 就是说使用使用CMS内存收集算法<br>-XX:SurvivorRatio&#x3D;3 ， 就是说Eden区与Survivor区的大小比值为3：1：1<br>题目中所问的Eden区的大小是指年轻代的大小，直接根据-Xmn：500M和-XX:SurvivorRatio&#x3D;3可以直接计算得出<br>500M*(3&#x2F;(3+1+1))<br>&#x3D;500M<em>（3&#x2F;5）<br>&#x3D;500M</em>0.6<br>&#x3D;300M<br>所以Eden区域的大小为300M。</p>
<p>参数解释：<br>-Xms1G ：初始堆空间为1G<br>-Xmx2G ：指定最大堆空间为2G<br>-Xmn500M ：指定堆空间的年轻代大小为500M（年轻代&#x3D;Eden+Survivor）<br>-XX:MaxPermSize&#x3D;64M：指定最大永久代为64M<br>-XX:+UseConcMarkSweepGC 使用CMS垃圾收集器<br>-XX:SurvivorRatio&#x3D;3 指定堆的年轻代中Eden和Survivor区的比例，也就是Eden:Survivor(from):Survivor(to)&#x3D;3:1:1<br><strong>由-Xmn500M可知：eden&#x3D;3&#x2F;5*500M&#x3D;300M</strong><br><strong>答案为C，</strong><br>堆内存示意图：<br><img data-src="https://uploadfiles.nowcoder.com/images/20201231/664012_1609386498443/24ED9A1B4F0E6D45AB82F7DBA4B219CD"></p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4:"></a>考点4:</h1><p>下列关于Java并发的说法中正确的是（）</p>
<ul>
<li>A CopyOnWriteArrayList适用于写多读少的并发场景</li>
<li>B ReadWriteLock适用于读多写少的并发场景</li>
<li>C ConcurrentHashMap的写操作不需要加锁，读操作需要加锁</li>
<li>D 只要在定义int类型的成员变量i的时候加上volatile关键字，那么多线程并发执行i++这样的操作的时候就是线程安全的了</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>答案：B<br>A，CopyOnWriteArrayList适用于<strong>写少读多</strong>的并发场景<br>B，ReadWriteLock即为读写锁，他要求写与写之间互斥，读与写之间互斥，读与读之间可以并发执行。在读多写少的情况下可以提高效率<br>C，ConcurrentHashMap是同步的HashMap，读写都加锁<br>D，<strong>volatile只保证多线程操作的可见性</strong>，不保证原子性</p>
<p>对于D选项，volatite只保证线程在“加载数据阶段”加载的数据是最新的，并不能保证线程安全。</p>
<h2 id="volatite"><a href="#volatite" class="headerlink" title="volatite"></a>volatite</h2><p>对于D选项，volatite只保证线程在“加载数据阶段”加载的数据是最新的，并不能保证线程安全。<br>一个线程执行的过程有三个阶段：<br>加载（复制）主存数据到操作栈 –&gt;  对操作栈数据进行修改  –&gt; 将操作栈数据写回主存。</p>
<p>volatite关键字，让编译器不去优化代码使用缓存等，以保证线程在“加载数据阶段”加载的数据都是最新的<br>比如：<br>某一时刻i&#x3D;6是最新的值，volatile保证线程A,B都同时加载了这个最新的值，<br>然后A执行i(A)+1&#x3D;7,然后将7写回主存，<br>B也执行i(B)+1&#x3D;7,然后也将7写回内存，<br>这样，执行两次加法，i却只增加了1。</p>
<p>对于volatile修饰的变量，jvm虚拟机只是保证从主内存加载到线程工作内存的值是最新的，同时线程工作内存中的操作并不是原子性的。所以在一个线程对该变量进行操作的同时，其他的线程有可能也在对该变量进行操作。</p>
<p>A：CopyOnWrite并发容器用于读多写少的并发场景，Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。<br>C：在<strong>JDK1.7</strong>之前，ConcurrentHashMap是通过分段锁机制来实现的，所以其最大并发度受Segment的个数限制。因此，在JDK1.8中，ConcurrentHashMap的实现原理摒弃了这种设计，而是选择了与HashMap类似的<strong>数组+链表+红黑树</strong>的方式实现，而加锁则采用CAS和synchronized实现。读写都加锁<br>D：volatile保证内存可见性和有序性（内存屏障实现），不能保证原子性。</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5:"></a>考点5:</h1><p>如果希望监听TCP端口9000，服务器端应该怎样创建socket?</p>
<ul>
<li>A new Socket(“localhost”,9000);</li>
<li>B new ServerSocket(9000);</li>
<li>C new Socket(9000);</li>
<li>D new ServerSocket(“localhost”,9000);</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>



<p>答案选B。<br><code>ServerSocket(int port)</code>是服务端绑定port端口，调accept()监听等待客户端连接，它返回一个连接队列中的一个socket。<br><code>Socket(InetAddress address ,int port)</code>是创建客户端连接主机的socket流，其中InetAddress是用来记录主机的类，port指定端口。<br>socket和servletSocket的交互如下图所示：<br><img data-src="https://uploadfiles.nowcoder.com/images/20161017/4552908_1476667093647_1915F9C678C8EA2DBDCFB50383935889"><br>详细了解，大家可以看此博客：<a href="http://www.cnblogs.com/rond/p/3565113.html">http://www.cnblogs.com/rond/p/3565113.html</a></p>
<ul>
<li>服务端：ServerSocket(port)，因为服务器知道自己的IP，所以不需要输入IP</li>
<li>客户端：Socket(host,port)，因为客户端不知道连接那个服务端，所以需要输入服务器的IP</li>
</ul>
<p>首先，服务器监听端口的必定用 ServerSocket；其次，根据对 Server 和 Client 的了解，<br>Server 只需要监听请求即可，<br>Client 则必须指明向谁请求和向服务器的哪个端口请求。 </p>
<p>ServerSocket(int port)创建一个serversocket绑定在服务器的特定的端口<br>Socket(InetAddress address, int port)创建一个socket流，连接到指定服务器(address)的指定端口(port)</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6:"></a>考点6:</h1><p>下列描述正确的是（ ）？</p>
<ul>
<li>A 类不可以多继承而接口可以多实现</li>
<li>B 抽象类自身可以定义成员而接口不可以</li>
<li>C 抽象类和接口都不能被实例化</li>
<li>D 一个类可以有多个基类和多个基接口</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

<p>1.java支持单继承，却可以实现多个接口。a对d错<br>2.接口没有构造方法，所以不能实例化，抽象类有构造方法，但是不是用来实例化的，是用来初始化的。c对<br>3.抽象类可以定义普通成员变量,静态成员变量。接口只能定义静态成员常量，也就是接口成员变量要使用 public static final来修饰。b错</p>
<p><strong>接口只能定义静态成员常量</strong></p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7:"></a>考点7:</h1><p>下面的Java赋值语句哪些是有错误的 （）</p>
<ul>
<li>A <code>int i =1000;</code></li>
<li>B <code>float f = 45.0;</code></li>
<li>C <code>char s = &#39;\u0639&#39;</code></li>
<li>D <code>Object o = &#39;f&#39;;</code></li>
<li>E <code>String s = &quot;hello,world\0&quot;;</code></li>
<li>F <code>Double d = 100;</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: BCF</details>

<p>B选项45.0默认是double类型的。<br>C选项少了分号<br>F选项是自动装箱， 装箱过程中调用的是Double类的valueOf(double d)方法， 而这里是100为int型， 所以编译会“cannot convert from int to Double”。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年09月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月15日 java1</title>
    <url>/exam//6019ea82/</url>
    <content><![CDATA[<h1 id="考点1-依赖注入"><a href="#考点1-依赖注入" class="headerlink" title="考点1:依赖注入"></a>考点1:依赖注入</h1><p>下面关于依赖注入(DI)的说法不正确的是()</p>
<ul>
<li>A 只有通过Spring才能实现依赖注入(DI)</li>
<li>B 依赖注入的主要目的是解耦合</li>
<li>C 常见的依赖注入方式有Setter和构造方法</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<p>Spring依赖注入（DI）的三种方式，分别为：<br>1．接口注入<br>2．Setter方法注入<br>3．构造方法注入</p>
<p>属性注入：<br>创建对象时候,向类里面属性里面设置值<br>注入的三种方式（java），在Spring框架中只支持前面两种方式</p>
<h2 id="第一种：使用set方法注入"><a href="#第一种：使用set方法注入" class="headerlink" title="第一种：使用set方法注入"></a>第一种：使用set方法注入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setName(<span class="string">&quot;abcd&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="第二种：有参数构造注入"><a href="#第二种：有参数构造注入" class="headerlink" title="第二种：有参数构造注入"></a>第二种：有参数构造注入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">User user=<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lucy&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="第三种：使用接口注入"><a href="#第三种：使用接口注入" class="headerlink" title="第三种：使用接口注入"></a>第三种：使用接口注入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Dao</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoImplements</span> Dao&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sping使用-有参数构造注入属性"><a href="#sping使用-有参数构造注入属性" class="headerlink" title="sping使用 有参数构造注入属性"></a>sping使用 有参数构造注入属性</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.property.propertyDemo1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小王小马&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestIOC</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 1.加载Spring配置文件，根据创建对象</span></span><br><span class="line">        APPlicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>)</span><br><span class="line">        <span class="comment">// 2.得到配置创建的对象</span></span><br><span class="line">        PropertyDemo1 demo1=(PropertyDemo1)context.getBean(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">        demo1.test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring使用set方法注入属性-使用的更多"><a href="#spring使用set方法注入属性-使用的更多" class="headerlink" title="spring使用set方法注入属性(使用的更多)"></a>spring使用set方法注入属性(使用的更多)</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 代表对象已经创建 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.property.Book&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name属性值：类里面定义的属性名称 value属性：设置具体的值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookname&quot;</span> <span class="attr">vlaue</span>=<span class="string">&quot;易筋经&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String bookname;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String bookname)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.bookname=bookname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demobook</span><span class="params">()</span>&#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;book........&quot;</span>+bookname);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestIOC</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 1.加载Spring配置文件，根据创建对象</span></span><br><span class="line">        APPlicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>)</span><br><span class="line">        <span class="comment">// 2.得到配置创建的对象</span></span><br><span class="line">        Book book=(Book)context.getBean(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">        book.demobook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这篇博文讲到依赖注入。除了spring，还有.net平台一些框架也用到了依赖注入。<br><a href="http://www.cnblogs.com/yangecnu/p/Introduce-Dependency-Injection.html">http://www.cnblogs.com/yangecnu/p/Introduce-Dependency-Injection.html</a></p>
<h1 id="考点2-for循环执行流程"><a href="#考点2-for循环执行流程" class="headerlink" title="考点2:for循环执行流程"></a>考点2:for循环执行流程</h1><p>下列循环语句序列执行完成后，i的值是（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 2</li>
<li>B 10</li>
<li>C 11</li>
<li>D 不确定</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h2 id="for循环的执行顺序"><a href="#for循环的执行顺序" class="headerlink" title="for循环的执行顺序"></a>for循环的执行顺序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>（表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>）</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>表达式1执行一次，判断表达式2是否成立，如果成立执行循环体；</li>
<li>循环体结束，表达式3执行一次，判断表达式2是否成立，如果成立执行循环体；</li>
<li>依次进行2的操作。直到表达式2不成立，退出循环。</li>
</ol>
<p>这个循环最后一次进入循环体时；i&#x3D;10了，然后执行<strong>表达式3</strong>，i&#x3D;11,最后执行<strong>表达式2</strong>，判断11大于10，退出循环。</p>
<h1 id="考点3-Servlet"><a href="#考点3-Servlet" class="headerlink" title="考点3:Servlet"></a>考点3:Servlet</h1><p>从以下哪一个选项中可以获得Servlet的初始化参数?</p>
<ul>
<li>A Servlet</li>
<li>B ServletContext</li>
<li>C ServletConfig</li>
<li>D GenericServlet</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>通过<code>ServletConfig</code>接口的<code>getInitParameter(java.lang.String name)</code>方法。</p>
<p>1）ServletConfig：Servlet的配置对象，容器在初始化Servlet时通过它传递信息给Servlet。<br>2）ServletContext：上下文对象，提供了一系列方法供Servlet与Web容器交互。</p>
<ul>
<li>ServletConfig对象：servlet配置对象，主要把servlet的初始化参数封装到这个对象中。一个网站中可能会存在多个servletConfig对象，一个servletConfig对象就封装了一个servlet的配置信息。可以在web.xml中通过<code>&lt;init-param&gt;&lt;/init-param&gt;</code>标签配置初始化参数，通过getInitParameter(String name)或getInitParameterNames()方法来获取初始化参数。注：初始化参数必须在当前的servlet程序中使用。</li>
<li>ServletContext对象：servlet上下文对象。一个网站只会创建一个servletContext对象，代表的是整个网站的环境信息。可以在web.xml中通过<code>&lt;context-param&gt;&lt;/context-param&gt;</code>标签配置全局参数，是通过servletConfig对象来获取servletContext对象的，调用的是getServletContext()方法。注：如果某个参数整个网站的程序都要使用，那么可将该参数设置为全局参数，因为可通过servletContext域对象去获取。在servle中有三个域对象，分别为：ServletContext、HttpServletRequest和HttpSession。</li>
</ul>
<h1 id="考点4-基本数据类型"><a href="#考点4-基本数据类型" class="headerlink" title="考点4:基本数据类型"></a>考点4:基本数据类型</h1><p>在 Java 中，属于整数类型变量的是（）</p>
<ul>
<li>A single</li>
<li>B double</li>
<li>C byte</li>
<li>D char</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h2 id="Java八种基本数据类型"><a href="#Java八种基本数据类型" class="headerlink" title="Java八种基本数据类型"></a>Java八种基本数据类型</h2><p>Java中的四类八种基本数据类型<br>第一类：整数类型  byte short int long<br>第二类：浮点型  float double<br>第三类：逻辑型  boolean(它只有两个值可取true false)<br>第四类：字符型  char</p>
<h1 id="考点5-Byte表示范文-Byte越界-自动拆箱装箱-引用传参"><a href="#考点5-Byte表示范文-Byte越界-自动拆箱装箱-引用传参" class="headerlink" title="考点5:Byte表示范文 Byte越界 自动拆箱装箱 引用传参"></a>考点5:Byte表示范文 Byte越界 自动拆箱装箱 引用传参</h1><p>如下代码，执行test()函数后，屏幕打印结果为（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Byte b)</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = b++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        add(++a);</span><br><span class="line">        System.out.print(a + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        add(b);</span><br><span class="line">        System.out.print(b + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A 127 127</li>
<li>B 128 127</li>
<li>C 129 128</li>
<li>D 以上都不对</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<p>Byte类型值大小为-128~127之间。并且Byte类型的值首尾相连，越界不会抛出异常<br>add(++a);这里++a会越界，a的值变为-128<br>add(b); 前面说了，add不起任何作用，b还是127</p>
<p>add()方法里面的修改值并不会起作用，而add(++a)会使a数值越界成-128，所以输出为-128 127</p>
<h1 id="考点6-main方式是静态方法不能访问非静态成员变量"><a href="#考点6-main方式是静态方法不能访问非静态成员变量" class="headerlink" title="考点6:main方式是静态方法不能访问非静态成员变量"></a>考点6:main方式是静态方法不能访问非静态成员变量</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System. out. println(<span class="string">&quot;Value is&quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面这段代码，以下说法正确的是：</p>
<ul>
<li>A 程序会打出 “Value is 0”</li>
<li>B 程序会抛出 NullPointerException</li>
<li>C 非静态变量不能够被静态方法引用</li>
<li>D 编译器会抛出 “possible reference before assignment”的错误</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>非静态成员只能被类的实例化对象引用，因此这里在静态方法中访问x会造成编译出错</p>
<p>当类加载时，static静态方法随着类加载而初始化，此时实例对象还未被创建，但是非静态成员变量需要等到实例对象创建才会被初始化，故无法被引用。</p>
<h1 id="考点7-Java表示符规则"><a href="#考点7-Java表示符规则" class="headerlink" title="考点7:Java表示符规则"></a>考点7:Java表示符规则</h1><p>下列不正确的 Java 语言标识符是（ ）</p>
<ul>
<li>A <code>Sky</code></li>
<li>B <code>$Computer</code></li>
<li>C <code>for</code></li>
<li>D <code>NULL</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<p>Java标识符命名规范是：<br>1）只能包含字母a-zA-Z，数字0-9，下划线_和美元符号$；<br>2）首字母不能为数字；<br>3）关键字和保留字不能作为标识符。</p>
<h2 id="中文可以作为变量名"><a href="#中文可以作为变量名" class="headerlink" title="中文可以作为变量名"></a>中文可以作为变量名</h2><p>中文可以作为变量名，中文的货币符号也是中文字符，也是可以作为变量名的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> base;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiaoShiFu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String ￥str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        String 你好 = <span class="string">&quot;helloWorld&quot;</span>;</span><br><span class="line">        System.out.println(￥str);</span><br><span class="line">        System.out.println(你好);</span><br><span class="line">        真的吗();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 真的吗() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;真的吗？我不信！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">123</span><br><span class="line">helloWorld</span><br><span class="line">真的吗？我不信！</span><br></pre></td></tr></table></figure>

<h1 id="考点8-基础知识"><a href="#考点8-基础知识" class="headerlink" title="考点8:基础知识"></a>考点8:基础知识</h1><p>以下说法中正确的有？</p>
<ul>
<li>A StringBuilder是 线程不安全的</li>
<li>B Java类可以同时用 abstract和final声明</li>
<li>C HashMap中，使用 get(key)&#x3D;&#x3D;null可以 判断这个Hasmap是否包含这个key</li>
<li>D volatile关键字不保证对变量操作的原子性</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: AD</details>


<h1 id="考点9-并发"><a href="#考点9-并发" class="headerlink" title="考点9:并发"></a>考点9:并发</h1><p>JDK提供的用于并发编程的同步器有哪些？</p>
<ul>
<li>A Semaphore</li>
<li>B CyclicBarrier</li>
<li>C CountDownLatch</li>
<li>D Counter</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<p>答案：ABC<br>A，Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过<br>acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。<br>B，CyclicBarrier 主要的方法就是一个：await()。await()<br>方法没被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此 CyclicBarrier 上面阻塞的线程开始运行。<br>C，直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指<br>CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。<br>D，Counter不是并发编程的同步器</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年09月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月18日 java1</title>
    <url>/exam//Infinity/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1:"></a>考点1:</h1><p>以下哪个不能用来处理线程安全</p>
<ul>
<li>A synchronized关键字</li>
<li>B volatile关键字</li>
<li>C Lock类</li>
<li>D transient关键字</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<ul>
<li>synchrozied关键字称作同步，主要用来给方法、代码块加锁，被加锁的代码段，同一时间内多线程同时访问同一对象的加锁方法&#x2F;代码块时，只能有一个线程执行能执行方法&#x2F;代码块中的代码，其余线程必须等待当前线程执行完以后才执行该方法&#x2F;代码块。</li>
<li>volatile关键字<ul>
<li>1.保证了不同线程对该变量操作的内存可见性.(当一个线程修改了变量,其他使用次变量的线程可以立即知道这一修改)。</li>
<li>2.禁止了指令重排序.</li>
</ul>
</li>
<li>Lock接口提供了与synchronized关键字类似的同步功能，但需要在使用时手动获取锁和释放锁。</li>
<li>transient关键字  简单地说，就是让某些被修饰的成员属性变量不被序列化。</li>
</ul>
<p>transient，变量修饰符，如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。当一个变量不希望被持久化的时候，比如说一些账号密码，就可以用transient关键字来表示该变量不参与序列化过程。<br>volatile关键字只能保证可见性，不能保证原子性</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2:"></a>考点2:</h1><p>下列代码编译和运行的结果是：（）                                             </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Threads4</span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Threads4</span>().go();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>&#123;</span><br><span class="line"> Runnable r=<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"> System.out.print(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> Thread t=<span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line"> t.start();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>A 编译错误</li>
<li>B 抛出运行时异常</li>
<li>C 输出：foo</li>
<li>D 代码正常运行，但是无输出</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3:"></a>考点3:</h1><p>下列说法正确的是（）？</p>
<ul>
<li>A 我们直接调用Thread对象的run方法会报异常，所以我们应该使用start方法来开启一个线程</li>
<li>B 一个进程是一个独立的运行环境，可以被看做一个程序或者一个应用。而线程是在进程中执行的一个任务。Java运行环境是一个包含了不同的类和程序的单一进程。线程可以被称为轻量级进程。线程需要较少的资源来创建和驻留在进程中，并且可以共享进程中的资源</li>
<li>C synchronized可以解决可见性问题，volatile可以解决原子性问题</li>
<li>D ThreadLocal用于创建线程的本地变量，该变量是线程之间不共享的</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: BD</details>

<p><a href="https://lanlan2017.github.io/JavaReadingNotes/a8a61bd3/">https://lanlan2017.github.io/JavaReadingNotes/a8a61bd3/</a></p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4:"></a>考点4:</h1><p>ArrayLists和LinkedList的区别，下述说法正确的有？</p>
<ul>
<li>A ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</li>
<li>B 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要迭代器。</li>
<li>C 对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。</li>
<li>D ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>

<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5:"></a>考点5:</h1><p>下列哪些操作会使线程释放锁资源？</p>
<ul>
<li>A sleep()</li>
<li>B wait()</li>
<li>C join()</li>
<li>D yield()</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<p>所谓的释放锁资源实际是通知对象内置的monitor对象进行释放，而<strong>只有所有对象都有内置的monitor对象才能实现任何对象的锁资源都可以释放</strong>。又因为所有类都继承自Object，所以wait(）就成了Object方法，也就是通过wait()来通知对象内置的monitor对象释放，而且事实上因为这涉及对硬件底层的操作，所以wait()方法是native方法，底层是用C写的。<br>其他三个方法都是Thread所有，所以其他3个是没有资格释放资源的<br>而<strong>join()有资格释放资源其实是通过调用wait()来实现的</strong></p>
<p>代码如下：<br>wait()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeoutMillis)</span> </span><br><span class="line">    <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>
<p>join()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (millis &amp;lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &amp;lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.sleep()方法</strong><br>在指定时间内让当前正在执行的线程暂停执行，但不会释放“锁标志”。不推荐使用。<br>sleep()使当前线程进入阻塞状态，在指定时间内不会执行。<br><strong>2.wait()方法</strong><br>在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁。<br>当前线程必须拥有当前对象锁。如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常。</p>
<p>唤醒当前对象锁的等待线程使用notify或notifyAll方法，也必须拥有相同的对象锁，否则也会抛出IllegalMonitorStateException异常。<br>waite()和notify()必须在synchronized函数或synchronized　block中进行调用。<br>如果在non-synchronized函数或non-synchronized　block中进行调用，虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。<br><strong>3.yield方法</strong><br>暂停当前正在执行的线程对象。<br>yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。<br>yield()只能使同优先级或更高优先级的线程有执行的机会。<br><strong>4.join方法</strong><br>join()等待该线程终止。<br><strong>等待调用join方法的线程结束</strong>，再继续执行。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t.join();<span class="comment">//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测</span></span><br></pre></td></tr></table></figure>
<p>yield()不会释放锁，只是通知调度器自己可以让出cpu时间片，但只是建议，调度器也不一定采纳</p>
<p>其实没有必要把简单的题目解析的太复杂。基本是只要wait（）方法才会释放锁，而join( )方法底层调用的就是wait( )方法，所以选bc</p>
<p>sleep只能让正在执行的线程暂停执行，但不会释放锁<br>wait方法在其他线程调用对象的notify或notifyAll方法前会导致当前线程等待。线程会释放占有的锁。<br>yield只能使当前线程重新回到可执行状态，不会释放锁</p>
<p>wait会释放锁，join底层采用的也是wait所以也会释放锁</p>
<p>yield()实际上是不释放锁，但是放弃了CPU时间片，让可运行状态变成了就绪状态。<br>join()是在该线程中插入一个已声明的线程，等待该线程执行完毕再执行该线程，再进行抢占锁资源 sleep()让当前正在执行的线程暂停执行，但不会释放“锁标志”。不推荐使用。 wait()线程会释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁。</p>
<h1 id="考点6-类型转换"><a href="#考点6-类型转换" class="headerlink" title="考点6:类型转换"></a>考点6:类型转换</h1><p>Java类Demo中存在方法func1、func2、func3和func4，请问该方法中，哪些是不合法的定义？( )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">　　<span class="type">float</span> <span class="title function_">func1</span><span class="params">()</span></span><br><span class="line">　　&#123;</span><br><span class="line">　　　　<span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">　　　　<span class="keyword">return</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="type">float</span> <span class="title function_">func2</span><span class="params">()</span></span><br><span class="line">　　&#123;</span><br><span class="line">　　　　<span class="type">short</span> i=<span class="number">2</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="type">float</span> <span class="title function_">func3</span><span class="params">()</span></span><br><span class="line">　　&#123;</span><br><span class="line">　　　　<span class="type">long</span> i=<span class="number">3</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="type">float</span> <span class="title function_">func4</span><span class="params">()</span></span><br><span class="line">　　&#123;</span><br><span class="line">　　　　<span class="type">double</span> i=<span class="number">4</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A func1</li>
<li>B func2</li>
<li>C func3</li>
<li>D func4</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: AD</details>

<p>这道题考的是数据类型转换问题。由大到小需要强制转换，由小到大不需要。<br> A：<code>return;</code>   没有返回值，<strong>错误</strong><br> B：<code>short → float</code> 无须强制转换，<strong>正确</strong><br> C：<code>long → float</code>  无须强制转换（<strong>这个最选项容易出错</strong>），<strong>正确。</strong><br> float占4个字节为什么比long占8个字节大呢，因为底层的实现方式不同。<br> <strong>浮点数的32位并不是简单直接表示大小，而是按照一定标准分配的</strong>。<br> 第1位，符号位，即S<br> 接下来8位，指数域，即E。<br> 剩下23位，小数域，即M，取值范围为[1 ,2 ) 或[0 , 1)<br> 然后按照公式：<code>V=(-1)^s * M * 2^E</code><br> <strong>也就是说浮点数在内存中的32位不是简单地转换为十进制，而是通过公式来计算而来，通过这个公式虽然，只有4个字节，但浮点数最大值要比长整型的范围要大</strong>。<br> D：<code>double → float</code> 没有强制转换，<strong>错误</strong>。</p>
<p> 转换原则 : <code>byte -&gt;short(char)-&gt;int-&gt;long-&gt;float-&gt;double</code>。</p>
<h1 id="考点7-重写-接口方法默认修饰符"><a href="#考点7-重写-接口方法默认修饰符" class="headerlink" title="考点7:重写 接口方法默认修饰符"></a>考点7:重写 接口方法默认修饰符</h1><p>根据以下接口和类的定义，要使代码没有语法错误，则类Hero中应该定义方法(    )。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Action</span>&#123;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span> <span class="keyword">implements</span> <span class="title class_">Action</span>&#123;  <span class="comment">//……  &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>A private void fly(){}</li>
<li>B void fly(){}</li>
<li>C protected void fly(){}</li>
<li>D public void fly(){}</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>接口方法默认是<code>public abstract</code>的，且实现该接口的类中对应的方法的可见性不能小于接口方法的可见性，因此也实现类的方法只能是public的。</p>
<h2 id="方法重写要求"><a href="#方法重写要求" class="headerlink" title="方法重写要求"></a>方法重写要求</h2><ul>
<li>方法名相同、</li>
<li>形参列表相同:</li>
<li>返回值类型更小或相等</li>
<li>抛出的异常类更小或相等</li>
<li>访问权限更大或相等</li>
</ul>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8:"></a>考点8:</h1><p>J2EE中，当把来自客户机的HTTP请求委托给servlet时，会调用HttpServlet的（ ）方法</p>
<ul>
<li>A service</li>
<li>B doget</li>
<li>C dopost</li>
<li>D init</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>



<p>A<br>HttpServlet容器响应Web客户请求流程如下： 1）Web客户向Servlet容器发出Http请求；<br>2）Servlet容器解析Web客户的Http请求；<br>3）Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息；<br>4）Servlet容器创建一个HttpResponse对象；<br>5）Servlet容器调用HttpServlet的service方法，这个方法中会根据request的Method来判断具体是执行doGet还是doPost，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象；<br>6）HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息；<br>7）HttpServlet调用HttpResponse的有关方法，生成响应数据；<br>8）Servlet容器把HttpServlet的响应结果传给Web客户。<br>doGet()<br>或<br>doPost()<br>是创建HttpServlet时需要覆盖的方法.</p>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9:"></a>考点9:</h1><p>下面有关java基本类型的默认值和取值范围，说法错误的是？</p>
<ul>
<li>A 字节型的类型默认值是0，取值范围是-2^7—2^7-1</li>
<li>B boolean类型默认值是false，取值范围是true\false</li>
<li>C 字符型类型默认是0，取值范围是-2^15 —2^15-1</li>
<li>D long类型默认是0，取值范围是-2^63—2^63-1</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>char占16位，而且没有负值。所以最小值是0。最大值是<code>1111111111111111 = 2^16 - 1</code></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">默认值</th>
<th align="left">存储需求（字节）</th>
<th align="left">取值范围</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">-2^7—2^7-1</td>
<td align="left">byteb&#x3D;10;</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">‘\u0000’</td>
<td align="left">2</td>
<td align="left">0—2^16-1</td>
<td align="left">char c&#x3D;’c’;</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">0</td>
<td align="left">2</td>
<td align="left">-2^15—2^15-1</td>
<td align="left">short s&#x3D;10;</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">0</td>
<td align="left">4</td>
<td align="left">-2^31—2^31-1</td>
<td align="left">int i&#x3D;10;</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">0</td>
<td align="left">8</td>
<td align="left">-2^63—2^63-1</td>
<td align="left">long o&#x3D;10L;</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">0.0f</td>
<td align="left">4</td>
<td align="left">-2^31—2^31-1</td>
<td align="left">float f&#x3D;10.0F</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">0.0d</td>
<td align="left">8</td>
<td align="left">-2^63—2^63-1</td>
<td align="left">double d&#x3D;10.0;</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">false</td>
<td align="left">1</td>
<td align="left">true\false</td>
<td align="left">boolean flag&#x3D;true;</td>
</tr>
</tbody></table>
<h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10:"></a>考点10:</h1><p>关于Java以下描述正确的有(      )</p>
<ul>
<li>A Class类是Object类的超类</li>
<li>B Object类是一个final类</li>
<li>C String类是一个final类</li>
<li>D Class类可以装载其它类</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: CD</details>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Class</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">Object</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">Serializable</span>, GenericDeclaration, Type, AnnotatedElement</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Object</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">Object</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">Serializable</span>, Comparable&lt;String&gt;, CharSequence</span><br></pre></td></tr></table></figure>
<p>装载应该就是加载，应该是<code>Class.forName()</code>这个方法</p>
<h1 id="考点11"><a href="#考点11" class="headerlink" title="考点11:"></a>考点11:</h1><p>Java中的集合类包括ArrayList、LinkedList、HashMap等类，下列关于集合类描述正确的是（）</p>
<ul>
<li>A ArrayList和LinkedList均实现了List接口</li>
<li>B ArrayList的访问速度比LinkedList快</li>
<li>C 添加和删除元素时，ArrayList的表现更佳</li>
<li>D HashMap实现Map接口，它允许任何类型的键和值对象，并允许将null用作键或值</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>

<p>B选项<br>ArrayList底层是一个数组结构，而LinkedList底层是一个链表</p>
<p><strong>链表</strong><br>特点：<strong>查询慢，增删快</strong><br>原因：链表中地址不是连续的，每次查询必须从头开始</p>
<p><strong>数组</strong><br>特点：<strong>查询快，增删慢</strong><br>原因：查询快：数组地址是连续的，我们通过数组首地址就可以找到数组，通过数组的索引可以快速查找下一个元素；数组长度固定，每次增&#x2F;删元素都必须创建一个新数组。</p>
<h1 id="考点12"><a href="#考点12" class="headerlink" title="考点12:"></a>考点12:</h1><p>final、finally和finalize的区别中，下述说法正确的有？</p>
<ul>
<li>A final用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。</li>
<li>B finally是异常处理语句结构的一部分，表示总是执行。</li>
<li>C finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源的回收，例如关闭文件等。</li>
<li>D 引用变量被final修饰之后，不能再指向其他对象，它指向的对象的内容也是不可变的。</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: AB</details>


<p>选AB<br>A，D考的一个知识点，final修饰变量，变量的引用（也就是指向的地址）不可变，但是引用的内容可以变（地址中的内容可变）。<br>B，finally表示总是执行。但是其实finally也有不执行的时候，但是这个题不要扣字眼。</p>
<ol>
<li>在try中调用System.exit(0)，强制退出了程序，finally块不执行。</li>
<li>在进入try块前，出现了异常，finally块不执行。</li>
</ol>
<p> C，finalize方法，这个选项错就错在，<strong>这个方法一个对象只能执行一次</strong>，只能在第一次进入被回收的队列，而且对象所属于的类重写了finalize方法才会被执行。第二次进入回收队列的时候，不会再执行其finalize方法，而是直接被二次标记，在下一次GC的时候被GC。<br> 放一张图吧<br> <img data-src="https://uploadfiles.nowcoder.com/images/20180716/3807435_1531748778229_B1F90475F3162B313B750B56294240E0"></p>
<h2 id="finalize只清理内存中的垃圾"><a href="#finalize只清理内存中的垃圾" class="headerlink" title="finalize只清理内存中的垃圾"></a>finalize只清理内存中的垃圾</h2><p>finalize 并不是用来关闭文件的，关闭文件的操作由 一些 native 本地方法处理，<strong>finalize只负责内存中垃圾对象的回收</strong>。</p>
<p>深入理解java虚拟机中说到：<br>当对象不可达后，仍需要两次标记才会被回收，首先垃圾收集器会先执行对象的finalize方法，但不保证会执行完毕（死循环或执行很缓慢的情况会被强行终止），此为第一次标记。第二次检查时，如果对象仍然不可达，才会执行回收。</p>
<p><strong>一般不要使用finalize，最主要的用途是回收特殊渠道申请的内存</strong>。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年09月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月17日 java1</title>
    <url>/exam//64ec3abf/</url>
    <content><![CDATA[<h1 id="考点1-自增运算符-先加加-后加加"><a href="#考点1-自增运算符-先加加-后加加" class="headerlink" title="考点1:自增运算符 先加加 后加加"></a>考点1:自增运算符 先加加 后加加</h1><p>以下程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> m=<span class="number">12</span>,n=<span class="number">34</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%d&quot;</span>,m++,++n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%d\n&quot;</span>,n++,++m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行后的输出结果是（）</p>
<ul>
<li>A 12353514</li>
<li>B 12353513</li>
<li>C 12343514</li>
<li>D 12343513</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h1 id="考点2-io-sql-awt-rmi包"><a href="#考点2-io-sql-awt-rmi包" class="headerlink" title="考点2:io sql awt rmi包"></a>考点2:io sql awt rmi包</h1><p>进行Java基本的GUI设计需要用到的包是（）</p>
<ul>
<li>A java.io</li>
<li>B java.sql</li>
<li>C java.awt</li>
<li>D java.rmi</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>图形用户界面(Graphical User Interface)GUI 是指采用图形方式显示的计算机操作用户界面<br>1.java.io提供了全面的IO接口。包含:文件读写，标准设备输出等<br>2.java.sql提供了Java编程语言访问并且存储数据的API，API包含一个框架<br>3.java.awt是一个软件包，包含用于用户界面和绘制图像的所有分类；<br>4.java.rmi提供RMI包，远程调用包(Remote Method Invocation)</p>
<p>图形用户界面（Graphical User Interface，简称 GUI）是指采用图形方式显示的计算机操作用户界面。<br>java.io提供了全面的IO接口。包括：文件读写、标准设备输出等。<br>java.sql提供使用 Java 编程语言访问并处理存储在数据源中的数据的 API。此 API包括一个框架，凭借此框架可以动态地安装不同驱动程序来访问不同数据源。<br>java.awt是一个软件包，包含用于创建用户界面和绘制图形图像的所有分类。功能：包含用于创建用户界面和绘制图形图像的所有类。<br>java.rmi提供 RMI 包。RMI 指的是远程方法调用 (Remote Method Invocation)。它是一种机制，能够让在某个Java虚拟机上的对象调用另一个 Java 虚拟机中的对象上的方法。</p>
<h1 id="考点3-String类方法"><a href="#考点3-String类方法" class="headerlink" title="考点3:String类方法"></a>考点3:String类方法</h1><p>以下代码的输出的正确结果是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;祝你考出好成绩！&quot;</span>;</span><br><span class="line">    System.out.println(s.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A 24</li>
<li>B 16</li>
<li>C 15</li>
<li>D 8</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>这题就是问这个字符串的长度，没有问占多少个字节啊，不用想的太复杂，就是8.<br>length() 方法返回的就是字符串的长度，一个 char 可以存下汉字，剩下的数数就完事了。<br>如果想获得占用字节数的话，可以用 s.getBytes(“GBK”).length，结果就是16了。</p>
<h1 id="考点4-String创建对象-常量池"><a href="#考点4-String创建对象-常量池" class="headerlink" title="考点4:String创建对象 常量池"></a>考点4:String创建对象 常量池</h1><p>String s &#x3D; new String(“xyz”);创建了几个StringObject？</p>
<ul>
<li>A 两个或一个都有可能</li>
<li>B 两个</li>
<li>C 一个</li>
<li>D 三个</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>如果在常量池中已经存在“xyz”，那么不会继续创建，只创建一个new String(“xyz”)的对象。如果常量池中没有，则会创建两个对象，一个是对象的值“xyz”，一个是new String(“xyz”)的对象。</p>
<h1 id="考点5-lambda表达式"><a href="#考点5-lambda表达式" class="headerlink" title="考点5:lambda表达式"></a>考点5:lambda表达式</h1><p>下面哪些写法能在 java8 中编译执行（）</p>
<ul>
<li>A dir.listFiles((File f)-&gt;f.getName().endsWith(“.Java”));</li>
<li>B dir.listFiles((File f)&#x3D;&gt;f.getName().endsWith(“.Java”));</li>
<li>C dir.listFiles((_.getName().endsWith(“.Java”)));</li>
<li>D dir.listFiles(f-&gt;f.getName().endsWith(“.Java”));</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: AD</details>

<p>Lambda表达式的主要作用就是<strong>代替匿名内部类</strong>的繁琐语法， 它由三部分组成：<br> （1） <strong>形参列表</strong>。形参列表允许省略形参类型。如果形参列表中只有一个参数，甚至连形参列表的圆括号也可以省略。<br> （2） <strong>箭头</strong>（→）。必须通过英文中画线和大于符号组成。<br> （3）<strong>代码块</strong>。如果代码块只包含一条语句，Lambda表达式允许省略代码块的花括号，那么那条语句就不要用花括号表示语句结束。Lambda代码块只有一条return语句，甚至可以省略return关键字。Lambda表达式需要返回值，而它的代码块中仅有一套省略了return的语句。Lambda表达式会自动返回这条语句的值。<br> 由此可见，应该是A和D正确。</p>
<h1 id="考点6-静态代码块"><a href="#考点6-静态代码块" class="headerlink" title="考点6:静态代码块"></a>考点6:静态代码块</h1><p>有关静态初始化块说法正确的是？</p>
<ul>
<li>A 无法直接调用静态初始化块</li>
<li>B 在创建第一个实例前或引用任何静态成员之前，将自动调用静态初始化块来初始化</li>
<li>C 静态初始化块既没有访问修饰符，也没有参数</li>
<li>D 在程序中，用户可以控制何时执行静态初始化块</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<h1 id="考点7-io流"><a href="#考点7-io流" class="headerlink" title="考点7:io流"></a>考点7:io流</h1><p>与InputStream流相对应的Java系统的“标准输入对象”是（）</p>
<ul>
<li>A System.in</li>
<li>B System.out</li>
<li>C System.err</li>
<li>D System.exit()</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h1 id="考点8-循环"><a href="#考点8-循环" class="headerlink" title="考点8:循环"></a>考点8:循环</h1><p>以下代码的循环次数是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(--i);</span><br><span class="line">            --i;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i != <span class="number">0</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A 0</li>
<li>B 1</li>
<li>C 7</li>
<li>D 无限次</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>从7开始，每次 -2，i  永远不可能&#x3D;&#x3D;0</p>
<h1 id="考点9-while语句-bealean表达式"><a href="#考点9-while语句-bealean表达式" class="headerlink" title="考点9:while语句 bealean表达式"></a>考点9:while语句 bealean表达式</h1><p>关于下面程序，哪些描述是正确的: (  )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">While</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> x= <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> ( x )  &#123;</span><br><span class="line">System.out.print(<span class="string">&quot;x minus one is &quot;</span> + (x - <span class="number">1</span>));</span><br><span class="line">x -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A 行1有语法错误</li>
<li>B 行4有语法错误</li>
<li>C 行5有语法错误</li>
<li>D 行6有语法错误</li>
<li>E 行2有语法错误,loop是关键字</li>
<li>F 程序能够正常编译和运行</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>while()括号里参数必须是布尔类型，要么true要么false。<br>x是int类型，是int表达式，int表达式不能作为while的条件。</p>
<h1 id="考点10-关系模型和对象模型的相互转换"><a href="#考点10-关系模型和对象模型的相互转换" class="headerlink" title="考点10:关系模型和对象模型的相互转换"></a>考点10:关系模型和对象模型的相互转换</h1><p>一般情况下，以下哪个选项不是关系数据模型与对象模型之间匹配关系？</p>
<ul>
<li>A 表对应类</li>
<li>B 记录对应对象</li>
<li>C 表的字段对应类的属性</li>
<li>D 表之间的参考关系对应类之间的依赖关系</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>目前ORMapping只是规定了数据结构和数据集的映射关系，还没到规定赖关系的阶段<br>一般关系数据模型和对象数据模型之间有以下对应关系：表对应类，记录对应对象，表的字段对应类的属性。</p>
<h1 id="考点11-自增运算符"><a href="#考点11-自增运算符" class="headerlink" title="考点11:自增运算符"></a>考点11:自增运算符</h1><p>下面的程序将来打印什么?（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestIncr</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        i = i++ + i;</span><br><span class="line">        System.out.println(<span class="string">&quot;I =&quot;</span> +i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A I &#x3D; 1</li>
<li>B I &#x3D; 2</li>
<li>C I &#x3D; 3</li>
<li>D 编译出错</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h1 id="考点12-super关键字"><a href="#考点12-super关键字" class="headerlink" title="考点12:super关键字"></a>考点12:super关键字</h1><p>关键字super的作用是？</p>
<ul>
<li>A 用来访问父类被隐藏的非私有成员变量</li>
<li>B 用来调用父类中被重写的方法</li>
<li>C 用来调用父类的构造函数</li>
<li>D 以上都是</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h1 id="考点13-线程输出"><a href="#考点13-线程输出" class="headerlink" title="考点13:线程输出"></a>考点13:线程输出</h1><p>执行以下程序，最终输出可能是：<br><img data-src="https://uploadfiles.nowcoder.com/images/20170815/5994168_1502781283025_4B0322EFF530C8D1FB43F444D6BDBAD6" alt="这里有一张图片"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread[] ths = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    ths[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;<span class="number">5</span>; j++) &#123;</span><br><span class="line">                System.out.println(j);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Thread th:ths)&#123;</span><br><span class="line">    th.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>*</code>代表空格</p>
<ul>
<li>A <code>010 2123012 3434</code></li>
<li>B <code>01201 340124 2334</code></li>
<li>C <code>0012314 01223344**</code></li>
<li>D <code>12345 12345 12345</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>线程间是异步的，也就是随机调用的；而线程内部是同步的，也就是顺序执行的。<br>有4才会有空格  空格之前没4 的全错<br>三个线程，三个空格，只有C输出了三个空格，其他都是俩哈哈哈</p>
<h1 id="考点14-Java体系结构"><a href="#考点14-Java体系结构" class="headerlink" title="考点14:Java体系结构"></a>考点14:Java体系结构</h1><p>Java的体系结构包含（    ）。</p>
<ul>
<li>A Java编程语言</li>
<li>B Java类文件格式</li>
<li>C Java API</li>
<li>D JVM</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>


<p>Java体系结构包括四个独立但相关的技术：</p>
<ul>
<li>Java程序设计语言</li>
<li>Java.class文件格式</li>
<li>Java应用编程接口（API）</li>
<li>Java虚拟机  我们再在看一下它们四者的关系：</li>
</ul>
<p>当我们编写并运行一个Java程序时，就同时运用了这四种技术，用<strong>Java程序设计语言</strong>编写源代码，把它编译成<strong>Java.class文件格式</strong>，然后再在<strong>Java虚拟机中运行class文件</strong>。当程序运行的时候，它通过调用class文件实现了<strong>Java API的方法</strong>来满足程序的Java API调用</p>
<h1 id="考点15-设计模式-管理模式两个基本要点"><a href="#考点15-设计模式-管理模式两个基本要点" class="headerlink" title="考点15:设计模式 管理模式两个基本要点"></a>考点15:设计模式 管理模式两个基本要点</h1><p>单例模式中，两个基本要点是</p>
<ul>
<li>A 构造函数私有</li>
<li>B 静态工厂方法</li>
<li>C 以上都不对</li>
<li>D 唯一实例</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: AD</details>

<h1 id="考点16-包装类-包装类默认缓存-包装类和基本类型可以比较值"><a href="#考点16-包装类-包装类默认缓存-包装类和基本类型可以比较值" class="headerlink" title="考点16:包装类 包装类默认缓存 包装类和基本类型可以比较值"></a>考点16:包装类 包装类默认缓存 包装类和基本类型可以比较值</h1><p>以下语句返回值为 true 的是（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a1=<span class="number">17</span>,a2=<span class="number">17</span>;</span><br><span class="line">Integer b1=<span class="number">2017</span>,b2=<span class="number">2017</span>;</span><br><span class="line">Integer c1=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2017</span>);</span><br><span class="line">Integer c2=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2017</span>);</span><br><span class="line">Integer d1=<span class="keyword">new</span> <span class="title class_">Interger</span>(<span class="number">2017</span>);</span><br><span class="line"><span class="type">int</span> d2=<span class="number">2017</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>A a1&#x3D;&#x3D;a2</li>
<li>B d1&#x3D;&#x3D;d2</li>
<li>C b1&#x3D;&#x3D;b2</li>
<li>D c1&#x3D;&#x3D;c2</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: AB</details>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a1=<span class="number">17</span>,a2=<span class="number">17</span>;</span><br><span class="line">Integer b1=<span class="number">2017</span>,b2=<span class="number">2017</span>;</span><br><span class="line">Integer c1=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2017</span>);</span><br><span class="line">Integer c2=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2017</span>);</span><br><span class="line">Integer d1=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2017</span>);</span><br><span class="line"><span class="type">int</span> d2=<span class="number">2017</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(a1 == a2);</span><br><span class="line">System.out.println(d1 == d2);</span><br><span class="line">System.out.println(b1 == b2);</span><br><span class="line">System.out.println(c1 == c2);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年09月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月23日 java1</title>
    <url>/exam//6decad7e/</url>
    <content><![CDATA[<h1 id="考点1-this调用语句"><a href="#考点1-this调用语句" class="headerlink" title="考点1:this调用语句"></a>考点1:this调用语句</h1><p>This调用语句必须是构造函数中的第一个可执行语句。</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>this()才必须是构造函数中的第一个可执行语句，用this调用语句并不需要。</p>
<h1 id="考点2-成员内部类"><a href="#考点2-成员内部类" class="headerlink" title="考点2:成员内部类"></a>考点2:成员内部类</h1><p>内部类（也叫成员内部类）可以有4种访问权限。（  ）</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>你就把内部类理解成类的成员，成员有4种访问权限吧，内部类也是！分别为private、protected、public以及默认的访问权限</p>
<h1 id="考点3-CallableStatement-PreparedStatement-Statement"><a href="#考点3-CallableStatement-PreparedStatement-Statement" class="headerlink" title="考点3:CallableStatement PreparedStatement Statement"></a>考点3:CallableStatement PreparedStatement Statement</h1><p>以下描述正确的是</p>
<ul>
<li>A CallableStatement是PreparedStatement的父接口</li>
<li>B PreparedStatement是CallableStatement的父接口</li>
<li>C CallableStatement是Statement的父接口</li>
<li>D PreparedStatement是Statement的父接口</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>Statement 每次执行sql语句，数据库都要执行sql语句的编译 ，最好用于仅执行一次查询并返回结果的情形，效率高于PreparedStatement.</p>
<p>PreparedStatement是预编译的，使用PreparedStatement有几个好处<br>a. 在执行可变参数的一条SQL时，PreparedStatement比Statement的效率高，因为DBMS预编译一条SQL当然会比多次编译一条SQL的效率要高。<br>b. 安全性好，有效防止Sql注入等问题。<br>c. 对于多次重复执行的语句，使用PreparedStament效率会更高一点，并且在这种情况下也比较适合使用batch；<br>d. 代码的可读性和可维护性。</p>
<p>CallableStatement接口扩展PreparedStatement，用来调用存储过程,它提供了对输出和输入&#x2F;输出参数的支持。CallableStatement<br>接口还具有对 PreparedStatement 接口提供的输入参数的支持。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CallableStatement</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">PreparedStatement</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PreparedStatement</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">Statement</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Statement</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">Wrapper</span>, AutoCloseable</span><br></pre></td></tr></table></figure>
<h1 id="考点4-多态方法调用"><a href="#考点4-多态方法调用" class="headerlink" title="考点4:多态方法调用"></a>考点4:多态方法调用</h1><p>Test.main()函数执行后的输出是（ ）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">B</span>().getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">A</span> <span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">            setValue(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value= value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                value ++;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.setValue(value);</span><br><span class="line">                System.out.println(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">B</span> <span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="number">5</span>);</span><br><span class="line">            setValue(getValue()- <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.setValue(<span class="number">2</span> * value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A 6 7 7</li>
<li>B 22 34 17</li>
<li>C 22 74 74</li>
<li>D 11 17 34</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h2 id="始终优先调用子类重写的方法"><a href="#始终优先调用子类重写的方法" class="headerlink" title="始终优先调用子类重写的方法"></a>始终优先调用子类重写的方法</h2><p>本题中，始终需要遵循一个原则，即： <strong>调用的方法都是实例化的子类中的重写方法，只有明确调用了super.xxx关键词或者是子类中没有该方法时，才会去调用父类相同的同名方法</strong>。</p>
<p>这道题的知识点：子类中的方法覆盖父类的方法以后，由于向上转型，父类调用方法的时候是调用子类的，除非用super。<br>还有一个点就是在Try catch  finally 体系当中，在return之前始终会执行finally里面的代码，如果finally里面有return，则数据跟随finally改变。如果没有return，则原数据不跟随finally里改变的数据改变！</p>
<p>main方法中只有一条System.out.println(new B().getValue());语句</p>
<h3 id="先执行new-B"><a href="#先执行new-B" class="headerlink" title="先执行new B()"></a>先执行new B()</h3><blockquote>
<p>new B()</p>
<figure class="highlight java"><figcaption><span>B类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">B</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="number">5</span>);<span class="comment">//&lt;--执行这句</span></span><br><span class="line">    setValue(getValue()- <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>super(5);</p>
<figure class="highlight java"><figcaption><span>A类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">A</span> <span class="params">(<span class="type">int</span> v)</span> &#123; <span class="comment">//v=5</span></span><br><span class="line">    setValue(v);<span class="comment">//v=5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为new的对象是B,执行的是子类重写的setValue():</p>
<figure class="highlight java"><figcaption><span>B类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;<span class="comment">//v=5</span></span><br><span class="line">    <span class="built_in">super</span>.setValue(<span class="number">2</span> * value);<span class="comment">//2*value=2*5=10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里明确使用了super关键字，所以调用父类的setValue方法：</p>
<figure class="highlight java"><figcaption><span>A类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;<span class="comment">//value=10</span></span><br><span class="line">    <span class="built_in">this</span>.value= value;<span class="comment">//value=10,this.value=10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<p>到这里super(5);算是执行完毕了，继续执行下一句：</p>
<figure class="highlight java"><figcaption><span>B类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">B</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="number">5</span>);<span class="comment">//&lt;--执行完毕</span></span><br><span class="line">    setValue(getValue()- <span class="number">3</span>);<span class="comment">//&lt;--执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行 setValue(getValue()- 3);</p>
<blockquote>
<p>先执行getValue()方法，B类中并没有有定义getValue()方法，所以调用的是父类的getValue方法：</p>
<blockquote>
<p>先执行getValue的try语句块</p>
<pre><code class="java">public int getValue() &#123;
    try &#123;
        value ++;//1. value=10,value++之后value=11
        return value;//2 return 11; 
    &#125; finally &#123;
        this.setValue(value); //3. 当前对象是B类的对象，调用B类的setValue方法，value=11
        System.out.println(value);
    &#125;
&#125;
</code></pre>
<p>try块中有return语句，getValue的返回值为11</p>
</blockquote>
<p>然后执行finally语句块。</p>
<blockquote>
<p>先执行this.setValue(value);</p>
<pre><code class="java">public void setValue(int value) &#123;// value=11
    super.setValue(2 * value);//2 * value=2 *11=22,接着调用父类的setValue方法
&#125;
</code></pre>
<p>调用父类的setValue方法</p>
<blockquote>
<pre><code class="java">public void setValue(int value) &#123;// value=22
    this.value= value;//this.value=22
&#125;
</code></pre>
</blockquote>
<p>然后执行System.out.println(value);<strong>输出22</strong></p>
</blockquote>
</blockquote>
<p>getValue()执行完毕，返回值11</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">B</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="number">5</span>);</span><br><span class="line">    setValue(getValue()- <span class="number">3</span>);<span class="comment">//getValue=11,getValue()- 3=11-3=8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行setValue(8)，当前对象有setValue方法，调用B类定义的setValue方法：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;<span class="comment">//value=8</span></span><br><span class="line">    <span class="built_in">super</span>.setValue(<span class="number">2</span> * value);<span class="comment">//2 * value=2*8=16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行父类的setValue方法：</p>
<blockquote>
<pre><code class="java">public void setValue(int value) &#123;//value=16
    this.value= value;//this.value=16
&#125;
</code></pre>
<p>到这里,new B()执行完毕。this.value&#x3D;16</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h3 id="然后执行new-B-getValue"><a href="#然后执行new-B-getValue" class="headerlink" title="然后执行new B().getValue()"></a>然后执行new B().getValue()</h3><blockquote>
<p>然后执行new B().<strong>getValue()</strong><br>子类B中没有这个方法，调用父类继承来的getValue方法</p>
<blockquote>
<p>先执行try块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        value ++;<span class="comment">//this.value=16 value++之后 this.value=17</span></span><br><span class="line">        <span class="keyword">return</span> value;<span class="comment">//getValue()返回值是17</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setValue(value);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后执行finally块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        value ++;<span class="comment">//this.value=17</span></span><br><span class="line">        <span class="keyword">return</span> value;<span class="comment">//getValue()返回值是17</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setValue(value);<span class="comment">//value=17</span></span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先调用当前类的setValue方法：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;<span class="comment">//value=17</span></span><br><span class="line">    <span class="built_in">super</span>.setValue(<span class="number">2</span> * value);<span class="comment">//2 * value=2 * 14=34</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用父类的setValue方法：</p>
<blockquote>
<pre><code class="java">public void setValue(int value) &#123;//value=24
    this.value= value;//this.value=34
&#125;
</code></pre>
</blockquote>
</blockquote>
<p>然后执行 System.out.println(value);语句，<strong>输出34</strong></p>
</blockquote>
<p>到这里new B().**getValue()**已经执行完毕，getValue()返回17.</p>
</blockquote>
<h3 id="最后执行最外层的数据语句"><a href="#最后执行最外层的数据语句" class="headerlink" title="最后执行最外层的数据语句"></a>最后执行最外层的数据语句</h3><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">B</span>().getValue());<span class="comment">//17</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出17</strong></p>
</blockquote>
<h1 id="考点5-JRE判断程序执行结束的标准-前台线程-后台线程"><a href="#考点5-JRE判断程序执行结束的标准-前台线程-后台线程" class="headerlink" title="考点5:JRE判断程序执行结束的标准 前台线程 后台线程"></a>考点5:JRE判断程序执行结束的标准 前台线程 后台线程</h1><p>jre 判断程序是否执行结束的标准是（）</p>
<ul>
<li>A 所有的前台线程执行完毕</li>
<li>B 所有的后台线程执行完毕</li>
<li>C 所有的线程执行完毕</li>
<li>D 和以上都无关</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h2 id="前台线程-后台线程-用户线程-守护线程"><a href="#前台线程-后台线程-用户线程-守护线程" class="headerlink" title="前台线程 后台线程 用户线程 守护线程"></a>前台线程 后台线程 用户线程 守护线程</h2><p>其实这个题，就是在说守护线程和非守护（用户）线程的问题。后台线程就是守护线程，前台线程就是用户线程。<br>守护线程：是指在程序运行时在后台提供一种通用服务的线程，这种线程并不是必须的。同时守护线程的线程优先级都很低的。JVM中的GC线程就是一个守护线程，只要JVM启动，GC线程就启动了。</p>
<p>用户线程和守护线程几乎没有什么区别，唯一的区别就在于，<strong>如果用户线程都已经退出了，只剩下了守护线程，那么JVM直接就退出了</strong>。</p>
<p>下面举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : begin&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test : begin&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line">        t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;test : end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test : begin</span><br><span class="line">test : end</span><br></pre></td></tr></table></figure>
<p>运行结果中不会有Thread-0 ： end，是因为，守护线程开启之后，中间睡了2s，这个时候又没有锁，主线程直接就执行完了，<br>一旦主线程结束，那么JVM中就只剩守护线程了，JVM直接就退出了，不管你守护线程有没有执行完。 </p>
<p>jre判断程序是否执行结束的标准是：所有的前台线程执行完毕。</p>
<h1 id="考点6-自增运算符"><a href="#考点6-自增运算符" class="headerlink" title="考点6:自增运算符"></a>考点6:自增运算符</h1><p>以下代码执行的结果显示是多少（）？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demoe</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            num = num + i;</span><br><span class="line">            count = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;num * count=&quot;</span> + (num * count));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A num * count &#x3D; 505000</li>
<li>B num * count &#x3D; 0</li>
<li>C 运行时错误</li>
<li>D num * count &#x3D; 5050</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p><code>count = count++;</code>这个先将count这个值0暂存起来，然后count自加1变成1，最后将暂存的值赋值给count，count最终的值为0</p>
<h1 id="考点7-类的加载顺序-先静态后非静态-先父类后子类"><a href="#考点7-类的加载顺序-先静态后非静态-先父类后子类" class="headerlink" title="考点7:类的加载顺序:先静态后非静态 先父类后子类"></a>考点7:类的加载顺序:先静态后非静态 先父类后子类</h1><p>关于下列代码的执行顺序，下面描述正确的有哪些选项（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloA</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;A的构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#123; </span><br><span class="line">    System.out.println(<span class="string">&quot;A的构造代码块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> &#123; </span><br><span class="line">    System.out.println(<span class="string">&quot;A的静态代码块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">HelloA</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloA</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 打印顺序A的静态代码块&gt; A的构造函数</li>
<li>B 打印顺序A的静态代码块&gt; A的构造代码块</li>
<li>C 打印顺序A的构造代码块&gt; A的构造函数</li>
<li>D 打印顺序A的构造函数&gt; A的构造代码块</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<h2 id="类的加载顺序"><a href="#类的加载顺序" class="headerlink" title="类的加载顺序"></a>类的加载顺序</h2><p>1.父类静态代码块<br>2.子类静态代码块<br>3.父类构造代码块<br>4.父类构造函数<br>5.子类构造代码块<br>6.子类构造方法</p>
<p>总结：<strong>先静态后非静态，先父类后子类</strong>。</p>
<h1 id="考点8-字符集编码-国际化"><a href="#考点8-字符集编码-国际化" class="headerlink" title="考点8:字符集编码 国际化"></a>考点8:字符集编码 国际化</h1><p>在Java语言中，下列关于字符集编码（Character set encoding）和国际化（i18n）的问题，哪些是正确的？</p>
<ul>
<li>A 每个中文字符占用2个字节，每个英文字符占用1个字节</li>
<li>B 假设数据库中的字符是以GBK编码的，那么显示数据库数据的网页也必须是GBK编码的。</li>
<li>C Java的char类型，通常以UTF-16 Big Endian的方式保存一个字符。</li>
<li>D 实现国际化应用常用的手段是利用ResourceBundle类</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: CD</details>

<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>A 显然是错误的，<strong>Java一律采用Unicode编码方式，每个字符无论中文还是英文字符都占用2个字节</strong>。<br>B 也是不正确的，不同的编码之间是可以转换的，通常流程如下：<br><strong>将字符串S以其自身编码方式分解为字节数组，再将字节数组以你想要输出的编码方式重新编码为字符串</strong>。<br>例：</p>
<h3 id="GBK字符串转UTF-8字符串"><a href="#GBK字符串转UTF-8字符串" class="headerlink" title="GBK字符串转UTF-8字符串"></a>GBK字符串转UTF-8字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">newUTF8Str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(oldGBKStr.getBytes(<span class="string">&quot;GBK&quot;</span>), <span class="string">&quot;UTF8&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>C 是正确的。Java虚拟机中通常使用UTF-16的方式保存一个字符<br>D 也是正确的。ResourceBundle能够依据Local的不同，选择性的读取与Local对应后缀的properties文件，以达到国际化的目的。<br>综上所述，答案是  C 和 D。</p>
<h1 id="考点9-字符流-字节流"><a href="#考点9-字符流-字节流" class="headerlink" title="考点9:字符流 字节流"></a>考点9:字符流 字节流</h1><p>character流和byte流的区别不包括（）</p>
<ul>
<li>A 每次读入的字节数不同</li>
<li>B 前者带有缓冲，后者没有。</li>
<li>C 前者是字符读入，后者是字节读入。</li>
<li>D 二者没有区别，可以互换。</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>

<p>字符流和字节流每次读入的字节数是不确定的，可能相同也可能不相同；<br>字符流和字节流都有缓冲流</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年09月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月19日 java1</title>
    <url>/exam//2d307811/</url>
    <content><![CDATA[<h1 id="考点1-赋值运算符左值必须是变量"><a href="#考点1-赋值运算符左值必须是变量" class="headerlink" title="考点1:赋值运算符左值必须是变量"></a>考点1:赋值运算符左值必须是变量</h1><p>下面语句正确的是（）</p>
<ul>
<li>A <code>x+1=5</code></li>
<li>B <code>i++=1</code></li>
<li>C <code>a++b=1</code></li>
<li>D <code>x+=1</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h2 id="赋值运算符-左值必须是变量"><a href="#赋值运算符-左值必须是变量" class="headerlink" title="赋值运算符 左值必须是变量"></a>赋值运算符 左值必须是变量</h2><p>首先赋值运算符“&#x3D;”右值可以是任何常数、变量或者表达式（只要能生成一个值就行）。但<strong>左值必须是一个明确的、已命名的变量</strong>。 </p>
<p>常用的双元运算符：<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code></p>
<p>解析：<br>A：x+1&#x3D;5，赋值运算符左边是表达式，不对；<br>B：i++&#x3D;1，从左到右运算是i&#x3D;i+1&#x3D;1，赋值运算符左边是表达式，错误；<br>C：a++b&#x3D;1，赋值运算符左边为表达式，错误。<br>D：x+&#x3D;1，既x&#x3D;x+1，正确。 </p>
<p>注意背一下各个运算符的先后顺序。</p>
<h1 id="考点2-负数求余运算"><a href="#考点2-负数求余运算" class="headerlink" title="考点2:负数求余运算"></a>考点2:负数求余运算</h1><p>以下代码段执行后的输出结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> -<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> -<span class="number">12</span>;</span><br><span class="line">System.out.println(y % x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A -1</li>
<li>B 2</li>
<li>C 1</li>
<li>D -2</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>换个角度去理解，<code>y%x</code>算得是y在除以x后还剩多少。这里显然是还剩-2没有除。</p>
<p>验算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不论正负，都是a%b=a-a/b*b</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-2=-12 - (-12/-5)*(-5)</span><br><span class="line">=-12 - (2)*(-5)</span><br><span class="line">=-12 - (-10)</span><br><span class="line">=-12 + 10</span><br><span class="line">=-2</span><br></pre></td></tr></table></figure>

<p>在java中，求余运算，a%b，结果的符号和被除数a的符号一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;-12 % -5= &quot;</span> + (-<span class="number">12</span> % -<span class="number">5</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;-12 % +5= &quot;</span> + (-<span class="number">12</span> % +<span class="number">5</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;+12 % -5= &quot;</span> + (<span class="number">12</span> % -<span class="number">5</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;+12 % +5= &quot;</span> + (<span class="number">12</span> % +<span class="number">5</span>));</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-12 % -5= -2</span><br><span class="line">-12 % +5= -2</span><br><span class="line">+12 % -5= 2</span><br><span class="line">+12 % +5= 2</span><br></pre></td></tr></table></figure>
<p>当a为-12时，无论b是+5，还是-5。a%b的结果都是-2<br>当a为+12时，无论b是+5，还是-5。a%b的结果都是+2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;-17 % -5= &quot;</span> + (-<span class="number">17</span> % -<span class="number">5</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;-17 % +5= &quot;</span> + (-<span class="number">17</span> % +<span class="number">5</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;+17 % -5= &quot;</span> + (<span class="number">17</span> % -<span class="number">5</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;+17 % +5= &quot;</span> + (<span class="number">17</span> % +<span class="number">5</span>));</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-17 % -5= -2</span><br><span class="line">-17 % +5= -2</span><br><span class="line">+17 % -5= 2</span><br><span class="line">+17 % +5= 2</span><br></pre></td></tr></table></figure>

<h1 id="考点3-使用迭代器遍历集合时，不可改变集合"><a href="#考点3-使用迭代器遍历集合时，不可改变集合" class="headerlink" title="考点3:使用迭代器遍历集合时，不可改变集合"></a>考点3:使用迭代器遍历集合时，不可改变集合</h1><p>list是一个ArrayList的对象，哪个选项的代码填到&#x2F;&#x2F;todo delete处，可以在Iterator遍历的过程中正确并安全的删除一个list中保存的对象？（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> it.next();</span><br><span class="line"><span class="keyword">if</span> (needDelete(obj))<span class="comment">//needDelete返回boolean，决定是否要删除</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//todo delete</span></span><br><span class="line">&#125;</span><br><span class="line">index ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A <code>it.remove();</code></li>
<li>B <code>list.remove(obj);</code></li>
<li>C <code>list.remove(index);</code></li>
<li>D <code>list.remove(obj,index);</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h2 id="迭代器遍历集合时-不可调用集合对象的remove方法或add方法"><a href="#迭代器遍历集合时-不可调用集合对象的remove方法或add方法" class="headerlink" title="迭代器遍历集合时 不可调用集合对象的remove方法或add方法"></a>迭代器遍历集合时 不可调用集合对象的remove方法或add方法</h2><p><strong>如果你想在循环语句中删除集合中的某个元素，就要用迭代器iterator的remove()方法</strong>，因为它的remove()方法不仅会删除元素，还会维护一个标志，用来记录目前是不是可删除状态，例如，你不能连续两次调用它的remove()方法，调用之前至少有一次next()方法的调用。</p>
<h2 id="通过for循环遍历集合时，如何调用集合的remove方法删除元素，又不报错"><a href="#通过for循环遍历集合时，如何调用集合的remove方法删除元素，又不报错" class="headerlink" title="通过for循环遍历集合时，如何调用集合的remove方法删除元素，又不报错"></a>通过for循环遍历集合时，如何调用集合的remove方法删除元素，又不报错</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">list.remove(i);</span><br><span class="line">i--; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器在迭代过程中要注意的事项：<br>1.迭代器在迭代过程中不允许使用<strong>集合对象</strong>改变集合的元素个数。否则会报出：ConcurrentModificationException，即并发修改异常。<br>2.在迭代过程中如果需要改变集合中的元素个数，<strong>只能使用迭代器的方法去改变</strong>。如add()方法和remove()方法。</p>
<h3 id="不使用迭代器时，可以通过集合对象remove和add"><a href="#不使用迭代器时，可以通过集合对象remove和add" class="headerlink" title="不使用迭代器时，可以通过集合对象remove和add"></a>不使用迭代器时，可以通过集合对象remove和add</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">0</span>);</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">4</span>);</span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">// list.remove(2);</span></span><br><span class="line">list.remove(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0, 1, 2, 3, 4, 5]</span><br><span class="line">[0, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>

<h3 id="使用迭代器遍历集合时，不可调用集合对象remove方法"><a href="#使用迭代器遍历集合时，不可调用集合对象remove方法" class="headerlink" title="使用迭代器遍历集合时，不可调用集合对象remove方法"></a>使用迭代器遍历集合时，不可调用集合对象remove方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">0</span>);</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">4</span>);</span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> iterator.next();</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">// 报错：java.util.ConcurrentModificationException</span></span><br><span class="line">list.remove(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 报错：java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment">// list.add(5);</span></span><br><span class="line"><span class="comment">// 正确做法</span></span><br><span class="line"><span class="comment">// iterator.remove();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0, 1, 2, 3, 4, 5]</span><br><span class="line">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span><br><span class="line">at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)</span><br><span class="line">at java.util.ArrayList$Itr.next(ArrayList.java:859)</span><br><span class="line">at base.QiuYu.main(QiuYu.java:35)</span><br></pre></td></tr></table></figure>
<h3 id="使用迭代器遍历集合是不可调用集合对象的add方法"><a href="#使用迭代器遍历集合是不可调用集合对象的add方法" class="headerlink" title="使用迭代器遍历集合是不可调用集合对象的add方法"></a>使用迭代器遍历集合是不可调用集合对象的add方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">0</span>);</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">4</span>);</span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> iterator.next();</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">// 报错：java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment">// list.remove(2);</span></span><br><span class="line"><span class="comment">// 报错：java.util.ConcurrentModificationException</span></span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 正确做法</span></span><br><span class="line"><span class="comment">// iterator.remove();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0, 1, 2, 3, 4, 5]</span><br><span class="line">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span><br><span class="line">at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)</span><br><span class="line">at java.util.ArrayList$Itr.next(ArrayList.java:859)</span><br><span class="line">at base.QiuYu.main(QiuYu.java:27)</span><br></pre></td></tr></table></figure>

<h3 id="迭代器遍历集合时，如果要删除集合中的元素，只能调用迭代器对象的remove方法"><a href="#迭代器遍历集合时，如果要删除集合中的元素，只能调用迭代器对象的remove方法" class="headerlink" title="迭代器遍历集合时，如果要删除集合中的元素，只能调用迭代器对象的remove方法"></a>迭代器遍历集合时，如果要删除集合中的元素，只能调用迭代器对象的remove方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">0</span>);</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">4</span>);</span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> iterator.next();</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">// 报错：java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment">// list.remove(2);</span></span><br><span class="line"><span class="comment">// 报错：java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment">// list.add(5);</span></span><br><span class="line"><span class="comment">// 正确做法</span></span><br><span class="line">iterator.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0, 1, 2, 3, 4, 5]</span><br><span class="line">[0, 1, 3, 4, 5]</span><br></pre></td></tr></table></figure>

<h1 id="考点4-不同的Map的key和value是否能为null"><a href="#考点4-不同的Map的key和value是否能为null" class="headerlink" title="考点4:不同的Map的key和value是否能为null"></a>考点4:不同的Map的key和value是否能为null</h1><p>在Java中，关于HashMap类的描述，以下正确的是 ()</p>
<ul>
<li>A HashMap使用键&#x2F;值得形式保存数据</li>
<li>B HashMap 能够保证其中元素的顺序</li>
<li>C HashMap允许将null用作键</li>
<li>D HashMap允许将null用作值</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details>

<table>
<thead>
<tr>
<th align="left">Map集合类</th>
<th align="left">key</th>
<th align="left">value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HashMap</td>
<td align="left">允许为null</td>
<td align="left">允许为null</td>
</tr>
<tr>
<td align="left">TreeMap</td>
<td align="left">不允许为null</td>
<td align="left">允许为null</td>
</tr>
<tr>
<td align="left">ConcurrentMap</td>
<td align="left">不允许为null</td>
<td align="left">不允许为null</td>
</tr>
<tr>
<td align="left">HashTable</td>
<td align="left">不允许为null</td>
<td align="left">不允许为null</td>
</tr>
</tbody></table>
<h1 id="考点5-对象序列化"><a href="#考点5-对象序列化" class="headerlink" title="考点5:对象序列化"></a>考点5:对象序列化</h1><p>以下关于对象序列化描述正确的是</p>
<ul>
<li>A 使用FileOutputStream可以将对象进行传输</li>
<li>B 使用PrintWriter可以将对象进行传输</li>
<li>C 使用transient修饰的变量不会被序列化</li>
<li>D 对象序列化的所属类需要实现Serializable接口</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: CD</details>

<h2 id="static和transient的成员变量不能对象序列化"><a href="#static和transient的成员变量不能对象序列化" class="headerlink" title="static和transient的成员变量不能对象序列化"></a>static和transient的成员变量不能对象序列化</h2><p>使用ObjectOutputStream和ObjectInputStream可以将对象进行传输.<br>声明为static和transient类型的成员数据不能被串行化。<br>因为static代表类的状态， transient代表对象的临时数据。</p>
<h1 id="考点7-正则表达式"><a href="#考点7-正则表达式" class="headerlink" title="考点7:正则表达式"></a>考点7:正则表达式</h1><p>正则表达式语法中 <code>\d</code> 匹配的是？（）</p>
<ul>
<li>A 数字</li>
<li>B 非数字</li>
<li>C 字母</li>
<li>D 空白字符</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<table>
<thead>
<tr>
<th align="left">正则表达式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>\d</code></td>
<td align="left">匹配一个数字字符。等价于 <code>[0-9]</code>。</td>
</tr>
<tr>
<td align="left"><code>\D</code></td>
<td align="left">匹配一个非数字字符。等价于 <code>[^0-9]</code>。</td>
</tr>
<tr>
<td align="left"><code>\f</code></td>
<td align="left">匹配一个换页符。等价于 <code>\x0c</code> 和 <code>\cL</code>。</td>
</tr>
<tr>
<td align="left"><code>\n</code></td>
<td align="left">匹配一个换行符。等价于 <code>\x0a</code> 和 <code>\cJ</code>。</td>
</tr>
<tr>
<td align="left"><code>\r</code></td>
<td align="left">匹配一个回车符。等价于 <code>\x0d</code> 和 <code>\cM</code>。</td>
</tr>
<tr>
<td align="left"><code>\s</code></td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 <code>[ \f\n\r\t\v]</code>。</td>
</tr>
<tr>
<td align="left"><code>\S</code></td>
<td align="left">匹配任何非空白字符。等价于 <code>[^ \f\n\r\t\v]</code>。</td>
</tr>
<tr>
<td align="left"><code>\t</code></td>
<td align="left">匹配一个制表符。等价于 <code>\x09</code> 和 <code>\cI</code>。</td>
</tr>
<tr>
<td align="left"><code>\v</code></td>
<td align="left">匹配一个垂直制表符。等价于 <code>\x0b</code> 和 <code>\cK</code>。</td>
</tr>
<tr>
<td align="left"><code>\w</code></td>
<td align="left">匹配字母、数字、下划线。等价于’<code>[A-Za-z0-9_]</code>‘。</td>
</tr>
<tr>
<td align="left"><code>\W</code></td>
<td align="left">匹配非字母、数字、下划线。等价于 ‘<code>[^A-Za-z0-9_]</code>‘。</td>
</tr>
</tbody></table>
<h1 id="考点6-数组的下标"><a href="#考点6-数组的下标" class="headerlink" title="考点6:数组的下标"></a>考点6:数组的下标</h1><p>已知声明并初始化二维数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[][]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>，则的<code>arr[1][1]</code>值为（）</p>
<ul>
<li>A <code>1</code></li>
<li>B <code>2</code></li>
<li>C <code>4</code></li>
<li>D <code>5</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>一定要记住数组中以0下标开始</p>
<h1 id="考点8-List和Set的异同"><a href="#考点8-List和Set的异同" class="headerlink" title="考点8:List和Set的异同"></a>考点8:List和Set的异同</h1><p>列表(List)和集合(Set)下面说法正确的是？( )</p>
<ul>
<li>A Set中至多只能有一个空元素</li>
<li>B List中至多只能有一个空元素</li>
<li>C List和Set都可以包含重复元素的有序集合</li>
<li>D List和Set都是有序集合</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>java里面讲的有序无序，指的是你按照顺序存进去数据，然后再按照顺序取出来，两者是一样的。比如List(0)我放的是“a”，那么我list.get(0)取出来也是“a”。并不代表我存了打乱顺序存1到10十个数，它会自己给按照升序或者降序给你排好序。</p>
<p>list有序有重；set无序无重</p>
<h1 id="考点9-Servlet过滤器"><a href="#考点9-Servlet过滤器" class="headerlink" title="考点9:Servlet过滤器"></a>考点9:Servlet过滤器</h1><p>在J2EE中，使用Servlet过滤器，需要在<code>web.xml</code>中配置（）元素</p>
<ul>
<li>A <code>&lt;filter&gt;</code></li>
<li>B <code>&lt;filter-mapping&gt;</code></li>
<li>C <code>&lt;servlet-filter&gt;</code></li>
<li>D <code>&lt;filter-config&gt;</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: AB</details>

<p>答案：AB<br>Servlet过滤器的配置包括两部分：<br>第一部分是过滤器在Web应用中的定义，由<code>&lt;filter&gt;</code>元素表示，包括<code>&lt;filter-name&gt;</code>和<code>&lt;filter-class&gt;</code>两个必需的子元素<br>第二部分是过滤器映射的定义，由<code>&lt;filter-mapping&gt;</code>元素表示,可以将一个过滤器映射到一个或者多个Servlet或JSP文件，也可以采用<code>url-pattern</code>将过滤器映射到任意特征的<code>URL</code>。</p>
<h2 id="字符编码过滤器示例"><a href="#字符编码过滤器示例" class="headerlink" title="字符编码过滤器示例"></a>字符编码过滤器示例</h2><p>举个例子，如下图：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 字符编码过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>没有<code>&lt;servlet-filter&gt;</code>和<code>&lt;filter-config&gt;</code></p>
<h1 id="考点10-反序列化-clone不调用构造器，new，反射newInstance调用构造器"><a href="#考点10-反序列化-clone不调用构造器，new，反射newInstance调用构造器" class="headerlink" title="考点10:反序列化 clone不调用构造器，new，反射newInstance调用构造器"></a>考点10:反序列化 clone不调用构造器，new，反射newInstance调用构造器</h1><p>下面的对象创建方法中哪些会调用构造方法 （）？</p>
<ul>
<li>A new语句创建对象</li>
<li>B 调用Java.io.ObjectInputStream的readObject方法</li>
<li>C java反射机制使用java.lang.Class或java.lang.reflect.Constructor的newInstance()方法</li>
<li>D 调用对象的clone()方法</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

<p>readObject方法只是从文件中还原对象，clone只是一种复制拷贝对象。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/09/20210922184708.png" alt="7020520_1564402470654_E2A51A5DD194A70AC60F152482E33E06"></p>
<h1 id="考点11-String-基本类型转String"><a href="#考点11-String-基本类型转String" class="headerlink" title="考点11:String 基本类型转String"></a>考点11:String 基本类型转String</h1><p>java中 <code>String str = &quot;hello world&quot;</code>下列语句错误的是？</p>
<ul>
<li>A <code>str+=&#39; a&#39;</code></li>
<li>B <code>int strlen = str.length</code></li>
<li>C <code>str=100</code></li>
<li>D <code>str=str+100</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<p>A选项，单引号中不能有两个字符，<br>B选项，String对象没有.length属性，只有.length()方法<br>C选项，int类型的数据不能赋值给String类型的变量str</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年09月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年10月11日 java1</title>
    <url>/exam//b1e8cc06/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1:"></a>考点1:</h1><p>关于下面代码 int[] x&#x3D;new int[25]; 描述正确的是（）</p>
<ul>
<li>A x[25]存放了数据“\0”。</li>
<li>B x[24] 存放了数据“\0”。</li>
<li>C 若访问x[25]，程序将抛出异常。</li>
<li>D x[1]访问此数组的第一个元素。</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>A:不存在x[25] 索引从0开始到length-1<br>B:x[24]<br>存的是默认值0(java中没有’\0’这一说)<br>C:超出内存 正确<br>D:第二元素</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2:"></a>考点2:</h1><p>下列哪个语句语法正确？（ ）</p>
<ul>
<li>A byte y &#x3D; 11; byte x &#x3D; y +y;</li>
<li>B String x &#x3D; new Object();</li>
<li>C Object x &#x3D; new String(“Hellow”);</li>
<li>D int a [11] &#x3D; new int [11];</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>正确答案是C</p>
<p> 对于A，前一半语句赋值是没有问题的，问题是后半句，<strong>在对byte型的变量进行相加时，会先自动转换为int型进行计算，所以计算结果也是int型的，int型赋值给byte需要强制转换</strong>，所以A会出错</p>
<p> 对于B，因为object是String的父类，所以不能这样使用，不能把父类对象赋值给子类，只能是<code>Object x = new String();</code></p>
<p> 对于C，因为String是Object的子类，所以可以将子类赋值给父类。</p>
<p> 对于D，因为在声明变量时不需要指定容量，例如int  a[] &#x3D; new int[11];这样是正确的，但是像D选项这样是错误的</p>
<p>选C。该题考查的是<strong>数据类型转换以及转换原则和取值范围</strong>。<br> A选项属于赋值和算术运算的转换：<strong>byte取值范围-128～127</strong>，所以byte y &#x3D; 11正确；byte x &#x3D; y +y基本就是先转换为高位数据类型，再参加运算，结果也是最高位的数据类型， byte short char运算会转换为<strong>int，</strong>所以错误。<br> B选项是多态的条件应用：1.要有继承；2.要有重写；3.<strong>父类引用指向子类对象</strong>。Object是一切类的基类，正确的写法应该是：<strong>Object x&#x3D;new String()<strong>。所以B选项错误。<br> D选项</strong>声明数组变量</strong>的错误，正确的应该是<strong>int a []<strong>或者</strong>int[] a</strong>。所以D错误。</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3:"></a>考点3:</h1><p>This调用语句必须是构造函数中的第一个可执行语句。</p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>this()才必须是构造函数中的第一个可执行语句，用this调用语句并不需要。</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4:"></a>考点4:</h1><p>下列哪些语句关于内存回收的说明是正确的? (  )</p>
<ul>
<li>A 程序员必须创建一个线程来释放内存</li>
<li>B 内存回收程序负责释放无用内存</li>
<li>C 内存回收程序允许程序员直接释放内存</li>
<li>D 内存回收程序可以在指定的时间释放内存对象</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>A : JVM会自己创建垃圾回收线程；<br>B ：内存回收线程的作用，正确；<br>C ：程序员无法释放内存，程序员最多是使用System.gc()和Runtime.getRuntime().gc()通知系统释放内存；<br>D：系统释放内存时间是不确定的，会根据当前程序的内存使用情况而定。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211012130657.png" alt="img"></p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5:"></a>考点5:</h1><p>下列语句中，正确的是</p>
<ul>
<li>A float x&#x3D;0.0</li>
<li>B boolean b&#x3D;3&gt;5</li>
<li>C char c&#x3D;”A”</li>
<li>D double &#x3D;3.14</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>
在java里面 float类型数据类型初始化时必须使用后缀f  因为java默认浮点型是double   用后缀f表示为float类型；
A应为：float x = 0.0f;
布尔值可以是一个表达式的值，但必须是一个true或者false值
B正确
char只能是一个字符 而不是一个字符串
C应为：char c='A';
D没变量名...没变量名...没变量名...重要的事情说三遍

<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6:"></a>考点6:</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharToString</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="type">char</span> <span class="variable">myChar</span> <span class="operator">=</span> <span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">myStr</span> <span class="operator">=</span> Character.toString(myChar);</span><br><span class="line">  System.out.println(<span class="string">&quot;String is: &quot;</span>+myStr);</span><br><span class="line">  myStr = String.valueOf(myChar);</span><br><span class="line">  System.out.println(<span class="string">&quot;String is: &quot;</span>+myStr);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此代码片段输出正确的值是（）</p>
<ul>
<li>A <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String is: g</span><br><span class="line">String is: g</span><br></pre></td></tr></table></figure></li>
<li>B <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String is: 103</span><br><span class="line">String is: g</span><br></pre></td></tr></table></figure></li>
<li>C <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String is: g</span><br><span class="line">String is: 103</span><br></pre></td></tr></table></figure></li>
<li>D <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String is: 103</span><br><span class="line">String is: 103</span><br></pre></td></tr></table></figure></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="type">char</span> data[] = &#123;c&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的都是字符串,<strong>只有char变成 int 的时候才会变为对应的assic码</strong></p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7:"></a>考点7:</h1><p>已知x &gt;&#x3D; y and y &gt;&#x3D; z 为真，那么x &gt; z or y &#x3D; z 值为</p>
<ul>
<li>A 真</li>
<li>B 假</li>
<li>C 无法确定</li>
<li>D x y z同为正数时为真</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>答案应该是C<br>条件可以简单分析为数学不等式  x&gt;&#x3D;y&gt;&#x3D;z，那么x&gt;z不一定为true<br>当x&gt;z为true，后面的条件忽略，结果为真；<br>当x&#x3D;&#x3D;z，x&gt;z为fslae，继续判断后一个条件</p>
<ul>
<li>如果z&#x3D;&#x3D;0，则y&#x3D;z为false，结果为假；</li>
<li>如果z!&#x3D;0，则y&#x3D;z为true，结果为真；<br>所以，最后的结果是不确定的。</li>
</ul>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8:"></a>考点8:</h1><p>以下哪些表达式返回为真（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a=<span class="string">&quot;My field1&quot;</span>;</span><br><span class="line">String b=<span class="string">&quot;My field1&quot;</span>;</span><br><span class="line">String c=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;My field1&quot;</span>);</span><br><span class="line">String d=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;My field1&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>A a&#x3D;&#x3D;b</li>
<li>B a&#x3D;&#x3D;c</li>
<li>C c&#x3D;d</li>
<li>D a.equals(b)</li>
<li>E a.equals(c)</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ADE</details>

<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9:"></a>考点9:</h1><p>下列正确的有（）</p>
<ul>
<li>A call by value不会改变实际参数的数值</li>
<li>B call by reference能改变实际参数的参考地址</li>
<li>C call by reference不能改变实际参数的参考地址</li>
<li>D call by reference能改变实际参数的内容</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details>

<p>选ACD。该题考察的是<strong>值传递和引用传递</strong>参数的调用。</p>
<ul>
<li><strong>值传递</strong>是将变量的一个副本传递到方法中，方法中如何操作该变量副本，都不会改变原变量的值。</li>
<li><strong>引用传递</strong>是将变量的内存地址传递给方法，方法操作变量时会找到保存在该地址的变量，对其进行操作。会对原变量造成影响。</li>
</ul>
<h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10:"></a>考点10:</h1><p>以下说法哪个是正确的（）</p>
<ul>
<li>A IOException在编译时会被发现</li>
<li>B NullPointerEception在编译时不被发现</li>
<li>C SQLException在编译时会被发现</li>
<li>D FileNotFoundException在编译时会被发现</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>

<p>Java的异常分为两种，一种是运行时异常（RuntimeException），一种是非运行异常也叫检查式异常（CheckedException）。<br>1、运行时异常不需要程序员去处理，当异常出现时，JVM会帮助处理。常见的运行时异常有：</p>
<ul>
<li>ClassCastException(类转换异常)</li>
<li>ClassNotFoundException</li>
<li>IndexOutOfBoundsException(数组越界异常)</li>
<li>NullPointerException(空指针异常)</li>
<li>ArrayStoreException(数组存储异常，即数组存储类型不一致)</li>
<li>还有IO操作的BufferOverflowException异常</li>
</ul>
<p>2、非运行异常需要程序员手动去捕获或者抛出异常进行显示的处理，因为Java认为Checked异常都是可以被修复的异常。常见的异常有：</p>
<ul>
<li>IOException</li>
<li>SqlException</li>
</ul>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年10月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月24日 java1</title>
    <url>/exam//412c95a0/</url>
    <content><![CDATA[<h1 id="考点1-垃圾回收机制"><a href="#考点1-垃圾回收机制" class="headerlink" title="考点1:垃圾回收机制"></a>考点1:垃圾回收机制</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String str0=<span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> String str1=<span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line">String str2=str1.substring(<span class="number">5</span>);</span><br><span class="line">String str3=<span class="keyword">new</span> <span class="title class_">String</span>(str2);</span><br><span class="line">String str4=<span class="keyword">new</span> <span class="title class_">String</span>(str3.toCharArray());</span><br><span class="line">str0=<span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>假定str0,…,str4后序代码都是只读引用。<br>Java 7中，以上述代码为基础，在发生过一次FullGC后，上述代码在Heap空间（不包括PermGen）保留的字符数为（）</p>
<ul>
<li>A 5</li>
<li>B 10</li>
<li>C 15</li>
<li>D 20</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>常量池是PermGen的</p>
<p>这是一个关于java的垃圾回收机制的题目。垃圾回收主要针对的是堆区的回收，因为栈区的内存是随着线程而释放的。<br>堆区分为三个区：</p>
<ul>
<li><p>年轻代（Young Generation）、</p>
</li>
<li><p>年老代（Old Generation）、</p>
</li>
<li><p>永久代（Permanent Generation，也就是方法区）。</p>
</li>
<li><p>年轻代：对象被创建时（new）的对象通常被放在Young（除了一些占据内存比较大的对象）,经过一定的Minor GC（针对年轻代的内存回收）还活着的对象会被移动到年老代（一些具体的移动细节省略）。</p>
</li>
<li><p>年老代：就是上述年轻代移动过来的和一些比较大的对象。Minor GC(FullGC)是针对年老代的回收</p>
</li>
<li><p>永久代：存储的是final常量，static变量，常量池。</p>
</li>
</ul>
<p>str3,str4都是直接new的对象，而substring的源代码其实也是new一个string对象返回。：</p>
<figure class="highlight java"><figcaption><span>java/lang/String.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">subLen</span> <span class="operator">=</span> value.length - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="built_in">this</span> : <span class="keyword">new</span> <span class="title class_">String</span>(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过fullgc之后，年老区的内存回收，则年轻区的占了15个，不算PermGen。所以答案选C</p>
<h1 id="考点2-递归"><a href="#考点2-递归" class="headerlink" title="考点2:递归"></a>考点2:递归</h1><p>下面这段程序的输出结果是（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        split(<span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">split</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (number % <span class="number">2</span> != <span class="number">0</span>) System.out.print(split((number + <span class="number">1</span>) / <span class="number">2</span>));</span><br><span class="line">                System.out.print(split(number / <span class="number">2</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A 12136</li>
<li>B 63121</li>
<li>C 61213</li>
<li>D 11236</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>这种题目还考眼力，代码不规范，格式化后的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">split</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (number &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (number % <span class="number">2</span> != <span class="number">0</span>) </span><br><span class="line">            System.out.print(split((number + <span class="number">1</span>) / <span class="number">2</span>));</span><br><span class="line">        System.out.print(split(number / <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>split(12);</p>
<blockquote>
<p>12&gt;1,true,进入外层if</p>
<blockquote>
<p>12%2!&#x3D;0,false,不进入内层if.</p>
<p>执行System.out.print(split(12 &#x2F; 2));也就是System.out.print(split(6));</p>
<blockquote>
<p>先执行split(6)</p>
<blockquote>
<p>6&gt;1,进入外层if<br>6 % 2 !&#x3D; 0,false,不进入内层if,</p>
<p>执行System.out.print(split(6 &#x2F; 2));也就是执行System.out.print(split(3));</p>
<blockquote>
<p>先执行split(3)</p>
<blockquote>
<p>3&gt;1,true,进入外层if</p>
<p>3 % 2 !&#x3D; 0,true,进入内层if</p>
<blockquote>
<p>执行System.out.print(split((3 + 1) &#x2F; 2));也就是执行System.out.print(split(2));</p>
<blockquote>
<p>先执行split(2)<br>2&gt;1,true,进入外层if<br>2 % 2 !&#x3D; 0,false,不进入内层if<br>执行System.out.print(split(2 &#x2F; 2));也就是执行System.out.print(split(1));</p>
<blockquote>
<p>先执行split(1)<br>1&gt;1,false,不进入外层if,return 1,也就是split(1)&#x3D;1</p>
</blockquote>
<p>执行System.out.print(split(1))，也就是System.out.print(1)；，输出1，<br>执行sprint(2)的返回语句，返回2<br>执行System.out.print(split(2));也就是执行System.out.print(2);，输出2</p>
</blockquote>
<p>退出内层if</p>
<p>执行System.out.print(split(3 &#x2F; 2));，也就是执行System.out.print(split(1));</p>
<blockquote>
<p>先执行split(1)<br>1&gt;1,false,不进入外层if,返回1，split(1)&#x3D;1</p>
</blockquote>
<p>执行System.out.print(split(1));也就是执行执行System.out.print(1);，输出1</p>
</blockquote>
<p>退出外层if,返回3，split(3)&#x3D;3</p>
</blockquote>
</blockquote>
<p>执行System.out.print(split(3));也就是执行执行System.out.print(3);输出3</p>
<p>执行split(6)的返回语句，返回6，</p>
</blockquote>
<p>执行System.out.print(split(6));也就是执行System.out.print(6);输出6</p>
</blockquote>
<p>退出split(12)的外层if</p>
</blockquote>
<p>split(12)返回12</p>
</blockquote>
<p>考察方法进栈与出栈的顺序。先进后出<br>有个知识点，<strong>方法在出栈的时候，执行的是return语句</strong>。因为出栈就意味着方法结束并销毁，如果没有return语句，那么方法出栈的时候什么都不执行，就直接销毁。</p>
<p>1.执行split（12）时，执行代码System.out.print(split(number &#x2F; 2))<br>    split（12&#x2F;2）进栈，此时number&#x3D;6；<br>2.执行split（6）时，执行代码System.out.print(split(number &#x2F; 2))<br>    split（6&#x2F;2）进栈，此时number&#x3D;3；<br>3.执行split（3）时，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第<span class="number">1</span>行 <span class="keyword">if</span> (number % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">第<span class="number">2</span>行          System.out.print(split((number + <span class="number">1</span>) / <span class="number">2</span>));</span><br><span class="line">第<span class="number">3</span>行    System.out.print(split(number / <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>按照顺序执行<br>先执行第2行<br>    首先split（(3+1)&#x2F;2）进栈，此时number&#x3D;2，<br>    再执行split（2），那么split（2&#x2F;2）进栈，此时number&#x3D;1， 最后return 1，<br>    注意此时第2行代码还没有结束<br>    此时<br>    split（2&#x2F;2）出栈，输出1；<br>    split（(3+1)&#x2F;2）出栈，输出2；<br>第二行代码结束，再执行第三行，此时number&#x3D;3，执行System.out.print(split(number &#x2F; 2))<br>        split（3&#x2F;2）进栈，number&#x3D;1，return，那么就需要出栈了<br>split（3&#x2F;2）出栈，输出1<br>split（6&#x2F;2）出栈，输出3<br>split（12&#x2F;2）出栈，输出6；<br>最终结果12136；</p>
<p>split（number）方法，最终返回的是number这个值，所以split（n）出栈的输出结果就是n</p>
<p>整理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">split（12/2）进栈</span><br><span class="line">split（6/2）进栈</span><br><span class="line">split（(3+1)/2）进栈</span><br><span class="line">split（2/2）进栈</span><br><span class="line">       split（2/2）出栈，输出1</span><br><span class="line">        split（(3+1)/2）出栈，输出2</span><br><span class="line"></span><br><span class="line">split（2/2）进栈</span><br><span class="line">        split（2/2）出栈，输出1</span><br><span class="line">split（6/2）出栈，输出3</span><br><span class="line">split（12/2）出栈，输出6</span><br></pre></td></tr></table></figure>

<h1 id="考点3-JVM内存配置参数"><a href="#考点3-JVM内存配置参数" class="headerlink" title="考点3:JVM内存配置参数"></a>考点3:JVM内存配置参数</h1><p>对于JVM内存配置参数：<br>-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio&#x3D;3<br>,其最小内存值和Survivor区总大小分别是（）</p>
<ul>
<li>A 5120m，1024m</li>
<li>B 5120m，2048m</li>
<li>C 10240m，1024m</li>
<li>D 10240m，2048m</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-Xmx：</td>
<td align="left">最大堆大小</td>
</tr>
<tr>
<td align="left">-Xms：</td>
<td align="left">初始堆大小</td>
</tr>
<tr>
<td align="left">-Xmn:</td>
<td align="left">年轻代大小</td>
</tr>
<tr>
<td align="left">-XXSurvivorRatio：</td>
<td align="left">年轻代中Eden区与Survivor的一个区的大小比值，Survivor有两个区</td>
</tr>
</tbody></table>
<p>-Xms10240m，初始堆大小即最小内存值为10240m<br>-Xmn5120m，表示年轻代大小5120m</p>
<p>-XXSurvivorRatio&#x3D;3表示Eden:S0:S1&#x3D;3:1:1<br>Survivor区总大小&#x3D;<code>(5120/(3+1+1))*(1+1)=(5120/5)*2=1024*2=2048</code></p>
<h1 id="考点4-Servlet-ServletContext参数值"><a href="#考点4-Servlet-ServletContext参数值" class="headerlink" title="考点4:Servlet ServletContext参数值"></a>考点4:Servlet ServletContext参数值</h1><p>如何获取ServletContext设置的参数值？</p>
<ul>
<li>A context.getParameter()</li>
<li>B context.getInitParameter()</li>
<li>C context.getAttribute()</li>
<li>D context.getRequestDispatcher()</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>getParameter()是获取POST&#x2F;GET传递的参数值；<br>getInitParameter获取Tomcat的server.xml中设置Context的初始化参数<br>getAttribute()是获取对象容器中的数据值；<br>getRequestDispatcher是请求转发。</p>
<h1 id="考点5-线程-InterruptedException"><a href="#考点5-线程-InterruptedException" class="headerlink" title="考点5:线程 InterruptedException"></a>考点5:线程 InterruptedException</h1><p>下面哪个行为被打断不会导致InterruptedException：（ ）？</p>
<ul>
<li>A Thread.join</li>
<li>B Thread.sleep</li>
<li>C Object.wait</li>
<li>D CyclicBarrier.await</li>
<li>E Thread.suspend</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: E</details>

<p>抛InterruptedException的代表方法有：<br>java.lang.Object 类的 wait 方法<br>java.lang.Thread 类的 sleep 方法<br>java.lang.Thread 类的 join 方法</p>
<h2 id="Thread只有sleep​和join这两个方法抛出InterruptedException"><a href="#Thread只有sleep​和join这两个方法抛出InterruptedException" class="headerlink" title="Thread只有sleep​和join这两个方法抛出InterruptedException"></a>Thread只有sleep​和join这两个方法抛出InterruptedException</h2><p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> sleep​(<span class="type">long</span> millis) <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> sleep​(<span class="type">long</span> millis, <span class="type">int</span> nanos) <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> join​(<span class="type">long</span> millis) <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> join​(<span class="type">long</span> millis, <span class="type">int</span> nanos) <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure>
<h2 id="Thread的suspend方法"><a href="#Thread的suspend方法" class="headerlink" title="Thread的suspend方法"></a>Thread的suspend方法</h2><p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html#suspend()">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html#suspend()</a></p>
<p>文档中描述如下</p>
<blockquote>
<p><code>@Deprecated(since=&quot;1.2&quot;) public final void suspend()</code><br><strong>Deprecated.</strong><br>This method has been deprecated, as it is inherently deadlock-prone. If the target thread holds a lock on the monitor protecting a critical system resource when it is suspended, no thread can access this resource until the target thread is resumed. If the thread that would resume the target thread attempts to lock this monitor prior to calling resume, deadlock results. Such deadlocks typically manifest themselves as “frozen” processes. For more information, see Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?.<br>Suspends this thread.<br>First, the checkAccess method of this thread is called with no arguments. This may result in throwing a SecurityException (in the current thread).<br>If the thread is alive, it is suspended and makes no further progress unless and until it is resumed.<br><strong>Throws:</strong><br>SecurityException - if the current thread cannot modify this thread.<br><strong>See Also:</strong><br>checkAccess()</p>
</blockquote>
<p>没看到有抛出InterruptedException异常</p>
<h2 id="Object类中只有wait方法抛出InterruptedException"><a href="#Object类中只有wait方法抛出InterruptedException" class="headerlink" title="Object类中只有wait方法抛出InterruptedException"></a>Object类中只有wait方法抛出InterruptedException</h2><p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#wait()">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#wait()</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> wait​(<span class="type">long</span> timeoutMillis) <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> wait​(<span class="type">long</span> timeoutMillis, <span class="type">int</span> nanos) <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure>

<h1 id="考点6-网路编程-URL类"><a href="#考点6-网路编程-URL类" class="headerlink" title="考点6:网路编程 URL类"></a>考点6:网路编程 URL类</h1><p><code>URL u =new URL(&quot;http://www.123.com&quot;);</code>。如果<code>www.123.com</code>不存在，则返回<code>______</code>。</p>
<ul>
<li>A <code>http://www.123.com</code></li>
<li>B <code>””</code></li>
<li>C <code>null</code></li>
<li>D 抛出异常</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h2 id="new-URL只检查URL的格式是否正确"><a href="#new-URL只检查URL的格式是否正确" class="headerlink" title="new URL只检查URL的格式是否正确"></a>new URL只检查URL的格式是否正确</h2><p>new URL()时必须捕获检查异常，但这个异常是由于字符串格式和URL不符导致的，与网址是否存在无关。URL的toString方法返回字符串，无论网址是否存在。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLtest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// URL u =new URL(&quot;http://www.123.com&quot;);</span></span><br><span class="line">            <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://www.agaeww123fjaoufoaufoajquroquroqj223453uuiu.com&quot;</span>);</span><br><span class="line">            System.out.println(u);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.agaeww123fjaoufoaufoajquroquroqj223453uuiu.com</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLtest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// URL u =new URL(&quot;http://www.123.com&quot;);</span></span><br><span class="line">            <span class="comment">// URL u =new URL(&quot;http://www.agaeww123fjaoufoaufoajquroquroqj223453uuiu.com&quot;);</span></span><br><span class="line">            <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;hello_world://www.nihao.com&quot;</span>);</span><br><span class="line">            System.out.println(u);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.net.MalformedURLException: no protocol: hello_world://www.nihao.com</span><br><span class="line">    at java.net.URL.&lt;init&gt;(URL.java:600)</span><br><span class="line">    at java.net.URL.&lt;init&gt;(URL.java:497)</span><br><span class="line">    at java.net.URL.&lt;init&gt;(URL.java:446)</span><br><span class="line">    at base.net.URLtest.main(URLtest.java:11)</span><br></pre></td></tr></table></figure>
<h2 id="URL文档"><a href="#URL文档" class="headerlink" title="URL文档"></a>URL文档</h2><p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URL.html#%3Cinit%3E(java.lang.String)">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URL.html#%3Cinit%3E(java.lang.String)</a></p>
<blockquote>
<p>public URL​(String spec)<br>    throws MalformedURLException<br>Creates a URL object from the String representation.<br>This constructor is equivalent to a call to the two-argument constructor with a null first argument.<br><strong>Parameters:</strong><br>spec - the String to parse as a URL.<br><strong>Throws:</strong><br><code>MalformedURLException</code> - if no protocol is specified, or an unknown protocol is found, or spec is null, or the parsed URL fails to comply with the specific syntax of the associated protocol.<br><strong>See Also:</strong><br>URL(java.net.URL, java.lang.String)</p>
</blockquote>
<h1 id="考点7-异常基础知识"><a href="#考点7-异常基础知识" class="headerlink" title="考点7:异常基础知识"></a>考点7:异常基础知识</h1><p>下面哪些情况可以引发异常：</p>
<ul>
<li>A 数组越界</li>
<li>B 指定URL不存在</li>
<li>C 使用throw语句抛出</li>
<li>D 使用throws语句</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<p>throws 和 throw：<br>throws出现在方法头，表示可能会出现异常；<br>throw是在方法体，抛出了异常，执行throw则一定抛出了某种异常</p>
<p>两者都是消极的异常处理方式，只是抛出或者可能抛出异常，是不会由函数处理，真正的处理异常由它的上层调用处理。</p>
<h1 id="考点8-异常基础知识"><a href="#考点8-异常基础知识" class="headerlink" title="考点8:异常基础知识"></a>考点8:异常基础知识</h1><p>下面有关 JAVA 异常类的描述,说法正确的有()</p>
<ul>
<li>A 异常的继承结构:基类为 Throwable,Error 和 Exception 。实现 Throwable, RuntimeException 和 IOException 等继承 Exception</li>
<li>B 非 RuntimeException 一般是外部错误(不考虑Error的情况下),其可以在当前类被 try{}catch 语句块所捕获</li>
<li>C Error 类体系描述了 Java 运行系统中的内部错误以及资源耗尽的情形,Error 不需要捕捉</li>
<li>D RuntimeException 体系包括错误的类型转换、数组越界访问和试图访问空指针等等,必须 被 try{}catch 语句块所捕获</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/09/20210924162953.png" alt="image-20210924162953709"></p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/09/20210924163133.png" alt="image-20210924163133318"></p>
<h1 id="考点9-CMS垃圾收集器"><a href="#考点9-CMS垃圾收集器" class="headerlink" title="考点9:CMS垃圾收集器"></a>考点9:CMS垃圾收集器</h1><p>CMS垃圾回收器在那些阶段是没用用户线程参与的</p>
<ul>
<li>A 初始标记</li>
<li>B 并发标记</li>
<li>C 重新标记</li>
<li>D 并发清理</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

<p>带并发的都是与用户线程一起执行的<br><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/09/20210916174348.png" alt="这里有一张图片"><br><a href="/JavaReadingNotes/be2b4fbf/">3.5.6 CMS收集器</a></p>
<h1 id="考点10-线程基础知识"><a href="#考点10-线程基础知识" class="headerlink" title="考点10:线程基础知识"></a>考点10:线程基础知识</h1><p>以下说法错误的是（）</p>
<ul>
<li>A 其他选项均不正确</li>
<li>B java线程类优先级相同</li>
<li>C Thread和Runnable接口没有区别</li>
<li>D 如果一个类继承了某个类，只能使用Runnable实现线程</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details>

<p><strong>Thread和Runable有区别</strong><br>Thread是一个类，Runable是一个接口。<br>Runable只有一个run方法，<br>而Thread除了有run方法，还有从Object继承来的方法，以及Thread中定义的start,sleep等方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">Object</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br></pre></td></tr></table></figure>
<p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html#method.summary">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html#method.summary</a><br><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runnable.html#method.summary">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runnable.html#method.summary</a></p>
<p><strong>实现线程的方式</strong></p>
<ul>
<li>继承Thread，然后调用Thread子类的start()方法启动线程</li>
<li>实现Runable接口，然后new Thread(new Runable实现类).start()</li>
<li>实现Callable接口，c&#x3D;new Callable实现类，f&#x3D;new FutureTask(c),new Thread(f).start()。然后通过f.get()获得线程的返回值。</li>
</ul>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年09月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年10月12日 java1</title>
    <url>/exam//5adf7705/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1:"></a>考点1:</h1><p>下列语句序列执行后，输出结果是（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ex</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line"><span class="type">int</span> a=<span class="number">13</span>;</span><br><span class="line">a=a/<span class="number">5</span>；</span><br><span class="line">System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 1</li>
<li>B 2</li>
<li>C 3</li>
<li>D 4</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>a是int类型,13&#x2F;5得到一个浮点类型,浮点类型转成整数类型的原则是,不四舍五入,直接截断小数点后的部分.</p>
<p>整数相除之后还是整数，会丢失掉小数部分的数值。</p>
<p>13&#x2F;5取商为2，然后再赋值给a,所有输出a&#x3D;2。</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2:"></a>考点2:</h1><p>设有下面一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Student</span>  <span class="keyword">extends</span>  <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="type">long</span>    id;     <span class="comment">// 身份证号</span></span><br><span class="line"><span class="type">int</span>  score;  <span class="comment">// 入学总分</span></span><br><span class="line">String  name;   <span class="comment">// 姓名</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">getScore</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span>  score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问：类 Person 和类 Student 的关系是（ ）。</p>
<ul>
<li>A 包含关系</li>
<li>B 继承关系</li>
<li>C 关联关系</li>
<li>D 无关系，上述类定义有语法错误</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3:"></a>考点3:</h1><p>下列不属于类及类成员的访问控制符是：（ ）</p>
<ul>
<li>A public</li>
<li>B private</li>
<li>C static</li>
<li>D protected</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<table>
<thead>
<tr>
<th align="left">作用域</th>
<th align="left">当前类</th>
<th align="left">同包</th>
<th align="left">子类</th>
<th align="left">其他</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Public</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
</tr>
<tr>
<td align="left">Protected</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">×</td>
</tr>
<tr>
<td align="left">Default</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">×</td>
<td align="left">×</td>
</tr>
<tr>
<td align="left">Private</td>
<td align="left">√</td>
<td align="left">×</td>
<td align="left">×</td>
<td align="left">×</td>
</tr>
</tbody></table>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4:"></a>考点4:</h1><p>以下程序会输出什么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span><span class="number">100</span>,b=<span class="number">50</span>,c=a---b,d=a---b;</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br><span class="line">System.out.println(c);</span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure>

<ul>
<li>A 100 48 48 49</li>
<li>B 100 49 48 52</li>
<li>C 98 50 50 49</li>
<li>D 98 50 50 48</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c=a---b 等于c=a-- -b 等于c=100-50=50,a=99</span><br><span class="line">b=a---b 等于c=a-- -b 等于d=99-50=49,a=98</span><br></pre></td></tr></table></figure>
<p>综上得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=98,b=50,c=50,d=49</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/antineutrino/p/3301843.html">https://www.cnblogs.com/antineutrino/p/3301843.html</a></p>
<h2 id="Java运算符优先级"><a href="#Java运算符优先级" class="headerlink" title="Java运算符优先级"></a>Java运算符优先级</h2><table>
<thead>
<tr>
<th align="left">优先级</th>
<th align="left">运算符</th>
<th align="left">结合性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><code>()</code>、<code>[]</code>、<code>&#123;&#125;</code></td>
<td align="left">从左向右</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><code>!</code>、<code>+</code>、<code>-</code>、<code>~</code>、<code>++</code>、<code>--</code></td>
<td align="left">从右向左</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><code>*</code>、<code>/</code>、<code>%</code></td>
<td align="left">从左向右</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><code>+</code>、<code>-</code></td>
<td align="left">从左向右</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><code>&lt;&lt;</code>、<code>&gt;&gt;</code>、&gt;&gt;&gt;</td>
<td align="left">从左向右</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;、instanceof</td>
<td align="left">从左向右</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">&#x3D;&#x3D;、!&#x3D;</td>
<td align="left">从左向右</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">&amp;</td>
<td align="left">从左向右</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><code>^</code></td>
<td align="left">从左向右</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">&amp;#124;</td>
<td align="left">从左向右</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">&amp;&amp;</td>
<td align="left">从左向右</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">&amp;#124;&amp;#124;</td>
<td align="left">从左向右</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><code>?:</code></td>
<td align="left">从右向左</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、&amp;&#x3D;、&amp;#124;&#x3D;、^&#x3D;、<code>~=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、&gt;&gt;&gt;&#x3D;</td>
<td align="left">从右向左</td>
</tr>
</tbody></table>
<p><a href="http://c.biancheng.net/view/794.html">http://c.biancheng.net/view/794.html</a></p>
<h2 id="运算符的结合性"><a href="#运算符的结合性" class="headerlink" title="运算符的结合性"></a>运算符的结合性</h2><p>许多操作符的优先级都是相同的。这时，操作符的结合性就开始发挥作用了。<strong>在表达式中如果有几个优先级相同的操作符，结合性就起仲裁的作用，由它决定哪个操作符先执行。先执行，可以看做是加上括号</strong>。</p>
<p>比如，<strong>右结合（从右到左），那就是，把右边的运算用括号先括起来，再与左边的进行计算</strong>，这样自然是先执行右边的了。  比如   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a,b=<span class="number">1</span>,c=<span class="number">2</span>;</span><br><span class="line">a=b=c;</span><br><span class="line">```  </span><br><span class="line">这里<span class="string">&#x27;=&#x27;</span>的结合性是从右到左。 故a=b=c; 可变为a=(b=c);  即a=<span class="number">2</span>。</span><br><span class="line"></span><br><span class="line"># 考点<span class="number">5</span>:</span><br><span class="line">通过HttpServletRequest. getParameter获取的参数.</span><br><span class="line">- A 总是采用UTF-<span class="number">8</span>编码</span><br><span class="line">- B 总是采用lS08859-<span class="number">1</span>编码</span><br><span class="line">- C 由客户端浏览器和Web容器配置共同决定编码</span><br><span class="line">- D 由服务器所在的操作系统决定编码</span><br><span class="line"></span><br><span class="line">&lt;details&gt;&lt;summary&gt;显示答案/隐藏答案&lt;/summary&gt;正确答案: C&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">选C</span><br><span class="line"><span class="number">1</span>、浏览器根据jsp页面开头声明的编码方式对request中参数编码；</span><br><span class="line"><span class="number">2</span>、tomcat默认解码是ISO-<span class="number">8859</span>-<span class="number">1</span>，</span><br><span class="line">但是我们可以显示指定解码格式</span><br><span class="line">- 通过调用request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>)，</span><br><span class="line">- 或者修改tomcat的配置文件server.xml中的编码，添加uriEncoding属性。</span><br><span class="line"></span><br><span class="line"># 考点<span class="number">6</span>:</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> y=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x=y)</span><br><span class="line">            System.out.println(<span class="string">&quot;Not equal&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Equal&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面结果输出是？</p>
<ul>
<li>A The output is “Equal”</li>
<li>B The output in “Not Equal”</li>
<li>C An error at line 5 causes compilation to fall.</li>
<li>D The program executes but does not print a message.</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>这个题考查两个知识点。<br>1、Java中，<strong>赋值是有返回值的，赋什么值，就返回什么值</strong>。比如这题，x&#x3D;y，返回y的值，所以括号里的值是1。<br>2、<strong>Java跟C的区别，C中赋值后会与0进行比较，如果大于0，就认为是true；而Java不会与0比较，而是直接把赋值后的结果放入括号</strong>。</p>
<p>这题，我忽略了第二点。</p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8:"></a>考点8:</h1><p>下面的输出结果是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">  &#123;</span><br><span class="line">    String str=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">else</span>     &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A true</li>
<li>B false</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>&#x3D;&#x3D;判断的是对象引用地址是否相同， </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这种方式创建的字符串，和正常创建对象一样，保存在堆区。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这种方式创建的字符串，保存在字符串常量区。</p>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9:"></a>考点9:</h1><p>以下代码段执行后的输出结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> -<span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> -<span class="number">12</span>;</span><br><span class="line">        System.out.println(y % x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A -1</li>
<li>B 2</li>
<li>C 1</li>
<li>D -2</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>无论是正数还是负数，在取余运算时都有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">被除数=商×除数+余数</span><br></pre></td></tr></table></figure>
<p>，所以-12&#x3D;2×(-5)+(-2)，-12是被除数，-5是除数，2是商，余数是-2。</p>
<p><code>%</code>是取余运算最后符号和第1个值一样，<br><code>Math.floorMod()</code>是取模，最后符号和第2个值一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(-<span class="number">12</span> % -<span class="number">5</span>);</span><br><span class="line">System.out.println(-<span class="number">12</span> % <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="number">12</span> % -<span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="number">12</span> % <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">System.out.println(Math.floorMod(-<span class="number">12</span>, -<span class="number">5</span>));</span><br><span class="line">System.out.println(Math.floorMod(-<span class="number">12</span>, <span class="number">5</span>));</span><br><span class="line">System.out.println(Math.floorMod(<span class="number">12</span>, -<span class="number">5</span>));</span><br><span class="line">System.out.println(Math.floorMod(<span class="number">12</span>, <span class="number">5</span>));</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-2</span><br><span class="line">-2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">===============================</span><br><span class="line">-2</span><br><span class="line">3</span><br><span class="line">-3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><code>%</code>是取余数，结果的符号要看<strong>被除数</strong>，也就是与第一个数同符号。</p>
<h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10:"></a>考点10:</h1><p>下面哪些具体实现类可以用于存储键，值对，并且方法调用提供了基本的多线程安全支持：(  )</p>
<ul>
<li>A java.util.ConcurrentHashMap</li>
<li>B java.util.Map</li>
<li>C java.util.TreeMap</li>
<li>D java.util.SortMap</li>
<li>E java.util.Hashtable</li>
<li>F java.util.HashMap</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: AE</details>


<h1 id="考点11"><a href="#考点11" class="headerlink" title="考点11:"></a>考点11:</h1><p>character流和byte流的区别不包括（）</p>
<ul>
<li>A 每次读入的字节数不同</li>
<li>B 前者带有缓冲，后者没有。</li>
<li>C 前者是字符读入，后者是字节读入。</li>
<li>D 二者没有区别，可以互换。</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>

<p>做错两次了，这个不包括，有点绕，题目改成 character流和byte流的说法错误的是，这样简单点</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年10月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年10月12日 java2</title>
    <url>/exam//c3d626bf/</url>
    <content><![CDATA[<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2:"></a>考点2:</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">returnTest</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码返回值是什么？</p>
<ul>
<li>A true</li>
<li>B false</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>一旦在finally块中使用了return或throw语句，将会导致try块，catch块中的return，throw语句失效</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3:"></a>考点3:</h1><p>检查程序，是否存在问题，如果存在指出问题所在，如果不存在，说明输出结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloB</span> <span class="keyword">extends</span> <span class="title class_">HelloA</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HelloB</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;I’m B class&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">static</span></span><br><span class="line"> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;static B&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">HelloB</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloA</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HelloA</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;I’m A class&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">static</span></span><br><span class="line"> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;static A&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A static A I’m A class static B I’m B class</li>
<li>B I’m A class I’m B class static A static B</li>
<li>C static A static B I’m A class I’m B class</li>
<li>D I’m A class static A I’m B class static B</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>子由父生，执行顺序为：<br>父类的静态代码块&gt;子类的静态代码块&gt;父类的构造代码块&gt;父类的构造函数&gt;子类的构造代码块&gt;子类的构造函数</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4:"></a>考点4:</h1><p>面向对象方法的多态性是指（）</p>
<ul>
<li>A 一个类可以派生出多个特殊类</li>
<li>B 一个对象在不同的运行环境中可以有不同的变体</li>
<li>C 针对一消息，不同的对象可以以适合自身的方式加以响应</li>
<li>D 一个对象可以是由多个其他对象组合而成的</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>C听起来好别扭，我觉得是：对于同一个父类方法，不同的子类会有不同的实现方式</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5:"></a>考点5:</h1><p>以下代码运行输出的是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Person&quot;</span>;</span><br><span class="line">    <span class="type">int</span> age=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String grade;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A 输出：Person</li>
<li>B 没有输出</li>
<li>C 编译出错</li>
<li>D 运行出错</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<p>2.关于多态。<strong>子类继承了父类的所有成员，包括private权限的成员变量</strong>，但是继承的子类具有私有变量的拥有权但是没有使用权。<br>3.private的成员变量，根据权限修饰符的访问控制范围，只有在类内部才能被访问，就算是他的子类，也不能访问。</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6:"></a>考点6:</h1><p>在java中，下列对继承的说法，正确的是（ ）</p>
<ul>
<li>A 子类能继承父类的所有成员</li>
<li>B 子类继承父类的非私有方法和状态</li>
<li>C 子类只能继承父类的public方法和状态</li>
<li>D 子类只能继承父类的方法</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h2 id="子类和继承父类的所有成员"><a href="#子类和继承父类的所有成员" class="headerlink" title="子类和继承父类的所有成员"></a>子类和继承父类的所有成员</h2><p><strong>我们有时候会分不清继承和访问权限的问题。子类可以继承父类所有的成员，但是对private这样的，没有访问权。</strong></p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7:"></a>考点7:</h1><p>如果希望监听TCP端口9000，服务器端应该怎样创建socket?</p>
<ul>
<li>A new Socket(“localhost”,9000);</li>
<li>B new ServerSocket(9000);</li>
<li>C new Socket(9000);</li>
<li>D new ServerSocket(“localhost”,9000);</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8:"></a>考点8:</h1><p>下列关于容器集合类的说法正确的是？</p>
<ul>
<li>A LinkedList继承自List</li>
<li>B AbstractSet继承自Set</li>
<li>C HashSet继承自AbstractSet</li>
<li>D WeakMap继承自HashMap</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>a选项LinkedList类是实现了List接口，而不是继承</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>
<p>b选项AbstractSet类实现Set接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>c选项HashSet继承AbstractSet类，同时也实现Set</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>
<p>D选项，java没有WeakMap，有WeakHashMap:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakHashMap</span>&lt;K,​V&gt;</span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,​V&gt;</span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,​V&gt;</span><br></pre></td></tr></table></figure>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9:"></a>考点9:</h1><p>下列关于异常的说法，正确的是（）</p>
<ul>
<li>A RuntimeException及其子类的异常可以不做处理</li>
<li>B Catch段中的语句，不允许再次出现异常</li>
<li>C 在方法定义中以throws标识出的异常，在调用该方法中的方法必须处理</li>
<li>D 程序中所有的可能出现的异常必须在catch中捕获，否则将引起编译错误</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年10月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年10月13日 java1</title>
    <url>/exam//b51d1c3b/</url>
    <content><![CDATA[<h1 id="考点1-变量初始化话"><a href="#考点1-变量初始化话" class="headerlink" title="考点1:变量初始化话"></a>考点1:变量初始化话</h1><p>下列程序test 类中的变量c 的最后结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">50</span>) &#123;</span><br><span class="line">             b = <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c = b + a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>A 10</li>
<li>B 0</li>
<li>C 19</li>
<li>D 编译出错</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>方法中定义的变量一定要初始化，类中定义的变量可不用初始化，会有默认值<br>报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The local variable b may not have been initialized</span><br></pre></td></tr></table></figure>

<h1 id="考点2-快速排序"><a href="#考点2-快速排序" class="headerlink" title="考点2:快速排序"></a>考点2:快速排序</h1><p>下面程序的输出结果是什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A2</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] a=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>&#125;;</span><br><span class="line">        doSomething(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a.length-<span class="number">1</span>;i++)</span><br><span class="line">        System.out.print(a[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="type">int</span> p=core(a,start,end);</span><br><span class="line">            doSomething(a,start,p-<span class="number">1</span>);</span><br><span class="line">            doSomething(a,p+<span class="number">1</span>,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">core</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> start,<span class="type">int</span> end)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=a[end];</span><br><span class="line">        <span class="type">int</span> i=start;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=start;j&lt;=end-<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;=x)&#123;</span><br><span class="line">                swap(a,i,j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a,i,end);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> i,<span class="type">int</span> j)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp=a[i];</span><br><span class="line">        a[i]=a[j];</span><br><span class="line">        a[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>A 找到最大值</li>
<li>B 找到最小值</li>
<li>C 从大到小的排序</li>
<li>D 从小到大的排序</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h1 id="考点3-maven和ant"><a href="#考点3-maven和ant" class="headerlink" title="考点3:maven和ant"></a>考点3:maven和ant</h1><p>下面有关maven和ant的描述，描述错误的是？</p>
<ul>
<li>A Ant 没有正式的约定如一个一般项目的目录结构，你必须明确的告诉 Ant 哪里去找源代码</li>
<li>B Maven 拥有约定，因为你遵循了约定，它已经知道你的源代码在哪里</li>
<li>C maven和ant都有“生命周期”的概念，当你输入一个命令后，maven或者ant会执行一系列的有序的步骤，直到到达你指定的生命周期</li>
<li>D Ant构建文件默认命名为build.xml，Maven默认构建文件为pom.xml</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h2 id="Ant的作用：是一种基于Java的build工具"><a href="#Ant的作用：是一种基于Java的build工具" class="headerlink" title="Ant的作用：是一种基于Java的build工具"></a>Ant的作用：是一种基于Java的build工具</h2><ol>
<li>能够用ant编译java类。生成class文件</li>
<li>ant能够自己定义标签、配置文件，用于构建。</li>
<li>ant能够把相关层构建成jar包 。</li>
<li>ant把整个项目生成web包。并公布到Tomcat</li>
</ol>
<h3 id="Ant的长处："><a href="#Ant的长处：" class="headerlink" title="Ant的长处："></a>Ant的长处：</h3><ol>
<li>跨平台性：Ant是纯Java语言编写的，因此具有非常好的跨平台性。</li>
<li>操作简单：Ant是由一个内置任务和可选任务组成的。Ant执行时须要一个XML文件(构建文件)。</li>
<li>Ant通过调用target树，就能够运行各种task：每一个task实现了特定接口对象。因为Ant构建文件时XML格式的文件。所以非常easy维护和书写，并且结构非常清晰。</li>
<li>Ant能够集成到开发环境中：因为Ant的跨平台性和操作简单的特点。它非常easy集成到一些开发环境中去。</li>
</ol>
<h2 id="Maven的作用：-除了以程序构建能力为特色之外，还提供高级项目管理工具。"><a href="#Maven的作用：-除了以程序构建能力为特色之外，还提供高级项目管理工具。" class="headerlink" title="Maven的作用： 除了以程序构建能力为特色之外，还提供高级项目管理工具。"></a>Maven的作用： 除了以程序构建能力为特色之外，还提供高级项目管理工具。</h2><p>Maven除了具备Ant的功能外。还添加了下面基本的功能：</p>
<ol>
<li>使用Project Object Model来对软件项目管理。</li>
<li>内置了很多其它的隐式规则，使得构建文件更加简单。</li>
<li>内置依赖管理和Repository来实现依赖的管理和统一存储；</li>
<li>内置了软件构建的生命周期；</li>
</ol>
<h3 id="Maven的长处："><a href="#Maven的长处：" class="headerlink" title="Maven的长处："></a>Maven的长处：</h3><ol>
<li>拥有约定，知道你的代码在哪里，放到哪里去</li>
<li>拥有一个生命周期，比如运行 mvn install就能够自己主动运行编译，測试。打包等构建过程</li>
<li>仅仅须要定义一个pom.xml,然后把源代码放到默认的文件夹，Maven帮你处理其它事情</li>
<li>拥有依赖管理。仓库管理</li>
</ol>
<p>总体的比較：</p>
<ul>
<li>Ant将提供了非常多能够重用的task，比如copy, move, delete以及junit单元测试</li>
<li>Maven则提供了非常多能够重用的过程。</li>
</ul>
<h1 id="考点4-java8中使用开放地址法的类"><a href="#考点4-java8中使用开放地址法的类" class="headerlink" title="考点4:java8中使用开放地址法的类"></a>考点4:java8中使用开放地址法的类</h1><p>java8中，下面哪个类用到了解决哈希冲突的开放定址法</p>
<ul>
<li>A LinkedHashSet</li>
<li>B HashMap</li>
<li>C ThreadLocal</li>
<li>D TreeMap</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>HashMap采用了<strong>链地址法</strong>，ThreadLocalMap则是<strong>开放地址法</strong>。</p>
<ul>
<li>开放定址法：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。沿此序列逐个单元地查找，直到找到给定<br>的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探查到开放的 地址则表明表中无待查的关键字，即查找失败。</li>
<li>链地址法：将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。</li>
</ul>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5:"></a>考点5:</h1><p>下列关于while循环、do-while循环和for循环说法错误的是</p>
<ul>
<li>A while循环先执行条件判断，do-while循环执行循环体</li>
<li>B do-while循环结束的条件是关键字while后的条件表达式成立</li>
<li>C for循环结构中的3个表达式缺一不可</li>
<li>D while循环能够实现的操作，for循环也能实现</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6:"></a>考点6:</h1><p>以下类型为Final类型的为（）</p>
<ul>
<li>A HashMap</li>
<li>B StringBuffer</li>
<li>C String</li>
<li>D Hashtable</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<blockquote>
<p><strong>Class HashMap&lt;K,​V&gt;</strong><br><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/HashMap.html">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/HashMap.html</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,​V&gt;</span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,​V&gt;</span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,​V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>
<p><strong>Direct Known Subclasses:</strong><br>LinkedHashMap, PrinterStateReasons</p>
</blockquote>
<blockquote>
<p><strong>Class Hashtable&lt;K,​V&gt;</strong><br><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Hashtable.html">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Hashtable.html</a><br><strong>All Implemented Interfaces:</strong><br>Serializable, Cloneable, Map&lt;K,​V&gt;<br><strong>Direct Known Subclasses:</strong><br>Properties, UIDefaults</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hashtable</span>&lt;K,​V&gt;</span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">Dictionary</span>&lt;K,​V&gt;</span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,​V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="String-StringBuffer-StringBuilder都是final类"><a href="#String-StringBuffer-StringBuilder都是final类" class="headerlink" title="String StringBuffer StringBuilder都是final类"></a>String StringBuffer StringBuilder都是final类</h2><blockquote>
<p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">Object</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">Serializable</span>, Comparable&lt;String&gt;, CharSequence</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuffer.html">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuffer.html</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringBuffer</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">Object</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">Serializable</span>, Comparable&lt;StringBuffer&gt;, CharSequence</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringBuilder</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">Object</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">Serializable</span>, Comparable&lt;StringBuilder&gt;, CharSequence</span><br></pre></td></tr></table></figure>
</blockquote>
<p>通过阅读源码可以知道，string与stringbuffer都是通过字符数组实现的。<br>其中string的字符数组是final修饰的，所以字符数组不可以修改。<br>stringbuffer的字符数组没有final修饰，所以字符数组可以修改。<br>string与stringbuffer都是final修饰，只是限制他们所存储的引用地址不可修改。<br>至于地址所指内容能不能修改，则需要看字符数组可不可以修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringBuilder</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractStringBuilder</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, CharSequence</span><br><span class="line">&#123;......&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringBuffer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractStringBuilder</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, CharSequence</span><br><span class="line">&#123;......&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7:"></a>考点7:</h1><p>在使用super和this关键字时，以下描述错误的是（）</p>
<ul>
<li>A 在子类构造方法中使用super()显示调用父类的构造方法，super()必须写在子类构造方法的第一行，否则编译不通过</li>
<li>B super()和this()不一定要放在构造方法内第一行</li>
<li>C this()和super()可以同时出现在一个构造函数中</li>
<li>D this()和super()可以在static环境中使用，包括static方法和static语句块</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details>


]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年10月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年10月13日 java2</title>
    <url>/exam//2c144d81/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1:"></a>考点1:</h1><p>在java中，已定义两个接口B和C，要定义一个实现这两个接口的类，以下语句正确的是（）</p>
<ul>
<li>A interface A extends B，C</li>
<li>B interface A eimplements B，C</li>
<li>C class A implements B，C</li>
<li>D class A implements B，implements C</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>类实现多个接口的时候，只需要一个implements，多个接口通过逗号进行隔开，先继承类再实现接口</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2:"></a>考点2:</h1><p>在socket编程中，可以使用方法（      ）获取本机的ip地址</p>
<ul>
<li>A getInetAddress()</li>
<li>B getLocalAddress()</li>
<li>C getReuseAddress()</li>
<li>D getLocalPort()</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>getInetAddress获取主机名和IP地址<br>getLocalAddress()顾名思义，获取本地IP地址<br>getReuseAddress()返回布尔类型，表示复用地址<br>getLocalPort()API 的说明：“Returns the Internet Protocol (IP) port number of the interface on which the request was received. ”</p>
<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3:"></a>考点3:</h1><p>下面有关servlet中init,service,destroy方法描述错误的是？</p>
<ul>
<li>A init()方法是servlet生命的起点。一旦加载了某个servlet，服务器将立即调用它的init()方法</li>
<li>B service()方法处理客户机发出的所有请求</li>
<li>C destroy()方法标志servlet生命周期的结束</li>
<li>D servlet在多线程下使用了同步机制，因此，在并发编程下servlet是线程安全的</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>答案为D。</p>
<p>servlet在多线程下其本身并不是线程安全的。</p>
<p>如果在类中定义成员变量，而在service中根据不同的线程对该成员变量进行更改，那么在并发的时候就会引起错误。最好是在方法中，定义局部变量，而不是类变量或者对象的成员变量。由于方法中的局部变量是在栈中，彼此各自都拥有独立的运行空间而不会互相干扰，因此才做到线程安全。</p>
<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4:"></a>考点4:</h1><p>下面代码运行结果是（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;    </span><br><span class="line">         <span class="keyword">try</span> &#123;    </span><br><span class="line">             <span class="keyword">return</span> a+b;        </span><br><span class="line">         &#125; </span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;    </span><br><span class="line">            System.out.println(<span class="string">&quot;catch语句块&quot;</span>);    </span><br><span class="line">         &#125;    </span><br><span class="line">         <span class="keyword">finally</span>&#123;    </span><br><span class="line">             System.out.println(<span class="string">&quot;finally语句块&quot;</span>);    </span><br><span class="line">         &#125;    </span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">    &#125; </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String argv[])</span>&#123; </span><br><span class="line">         <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Test</span>(); </span><br><span class="line">         System.out.println(<span class="string">&quot;和是：&quot;</span>+test.add(<span class="number">9</span>, <span class="number">34</span>)); </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A catch语句块 和是：43</li>
<li>B 编译异常</li>
<li>C finally语句块 和是：43</li>
<li>D 和是：43 finally语句块</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>为什么不是先输出：和是 finally块 43的原因。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;和是：&quot;</span>+test.add(<span class="number">9</span>, <span class="number">34</span>));</span><br></pre></td></tr></table></figure>
<p>这是进行字符串拼接是一个整体，所以首先是进入add方法中，进去之后先把先不运算result，而是输出finally块。<br>注意：此时finally块输出结果是：<strong>finally语句块</strong>，这句话首先打印到控制台中。打印完后返回来执行try中的return得到43，所以此时再将结果与”和是：”进行拼接，得到：<strong>和是43</strong>。<br>所以此时控制台又多了一句话：<strong>和是43</strong>。加上之前finally先在控制台上的输出，所以结果为：<br><strong>finally语句块 和是：43</strong></p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5:"></a>考点5:</h1><p>容器panel缺省使用的布局编辑策略是( )</p>
<ul>
<li>A Border Layout</li>
<li>B Flow Layout</li>
<li>C GridLayout</li>
<li>D Card Layout</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6:"></a>考点6:</h1><p>下面有关servlet和cgi的描述，说法错误的是？</p>
<ul>
<li>A servlet处于服务器进程中，它通过多线程方式运行其service方法</li>
<li>B CGI对每个请求都产生新的进程，服务完成后就销毁</li>
<li>C servlet在易用性上强于cgi，它提供了大量的实用工具例程，例如自动地解析和解码HTML表单数据、读取和设置HTTP头、处理Cookie、跟踪会话状态等</li>
<li>D cgi在移植性上高于servlet，几乎所有的主流服务器都直接或通过插件支持cgi</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>选择D，servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。</p>
<p>概括来讲，Servlet可以完成和CGI相同的功能。</p>
<h2 id="CGI-通用网管接口"><a href="#CGI-通用网管接口" class="headerlink" title="CGI 通用网管接口"></a>CGI 通用网管接口</h2><p>CGI（Common Gateway Interface通用网关接口）程序来实现数据在Web上的传输，使用的是如Perl这样的语言编写的，<strong>它对于客户端作出的每个请求，必须创建CGI程序的一个新实例</strong>，这样占用大量的内存资源。由此才引入了Servlet技术。</p>
<p>Servlet是一个用java编写的应用程序，在服务器上运行，处理请求信息并将其发送到客户端。对于客户端的请求，只需要创建Servlet的实例一次，因此节省了大量的内存资源。Servlet在初始化后就保留在内存中，因此每次作出请求时无需加载。</p>
<p>CGI应用开发比较困难，因为它要求程序员有处理参数传递的知识，这不是一种通用的技能。CGI不可移植，为某一特定平台编写的CGI应用只能运行于这一环境中。每一个CGI应用存在于一个由客户端请求激活的进程中，并且在请求被服务后被卸载。这种模式将引起很高的内存、CPU开销，而且在同一进程中不能服务多个客户。</p>
<p>Servlet提供了Java应用程序的所有优势——可移植、稳健、易开发。使用Servlet Tag技术，Servlet能够生成嵌于静态HTML页面中的动态内容。</p>
<p>Servlet对CGI的最主要优势在于一个Servlet被客户端发送的第一个请求激活，然后它将继续运行于后台，等待以后的请求。每个请求将生成一个新的线程，而不是一个完整的进程。多个客户能够在同一个进程中同时得到服务。一般来说，Servlet进程只是在Web Server卸载时被卸载。</p>
<p>原文：<a href="https://blog.csdn.net/zdwzzu2006/article/details/5945635" target="_blank">https://blog.csdn.net/zdwzzu2006/article/details/5945635</a></p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7:"></a>考点7:</h1><p>关于匿名内部类叙述正确的是？ ( )</p>
<ul>
<li>A 匿名内部类可以继承一个基类，不可以实现一个接口</li>
<li>B 匿名内部类不可以定义构造器</li>
<li>C 匿名内部类不能用于形参</li>
<li>D 以上说法都不正确</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>在使用匿名内部类的过程中，我们需要注意如下几点：<br>1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。<br>2、匿名内部类中是不能定义构造函数的。<br>3、匿名内部类中不能存在任何的静态成员变量和静态方法。<br>4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。<br>5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8:"></a>考点8:</h1><p>下面的对象创建方法中哪些会调用构造方法 （）？</p>
<ul>
<li>A new语句创建对象</li>
<li>B 调用Java.io.ObjectInputStream的readObject方法</li>
<li>C java反射机制使用java.lang.Class或java.lang.reflect.Constructor的newInstance()方法</li>
<li>D 调用对象的clone()方法</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

<p>readObject （）对象反序列化<br>clone（）只是拷贝而已<br>也就是说会绕过任何构造函数（有参和无参），因为clone方法的原理是从堆内存中以二进制流的方式进行拷贝，直接分配一块新内存。</p>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9:"></a>考点9:</h1><p>以下说法中正确的有？</p>
<ul>
<li>A StringBuilder是 线程不安全的</li>
<li>B Java类可以同时用 abstract和final声明</li>
<li>C HashMap中，使用 get(key)&#x3D;&#x3D;null可以 判断这个Hasmap是否包含这个key</li>
<li>D volatile关键字不保证对变量操作的原子性</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: AD</details>

<p>StringBuffer线程安全，StringBuilder线程不安全<br><code>get(key)</code>只是获取 <code>key</code> 对应的 <code>value</code>，无法判断是否 <code>key</code> 存在；</p>
<p>volatile轻量级的同步机制，能保证数据的可见性，但不能保证数据的原子性；</p>
<h1 id="考点10-待学习：并发编程"><a href="#考点10-待学习：并发编程" class="headerlink" title="考点10:待学习：并发编程"></a>考点10:待学习：并发编程</h1><p>JDK提供的用于并发编程的同步器有哪些？</p>
<ul>
<li>A Semaphore</li>
<li>B CyclicBarrier</li>
<li>C CountDownLatch</li>
<li>D Counter</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<p>答案：ABC<br>A，Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过<br>acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。<br>B，CyclicBarrier 主要的方法就是一个：await()。await()<br>方法没被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此 CyclicBarrier 上面阻塞的线程开始运行。<br>C，直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指<br>CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。<br>D，Counter不是并发编程的同步器</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年10月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年10月13日 java3</title>
    <url>/exam//f6bf4a59/</url>
    <content><![CDATA[<h1 id="考点1-int除法"><a href="#考点1-int除法" class="headerlink" title="考点1:int除法"></a>考点1:int除法</h1><p>下列语句序列执行后，输出结果是（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ex</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line"><span class="type">int</span> a=<span class="number">13</span>;</span><br><span class="line">a=a/<span class="number">5</span>；</span><br><span class="line">System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 1</li>
<li>B 2</li>
<li>C 3</li>
<li>D 4</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>a是int类型,13&#x2F;5得到一个浮点类型,浮点类型转成整数类型的原则是,不四舍五入,直接截断小数点后的部分.</p>
<p>整数相除之后还是整数，会丢失掉小数部分的数值。</p>
<p>13&#x2F;5取商为2，然后再赋值给a,所有输出a&#x3D;2。</p>
<h1 id="考点2-继承"><a href="#考点2-继承" class="headerlink" title="考点2:继承"></a>考点2:继承</h1><p>设有下面一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Student</span>  <span class="keyword">extends</span>  <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="type">long</span>    id;     <span class="comment">// 身份证号</span></span><br><span class="line"><span class="type">int</span>  score;  <span class="comment">// 入学总分</span></span><br><span class="line">String  name;   <span class="comment">// 姓名</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">getScore</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span>  score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问：类 Person 和类 Student 的关系是（ ）。</p>
<ul>
<li>A 包含关系</li>
<li>B 继承关系</li>
<li>C 关联关系</li>
<li>D 无关系，上述类定义有语法错误</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h1 id="考点3-访问控制符"><a href="#考点3-访问控制符" class="headerlink" title="考点3:访问控制符"></a>考点3:访问控制符</h1><p>下列不属于类及类成员的访问控制符是：（ ）</p>
<ul>
<li>A public</li>
<li>B private</li>
<li>C static</li>
<li>D protected</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<table>
<thead>
<tr>
<th align="left">作用域</th>
<th align="left">当前类</th>
<th align="left">同包</th>
<th align="left">子类</th>
<th align="left">其他</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Public</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
</tr>
<tr>
<td align="left">Protected</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">×</td>
</tr>
<tr>
<td align="left">Default</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">×</td>
<td align="left">×</td>
</tr>
<tr>
<td align="left">Private</td>
<td align="left">√</td>
<td align="left">×</td>
<td align="left">×</td>
<td align="left">×</td>
</tr>
</tbody></table>
<h1 id="考点4-自增，自减运算符"><a href="#考点4-自增，自减运算符" class="headerlink" title="考点4:自增，自减运算符"></a>考点4:自增，自减运算符</h1><p>以下程序会输出什么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span><span class="number">100</span>,b=<span class="number">50</span>,c=a---b,d=a---b;</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br><span class="line">System.out.println(c);</span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure>

<ul>
<li>A 100 48 48 49</li>
<li>B 100 49 48 52</li>
<li>C 98 50 50 49</li>
<li>D 98 50 50 48</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c=a---b 等于c=a-- -b 等于c=100-50=50,a=99</span><br><span class="line">b=a---b 等于c=a-- -b 等于d=99-50=49,a=98</span><br></pre></td></tr></table></figure>
<p>综上得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=98,b=50,c=50,d=49</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/antineutrino/p/3301843.html">https://www.cnblogs.com/antineutrino/p/3301843.html</a></p>
<h2 id="Java运算符优先级"><a href="#Java运算符优先级" class="headerlink" title="Java运算符优先级"></a>Java运算符优先级</h2><table>
<thead>
<tr>
<th align="left">优先级</th>
<th align="left">运算符</th>
<th align="left">结合性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><code>()</code>、<code>[]</code>、<code>&#123;&#125;</code></td>
<td align="left">从左向右</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><code>!</code>、<code>+</code>、<code>-</code>、<code>~</code>、<code>++</code>、<code>--</code></td>
<td align="left">从右向左</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><code>*</code>、<code>/</code>、<code>%</code></td>
<td align="left">从左向右</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><code>+</code>、<code>-</code></td>
<td align="left">从左向右</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><code>&lt;&lt;</code>、<code>&gt;&gt;</code>、&gt;&gt;&gt;</td>
<td align="left">从左向右</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;、instanceof</td>
<td align="left">从左向右</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">&#x3D;&#x3D;、!&#x3D;</td>
<td align="left">从左向右</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">&amp;</td>
<td align="left">从左向右</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><code>^</code></td>
<td align="left">从左向右</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">&amp;#124;</td>
<td align="left">从左向右</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">&amp;&amp;</td>
<td align="left">从左向右</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">&amp;#124;&amp;#124;</td>
<td align="left">从左向右</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><code>?:</code></td>
<td align="left">从右向左</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、&amp;&#x3D;、&amp;#124;&#x3D;、^&#x3D;、<code>~=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、&gt;&gt;&gt;&#x3D;</td>
<td align="left">从右向左</td>
</tr>
</tbody></table>
<p><a href="http://c.biancheng.net/view/794.html">http://c.biancheng.net/view/794.html</a></p>
<h2 id="运算符的结合性"><a href="#运算符的结合性" class="headerlink" title="运算符的结合性"></a>运算符的结合性</h2><p>许多操作符的优先级都是相同的。这时，操作符的结合性就开始发挥作用了。<strong>在表达式中如果有几个优先级相同的操作符，结合性就起仲裁的作用，由它决定哪个操作符先执行。先执行，可以看做是加上括号</strong>。</p>
<p>比如，<strong>右结合（从右到左），那就是，把右边的运算用括号先括起来，再与左边的进行计算</strong>，这样自然是先执行右边的了。  比如   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a,b=<span class="number">1</span>,c=<span class="number">2</span>;</span><br><span class="line">a=b=c;</span><br></pre></td></tr></table></figure>
<p>这里’&#x3D;’的结合性是从右到左。 故a&#x3D;b&#x3D;c; 可变为a&#x3D;(b&#x3D;c);  即a&#x3D;2。</p>
<h1 id="考点5-Servlet"><a href="#考点5-Servlet" class="headerlink" title="考点5:Servlet"></a>考点5:Servlet</h1><p>通过HttpServletRequest. getParameter获取的参数.</p>
<ul>
<li>A 总是采用UTF-8编码</li>
<li>B 总是采用lS08859-1编码</li>
<li>C 由客户端浏览器和Web容器配置共同决定编码</li>
<li>D 由服务器所在的操作系统决定编码</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>选C<br>1、浏览器根据jsp页面开头声明的编码方式对request中参数编码；<br>2、tomcat默认解码是ISO-8859-1，<br>但是我们可以显示指定解码格式</p>
<ul>
<li>通过调用request.setCharacterEncoding(“UTF-8”)，</li>
<li>或者修改tomcat的配置文件server.xml中的编码，添加uriEncoding属性。</li>
</ul>
<h1 id="考点6-比较运算符-赋值运算符"><a href="#考点6-比较运算符-赋值运算符" class="headerlink" title="考点6:比较运算符 赋值运算符"></a>考点6:比较运算符 赋值运算符</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> y=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x=y)</span><br><span class="line">            System.out.println(<span class="string">&quot;Not equal&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Equal&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面结果输出是？</p>
<ul>
<li>A The output is “Equal”</li>
<li>B The output in “Not Equal”</li>
<li>C An error at line 5 causes compilation to fall.</li>
<li>D The program executes but does not print a message.</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>这个题考查两个知识点。<br>1、Java中，<strong>赋值是有返回值的，赋什么值，就返回什么值</strong>。比如这题，x&#x3D;y，返回y的值，所以括号里的值是1。<br>2、<strong>Java跟C的区别，C中赋值后会与0进行比较，如果大于0，就认为是true；而Java不会与0比较，而是直接把赋值后的结果放入括号</strong>。</p>
<p>这题，我忽略了第二点。</p>
<h1 id="考点8-x3D-x3D-运算符"><a href="#考点8-x3D-x3D-运算符" class="headerlink" title="考点8:&#x3D;&#x3D;运算符"></a>考点8:&#x3D;&#x3D;运算符</h1><p>下面的输出结果是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">  &#123;</span><br><span class="line">    String str=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">else</span>     &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A true</li>
<li>B false</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>&#x3D;&#x3D;判断的是对象引用地址是否相同， </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这种方式创建的字符串，和正常创建对象一样，保存在堆区。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这种方式创建的字符串，保存在字符串常量区。</p>
<h1 id="考点9-负数求余运算"><a href="#考点9-负数求余运算" class="headerlink" title="考点9:负数求余运算"></a>考点9:负数求余运算</h1><p>以下代码段执行后的输出结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> -<span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> -<span class="number">12</span>;</span><br><span class="line">        System.out.println(y % x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A -1</li>
<li>B 2</li>
<li>C 1</li>
<li>D -2</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>无论是正数还是负数，在取余运算时都有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">被除数=商×除数+余数</span><br></pre></td></tr></table></figure>
<p>，所以-12&#x3D;2×(-5)+(-2)，-12是被除数，-5是除数，2是商，余数是-2。</p>
<p><code>%</code>是取余运算最后符号和第1个值一样，<br><code>Math.floorMod()</code>是取模，最后符号和第2个值一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(-<span class="number">12</span> % -<span class="number">5</span>);</span><br><span class="line">System.out.println(-<span class="number">12</span> % <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="number">12</span> % -<span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="number">12</span> % <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">System.out.println(Math.floorMod(-<span class="number">12</span>, -<span class="number">5</span>));</span><br><span class="line">System.out.println(Math.floorMod(-<span class="number">12</span>, <span class="number">5</span>));</span><br><span class="line">System.out.println(Math.floorMod(<span class="number">12</span>, -<span class="number">5</span>));</span><br><span class="line">System.out.println(Math.floorMod(<span class="number">12</span>, <span class="number">5</span>));</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-2</span><br><span class="line">-2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">===============================</span><br><span class="line">-2</span><br><span class="line">3</span><br><span class="line">-3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><code>%</code>是取余数，结果的符号要看<strong>被除数</strong>，也就是与第一个数同符号。</p>
<h1 id="考点10-多线程安全支持的Map"><a href="#考点10-多线程安全支持的Map" class="headerlink" title="考点10:多线程安全支持的Map"></a>考点10:多线程安全支持的Map</h1><p>下面哪些具体实现类可以用于存储键，值对，并且方法调用提供了基本的多线程安全支持：(  )</p>
<ul>
<li>A java.util.ConcurrentHashMap</li>
<li>B java.util.Map</li>
<li>C java.util.TreeMap</li>
<li>D java.util.SortMap</li>
<li>E java.util.Hashtable</li>
<li>F java.util.HashMap</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: AE</details>


<h1 id="考点11"><a href="#考点11" class="headerlink" title="考点11:"></a>考点11:</h1><p>character流和byte流的区别不包括（）</p>
<ul>
<li>A 每次读入的字节数不同</li>
<li>B 前者带有缓冲，后者没有。</li>
<li>C 前者是字符读入，后者是字节读入。</li>
<li>D 二者没有区别，可以互换。</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>

<p>做错两次了，这个不包括，有点绕，题目改成 character流和byte流的说法错误的是，这样简单点</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年10月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年11月03日 java1</title>
    <url>/exam//f4d55bc2/</url>
    <content><![CDATA[<h1 id="考点1-GUI"><a href="#考点1-GUI" class="headerlink" title="考点1:GUI"></a>考点1:GUI</h1><p>在委托事件模型中，源生成事件并把它发送给一个或多个监听器，每个监听器必须向事件源注册。</p>
<ul>
<li>A T</li>
<li>B F</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h1 id="考点2-快速排序"><a href="#考点2-快速排序" class="headerlink" title="考点2:快速排序"></a>考点2:快速排序</h1><p>下面程序的输出结果是什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A2</span>&#123; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] a=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    doSomething(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a.length-<span class="number">1</span>;i++)</span><br><span class="line">    System.out.print(a[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&lt;end)&#123;</span><br><span class="line">        <span class="type">int</span> p=core(a,start,end);</span><br><span class="line">        doSomething(a,start,p-<span class="number">1</span>);</span><br><span class="line">        doSomething(a,p+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">core</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> start,<span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x=a[end];</span><br><span class="line">    <span class="type">int</span> i=start;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=start;j&lt;=end-<span class="number">1</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j]&gt;=x)&#123;</span><br><span class="line">            swap(a,i,j);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a,i,end);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> i,<span class="type">int</span> j)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp=a[i];</span><br><span class="line">    a[i]=a[j];</span><br><span class="line">    a[j]=tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>A 找到最大值</li>
<li>B 找到最小值</li>
<li>C 从大到小的排序</li>
<li>D 从小到大的排序</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>这道题目的核心思想是：根据交换的次数，决定存储的位置，交换0次，存在第一位，代表最大，交换1次，存在第二位，代表次大，以此类推…..结果可以拿一个有序的递增序列进行验证，这样比较直观，而且简单粗暴</p>
<p>快速排序，比较经常使用的方式可以参照下面两个网址。<br>介绍：<a href="http://blog.csdn.net/morewindows/article/details/6684558">http://blog.csdn.net/morewindows/article/details/6684558</a><br>演示：<a href="http://www.tyut.edu.cn/kecheng1/site01/suanfayanshi/quick_sort.asp">http://www.tyut.edu.cn/kecheng1/site01/suanfayanshi/quick_sort.asp</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//看我的注释这种快排的思路就很清晰了,这是只从一个方向遍历的快排</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span> &#125;;</span><br><span class="line">        quickSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= a.length - <span class="number">1</span>; i++)</span><br><span class="line">            System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> core(a, start, end);</span><br><span class="line">            quickSort(a, start, p - <span class="number">1</span>);</span><br><span class="line">            quickSort(a, p + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">core</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> a[end];</span><br><span class="line">        <span class="comment">//记录遍历完后最后一个数应该放在的位置,初始就是start,因为如果前面没有数比最后一个数大,那么下面遍历完后最后一个数就应该放在start的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; </span><br><span class="line">        <span class="comment">//遍历的目的是把参与排序的这轮数中比最后一个数大的数都放到最后一个数前面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> start; j &lt;= end - <span class="number">1</span>; j++) &#123; </span><br><span class="line">            <span class="keyword">if</span> (a[j] &amp;gt;= x) &#123;</span><br><span class="line">                swap(a, i, j);</span><br><span class="line">                <span class="comment">//每遇到一个比最后一个数大的数,最后一个数应该放的位置就+1</span></span><br><span class="line">                i++; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里一交换后就把最后一个数放在了正确的位置,这样左边的数都比最后一个数大,右边的数都比最后一个数小</span></span><br><span class="line">        swap(a, i, end); </span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是快速排序的另一种实现。严蔚敏的教材上是选择第一个元素作为中枢，从两侧向中间扫描逼近，最后确定枢轴应该在的位置；而上面这种解法则是算法导论上的，选择最后一个元素作为枢轴，然后单侧扫描逼近，最后确定枢轴应该在的位置（根据用变量i记录的交换的次数决定最后一个元素是第i大，然后把它放在第i个位置）。每次确定枢轴应该在的位置这一点是相同的，不同的是确定枢轴位置的过程。</p>
<h1 id="考点3-JVM参数配置"><a href="#考点3-JVM参数配置" class="headerlink" title="考点3:JVM参数配置"></a>考点3:JVM参数配置</h1><p>假如某个JAVA进程的JVM参数配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3,</span><br></pre></td></tr></table></figure>
<p>请问eden区最终分配的大小是多少？</p>
<ul>
<li>A 64M</li>
<li>B 500M</li>
<li>C 300M</li>
<li>D 100M</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>这是网易2016年在线笔试题中的一道选择题。<br>先分析一下里面各个参数的含义：<br>-Xms：1G ， 就是说初始堆大小为1G<br>-Xmx：2G ， 就是说最大堆大小为2G<br>-Xmn：500M ，就是说年轻代大小是500M（包括一个Eden和两个Survivor）<br>-XX:MaxPermSize：64M ， 就是说设置持久代最大值为64M<br>-XX:+UseConcMarkSweepGC ， 就是说使用使用CMS内存收集算法<br>-XX:SurvivorRatio&#x3D;3 ， 就是说Eden区与Survivor区的大小比值为3：1：1<br>题目中所问的Eden区的大小是指年轻代的大小，直接根据-Xmn：500M和-XX:SurvivorRatio&#x3D;3可以直接计算得出<br>500M*(3&#x2F;(3+1+1))<br>&#x3D;500M<em>（3&#x2F;5）<br>&#x3D;500M</em>0.6<br>&#x3D;300M<br>所以Eden区域的大小为300M。</p>
<p>Xms 起始内存<br>Xmx 最大内存<br>Xmn 新生代内存<br>Xss 栈大小。 就是创建线程后，分配给每一个线程的内存大小<br>-XX:NewRatio&#x3D;n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1&#x2F;4<br>-XX:SurvivorRatio&#x3D;n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor&#x3D;3：2，一个Survivor区占整个年轻代的1&#x2F;5<br>-XX:MaxPermSize&#x3D;n:设置持久代大小<br>收集器设置<br>-XX:+UseSerialGC:设置串行收集器<br>-XX:+UseParallelGC:设置并行收集器<br>-XX:+UseParalledlOldGC:设置并行年老代收集器<br>-XX:+UseConcMarkSweepGC:设置并发收集器<br>垃圾回收统计信息<br>-XX:+PrintGC<br>-XX:+PrintGCDetails<br>-XX:+PrintGCTimeStamps<br>-Xloggc:filename<br>并行收集器设置<br>-XX:ParallelGCThreads&#x3D;n:设置并行收集器收集时使用的CPU数。并行收集线程数。<br>-XX:MaxGCPauseMillis&#x3D;n:设置并行收集最大暂停时间<br>-XX:GCTimeRatio&#x3D;n:设置垃圾回收时间占程序运行时间的百分比。公式为1&#x2F;(1+n)<br>并发收集器设置<br>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。<br>-XX:ParallelGCThreads&#x3D;n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</p>
<h1 id="考点4-泛型无法提升性能"><a href="#考点4-泛型无法提升性能" class="headerlink" title="考点4:泛型无法提升性能"></a>考点4:泛型无法提升性能</h1><p>在开发中使用泛型取代非泛型的数据类型（比如用ArrayList<String>取代ArrayList），程序的运行时性能会变得更好。（） </p>
<ul>
<li>A 正确</li>
<li>B 错误</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h2 id="使用泛型的好处"><a href="#使用泛型的好处" class="headerlink" title="使用泛型的好处"></a>使用泛型的好处</h2><p><strong>1，类型安全</strong>。 泛型的主要目标是提高 Java 程序的类型安全。通过知道使用泛型定义的变量的类型限制，编译器可以在一个高得多的程度上验证类型假设。没有泛型，这些假设就只存在于程序员的头脑中（或者如果幸运的话，还存在于代码注释中）。</p>
<p><strong>2，消除强制类型转换</strong>。 泛型的一个附带好处是，消除源代码中的许多强制类型转换。这使得代码更加可读，并且减少了出错机会。</p>
<p><strong>3，潜在的性能收益</strong>。 泛型为较大的优化带来可能。在泛型的初始实现中，编译器将强制类型转换（没有泛型的话，程序员会指定这些强制类型转换）插入生成的字节码中。但是更多类型信息可用于编译器这一事实，为未来版本的 JVM 的优化带来可能。由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改。所有工作都在编译器中完成，编译器生成类似于没有泛型（和强制类型转换）时所写的代码，只是更能确保类型安全而已。</p>
<p><strong>所以泛型只是提高了数据传输安全性，并没有改变程序运行的性能</strong></p>
<h1 id="考点5-正则表达式"><a href="#考点5-正则表达式" class="headerlink" title="考点5:正则表达式"></a>考点5:正则表达式</h1><p>以下代码将打印出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123; </span><br><span class="line">    <span class="type">String</span> <span class="variable">classFile</span> <span class="operator">=</span> <span class="string">&quot;com.jd.&quot;</span>.replaceAll(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>) + <span class="string">&quot;MyClass.class&quot;</span>;</span><br><span class="line">    System.out.println(classFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A <code>com. jd</code></li>
<li>B <code>com/jd/MyClass.class</code></li>
<li>C <code>///////MyClass.class</code></li>
<li>D <code>com.jd.MyClass</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>C。由于replaceAll方法的第一个参数是一个正则表达式，而”<code>.</code>“在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成”<code>/</code>“。如果想替换的只是”<code>.</code>“，那么久要写成”<code>\\.</code>“。</p>
<h1 id="考点6-自动类型提升"><a href="#考点6-自动类型提升" class="headerlink" title="考点6:自动类型提升"></a>考点6:自动类型提升</h1><p>代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> b1=<span class="number">1</span>,b2=<span class="number">2</span>,b3,b6;  </span><br><span class="line"><span class="keyword">final</span> <span class="type">byte</span> b4=<span class="number">4</span>,b5=<span class="number">6</span>;  </span><br><span class="line">b6=b4+b5;  </span><br><span class="line">b3=(b1+b2);  </span><br><span class="line">System.out.println(b3+b6);</span><br></pre></td></tr></table></figure>
<p>关于上面代码片段叙述正确的是（）</p>
<ul>
<li>A 输出结果：13</li>
<li>B 语句：b6&#x3D;b4+b5编译出错</li>
<li>C 语句：b3&#x3D;b1+b2编译出错</li>
<li>D 运行期抛出异常</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h2 id="byte-short-char计算时自动提升为int"><a href="#byte-short-char计算时自动提升为int" class="headerlink" title="byte,short,char计算时自动提升为int"></a>byte,short,char计算时自动提升为int</h2><p>被final修饰的变量是常量，这里的<code>b6=b4+b5</code>可以看成是<code>b6=10</code>；在编译时就已经变为<code>b6=10</code>了</p>
<p>而b1和b2是byte类型，java中进行计算时候将他们提升为int类型，再进行计算，b1+b2计算后已经是int类型，赋值给b3，b3是byte类型，类型不匹配，编译不会通过，需要进行强制转换。</p>
<p><strong>Java中的byte，short，char进行计算时都会提升为int类型。</strong><br><img data-src="https://uploadfiles.nowcoder.com/images/20190110/5436464_1547131030377_7780F2D687FD9BBBD1E6F619B8CF6AB5" alt="这里有一张图片"></p>
<h1 id="考点7-排序算法对比"><a href="#考点7-排序算法对比" class="headerlink" title="考点7:排序算法对比"></a>考点7:排序算法对比</h1><p>在各自最优条件下,对N个数进行排序,哪个算法复杂度最低的是? （）</p>
<ul>
<li>A 插入排序</li>
<li>B 快速排序</li>
<li>C 堆排序</li>
<li>D 归并排序</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p><img data-src="https://uploadfiles.nowcoder.com/images/20190723/7030223_1563849688450_24E76E1D39B3817C690AA77B782FB765" alt="img"></p>
<p><img data-src="https://uploadfiles.nowcoder.com/images/20190727/5227440_1564208997208_C0C78CE31C2575E39A0EE7AE31E20FB8" alt="img"></p>
<h1 id="考点8-反射机制能实现的功能"><a href="#考点8-反射机制能实现的功能" class="headerlink" title="考点8:反射机制能实现的功能"></a>考点8:反射机制能实现的功能</h1><p>JAVA反射机制主要提供了以下哪些功能？</p>
<ul>
<li>A 在运行时判断一个对象所属的类</li>
<li>B 在运行时构造一个类的对象</li>
<li>C 在运行时判断一个类所具有的成员变量和方法</li>
<li>D 在运行时调用一个对象的方法</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>

<h1 id="考点9-会话跟踪实现技术"><a href="#考点9-会话跟踪实现技术" class="headerlink" title="考点9:会话跟踪实现技术"></a>考点9:会话跟踪实现技术</h1><p>下面哪项技术可以用在WEB开发中实现会话跟踪实现？</p>
<ul>
<li>A session</li>
<li>B Cookie</li>
<li>C 地址重写</li>
<li>D 隐藏域</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>

<h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10:"></a>考点10:</h1><p>character流和byte流的区别不包括（）</p>
<ul>
<li>A 每次读入的字节数不同</li>
<li>B 前者带有缓冲，后者没有。</li>
<li>C 前者是字符读入，后者是字节读入。</li>
<li>D 二者没有区别，可以互换。</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年11月09日 java1</title>
    <url>/exam//da4a88da/</url>
    <content><![CDATA[<h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1:"></a>考点1:</h1><p>有这样一段程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>&#123; </span><br><span class="line">        List list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>(); </span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Set set=<span class="keyword">new</span> <span class="title class_">HashSet</span>(); </span><br><span class="line">        set.add(<span class="string">&quot;a&quot;</span>); </span><br><span class="line">        set.add(<span class="string">&quot;b&quot;</span>); </span><br><span class="line">        set.add(<span class="string">&quot;a&quot;</span>); </span><br><span class="line">        System.out.println(list.size()+<span class="string">&quot;,&quot;</span>+set.size()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请问运行主要的程序会打印出的是什么（）</p>
<ul>
<li>A 2,2</li>
<li>B 2,3</li>
<li>C 3,2</li>
<li>D 3,3</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>list有序可重复，set无序不可重复</p>
<h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2:"></a>考点2:</h1><p>根据下面的程序代码，哪些选项的值返回true？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> &#123;  </span><br><span class="line">    <span class="type">long</span> width;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Square</span><span class="params">(<span class="type">long</span> l)</span> &#123;   </span><br><span class="line">        width = l;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String arg[])</span> &#123;   </span><br><span class="line">        Square a, b, c;   </span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">Square</span>(<span class="number">42L</span>);   </span><br><span class="line">        b = <span class="keyword">new</span> <span class="title class_">Square</span>(<span class="number">42L</span>);   </span><br><span class="line">        c = b;   </span><br><span class="line">        <span class="type">long</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">42L</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A a &#x3D;&#x3D; b</li>
<li>B s &#x3D;&#x3D; a</li>
<li>C b &#x3D;&#x3D; c</li>
<li>D a.equals(s)</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3:"></a>考点3:</h1><p>下面代码运行结果是（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;    </span><br><span class="line">         <span class="keyword">try</span> &#123;    </span><br><span class="line">             <span class="keyword">return</span> a+b;        </span><br><span class="line">         &#125; </span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;    </span><br><span class="line">            System.out.println(<span class="string">&quot;catch语句块&quot;</span>);    </span><br><span class="line">         &#125;    </span><br><span class="line">         <span class="keyword">finally</span>&#123;    </span><br><span class="line">             System.out.println(<span class="string">&quot;finally语句块&quot;</span>);    </span><br><span class="line">         &#125;    </span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">    &#125; </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String argv[])</span>&#123; </span><br><span class="line">         <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Test</span>(); </span><br><span class="line">         System.out.println(<span class="string">&quot;和是：&quot;</span>+test.add(<span class="number">9</span>, <span class="number">34</span>)); </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">catch语句块 </span><br><span class="line">和是：43</span><br></pre></td></tr></table></figure></li>
<li>B 编译异常</li>
<li>C <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">finally语句块 </span><br><span class="line">和是：43</span><br></pre></td></tr></table></figure></li>
<li>D <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">和是：43</span><br><span class="line">finally语句块</span><br></pre></td></tr></table></figure></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4:"></a>考点4:</h1><p>要导入<code>java/awt/event</code>下面的所有类，叙述正确的是？()</p>
<ul>
<li>A <code>import java.awt.*</code>和<code>import java.awt.event.*</code>都可以</li>
<li>B 只能是<code>import java.awt.*</code></li>
<li>C 只能是<code>import java.awt.event.*</code></li>
<li>D <code>import java.awt.*</code>和<code>import java.awt.event.*</code>都不可以</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>导包只可以导到当前层，不可以再导入包里面的包中的类</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5:"></a>考点5:</h1><p>以下代码的输出结果是？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">B</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">B</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A 静态块 构造块 构造块 构造块</li>
<li>B 构造块 静态块 构造块 构造块</li>
<li>C 构造块 构造块 静态块 构造块</li>
<li>D 构造块 构造块 构造块 静态块</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>静态成员最先初始化，静态成员包括，静态成员变量，和静态成员方法。<br>如果有多个静态成员，按其从上到下定义的顺序，进行初始化。</p>
<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6:"></a>考点6:</h1><p>String与StringBuffer的区别是？</p>
<ul>
<li>A String是不可变的对象，StringBuffer是可以再编辑的</li>
<li>B 字符串是常量，StringBuffer是变量</li>
<li>C String是可变的对象，StringBuffer是不可以再编辑的</li>
<li>D 以上说法都不正确</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: AB</details>

<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7:"></a>考点7:</h1><p>final、finally、finalize三个关键字的区别是（）</p>
<ul>
<li>A final是修饰符（关键字）可以修饰类、方法、变量</li>
<li>B finally在异常处理的时候使用，提供finally块来执行任何清除操作</li>
<li>C finalize是方法名，在垃圾收入集器将对象从内存中清除出去之前做必要的清理工作</li>
<li>D finally和finalize一样都是用于异常处理的方法</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8:"></a>考点8:</h1><p>对 Map 的用法，正确的有：</p>
<ul>
<li>A <code>new java.util.Map().put(&quot;key&quot; , &quot;value&quot;);</code></li>
<li>B <code>new java.util.SortedMap().put(&quot;key&quot; , &quot;value&quot;);</code></li>
<li>C <code>new java.util.HashMap().put(null , null );</code></li>
<li>D <code>new java.util.TreeMap().put(0 , null );</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: CD</details>

<h2 id="Map和SortedMap是接口，不能直接new"><a href="#Map和SortedMap是接口，不能直接new" class="headerlink" title="Map和SortedMap是接口，不能直接new"></a>Map和SortedMap是接口，不能直接new</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K,​V&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SortedMap</span>&lt;K,​V&gt; <span class="keyword">extends</span> <span class="title class_">Map</span>&lt;K,​V&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,​V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,​V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,​V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap</span>&lt;K,​V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,​V&gt; <span class="keyword">implements</span> <span class="title class_">NavigableMap</span>&lt;K,​V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>

<h1 id="考点9-可以作为switch条件表达式的类型"><a href="#考点9-可以作为switch条件表达式的类型" class="headerlink" title="考点9:可以作为switch条件表达式的类型"></a>考点9:可以作为switch条件表达式的类型</h1><p>下面的switch语句中，x可以是哪些类型的数据：()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A long</li>
<li>B char</li>
<li>C float</li>
<li>D byte</li>
<li>E double</li>
<li>F Object</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: BD</details>

<ul>
<li>jdk1.7之前byte,short ,int ,char</li>
<li>jdk1.7之后加入String</li>
<li>java8，switch支持10种类型:<ul>
<li>基本类型：byte char short int</li>
<li>包装类 ：Byte,Short,Character,Integer String enum</li>
</ul>
</li>
</ul>
<p>实际只支持int类型 Java实际只能支持int类型的switch语句，那其他的类型时如何支持的</p>
<ul>
<li>a、基本类型byte char short <ul>
<li>原因：这些基本数字类型可自动向上转为int, 实际还是用的int。</li>
</ul>
</li>
<li>b、基本类型包装类Byte,Short,Character,Integer <ul>
<li>原因：java的自动拆箱机制 可看这些对象自动转为基本类型</li>
</ul>
</li>
<li>c、String 类型 <ul>
<li>原因：实际switch比较的string.hashCode值，它是一个int类型</li>
</ul>
</li>
<li>d、enum类型 <ul>
<li>原因 ：实际比较的是enum的ordinal值（表示枚举值的顺序），它也是一个int类型 所以也可以说 switch语句只支持int类型</li>
</ul>
</li>
</ul>
<h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10:"></a>考点10:</h1><p>Java是一门支持反射的语言,基于反射为Java提供了丰富的动态性支持，下面关于Java反射的描述，哪些是错误的：(    )</p>
<ul>
<li>A Java反射主要涉及的类如Class, Method, Filed,等，他们都在java.lang.reflet包下</li>
<li>B 通过反射可以动态的实现一个接口，形成一个新的类，并可以用这个类创建对象，调用对象方法</li>
<li>C 通过反射，可以突破Java语言提供的对象成员、类成员的保护机制，访问一般方式不能访问的成员</li>
<li>D Java反射机制提供了字节码修改的技术，可以动态的修剪一个类</li>
<li>E Java的反射机制会给内存带来额外的开销。例如对永生堆的要求比不通过反射要求的更多</li>
<li>F Java反射机制一般会带来效率问题，效率问题主要发生在查找类的方法和字段对象，因此通过缓存需要反射类的字段和方法就能达到与之间调用类的方法和访问类的字段一样的效率</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ADF</details>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.Class&lt;T&gt;</span><br><span class="line">java.lang.reflect.Method</span><br><span class="line">java.lang.reflect.Field</span><br></pre></td></tr></table></figure>

<p>A Class类在java.lang包<br>B 动态代理技术可以动态创建一个代理对象，反射不行<br>C 反射访问私有成员时，Field调用setAccessible可解除访问符限制<br>D CGLIB实现了字节码修改，反射不行<br>E 反射会动态创建额外的对象，比如每个成员方法只有一个Method对象作为root，他不胡直接暴露给用户。调用时会返回一个Method的包装类<br>F 反射带来的效率问题主要是动态解析类，JVM没法对反射代码优化。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年11月10日 java1</title>
    <url>/exam//ec0d698e/</url>
    <content><![CDATA[<h1 id="考点1-JVM内存镜像命令"><a href="#考点1-JVM内存镜像命令" class="headerlink" title="考点1:JVM内存镜像命令"></a>考点1:JVM内存镜像命令</h1><p>运用下列哪个命令能够获取JVM的内存映像</p>
<ul>
<li>A jinfo</li>
<li>B jmap</li>
<li>C jhat</li>
<li>D jstat</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>1、jps：查看本机java进程信息。<br>2、jstack：打印线程的<strong>栈</strong>信息，制作线程dump文件。<br>3、jmap：打印内存映射，制作<strong>堆</strong>dump文件<br>4、jstat：性能监控工具<br>5、jhat：内存分析工具<br>6、jconsole：简易的可视化控制台<br>7、jvisualvm：功能强大的控制台</p>
<p><a href="/JavaReadingNotes/37b3d733/">4.2.1 jps：虚拟机进程状况工具</a><br><a href="/JavaReadingNotes/3c1d0208/">4.2.2 jstat：虚拟机统计信息监视工具</a><br><a href="/JavaReadingNotes/e129420d/">4.2.3 jinfo：Java配置信息工具</a><br><a href="/JavaReadingNotes/49ed8d6e/">4.2.4 jmap：Java内存映像工具</a><br><a href="/JavaReadingNotes/7c6aacde/">4.2.5 jhat：虚拟机堆转储快照分析工具</a><br><a href="/JavaReadingNotes/2ca58d4c/">4.2.6 jstack：Java堆栈跟踪工具</a></p>
<h1 id="考点2-自增运算符-自加运算符"><a href="#考点2-自增运算符-自加运算符" class="headerlink" title="考点2:自增运算符 自加运算符"></a>考点2:自增运算符 自加运算符</h1><p>有变量int i &#x3D; 0; int a &#x3D; i++; int b &#x3D; ++a; int c &#x3D; a+b; int d &#x3D; (a &#x3D;&#x3D; 1)?b:c; 请问a和d的值分别是多少？(    )。</p>
<ul>
<li>A 2,4</li>
<li>B 1, 4</li>
<li>C 1, 2</li>
<li>D 1,1</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p><a href="/JavaReadingNotes/91617ce0/#%E8%87%AA%E5%8A%A0%E8%BF%90%E7%AE%97">自加运算</a></p>
<h1 id="考点3-Spring事务传播特性"><a href="#考点3-Spring事务传播特性" class="headerlink" title="考点3:Spring事务传播特性"></a>考点3:Spring事务传播特性</h1><p>下面有关SPRING的事务传播特性，说法错误的是？</p>
<ul>
<li>A PROPAGATION_SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行</li>
<li>B PROPAGATION_REQUIRED：支持当前事务，如果当前没有事务，就抛出异常</li>
<li>C PROPAGATION_REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起</li>
<li>D PROPAGATION_NESTED：支持当前事务，新增Savepoint点，与当前事务同步提交或回滚</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>Spring的API设计很不错，基本上根据英文翻译就能知道作用:<br>Required:必须的。说明必须要有事物，没有就新建事物。<br>supports:支持。说明仅仅是支持事务，没有事务就非事务方式执行。<br>mandatory:强制的。说明一定要有事务，没有事务就抛出异常。<br>required_new:必须新建事物。如果当前存在事物就挂起。<br>not_supported:不支持事物，如果存在事物就挂起。<br>never:绝不有事务。如果存在事物就抛出异常</p>
<p>事务属性的种类：传播行为、隔离级别、只读和事务超时</p>
<p>a) 传播行为定义了被调用方法的事务边界。</p>
<table>
<thead>
<tr>
<th align="left">传播行为</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PROPERGATION_MANDATORY</td>
<td align="left">表示方法必须运行在一个事务中，如果当前事务不存在，就抛出异常</td>
</tr>
<tr>
<td align="left">PROPAGATION_NESTED</td>
<td align="left">表示如果当前事务存在，则方法应该运行在一个嵌套事务中。否则，它看起来和PROPAGATION_REQUIRED看起来没什么俩样</td>
</tr>
<tr>
<td align="left">PROPAGATION_NEVER</td>
<td align="left">表示方法不能运行在一个事务中，否则抛出异常</td>
</tr>
<tr>
<td align="left">PROPAGATION_NOT_SUPPORTED</td>
<td align="left">表示方法不能运行在一个事务中，如果当前存在一个事务，则该方法将被挂起</td>
</tr>
<tr>
<td align="left">PROPAGATION_REQUIRED</td>
<td align="left">表示当前方法必须运行在一个事务中，如果当前存在一个事务，那么该方法运行在这个事务中，否则，将创建一个新的事务</td>
</tr>
<tr>
<td align="left">PROPAGATION_REQUIRES_NEW</td>
<td align="left">表示当前方法必须运行在自己的事务中，如果当前存在一个事务，那么这个事务将在该方法运行期间被挂起</td>
</tr>
<tr>
<td align="left">PROPAGATION_SUPPORTS</td>
<td align="left">表示当前方法不需要运行在一个是事务中，但如果有一个事务已经存在，该方法也可以运行在这个事务中</td>
</tr>
</tbody></table>
<p>b) 隔离级别</p>
<p>在操作数据时可能带来 3 个副作用，分别是脏读、不可重复读、幻读。为了避免这 3 中副作用的发生，在标准的 SQL 语句中定义了 4 种隔离级别，分别是未提交读、已提交读、可重复读、可序列化。而在 spring 事务中提供了 5 种隔离级别来对应在 SQL 中定义的 4 种隔离级别，如下：</p>
<table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ISOLATION_DEFAULT</td>
<td align="left">使用后端数据库默认的隔离级别</td>
</tr>
<tr>
<td align="left">ISOLATION_READ_UNCOMMITTED</td>
<td align="left">允许读取未提交的数据（对应未提交读），可能导致脏读、不可重复读、幻读</td>
</tr>
<tr>
<td align="left">ISOLATION_READ_COMMITTED</td>
<td align="left">允许在一个事务中读取另一个已经提交的事务中的数据（对应已提交读）。可以避免脏读，但是无法避免不可重复读和幻读</td>
</tr>
<tr>
<td align="left">ISOLATION_REPEATABLE_READ</td>
<td align="left">一个事务不可能更新由另一个事务修改但尚未提交（回滚）的数据（对应可重复读）。可以避免脏读和不可重复读，但无法避免幻读</td>
</tr>
<tr>
<td align="left">ISOLATION_SERIALIZABLE</td>
<td align="left">这种隔离级别是所有的事务都在一个执行队列中，依次顺序执行，而不是并行（对应可序列化）。可以避免脏读、不可重复读、幻读。但是这种隔离级别效率很低，因此，除非必须，否则不建议使用。</td>
</tr>
</tbody></table>
<p>c) 只读</p>
<p>如果在一个事务中所有关于数据库的操作都是只读的，也就是说，这些操作只读取数据库中的数据，而并不更新数据，那么应将事务设为只读模式（ READ_ONLY_MARKER ） , 这样更有利于数据库进行优化 。</p>
<p>因为只读的优化措施是事务启动后由数据库实施的，因此，只有将那些具有可能启动新事务的传播行为 (PROPAGATION_NESTED 、 PROPAGATION_REQUIRED 、 PROPAGATION_REQUIRED_NEW) 的方法的事务标记成只读才有意义。</p>
<p>如果使用 Hibernate 作为持久化机制，那么将事务标记为只读后，会将 Hibernate 的 flush 模式设置为 FULSH_NEVER, 以告诉 Hibernate 避免和数据库之间进行不必要的同步，并将所有更新延迟到事务结束。</p>
<p>d) 事务超时</p>
<p>如果一个事务长时间运行，这时为了尽量避免浪费系统资源，应为这个事务设置一个有效时间，使其等待数秒后自动回滚。与设</p>
<p>置“只读”属性一样，事务有效属性也需要给那些具有可能启动新事物的传播行为的方法的事务标记成只读才有意义。</p>
<h1 id="考点4-异常-英语"><a href="#考点4-异常-英语" class="headerlink" title="考点4:异常 英语"></a>考点4:异常 英语</h1><p>下面哪个不对？</p>
<ul>
<li>A RuntimeException is the superclass of those exceptions that can be thrown during the normal operation of the Java Virtual Machine.</li>
<li>B A method is not required to declare in its throws clause any subclasses of RuntimeExeption that might be thrown during the execution of the method but not caught</li>
<li>C An RuntimeException is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch.</li>
<li>D NullPointerException is one kind of RuntimeException</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>a.虚拟机会自己抛出RuntimeException异常<br>b.RuntimeException异常不需要声明抛出或者被捕获<br>c.subclass:子类， RuntimeException不是Throable子类，是Exception的子类<br>意思：RuntimeException 是Throable并表明他是一个严重的问题，应该合理的被tracatch捕获<br>d:空指针异常（NullPointException）是 RuntimeException</p>
<p><strong>C</strong>选项也是把Error的定义换成了RuntimeException,但这里的”indicates serious problems”不应该用在RuntimeException上,<strong>Error才表示严重的错误</strong>,RuntimeException并不是.</p>
<h1 id="考点5-Servlet-ServeltConfig"><a href="#考点5-Servlet-ServeltConfig" class="headerlink" title="考点5:Servlet ServeltConfig"></a>考点5:Servlet ServeltConfig</h1><p>ServletConfig接口默认是哪里实现的？</p>
<ul>
<li>A Servlet</li>
<li>B GenericServlet</li>
<li>C HttpServlet</li>
<li>D 用户自定义servlet</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ServletConfig</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GenericServlet</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>, ServletConfig, Serializable</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HttpServlet</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span></span><br></pre></td></tr></table></figure>
<p><a href="https://docs.oracle.com/javaee/7/api/javax/servlet/GenericServlet.html">https://docs.oracle.com/javaee/7/api/javax/servlet/GenericServlet.html</a></p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/11/20211111121609.png" alt="image-20211111121601854"></p>
<img class="kroki" data-src='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyNzhweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjM4M3B4O2hlaWdodDoyNzhweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAzODMgMjc4IiB3aWR0aD0iMzgzcHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48IS0tTUQ1PVtjYzNkZTBhMTc2ZGFhM2M0ZWM4NzVkZWFmZGY1ZGRkMV0KY2xhc3MgU2VyaWFsaXphYmxlLS0+PGcgaWQ9ImVsZW1fU2VyaWFsaXphYmxlIj48cmVjdCBjb2RlTGluZT0iMSIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9IlNlcmlhbGl6YWJsZSIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iMTA1IiB4PSI3IiB5PSI3Ii8+PGVsbGlwc2UgY3g9IjIyIiBjeT0iMjMiIGZpbGw9IiNCNEE3RTUiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMjQuNjcxOSwyNi4yOTY5IFEyNS4yMTg4LDI2LjI5NjkgMjUuNSwyNi40ODQ0IFEyNS43ODEzLDI2LjY1NjMgMjUuNzgxMywyNy4xNTYzIFEyNS43ODEzLDI4IDI0LjY3MTksMjggTDE5LjUzMTMsMjggUTE4LjQwNjMsMjggMTguNDA2MywyNy4xNTYzIFExOC40MDYzLDI2LjY1NjMgMTguNjg3NSwyNi40ODQ0IFExOC45ODQ0LDI2LjI5NjkgMTkuNTMxMywyNi4yOTY5IEwyMS4yNSwyNi4yOTY5IEwyMS4yNSwxOS43ODEzIEwxOS41MzEzLDE5Ljc4MTMgUTE4LjQwNjMsMTkuNzgxMyAxOC40MDYzLDE4LjkzNzUgUTE4LjQwNjMsMTguNDUzMSAxOC42ODc1LDE4LjI4MTMgUTE4Ljk4NDQsMTguMDkzOCAxOS41MzEzLDE4LjA5MzggTDI0LjY3MTksMTguMDkzOCBRMjUuMjE4OCwxOC4wOTM4IDI1LjUsMTguMjgxMyBRMjUuNzgxMywxOC40NTMxIDI1Ljc4MTMsMTguOTM3NSBRMjUuNzgxMywxOS43ODEzIDI0LjY3MTksMTkuNzgxMyBMMjIuOTUzMSwxOS43ODEzIEwyMi45NTMxLDI2LjI5NjkgTDI0LjY3MTksMjYuMjk2OSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBmb250LXN0eWxlPSJpdGFsaWMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNzMiIHg9IjM2IiB5PSIyOC42Ij5TZXJpYWxpemFibGU8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOCIgeDI9IjExMSIgeTE9IjM5IiB5Mj0iMzkiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iMTExIiB5MT0iNDciIHkyPSI0NyIvPjwvZz48IS0tTUQ1PVs2OWVlOGRlNmJmNzk1NjcyZTQ0Y2IyNWI3OGI5MWQ0Ml0KY2xhc3MgU2VydmxldC0tPjxnIGlkPSJlbGVtX1NlcnZsZXQiPjxyZWN0IGNvZGVMaW5lPSIyIiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iU2VydmxldCIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iNzYiIHg9IjE0Ny41IiB5PSI3Ii8+PGVsbGlwc2UgY3g9IjE2Mi41IiBjeT0iMjMiIGZpbGw9IiNCNEE3RTUiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMTY1LjE3MTksMjYuMjk2OSBRMTY1LjcxODgsMjYuMjk2OSAxNjYsMjYuNDg0NCBRMTY2LjI4MTMsMjYuNjU2MyAxNjYuMjgxMywyNy4xNTYzIFExNjYuMjgxMywyOCAxNjUuMTcxOSwyOCBMMTYwLjAzMTMsMjggUTE1OC45MDYzLDI4IDE1OC45MDYzLDI3LjE1NjMgUTE1OC45MDYzLDI2LjY1NjMgMTU5LjE4NzUsMjYuNDg0NCBRMTU5LjQ4NDQsMjYuMjk2OSAxNjAuMDMxMywyNi4yOTY5IEwxNjEuNzUsMjYuMjk2OSBMMTYxLjc1LDE5Ljc4MTMgTDE2MC4wMzEzLDE5Ljc4MTMgUTE1OC45MDYzLDE5Ljc4MTMgMTU4LjkwNjMsMTguOTM3NSBRMTU4LjkwNjMsMTguNDUzMSAxNTkuMTg3NSwxOC4yODEzIFExNTkuNDg0NCwxOC4wOTM4IDE2MC4wMzEzLDE4LjA5MzggTDE2NS4xNzE5LDE4LjA5MzggUTE2NS43MTg4LDE4LjA5MzggMTY2LDE4LjI4MTMgUTE2Ni4yODEzLDE4LjQ1MzEgMTY2LjI4MTMsMTguOTM3NSBRMTY2LjI4MTMsMTkuNzgxMyAxNjUuMTcxOSwxOS43ODEzIEwxNjMuNDUzMSwxOS43ODEzIEwxNjMuNDUzMSwyNi4yOTY5IEwxNjUuMTcxOSwyNi4yOTY5IFogIiBmaWxsPSIjMDAwMDAwIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGZvbnQtc3R5bGU9Iml0YWxpYyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI0NCIgeD0iMTc2LjUiIHk9IjI4LjYiPlNlcnZsZXQ8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTQ4LjUiIHgyPSIyMjIuNSIgeTE9IjM5IiB5Mj0iMzkiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSIxNDguNSIgeDI9IjIyMi41IiB5MT0iNDciIHkyPSI0NyIvPjwvZz48IS0tTUQ1PVs2YjkxZDNjYzdlODgxYmJmYjliM2EzNGM0MDkxZWEwMl0KY2xhc3MgU2VydmxldENvbmZpZy0tPjxnIGlkPSJlbGVtX1NlcnZsZXRDb25maWciPjxyZWN0IGNvZGVMaW5lPSIzIiBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjQ4IiBpZD0iU2VydmxldENvbmZpZyIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iMTE3IiB4PSIyNTkiIHk9IjciLz48ZWxsaXBzZSBjeD0iMjc0IiBjeT0iMjMiIGZpbGw9IiNCNEE3RTUiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMjc2LjY3MTksMjYuMjk2OSBRMjc3LjIxODgsMjYuMjk2OSAyNzcuNSwyNi40ODQ0IFEyNzcuNzgxMywyNi42NTYzIDI3Ny43ODEzLDI3LjE1NjMgUTI3Ny43ODEzLDI4IDI3Ni42NzE5LDI4IEwyNzEuNTMxMywyOCBRMjcwLjQwNjMsMjggMjcwLjQwNjMsMjcuMTU2MyBRMjcwLjQwNjMsMjYuNjU2MyAyNzAuNjg3NSwyNi40ODQ0IFEyNzAuOTg0NCwyNi4yOTY5IDI3MS41MzEzLDI2LjI5NjkgTDI3My4yNSwyNi4yOTY5IEwyNzMuMjUsMTkuNzgxMyBMMjcxLjUzMTMsMTkuNzgxMyBRMjcwLjQwNjMsMTkuNzgxMyAyNzAuNDA2MywxOC45Mzc1IFEyNzAuNDA2MywxOC40NTMxIDI3MC42ODc1LDE4LjI4MTMgUTI3MC45ODQ0LDE4LjA5MzggMjcxLjUzMTMsMTguMDkzOCBMMjc2LjY3MTksMTguMDkzOCBRMjc3LjIxODgsMTguMDkzOCAyNzcuNSwxOC4yODEzIFEyNzcuNzgxMywxOC40NTMxIDI3Ny43ODEzLDE4LjkzNzUgUTI3Ny43ODEzLDE5Ljc4MTMgMjc2LjY3MTksMTkuNzgxMyBMMjc0Ljk1MzEsMTkuNzgxMyBMMjc0Ljk1MzEsMjYuMjk2OSBMMjc2LjY3MTksMjYuMjk2OSBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBmb250LXN0eWxlPSJpdGFsaWMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODUiIHg9IjI4OCIgeT0iMjguNiI+U2VydmxldENvbmZpZzwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSIyNjAiIHgyPSIzNzUiIHkxPSIzOSIgeTI9IjM5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMjYwIiB4Mj0iMzc1IiB5MT0iNDciIHkyPSI0NyIvPjwvZz48IS0tTUQ1PVs0MTljOWUwOWRkNjJkOGQ1ZmYxYTBmZmY0NmUyOGM5ZF0KY2xhc3MgR2VuZXJpY1NlcnZsZXQtLT48ZyBpZD0iZWxlbV9HZW5lcmljU2VydmxldCI+PHJlY3QgY29kZUxpbmU9IjQiIGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iNDgiIGlkPSJHZW5lcmljU2VydmxldCIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iMTI2IiB4PSIxMjIuNSIgeT0iMTE1Ii8+PGVsbGlwc2UgY3g9IjEzNy41IiBjeT0iMTMxIiBmaWxsPSIjQTlEQ0RGIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTEzOC40NTMxLDEzNC42NTYzIFExMzguNDUzMSwxMzQuMTU2MyAxMzguNzM0NCwxMzMuOTg0NCBRMTM5LjAzMTMsMTMzLjc5NjkgMTM5LjU3ODEsMTMzLjc5NjkgTDEzOS45Njg4LDEzMy43OTY5IEwxMzkuNTc4MSwxMzIuODEyNSBMMTM1LjUzMTMsMTMyLjgxMjUgTDEzNS4xNDA2LDEzMy43OTY5IEwxMzUuNTMxMywxMzMuNzk2OSBRMTM2LjY0MDYsMTMzLjc5NjkgMTM2LjY0MDYsMTM0LjY1NjMgUTEzNi42NDA2LDEzNS41IDEzNS41MzEzLDEzNS41IEwxMzMuMjY1NiwxMzUuNSBRMTMyLjE0MDYsMTM1LjUgMTMyLjE0MDYsMTM0LjY1NjMgUTEzMi4xNDA2LDEzNC4xNDA2IDEzMi40Mzc1LDEzMy45Njg4IFExMzIuNzM0NCwxMzMuNzk2OSAxMzMuMjgxMywxMzMuNzk2OSBMMTM1LjkyMTksMTI3LjI4MTMgTDEzNC44NDM4LDEyNy4yODEzIFExMzMuNzAzMSwxMjcuMjgxMyAxMzMuNzAzMSwxMjYuNDM3NSBRMTMzLjcwMzEsMTI1LjkyMTkgMTM0LDEyNS43NjU2IFExMzQuMjk2OSwxMjUuNTkzOCAxMzQuODQzOCwxMjUuNTkzOCBMMTM4LjUxNTYsMTI1LjU5MzggTDE0MS45MDYzLDEzMy43OTY5IFExNDMuMDYyNSwxMzMuNzk2OSAxNDMuMDYyNSwxMzQuNjU2MyBRMTQzLjA2MjUsMTM1LjUgMTQxLjkzNzUsMTM1LjUgTDEzOS41NzgxLDEzNS41IFExMzguNDUzMSwxMzUuNSAxMzguNDUzMSwxMzQuNjU2MyBaIE0xMzguODc1LDEzMS4xMDk0IEwxMzcuNTQ2OSwxMjcuODQzOCBMMTM2LjIwMzEsMTMxLjEwOTQgTDEzOC44NzUsMTMxLjEwOTQgWiAiIGZpbGw9IiMwMDAwMDAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZm9udC1zdHlsZT0iaXRhbGljIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijk0IiB4PSIxNTEuNSIgeT0iMTM2LjYiPkdlbmVyaWNTZXJ2bGV0PC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjEyMy41IiB4Mj0iMjQ3LjUiIHkxPSIxNDciIHkyPSIxNDciLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSIxMjMuNSIgeDI9IjI0Ny41IiB5MT0iMTU1IiB5Mj0iMTU1Ii8+PC9nPjwhLS1NRDU9Wzk3NTc5YWY4NmE3NDQwYWY1ZTc0YzYwNDczNDljNDhjXQpjbGFzcyBIdHRwU2VydmxldC0tPjxnIGlkPSJlbGVtX0h0dHBTZXJ2bGV0Ij48cmVjdCBjb2RlTGluZT0iNSIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI0OCIgaWQ9Ikh0dHBTZXJ2bGV0IiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSIxMDIiIHg9IjEzNC41IiB5PSIyMjMiLz48ZWxsaXBzZSBjeD0iMTQ5LjUiIGN5PSIyMzkiIGZpbGw9IiNBOURDREYiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMTUwLjQ1MzEsMjQyLjY1NjMgUTE1MC40NTMxLDI0Mi4xNTYzIDE1MC43MzQ0LDI0MS45ODQ0IFExNTEuMDMxMywyNDEuNzk2OSAxNTEuNTc4MSwyNDEuNzk2OSBMMTUxLjk2ODgsMjQxLjc5NjkgTDE1MS41NzgxLDI0MC44MTI1IEwxNDcuNTMxMywyNDAuODEyNSBMMTQ3LjE0MDYsMjQxLjc5NjkgTDE0Ny41MzEzLDI0MS43OTY5IFExNDguNjQwNiwyNDEuNzk2OSAxNDguNjQwNiwyNDIuNjU2MyBRMTQ4LjY0MDYsMjQzLjUgMTQ3LjUzMTMsMjQzLjUgTDE0NS4yNjU2LDI0My41IFExNDQuMTQwNiwyNDMuNSAxNDQuMTQwNiwyNDIuNjU2MyBRMTQ0LjE0MDYsMjQyLjE0MDYgMTQ0LjQzNzUsMjQxLjk2ODggUTE0NC43MzQ0LDI0MS43OTY5IDE0NS4yODEzLDI0MS43OTY5IEwxNDcuOTIxOSwyMzUuMjgxMyBMMTQ2Ljg0MzgsMjM1LjI4MTMgUTE0NS43MDMxLDIzNS4yODEzIDE0NS43MDMxLDIzNC40Mzc1IFExNDUuNzAzMSwyMzMuOTIxOSAxNDYsMjMzLjc2NTYgUTE0Ni4yOTY5LDIzMy41OTM4IDE0Ni44NDM4LDIzMy41OTM4IEwxNTAuNTE1NiwyMzMuNTkzOCBMMTUzLjkwNjMsMjQxLjc5NjkgUTE1NS4wNjI1LDI0MS43OTY5IDE1NS4wNjI1LDI0Mi42NTYzIFExNTUuMDYyNSwyNDMuNSAxNTMuOTM3NSwyNDMuNSBMMTUxLjU3ODEsMjQzLjUgUTE1MC40NTMxLDI0My41IDE1MC40NTMxLDI0Mi42NTYzIFogTTE1MC44NzUsMjM5LjEwOTQgTDE0OS41NDY5LDIzNS44NDM4IEwxNDguMjAzMSwyMzkuMTA5NCBMMTUwLjg3NSwyMzkuMTA5NCBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBmb250LXN0eWxlPSJpdGFsaWMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNzAiIHg9IjE2My41IiB5PSIyNDQuNiI+SHR0cFNlcnZsZXQ8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iMTM1LjUiIHgyPSIyMzUuNSIgeTE9IjI1NSIgeTI9IjI1NSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjEzNS41IiB4Mj0iMjM1LjUiIHkxPSIyNjMiIHkyPSIyNjMiLz48L2c+PCEtLU1ENT1bYTdmODg0MGVjNGFjZjY2Y2Y1YTIyMWFjZjlhYzE1Y2VdCnJldmVyc2UgbGluayBTZXJpYWxpemFibGUgdG8gR2VuZXJpY1NlcnZsZXQtLT48ZyBpZD0ibGlua19TZXJpYWxpemFibGVfR2VuZXJpY1NlcnZsZXQiPjxwYXRoIGQ9Ik0xMDIuNDIsNjguMSBDMTIwLjcyLDgzLjUgMTQxLjU1LDEwMS4wMyAxNTcuNzgsMTE0LjY4ICIgZmlsbD0ibm9uZSIgaWQ9IlNlcmlhbGl6YWJsZS1iYWNrdG8tR2VuZXJpY1NlcnZsZXQiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wO3N0cm9rZS1kYXNoYXJyYXk6Ny4wLDcuMDsiLz48cG9seWdvbiBmaWxsPSJub25lIiBwb2ludHM9Ijk3LjY0LDczLjIzLDg2Ljg0LDU1LDEwNi42NSw2Mi41Miw5Ny42NCw3My4yMyIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PC9nPjwhLS1NRDU9WzNiMTk4MDhlMjkwMDdkNTIwY2IwMGQwMzM2OWM1OTYwXQpyZXZlcnNlIGxpbmsgU2VydmxldCB0byBHZW5lcmljU2VydmxldC0tPjxnIGlkPSJsaW5rX1NlcnZsZXRfR2VuZXJpY1NlcnZsZXQiPjxwYXRoIGQ9Ik0xODUuNSw3NS4wMiBDMTg1LjUsODguNTggMTg1LjUsMTAzLjA0IDE4NS41LDExNC42OCAiIGZpbGw9Im5vbmUiIGlkPSJTZXJ2bGV0LWJhY2t0by1HZW5lcmljU2VydmxldCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7c3Ryb2tlLWRhc2hhcnJheTo3LjAsNy4wOyIvPjxwb2x5Z29uIGZpbGw9Im5vbmUiIHBvaW50cz0iMTc4LjUsNzUsMTg1LjUsNTUsMTkyLjUsNzUsMTc4LjUsNzUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjwvZz48IS0tTUQ1PVtlYjI4ZTI0YmU5N2Q5MjhlYjk2NmMzZTYzZjEzMzJlMl0KcmV2ZXJzZSBsaW5rIFNlcnZsZXRDb25maWcgdG8gR2VuZXJpY1NlcnZsZXQtLT48ZyBpZD0ibGlua19TZXJ2bGV0Q29uZmlnX0dlbmVyaWNTZXJ2bGV0Ij48cGF0aCBkPSJNMjczLjEyLDY3LjY0IEMyNTMuODEsODMuMTUgMjMxLjcxLDEwMC44OSAyMTQuNTQsMTE0LjY4ICIgZmlsbD0ibm9uZSIgaWQ9IlNlcnZsZXRDb25maWctYmFja3RvLUdlbmVyaWNTZXJ2bGV0IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjcuMCw3LjA7Ii8+PHBvbHlnb24gZmlsbD0ibm9uZSIgcG9pbnRzPSIyNjguODgsNjIuMDcsMjg4Ljg2LDU1LDI3Ny42NSw3Mi45OCwyNjguODgsNjIuMDciIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjwvZz48IS0tTUQ1PVtkODY5YWQ3YjE3NGYxZDg4MTNlMWU5NmM4ZWUwYzkyMl0KcmV2ZXJzZSBsaW5rIEdlbmVyaWNTZXJ2bGV0IHRvIEh0dHBTZXJ2bGV0LS0+PGcgaWQ9ImxpbmtfR2VuZXJpY1NlcnZsZXRfSHR0cFNlcnZsZXQiPjxwYXRoIGQ9Ik0xODUuNSwxODMuMDIgQzE4NS41LDE5Ni41OCAxODUuNSwyMTEuMDQgMTg1LjUsMjIyLjY4ICIgZmlsbD0ibm9uZSIgaWQ9IkdlbmVyaWNTZXJ2bGV0LWJhY2t0by1IdHRwU2VydmxldCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBvbHlnb24gZmlsbD0ibm9uZSIgcG9pbnRzPSIxNzguNSwxODMsMTg1LjUsMTYzLDE5Mi41LDE4MywxNzguNSwxODMiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjwvZz48IS0tTUQ1PVswYmU5NDAxZGU5ODU0N2FkYWE4NTYyYmVkYWU2Y2QzYV0KQHN0YXJ0dW1sDQppbnRlcmZhY2UgU2VyaWFsaXphYmxlDQppbnRlcmZhY2UgU2VydmxldA0KaW50ZXJmYWNlIFNlcnZsZXRDb25maWcNCmFic3RyYWN0IEdlbmVyaWNTZXJ2bGV0IGltcGxlbWVudHMgU2VyaWFsaXphYmxlLFNlcnZsZXQsU2VydmxldENvbmZpZw0KYWJzdHJhY3QgSHR0cFNlcnZsZXQgZXh0ZW5kcyBHZW5lcmljU2VydmxldA0KQGVuZHVtbA0KClBsYW50VU1MIHZlcnNpb24gMS4yMDIyLjMoVHVlIE1hciAyOSAxNjoxMDo1NyBHTVQgMjAyMikKKEdQTCBzb3VyY2UgZGlzdHJpYnV0aW9uKQpKYXZhIFJ1bnRpbWU6IE9wZW5KREsgUnVudGltZSBFbnZpcm9ubWVudApKVk06IE9wZW5KREsgNjQtQml0IFNlcnZlciBWTQpEZWZhdWx0IEVuY29kaW5nOiBVVEYtOApMYW5ndWFnZTogZW4KQ291bnRyeTogVVMKLS0+PC9nPjwvc3ZnPg=='>

<h1 id="考点6-二维数组声明"><a href="#考点6-二维数组声明" class="headerlink" title="考点6:二维数组声明"></a>考点6:二维数组声明</h1><p>下面哪几个语句正确的声明一个整型的二维数组（）</p>
<ul>
<li>A <code>int a[][]=new int[][]</code></li>
<li>B <code>int b[10][10]=new int[][]</code></li>
<li>C <code>int c[][]=new int[10][10]</code></li>
<li>D <code>int []d[]=new int[10][10]</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: CD</details>


<p>定义二维数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[][]=<span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">10</span>] [<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> []a[]=<span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">10</span>] [<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> [][]a=<span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">10</span>] [<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>三种方式均可，一维，三维，四维以此类推。</p>
<h1 id="考点7-自动类型转换"><a href="#考点7-自动类型转换" class="headerlink" title="考点7:自动类型转换"></a>考点7:自动类型转换</h1><p>针对以下代码，哪些选项执行后是true的：（）<br>class CompareReference{<br>   public static void main(String [] args){<br>   float f&#x3D;42.0f;<br>   float f1[]&#x3D;new float[2];<br>   float f2[]&#x3D;new float[2];<br>   float[] f3&#x3D;f1;<br>   long x&#x3D;42;<br>   f1[0]&#x3D;42.0f;<br>  }<br>}</p>
<ul>
<li>A f1&#x3D;&#x3D;f2</li>
<li>B x&#x3D;&#x3D;f1[0]</li>
<li>C f1&#x3D;&#x3D;f3</li>
<li>D f2&#x3D;&#x3D;f1[1]</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<p><a href="https://lanlan2017.github.io/JavaReadingNotes/cb4479de/#3-5-1-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">自动类型转换</a>按从低到高的顺序转换。不同类型数据间的优先关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">低 ---------------------------------------&gt; 高</span><br><span class="line">        char</span><br><span class="line">          ↘</span><br><span class="line">byte→short→int→long→float→double</span><br></pre></td></tr></table></figure>

<p>选项B中，long型会向float型转换，再运算</p>
<h1 id="考点8-java关键字-字面量"><a href="#考点8-java关键字-字面量" class="headerlink" title="考点8:java关键字 字面量"></a>考点8:java关键字 字面量</h1><p>(不定项选择题)<br>如下哪些是 java 中有效的关键字（）</p>
<ul>
<li>A native</li>
<li>B NULL</li>
<li>C false</li>
<li>D this</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: AD</details>

<p><a href="https://lanlan2017.github.io/JavaReadingNotes/c6dce410/">3.2.3 Java关键字</a><br>true、false和null是直接量，而不是 </p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/11/20211112223154.png" alt="img"></p>
<h1 id="考点9-线程局部变量"><a href="#考点9-线程局部变量" class="headerlink" title="考点9:线程局部变量"></a>考点9:线程局部变量</h1><p>对于线程局部存储TLS(thread local storage)，以下表述正确的是</p>
<ul>
<li>A 解决多线程中的对同一变量的访问冲突的一种技术</li>
<li>B TLS会为每一个线程维护一个和该线程绑定的变量的副本</li>
<li>C 每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了</li>
<li>D Java平台的java.lang.ThreadLocal是TLS技术的一种实现</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>

<p>对于同一全局变量或者静态变量，每个线程访问的是同一变量，多个线程同时访存同一全局变量或者静态变量时会导致冲突，尤其是多个线程同时需要修改这一变量时，通过TLS机制，为每一个使用该全局变量的线程都提供一个变量值的副本，每一个线程均可以独立地改变自己的副本，而不会和其它线程的副本冲突。</p>
<blockquote>
<p>线程局部变量(<code>ThreadLocal</code>)的功用其实非常简单,就是<strong>为每一个使用该变量的线程都提供一个变量值的副本,使每一个线程都可以独立地改变自己的副本,而不会和其他线程的副本冲突</strong>。从线程的角度看,<strong>就好像每一个线程都完全拥有该变量一样</strong>。</p>
<p><strong>每个线程完全拥有自己的<code>ThreadLocal</code>变量,这就是<code>ThreadLocal</code>的用途</strong>。</p>
</blockquote>
<p><a href="http://localhost:4003/JavaReadingNotes/a8a61bd3/">http://localhost:4003/JavaReadingNotes/a8a61bd3/</a></p>
<p>如果是静态变量是共享的话，那必须同步，否则尽管有副本，还是会出错，故C错</p>
<h1 id="考点10-线程安全的Servlet"><a href="#考点10-线程安全的Servlet" class="headerlink" title="考点10:线程安全的Servlet"></a>考点10:线程安全的Servlet</h1><p>下列那些方法是线程安全的(所调用的方法都存在)</p>
<ul>
<li>A <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span> <span class="params">(ServletRequest req, ServletResponse resp)</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">I</span> <span class="operator">=</span> extractFromRequest(req);</span><br><span class="line">        encodeIntoResponse(resp,factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>B <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span> <span class="params">(ServletRequest req, ServletResponse resp)</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">I</span> <span class="operator">=</span> extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = factor(i);</span><br><span class="line">        count ++;</span><br><span class="line">        encodeIntoResponse(resp,factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>C <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">set</span> <span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>D <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factorizer</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">MyCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCache</span>(<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = cache.getFactors(i);</span><br><span class="line">        <span class="keyword">if</span> (factors == <span class="literal">null</span>) &#123;</span><br><span class="line">            factors = factor(i);</span><br><span class="line">            cache = <span class="keyword">new</span> <span class="title class_">MyCache</span>(i,factors);</span><br><span class="line">        &#125;</span><br><span class="line">        encodeIntoResponse(resp,factors);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details>

<p>这几个类都没有类属性，不存在共享资源，为了满足题目的意思，应该是多线程情况下使用同一个对象，以达到使成员成为共享资源的目的；<br>A：没有成员（没有共享资源），线程安全；<br>B：假设存在线程1和线程2，count初始值为0，当线程1执行count++中count+1（此时未写回最终计算值），这时线程2执行count++中读取count，发生数据错误，导致线程1线程2的结果都为1，而不是线程1的结果为1，线程2的结果为2，线程不安全；<br>C：成员私有，对成员的set get方法都加重量级锁，线程安全；<br>D：volatile有两个作用：<br>可见性（volatile变量的改变能使其他线程立即可见，但它不是线程安全的，参考B）和禁止重排序；这里是可见性的应用，类中方法对volatile修饰的变量只有赋值，线程安全； </p>
<p>自定义Servlet时尽量不要定义成员变量，多线程环境下定义的成员变量会成为线程共享变量，导致数据不一致问题</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年11月</category>
      </categories>
  </entry>
  <entry>
    <title>厨房窗户</title>
    <url>/exam//479200b3/</url>
    <content><![CDATA[<p>高度:80<br>长度:75cm</p>
<p>长度:38cm</p>
<p>75+75+38+38&#x3D;226</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年11月</category>
      </categories>
  </entry>
  <entry>
    <title>2019年10月28日Linux专项练习</title>
    <url>/exam//3e93982/</url>
    <content><![CDATA[<h1 id="2019年10月28日Linux专项练习"><a href="#2019年10月28日Linux专项练习" class="headerlink" title="2019年10月28日Linux专项练习"></a>2019年10月28日Linux专项练习</h1><h1 id="考点1-Linux给文件添加执行权限的命令"><a href="#考点1-Linux给文件添加执行权限的命令" class="headerlink" title="考点1:Linux给文件添加执行权限的命令"></a>考点1:Linux给文件添加执行权限的命令</h1><p>为脚本程序指定执行权限命令的参数为</p>
<ul>
<li>A <code>chmod +x filename.sh</code></li>
<li>B <code>chown +x filename.sh</code></li>
<li>C <code>chmod +w filename.sh</code></li>
<li>D <code>chown +r filename.sh</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul>
<li><code>chmod</code>拆开是<code>change modify</code>是<code>修改</code>之意，</li>
<li><code>chown</code>拆开是<code>change own</code>是<code>修改拥有者</code>之意</li>
</ul>
<h1 id="考点2-Linux-crontab"><a href="#考点2-Linux-crontab" class="headerlink" title="考点2:Linux crontab"></a>考点2:Linux crontab</h1><p><code>Linux crontab</code>中<code>*****/usr/local/run.sh</code>这句话5个<code>*</code>号分别代表什么？</p>
<ul>
<li>A 分钟 小时 日 月 星期</li>
<li>B 秒 分钟 小时 日 月</li>
<li>C 秒 分钟 小时 日 星期</li>
<li>D 分钟 小时 日 月 年</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p><code>crontab</code>是<code>Unix</code>和<code>Linux</code>用于 <strong>设置周期性被执行的指令</strong> ，是互联网很常用的技术，很多任务都会设置在<code>crontab</code>循环执行，如果不使用<code>crontab</code>，那么任务就是常驻程序</p>
<h3 id="分时日月周-分食日月粥"><a href="#分时日月周-分食日月粥" class="headerlink" title="分时日月周(分食日月粥)"></a>分时日月周(分食日月粥)</h3><p><code>crontab</code>基本格式 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* * * * * command</span><br></pre></td></tr></table></figure>

<p><code>第1列</code>表示分钟1～59 每分钟用*或者 *&#x2F;1表示<br><code>第2列</code>表示小时1～23（0表示0点）<br><code>第3列</code>表示日期1～31<br><code>第4列</code>表示月份1～12<br><code>第5列</code>标识号星期0～6（0表示星期天）<br><code>第6列</code>要运行的命令</p>
<h3 id="查看crontab-cat-x2F-etc-x2F-crontab"><a href="#查看crontab-cat-x2F-etc-x2F-crontab" class="headerlink" title="查看crontab cat &#x2F;etc&#x2F;crontab"></a>查看crontab cat &#x2F;etc&#x2F;crontab</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/crontab</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line"></span><br><span class="line">&amp;#35; For details see man 4 crontabs</span><br><span class="line"></span><br><span class="line">&amp;#35; Example of job definition:</span><br><span class="line">&amp;#35; .---------------- minute (0 - 59)</span><br><span class="line">&amp;#35; |  .------------- hour (0 - 23)</span><br><span class="line">&amp;#35; |  |  .---------- day of month (1 - 31)</span><br><span class="line">&amp;#35; |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class="line">&amp;#35; |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="line">&amp;#35; |  |  |  |  |</span><br><span class="line">&amp;#35; *  *  *  *  * user-name  command to be executed</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>

<h1 id="考点3-arp协议"><a href="#考点3-arp协议" class="headerlink" title="考点3:arp协议"></a>考点3:arp协议</h1><p>arp协议用了()</p>
<ul>
<li>A broadcast</li>
<li>B multicast</li>
<li>C unicast</li>
<li>D 以上选项都不正确</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><ul>
<li><code>arp(address resolution protocol)</code>是地址解析协议，<code>arp</code>协议发的都是广播包</li>
<li><code>unicast</code>：单播，</li>
<li><code>multicast</code>：多播，</li>
<li><code>broadcast</code>：广播。</li>
</ul>
<h1 id="考点4-kill命令"><a href="#考点4-kill命令" class="headerlink" title="考点4:kill命令"></a>考点4:kill命令</h1><p>你尝试登出时收到一个错误消息，显示你还有任务未完成，你需要使用下面哪个命令？</p>
<ul>
<li>A kill PID-of-the-process</li>
<li>B kill job-number-of-process</li>
<li>C kill</li>
<li>D kill PID-of-the-last-command</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><ul>
<li>kill pid 让进程正常退出</li>
<li>kill %job number 直接杀掉进程</li>
</ul>
<h1 id="考点5-shell脚本的命令行参数"><a href="#考点5-shell脚本的命令行参数" class="headerlink" title="考点5:shell脚本的命令行参数"></a>考点5:shell脚本的命令行参数</h1><p>如何获取上一条命令执行的返回码</p>
<ul>
<li>A <code>$!</code></li>
<li>B <code>$0</code></li>
<li>C <code>$?</code></li>
<li>D <code>$#</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>$0</code></td>
<td align="left">脚本启动名(包括路径)</td>
</tr>
<tr>
<td align="left"><code>$n</code></td>
<td align="left">第n个参数,n&#x3D;1,2,…9</td>
</tr>
<tr>
<td align="left"><code>$*</code></td>
<td align="left">所有参数列表(不包括脚本本身)</td>
</tr>
<tr>
<td align="left"><code>$@</code></td>
<td align="left">所有参数列表(独立字符串)</td>
</tr>
<tr>
<td align="left"><code>$#</code></td>
<td align="left">参数个数(不包括脚本本身)</td>
</tr>
<tr>
<td align="left"><code>$$</code></td>
<td align="left">当前程式的PID</td>
</tr>
<tr>
<td align="left"><code>$!</code></td>
<td align="left">执行上一个指令的PID</td>
</tr>
<tr>
<td align="left"><code>$?</code></td>
<td align="left">执行上一个指令的返回值</td>
</tr>
</tbody></table>
<h1 id="考点6-clone和fork的区别"><a href="#考点6-clone和fork的区别" class="headerlink" title="考点6:clone和fork的区别"></a>考点6:clone和fork的区别</h1><p>下列关于 clone 和 fork 的区别描述正确的有？</p>
<ul>
<li>A clone和fork最大不同在于fork不再复制父进程的栈空间，而是自己创建一个新的。</li>
<li>B clone和fork最大不同在于clone不再复制父进程的栈空间，而是自己创建一个新的。</li>
<li>C clone是fork的升级版本，不仅可以创建进程或者线程，还可以指定创建新的命名空间（namespace）、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等</li>
<li>D fork是clone的升级版本，不仅可以创建进程或者线程，还可以指定创建新的命名空间（namespace）、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>fork()函数复制时将父进程的所有资源都通过复制数据结构进行了复制，然后传递给子进程，所以fork()函数不带参数；<br>clone()函数则是将部分父进程的资源的数据结构进行复制， <strong>复制哪些资源是可选择的</strong> ，这个可以通过参数设定，所以clone()函数带参数，没有复制的资源可以通过指针共享给子进程。</p>
<ul>
<li>fork()是全部复制</li>
<li>vfork()是共享内存</li>
<li>clone()是可以将父进程资源有选择地复制给子进程，而没有复制的数据结构则通过指针的复制让子进程共享，具体要复制哪些资源给子进程，由参数列表中的clone_flags来决定。另外，clone()返回的是子进程的pid。</li>
</ul>
<h1 id="考点7-tar打包命令"><a href="#考点7-tar打包命令" class="headerlink" title="考点7:tar打包命令"></a>考点7:tar打包命令</h1><p>在linux中用使用tar命令将文件aaa打包为bak.tar。</p>
<ul>
<li>A <code>tar -cf bak.tar aaa</code></li>
<li>B <code>tar -xf bak.tar aaa</code></li>
<li>C <code>tar -czf bak.tar aaa</code></li>
<li>D <code>tar -rf bak.tar aaa</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><h3 id="tar解压缩命令"><a href="#tar解压缩命令" class="headerlink" title="tar解压缩命令"></a>tar解压缩命令</h3><p>语法：<code>tar [主选项+辅选项] </code>文件或者目录<br>使用该命令时，主选项是必须要有的，它告诉tar要做什么事情，辅选项是辅助使用的，可以选用。</p>
<h4 id="主选项"><a href="#主选项" class="headerlink" title="主选项"></a>主选项</h4><table>
<thead>
<tr>
<th align="left">主选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-c</code></td>
<td align="left">创建的档案文件。如果用户想备份一个目录或是一些文件，就要选择这个选项。相当于打包。</td>
</tr>
<tr>
<td align="left"><code>-x</code></td>
<td align="left">从档案文件中释放文件。相当于拆包。</td>
</tr>
<tr>
<td align="left"><code>-t</code></td>
<td align="left">列出档案文件的内容，查看已经备份了哪些文件。</td>
</tr>
<tr>
<td align="left">特别注意，主选项c,x,t仅能存在一个！不可同时存在！因为<strong>不可能同时压缩与解压缩</strong>。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="辅助选项"><a href="#辅助选项" class="headerlink" title="辅助选项"></a>辅助选项</h4><table>
<thead>
<tr>
<th align="left">辅助选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-z</code></td>
<td align="left">是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩或解压？一般格式为xx.tar.gz或xx. tgz</td>
</tr>
<tr>
<td align="left"><code>-j</code></td>
<td align="left">是否同时具有 bzip2 的属性？亦即是否需要用 bzip2压缩或解压？一般格式为xx.tar.bz2</td>
</tr>
<tr>
<td align="left"><code>-v</code></td>
<td align="left">压缩的过程中显示文件！这个常用</td>
</tr>
<tr>
<td align="left"><code>-f</code></td>
<td align="left">使用档名，请留意，在<strong>f之后要立即接档名</strong>喔！不要再加其他参数！</td>
</tr>
<tr>
<td align="left"><code>-p</code></td>
<td align="left">使用原文件的原来属性（属性不会依据使用者而变）</td>
</tr>
</tbody></table>
<h1 id="考点8-进程间通信的方式"><a href="#考点8-进程间通信的方式" class="headerlink" title="考点8:进程间通信的方式"></a>考点8:进程间通信的方式</h1><p>Unix系统中，哪些可以用于进程间的通信？（）</p>
<ul>
<li>A Socket</li>
<li>B 共享内存</li>
<li>C 消息队列</li>
<li>D 信号量</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>

<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><h3 id="Linux进程间通信"><a href="#Linux进程间通信" class="headerlink" title="Linux进程间通信"></a>Linux进程间通信</h3><ul>
<li>管道、</li>
<li>信号、</li>
<li>消息队列、</li>
<li>共享内存、</li>
<li>信号量、</li>
<li>套接字(<code>socket</code>)</li>
</ul>
<h3 id="Windows进程间通信"><a href="#Windows进程间通信" class="headerlink" title="Windows进程间通信"></a>Windows进程间通信</h3><ul>
<li>管道、</li>
<li>消息队列、</li>
<li>共享内存、</li>
<li>信号量(<code>semaphore</code>)、</li>
<li>套接字(<code>socket</code>)</li>
</ul>
<h3 id="Linux线程间通信"><a href="#Linux线程间通信" class="headerlink" title="Linux线程间通信"></a>Linux线程间通信</h3><ul>
<li>互斥量(<code>mutex</code>),</li>
<li>信号量,</li>
<li><strong>条件变量</strong></li>
</ul>
<h3 id="Windows线程间通信"><a href="#Windows线程间通信" class="headerlink" title="Windows线程间通信"></a>Windows线程间通信</h3><ul>
<li>互斥量(<code>mutex</code>),</li>
<li>信号量(<code>semaphore</code>)、</li>
<li><strong>临界区</strong>(<code>critical section</code>)、</li>
<li><strong>事件</strong>(<code>event</code>)</li>
</ul>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Linux</category>
        <category>2019年</category>
      </categories>
  </entry>
  <entry>
    <title>2021年04月09日Linux专项练习1</title>
    <url>/exam//a22040b2/</url>
    <content><![CDATA[<h1 id="考点1-测试网络是否连通的Linux命令"><a href="#考点1-测试网络是否连通的Linux命令" class="headerlink" title="考点1:测试网络是否连通的Linux命令"></a>考点1:测试网络是否连通的Linux命令</h1><p>下列哪些命令可以测试网络通不通？</p>
<ul>
<li>A <code>ping</code></li>
<li>B <code>traceroute</code></li>
<li>C <code>netstat</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p> A，ping命令常用来查看网络连接是否相通，底层是ICMP协议。如<code>ping www.baidu.com </code><br> B, traceroute是常用的路由查看命令，用来<strong>查看数据到达某个主机经过的路由地址</strong><br> C，netstat命令用来<strong>查看本机的传输层连接状态</strong>，如TCP连接，端口等信息</p>
<h1 id="考点2-Samba服务器的配置文件"><a href="#考点2-Samba服务器的配置文件" class="headerlink" title="考点2:Samba服务器的配置文件"></a>考点2:Samba服务器的配置文件</h1><p>Samba 服务器的配置文件是</p>
<ul>
<li>A <code>httpd.conf</code></li>
<li>B <code>inetd.conf</code></li>
<li>C <code>rc.samba</code></li>
<li>D <code>smb.conf</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h3 id="SMB"><a href="#SMB" class="headerlink" title="SMB"></a>SMB</h3><p>SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议。</p>
<h3 id="Samba"><a href="#Samba" class="headerlink" title="Samba"></a>Samba</h3><p>Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。</p>
<ul>
<li>WEB服务器配置文件   http.conf</li>
<li>WEB启动脚本配置文件   initd.conf</li>
<li>samba脚本          rc.samba</li>
<li>samba服务配置文件  smb.conf</li>
</ul>
<h1 id="考点3-Linux用户存放配置文件的目录"><a href="#考点3-Linux用户存放配置文件的目录" class="headerlink" title="考点3:Linux用户存放配置文件的目录"></a>考点3:Linux用户存放配置文件的目录</h1><p>在linux系统中,用来存放系统所需要的配置文件和子目录是</p>
<ul>
<li>A <code>/etc</code></li>
<li>B <code>/var</code></li>
<li>C <code>/root</code></li>
<li>D <code>/home</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<ul>
<li><code>etc</code>下放置配置文件</li>
<li><code>/var</code>下放置日志文件</li>
<li><code>/root</code>超级用户主目录</li>
<li><code>/home</code>使用者家目录</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Linux目录</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>/dev</code></td>
<td align="left">设备信息</td>
</tr>
<tr>
<td align="left"><code>/home</code></td>
<td align="left">家目录</td>
</tr>
<tr>
<td align="left"><code>/bin/sbin</code></td>
<td align="left">可执行文件</td>
</tr>
<tr>
<td align="left"><code>/etc</code></td>
<td align="left">系统文件</td>
</tr>
<tr>
<td align="left"><code>/lib/lib64</code></td>
<td align="left">动态库&#x2F;静态库</td>
</tr>
<tr>
<td align="left"><code>/lost+found</code></td>
<td align="left">丢失文件</td>
</tr>
<tr>
<td align="left"><code>/opt</code></td>
<td align="left">第三方文件（相对于操作系统）</td>
</tr>
<tr>
<td align="left"><code>/root</code></td>
<td align="left">管理员的家目录</td>
</tr>
<tr>
<td align="left"><code>/usr</code></td>
<td align="left">第三方头文件和库</td>
</tr>
<tr>
<td align="left"><code>/var</code></td>
<td align="left">系统日志文件&#x2F;缓存文件</td>
</tr>
<tr>
<td align="left">&#x2F;etc&#x2F;passwd</td>
<td align="left">用户数据库，其中的域给出了用户名、真实姓名、家目录、加密的口令和用户的其他信息。</td>
</tr>
<tr>
<td align="left">&#x2F;etc&#x2F;group</td>
<td align="left">类似&#x2F;etc&#x2F;passwd ，但说明的不是用户而是组。</td>
</tr>
<tr>
<td align="left">&#x2F;etc&#x2F;inittab</td>
<td align="left">init 的配置文件。</td>
</tr>
</tbody></table>
<h1 id="考点4-查看远程Linux运行了多少时间"><a href="#考点4-查看远程Linux运行了多少时间" class="headerlink" title="考点4:查看远程Linux运行了多少时间"></a>考点4:查看远程Linux运行了多少时间</h1><p>在Shell环境下,如何查看远程Linux系统运行了多少时间？</p>
<ul>
<li>A scp user@被监控主机ip “uptime”</li>
<li>B ssh user@被监控主机ip “uptime”</li>
<li>C ssh user@被监控主机ip “cputime”</li>
<li>D scp user@被监控主机ip “cputime”</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<ul>
<li>scp用于远程数据传输</li>
<li>ssh用于远程登录</li>
<li>uptime命令可以查看当前linux系统运行了多长时间</li>
</ul>
<p><a href="https://www.cnblogs.com/joshua317/articles/4740881.html">https://www.cnblogs.com/joshua317/articles/4740881.html</a></p>
<h3 id="ssh命令"><a href="#ssh命令" class="headerlink" title="ssh命令"></a>ssh命令</h3><p>ssh命令用于远程登录上Linux主机。<br>常用格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh [-l login_name] [-p port] [user@]hostname</span><br></pre></td></tr></table></figure>
<h3 id="scp命令"><a href="#scp命令" class="headerlink" title="scp命令"></a>scp命令</h3><p>scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp [可选参数] file_source file_target</span><br></pre></td></tr></table></figure>
<h3 id="uptime命令"><a href="#uptime命令" class="headerlink" title="uptime命令"></a>uptime命令</h3><p><strong>uptime命令</strong>能够打印系统总共运行了多长时间和系统的平均负载。<br>uptime命令可以显示的信息显示依次为：<br>现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载。<br><a href="http://man.linuxde.net/uptime">http://man.linuxde.net/uptime</a></p>
<h1 id="考点5-计算机存储原理"><a href="#考点5-计算机存储原理" class="headerlink" title="考点5:计算机存储原理"></a>考点5:计算机存储原理</h1><p>下面关于计算机存储原理说法错误的是 。</p>
<ul>
<li>A 存储器由大量可以存储二进制数据的存储单元组成</li>
<li>B 数据总线从存储器中获取数据的过程称为写操作</li>
<li>C 程序执行时,读取指令是指计算机自动从存储器中取出一条指令</li>
<li>D 虚拟存储技术缓解主存容量小的矛盾</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>考察的是计算机存储结构原理<br>存储位：存放<strong>二进制</strong>单元，是存储器最小的存储单位。  从存储器获取为读操作。存储到存储器为写操作。<br>虚拟存储技术：当进程运行时，先将其中一部分装入内存，另一部分暂留在磁盘，当要执行的指令或访问的数据不在内存时，由操作系统自动完成将他们从磁盘调入内存的工作  <img data-src="https://uploadfiles.nowcoder.com/images/20200218/300975041_1582039439525_DF41582E9D728E37EF30F19724309CF6"></p>
<h1 id="考点6-Linux日志-x2F-var-x2F-log-x2F-的子目录的用途"><a href="#考点6-Linux日志-x2F-var-x2F-log-x2F-的子目录的用途" class="headerlink" title="考点6:Linux日志&#x2F;var&#x2F;log&#x2F;的子目录的用途"></a>考点6:Linux日志&#x2F;var&#x2F;log&#x2F;的子目录的用途</h1><p>你被需要检查系统中的设备情况,需要检查哪个log日志？</p>
<ul>
<li>A <code>/var/log/tmp</code></li>
<li>B <code>/var/log/lastlog</code></li>
<li>C <code>/var/log/messages</code></li>
<li>D <code>/var/log/utmp</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h3 id="x2F-var-x2F-log子目录"><a href="#x2F-var-x2F-log子目录" class="headerlink" title="&#x2F;var&#x2F;log子目录"></a>&#x2F;var&#x2F;log子目录</h3><table>
<thead>
<tr>
<th align="left">&#x2F;var&#x2F;log子目录</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>&#x2F;var&#x2F;log&#x2F;messages</strong></td>
<td align="left">包括整体系统信息，其中也包含系统启动期间的日志。此外，mail，cron，daemon，kern和auth等内容也记录在var&#x2F;log&#x2F;messages日志中。</td>
</tr>
<tr>
<td align="left">&#x2F;<strong>var&#x2F;log&#x2F;dmesg</strong></td>
<td align="left">包含内核缓冲信息（kernel ring buffer）。在系统启动时，会在屏幕上显示许多与硬件有关的信息。可以用dmesg查看它们。</td>
</tr>
<tr>
<td align="left"><strong>&#x2F;var&#x2F;log&#x2F;auth.log</strong></td>
<td align="left">包含系统授权信息，包括用户登录和使用的权限机制等。</td>
</tr>
<tr>
<td align="left"><strong>&#x2F;var&#x2F;log&#x2F;boot.log</strong></td>
<td align="left">包含系统启动时的日志。</td>
</tr>
<tr>
<td align="left"><strong>&#x2F;var&#x2F;log&#x2F;daemon.log</strong></td>
<td align="left">包含各种系统后台守护进程日志信息。</td>
</tr>
<tr>
<td align="left"><strong>&#x2F;var&#x2F;log&#x2F;dpkg.log</strong></td>
<td align="left">包括安装或dpkg命令清除软件包的日志。</td>
</tr>
<tr>
<td align="left"><strong>&#x2F;var&#x2F;log&#x2F;kern.log</strong></td>
<td align="left">包含内核产生的日志，有助于在定制内核时解决问题。</td>
</tr>
<tr>
<td align="left"><strong>&#x2F;var&#x2F;log&#x2F;lastlog</strong></td>
<td align="left">记录所有用户的最近信息。这不是一个ASCII文件，因此需要用lastlog命令查看内容。</td>
</tr>
<tr>
<td align="left"><strong>&#x2F;var&#x2F;log&#x2F;maillog &#x2F;var&#x2F;log&#x2F;mail.log</strong></td>
<td align="left">包含来着系统运行电子邮件服务器的日志信息。例如，sendmail日志信息就全部送到这个文件中。</td>
</tr>
<tr>
<td align="left"><strong>&#x2F;var&#x2F;log&#x2F;user.log</strong></td>
<td align="left">记录所有等级用户信息的日志。</td>
</tr>
<tr>
<td align="left"><strong>&#x2F;var&#x2F;log&#x2F;Xorg.x.log</strong></td>
<td align="left">来自X的日志信息。</td>
</tr>
<tr>
<td align="left"><strong>&#x2F;var&#x2F;log&#x2F;alternatives.log</strong></td>
<td align="left">更新替代信息都记录在这个文件中。</td>
</tr>
<tr>
<td align="left"><strong>&#x2F;var&#x2F;log&#x2F;btmp</strong></td>
<td align="left">记录所有失败登录信息。使用last命令可以查看btmp文件。例如，”last -f &#x2F;var&#x2F;log&#x2F;btmp &amp;#124; more”。</td>
</tr>
<tr>
<td align="left"><strong>&#x2F;var&#x2F;log&#x2F;cups</strong></td>
<td align="left">涉及所有打印信息的日志。</td>
</tr>
<tr>
<td align="left"><strong>&#x2F;var&#x2F;log&#x2F;anaconda.log</strong></td>
<td align="left">在安装Linux时，所有安装信息都储存在这个文件中。</td>
</tr>
<tr>
<td align="left"><strong>&#x2F;var&#x2F;log&#x2F;yum.log</strong></td>
<td align="left">包含使用yum安装的软件包信息。</td>
</tr>
<tr>
<td align="left"><strong>&#x2F;var&#x2F;log&#x2F;cron</strong></td>
<td align="left">每当cron进程开始一个工作时，就会将相关信息记录在这个文件中。</td>
</tr>
<tr>
<td align="left"><strong>&#x2F;var&#x2F;log&#x2F;secure</strong></td>
<td align="left">包含验证和授权方面信息。例如，sshd会将所有信息记录（其中包括失败登录）在这里。</td>
</tr>
<tr>
<td align="left"><strong>&#x2F;var&#x2F;log&#x2F;wtmp或&#x2F;var&#x2F;log&#x2F;utmp</strong></td>
<td align="left">包含登录信息。使用wtmp可以找出谁正在登陆进入系统，谁使用命令显示这个文件或信息等。</td>
</tr>
<tr>
<td align="left"><strong>&#x2F;var&#x2F;log&#x2F;faillog</strong></td>
<td align="left">包含用户登录失败信息。此外，错误登录命令也会记录在本文件中。</td>
</tr>
</tbody></table>
<h3 id="特定应用相关的-x2F-var-x2F-log-x2F-的子目录"><a href="#特定应用相关的-x2F-var-x2F-log-x2F-的子目录" class="headerlink" title="特定应用相关的&#x2F;var&#x2F;log&#x2F;的子目录"></a>特定应用相关的&#x2F;var&#x2F;log&#x2F;的子目录</h3><p>除了上述Log文件以外，<br>&#x2F;var&#x2F;log还基于系统的具体应用包含以下一些子目录：</p>
<table>
<thead>
<tr>
<th align="left">应用相关的&#x2F;var&#x2F;log子目录</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x2F;var&#x2F;log&#x2F;httpd&#x2F;或&#x2F;var&#x2F;log&#x2F;apache2</td>
<td align="left">包含服务器access_log和error_log信息。</td>
</tr>
<tr>
<td align="left">&#x2F;var&#x2F;log&#x2F;lighttpd&#x2F;</td>
<td align="left">包含light HTTPD的access_log和error_log。</td>
</tr>
<tr>
<td align="left">&#x2F;var&#x2F;log&#x2F;mail&#x2F;</td>
<td align="left">这个子目录包含邮件服务器的额外日志。</td>
</tr>
<tr>
<td align="left">&#x2F;var&#x2F;log&#x2F;prelink&#x2F;</td>
<td align="left">包含.so文件被prelink修改的信息。</td>
</tr>
<tr>
<td align="left">&#x2F;var&#x2F;log&#x2F;audit&#x2F;</td>
<td align="left">包含被 Linux audit daemon储存的信息。</td>
</tr>
<tr>
<td align="left">&#x2F;var&#x2F;log&#x2F;samba&#x2F;</td>
<td align="left">包含由samba存储的信息。</td>
</tr>
<tr>
<td align="left">&#x2F;var&#x2F;log&#x2F;sa&#x2F;</td>
<td align="left">包含每日由sysstat软件包收集的sar文件。</td>
</tr>
<tr>
<td align="left">&#x2F;var&#x2F;log&#x2F;sssd&#x2F;</td>
<td align="left">用于守护进程安全服务。</td>
</tr>
</tbody></table>
<h1 id="考点7-tcpdump命令"><a href="#考点7-tcpdump命令" class="headerlink" title="考点7:tcpdump命令"></a>考点7:tcpdump命令</h1><p>linux tcpdump监听网卡 eth0,对方主机IP为10.1.1.180,tcp端口为80的数据,相应命令为？</p>
<ul>
<li>A tcpdump -h eth0 -nn ‘tcp and host 10.1.1.180:80’</li>
<li>B tcpdump -i eth0 -nn ‘tcp and host 10.1.1.180:80’</li>
<li>C tcpdump -h eth0 -nn ‘tcp and port 80 and host 10.1.1.180’</li>
<li>D tcpdump -i eth0 -nn ‘tcp and port 80 and host 10.1.1.180’</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>tcpdump抓包命令：用于截取网络分组，并输出分组内容的工具</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-A</td>
<td align="left">以ASCII格式打印所有分组，常用于www的网页的数据抓取</td>
</tr>
<tr>
<td align="left">-c</td>
<td align="left">收到指定的数量的分组后，停止tcpdump</td>
</tr>
<tr>
<td align="left">-C</td>
<td align="left">将一个原始分组写入文件之前，检查文件的当前大小是否超过了file_size的指定大小，超过则关闭当前文件然后打开一个新文件，、</td>
</tr>
<tr>
<td align="left">-d</td>
<td align="left">将匹配信心包的代码以人们能够理解的汇编格式给出</td>
</tr>
<tr>
<td align="left">-dd</td>
<td align="left">将匹配信息的代码以C语言程序段的格式给出</td>
</tr>
<tr>
<td align="left">-ddd</td>
<td align="left">将匹配信息的代码以十进制的形式给出</td>
</tr>
<tr>
<td align="left">-D</td>
<td align="left">打印系统中所有的可以用tcpdump截包的网络接口</td>
</tr>
<tr>
<td align="left">-e</td>
<td align="left">输出行打印数据链路层的头部信息</td>
</tr>
<tr>
<td align="left">-f</td>
<td align="left">将外部的internet地址以数字的形式打印</td>
</tr>
<tr>
<td align="left">-F</td>
<td align="left">从指定的文件中读取表达式，忽略命令行中给出的表达式、</td>
</tr>
<tr>
<td align="left"><strong>-i</strong></td>
<td align="left"><strong>指定监听的网络接口</strong></td>
</tr>
<tr>
<td align="left">-l</td>
<td align="left">使标准输出变成缓冲形式，可以把数据导出到文件</td>
</tr>
<tr>
<td align="left">-L</td>
<td align="left">列出网络接口的已知数据链路</td>
</tr>
<tr>
<td align="left">-b</td>
<td align="left">在数据链路层选择协议：ip arp rarp ipx</td>
</tr>
<tr>
<td align="left">-n</td>
<td align="left">不把网络地址转成名字</td>
</tr>
<tr>
<td align="left"><strong>-nn</strong></td>
<td align="left">不进行端口名称的转换</td>
</tr>
<tr>
<td align="left">-N</td>
<td align="left">不输出主机名中的域名部分</td>
</tr>
<tr>
<td align="left">-t</td>
<td align="left">输出的每一行不打印时间戳</td>
</tr>
<tr>
<td align="left">-tt</td>
<td align="left">在每一行中输出非格式化的时间戳</td>
</tr>
<tr>
<td align="left">-ttt</td>
<td align="left">输出本行和前面一行之间的时间差</td>
</tr>
<tr>
<td align="left">-tttt</td>
<td align="left">在每一行中输出由date处理的默认格式的时间戳</td>
</tr>
<tr>
<td align="left">-O</td>
<td align="left">不运行分组匹配代码优化程序</td>
</tr>
<tr>
<td align="left">-P</td>
<td align="left">不将网络接口设置成混杂模式</td>
</tr>
<tr>
<td align="left">-q</td>
<td align="left">快速输出，只输出较少的协议信息</td>
</tr>
<tr>
<td align="left">-r</td>
<td align="left">从指定文件中读取包</td>
</tr>
<tr>
<td align="left">-S</td>
<td align="left">将tcp的序列号以绝对值形式输出，而不是相对值</td>
</tr>
<tr>
<td align="left">-s</td>
<td align="left">从每个分组中读取最开始的snaplen个字节】</td>
</tr>
<tr>
<td align="left">-T</td>
<td align="left">将监听的包直接解释为指定类型的报文，常见有rpc远程过程调用，和snmp</td>
</tr>
<tr>
<td align="left">-v</td>
<td align="left">输出一个详细信息</td>
</tr>
<tr>
<td align="left">-vv</td>
<td align="left">输出详细的报文信息</td>
</tr>
<tr>
<td align="left">-w</td>
<td align="left">直接将分组写入文件中，而不是不分析打印</td>
</tr>
<tr>
<td align="left">-x</td>
<td align="left">可以列出16进制以及ASCII的数据包的内容</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-i 网路接口名字</span><br></pre></td></tr></table></figure>
<p>并且需要带上端口号</p>
<h1 id="考点8-Redhat发布的Linux"><a href="#考点8-Redhat发布的Linux" class="headerlink" title="考点8:Redhat发布的Linux"></a>考点8:Redhat发布的Linux</h1><p>在Redhat公司发布的Linux版本中,若要使得用户登录验证,需要修改以下_____脚本。</p>
<ul>
<li>A <code>/etc/inittab</code></li>
<li>B <code>/etc/passwd</code></li>
<li>C <code>/etc/shadow</code></li>
<li>D <code>/etc/group</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h3 id="x2F-etc目录的inittab-passwd-shadow-group文件的作用"><a href="#x2F-etc目录的inittab-passwd-shadow-group文件的作用" class="headerlink" title="&#x2F;etc目录的inittab passwd shadow group文件的作用"></a>&#x2F;etc目录的inittab passwd shadow group文件的作用</h3><table>
<thead>
<tr>
<th align="left">&#x2F;etc目录常用文件</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>/etc/inittab</code></td>
<td align="left">配置文件用来设置系统的默认<strong>运行级别</strong>。</td>
</tr>
<tr>
<td align="left"><code>/etc/passwd</code></td>
<td align="left">这个文件存放着所有用户帐号的信息，包括用户名和密码，因此，它对系统来说是至关重要的。</td>
</tr>
<tr>
<td align="left"><code>/etc/shadow</code></td>
<td align="left"><strong>用于存储 Linux 系统中用户的密码信息，又称为“影子文件”。</strong></td>
</tr>
<tr>
<td align="left"><code>/etc/group</code></td>
<td align="left">该文件是用户组配置文件，即用户组的所有信息都存放在此文件中</td>
</tr>
</tbody></table>
<p>其中，**&#x2F;ect&#x2F;passwd用来保存用户的基本信息，而&#x2F;etc&#x2F;shadow用来保存所有用户的密码**</p>
<h3 id="x2F-etc-x2F-shadow文件作用"><a href="#x2F-etc-x2F-shadow文件作用" class="headerlink" title="&#x2F;etc&#x2F;shadow文件作用"></a>&#x2F;etc&#x2F;shadow文件作用</h3><p>shadow文件只是用来存储用户的密码，shadow的文件的第二个字段表示该用户是否有设置密码，而用户登录是否需要验证还是要看passwd文件的第二个字段。</p>
<ul>
<li>如果第二个字段为空，表示该用户登录不需要验证。</li>
<li>如果第二个字段为x，表示该用户登录需要进行验证。</li>
</ul>
<h1 id="考点9-常见Linux发行版本"><a href="#考点9-常见Linux发行版本" class="headerlink" title="考点9:常见Linux发行版本"></a>考点9:常见Linux发行版本</h1><p>以下哪几种属于Linux操作系统的发行版？</p>
<ul>
<li>A <code>CentOS</code></li>
<li>B <code>Ubuntu</code></li>
<li>C <code>macOS</code></li>
<li>D <code>Redhat</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>

<p>CentOS：国内非常火的红帽系服务器系统<br>Ubuntu：很流行的桌面Linux版本<br>macOS：苹果的桌面系统，它的内核是不基于Linux的, macOS是类Unix系统<br>Redhat：红帽Linux系统</p>
<h1 id="考点10-subnet命令"><a href="#考点10-subnet命令" class="headerlink" title="考点10:subnet命令"></a>考点10:subnet命令</h1><p>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subnet 166.173.197.131 netmask 255.255.255.192&#123;</span><br><span class="line">range 166.173.197.10 166.173.197.107;</span><br><span class="line">default-lease-time 600;</span><br><span class="line">max-lease-time 7200;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表示？()</p>
<ul>
<li>A 向166.173.197.10网络分配从166.173.197.133到166.173.197.255</li>
<li>B 一个两小时的最大租用时间</li>
<li>C 指定了一个十分钟的缺省租用时间</li>
<li>D 网络地址166.173.197.0</li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<p><code>subnet</code>设置一个子网<code>166.173.197.131/24</code></p>
<ul>
<li><code>range</code>：可分配的<code>IP</code>地址范围上<code>166.173.197.10 ~ 166.173.197.107</code></li>
<li><code>default-lease-time</code>：默认租约时间</li>
<li><code>max-lease-time</code>：最大租约时间</li>
</ul>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Linux</category>
        <category>2021年04月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年04月11日Linux专项练习1</title>
    <url>/exam//80108c66/</url>
    <content><![CDATA[<h1 id="考点1-查看文件内容的命令"><a href="#考点1-查看文件内容的命令" class="headerlink" title="考点1:查看文件内容的命令"></a>考点1:查看文件内容的命令</h1><p>在Linux系统上,下面那个命令不可以用来查看文件内容()</p>
<ul>
<li>A <code>cat</code></li>
<li>B <code>ls</code></li>
<li>C <code>less</code></li>
<li>D <code>more</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>


<h1 id="考点2-查看线程信息功能的gdb命令"><a href="#考点2-查看线程信息功能的gdb命令" class="headerlink" title="考点2:查看线程信息功能的gdb命令"></a>考点2:查看线程信息功能的gdb命令</h1><p>写出完成gdb查看线程信息功能的gdb命令。</p>
<ul>
<li>A <code>bt</code></li>
<li>B <code>info thread</code></li>
<li>C <code>set scheduler-locking off</code></li>
<li>D <code>info break</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>


<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>backtrace bt</strong></td>
<td align="left">打印当前的函数调用栈的所有信息。</td>
</tr>
<tr>
<td align="left"><strong>info threads</strong></td>
<td align="left">显示当前可调试的所有线程，每个线程会有一个GDB为其分配的ID，后面操作线程的时候会用到这个ID。前面有*的是当前调试的线程。</td>
</tr>
<tr>
<td align="left"><strong>set scheduler-locking</strong></td>
<td align="left">线程调试 显示线程状态,参数<strong>off</strong>表示不锁定任何线程</td>
</tr>
<tr>
<td align="left"><strong>info break</strong></td>
<td align="left">可列出所有断点信息，info break 后也可设置要查看的break num</td>
</tr>
</tbody></table>
<h1 id="考点3-八进制文件权限授权命令"><a href="#考点3-八进制文件权限授权命令" class="headerlink" title="考点3:八进制文件权限授权命令"></a>考点3:八进制文件权限授权命令</h1><p>在linux中,将文件属性设置为所有者只读,其余无任何权限的命令为(假设文件名为myfile)</p>
<ul>
<li>A <code>chown 400 myfile</code></li>
<li>B <code>chmod 750 myfile</code></li>
<li>C <code>chown u+r myfile</code></li>
<li>D <code>chmod 400 myfile</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<h1 id="考点4-查看硬盘占用空间和剩余空间"><a href="#考点4-查看硬盘占用空间和剩余空间" class="headerlink" title="考点4:查看硬盘占用空间和剩余空间"></a>考点4:查看硬盘占用空间和剩余空间</h1><p>什么命令用来查看硬盘被占用了多少空间和剩余多少空间？</p>
<ul>
<li>A <code>du</code></li>
<li>B <code>df</code></li>
<li>C <code>free</code></li>
<li>D <code>vmstat</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>


<h3 id="du-disk-usage"><a href="#du-disk-usage" class="headerlink" title="du(disk usage)"></a>du(disk usage)</h3><p>统计目录(或文件)所占磁盘空间的大小<br>查看&#x2F;root目录占用磁盘空间的大小：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# du -h -d 0 /root</span><br><span class="line">45M    /root</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure>
<p>查看&#x2F;root目录以及&#x2F;root目录的一级子目录所占的磁盘空间大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# du -h -d 1 /root</span><br><span class="line">8.0K    /root/.pki</span><br><span class="line">20K    /root/.ssh</span><br><span class="line">2.6M    /root/.nvm</span><br><span class="line">12K    /root/.config</span><br><span class="line">42M    /root/.npm</span><br><span class="line">84K    /root/C_Test</span><br><span class="line">45M    /root</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>
<h3 id="df-disk-free"><a href="#df-disk-free" class="headerlink" title="df(disk free)"></a>df(disk free)</h3><p>用于显示文件系统的磁盘使用情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# df</span><br><span class="line">文件系统                                  1K-块     已用     可用 已用% 挂载点</span><br><span class="line">/dev/block/bootdevice/by-name/userdata 56814352 14404892 42393076   26% /</span><br><span class="line">tmpfs                                   1822552      368  1822184    1% /dev</span><br><span class="line">tmpfs                                   1843032        0  1843032    0% /dev/shm</span><br><span class="line">/data/media                            56763152 14421276 42341876   26% /mnt/files</span><br><span class="line">[root@localhost ~]# df -h</span><br><span class="line">文件系统                                容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/block/bootdevice/by-name/userdata   55G   14G   41G   26% /</span><br><span class="line">tmpfs                                   1.8G  368K  1.8G    1% /dev</span><br><span class="line">tmpfs                                   1.8G     0  1.8G    0% /dev/shm</span><br><span class="line">/data/media                              55G   14G   41G   26% /mnt/files</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        3686064     1383564      673684        2108     1628816     2266427</span><br><span class="line">Swap:             0           0           0</span><br><span class="line">[root@localhost ~]# free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           3.5G        1.3G        657M        2.1M        1.6G        2.2G</span><br><span class="line">Swap:            0B          0B          0B</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>
<h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><p>命令报告关于内核线程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vmstat</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 1  0      0 669372 164900 1529292    0    0    33    27    5   21 15  5 80  0  0</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>

<h1 id="考点5-八进制文件权限"><a href="#考点5-八进制文件权限" class="headerlink" title="考点5:八进制文件权限"></a>考点5:八进制文件权限</h1><p>linux系统中某文件的组外成员的权限为只读;所有者有全部权限;组内的权限为读与写,则该文件的权限为:</p>
<ul>
<li>A 753</li>
<li>B 763</li>
<li>C 754</li>
<li>D 764</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h3 id="ls-l第一列第1位含义"><a href="#ls-l第一列第1位含义" class="headerlink" title="ls -l第一列第1位含义"></a>ls -l第一列第1位含义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost blog]# ls -l</span><br><span class="line">总用量 14056</span><br><span class="line">-rw-r--r--.   1 root root     3196 3月  18 14:47 _config.yml</span><br><span class="line">-rw-r--r--.   1 root root 14159968 3月  20 22:46 db.json</span><br><span class="line">......</span><br><span class="line">drwxr-xr-x. 307 root root     8192 3月  18 14:49 node_modules</span><br><span class="line">-rw-r--r--.   1 root root      817 3月  18 14:49 package.json</span><br><span class="line">......</span><br><span class="line">drwxr-xr-x.   3 root root     4096 3月  18 14:47 themes</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">ls -l第一列第一位</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">l</td>
<td align="left">链接文件</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">目录</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">文件</td>
</tr>
</tbody></table>
<h3 id="ls-l第1列第2到10为含义"><a href="#ls-l第1列第2到10为含义" class="headerlink" title="ls -l第1列第2到10为含义"></a>ls -l第1列第2到10为含义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ls -l</span><br><span class="line">总用量 4</span><br><span class="line">lrwxrwxrwx. 1 root root   15 3月  19 02:30 blog -&gt; /opt/hexo/blog/</span><br><span class="line">drwxr-xr-x. 2 root root 4096 4月   3 22:48 C_Test</span><br><span class="line">lrwxrwxrwx. 1 root root   14 3月  19 21:17 exam -&gt; /opt/hexo/exam</span><br><span class="line">lrwxrwxrwx. 1 root root   11 3月  22 02:43 share -&gt; /mnt/files/</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">ls -l第一列第2~10位</th>
<th align="left">含义</th>
<th align="left">二进制</th>
<th align="left">八进制</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="left">读</td>
<td align="left">100</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">写</td>
<td align="left">010</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">x</td>
<td align="left">执行</td>
<td align="left">001</td>
<td align="left">1</td>
</tr>
</tbody></table>
<h3 id="chmod-八进制写法"><a href="#chmod-八进制写法" class="headerlink" title="chmod 八进制写法"></a>chmod 八进制写法</h3><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">ls -l结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>chmod 777 _config.yml</code></td>
<td align="left"><code>-rwxrwxrwx.   1 root root     3196 3月  18 14:47 _config.yml</code></td>
</tr>
<tr>
<td align="left"><code>chmod 776 _config.yml</code></td>
<td align="left"><code>-rwxrwxrw-.   1 root root     3196 3月  18 14:47 _config.yml</code></td>
</tr>
<tr>
<td align="left"><code>chmod 775 _config.yml</code></td>
<td align="left"><code>-rwxrwxr-x.   1 root root     3196 3月  18 14:47 _config.yml</code></td>
</tr>
<tr>
<td align="left"><code>chmod 774 _config.yml</code></td>
<td align="left"><code>-rwxrwxr--.   1 root root     3196 3月  18 14:47 _config.yml</code></td>
</tr>
<tr>
<td align="left"><code>chmod 773 _config.yml</code></td>
<td align="left"><code>-rwxrwx-wx.   1 root root     3196 3月  18 14:47 _config.yml</code></td>
</tr>
<tr>
<td align="left"><code>chmod 772 _config.yml</code></td>
<td align="left"><code>-rwxrwx-w-.   1 root root     3196 3月  18 14:47 _config.yml</code></td>
</tr>
<tr>
<td align="left"><code>chmod 771 _config.yml</code></td>
<td align="left"><code>-rwxrwx--x.   1 root root     3196 3月  18 14:47 _config.yml</code></td>
</tr>
<tr>
<td align="left"><code>chmod 770 _config.yml</code></td>
<td align="left"><code>-rwxrwx---.   1 root root     3196 3月  18 14:47 _config.yml</code></td>
</tr>
</tbody></table>
<p>u-g-o：用户-组内用户-其他用户<br>r-w-x：用4-2-1表示。<br>所有者u有全部权限：rwx; &#x3D; 7<br>组内g的权限为读与写:rw- &#x3D; 6<br>组外成员o的权限为只读：r– &#x3D; 4 </p>
<h1 id="考点6-fork-方法短路或"><a href="#考点6-fork-方法短路或" class="headerlink" title="考点6:fork()方法短路或"></a>考点6:fork()方法短路或</h1><p>int main(){fork()||fork();}共创建几个进程:___</p>
<ul>
<li>A 1</li>
<li>B 2</li>
<li>C 3</li>
<li>D 4</li>
<li>E 5</li>
<li>F 6</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h3 id="fork-返回值"><a href="#fork-返回值" class="headerlink" title="fork()返回值"></a>fork()返回值</h3><p>fork()<strong>给子进程返回一个零值</strong>，而<strong>给父进程返回一个非零值</strong>；<br>在main这个主进程中，首先执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fork()|| fork()</span><br></pre></td></tr></table></figure>
<p>左边的fork()会复制父进程得到一个子进程，然后左边这个fork()该子进程的ID，也就是返回一个非零值，根据||的短路原则，前面的表达式为真时，后面的表达式不执行，故包含main的这个主进程创建了一个子进程。 </p>
<p>由于子进程会复制父进程，而且子进程会根据fork()的返回值继续执行，就是说，在子进程中的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fork()||fork()</span><br></pre></td></tr></table></figure>
<p>这条语句左边表达式的返回值是0，所以||右边的表达式要执行，这时在子进程中又创建了一个进程， </p>
<p>即main进程-&gt;子进程-&gt;孙子进程，一共创建了3个进程。 </p>
<p><strong>fork函数在父进程中返回新创建子进程的进程ID</strong>，大于0，此时父进程根据左值优先原则，不在与后面进行异或；<br><strong>fork函数在子进程中返回0</strong>，此时子进程仍然需要进行下一个fork函数。</p>
<h3 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h3><figure class="highlight c"><figcaption><span>forkTest.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    fork()||fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num\n&quot;</span>);</span><br><span class="line">    <span class="comment">// sleep(100);</span></span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost C_Test]# ls</span><br><span class="line">a.out       file1.txt  file3.txt  forkTest.c      redCharacter.out  terminalColor.c</span><br><span class="line">command.sh  file2.txt  file4.txt  redCharacter.c  strerror.c        terminalColor.out</span><br><span class="line">[root@localhost C_Test]# gcc forkTest.c -o forkTest.o</span><br><span class="line">[root@localhost C_Test]# ls</span><br><span class="line">a.out       file1.txt  file3.txt  forkTest.c  redCharacter.c    strerror.c       terminalColor.out</span><br><span class="line">command.sh  file2.txt  file4.txt  forkTest.o  redCharacter.out  terminalColor.c</span><br><span class="line">[root@localhost C_Test]# ./forkTest.o </span><br><span class="line">num</span><br><span class="line">num</span><br><span class="line">num</span><br><span class="line">[root@localhost C_Test]# </span><br></pre></td></tr></table></figure>

<h1 id="考点7-Linux守护进程"><a href="#考点7-Linux守护进程" class="headerlink" title="考点7:Linux守护进程"></a>考点7:Linux守护进程</h1><p>网络服务的daemon是:</p>
<ul>
<li>A <code>netd</code></li>
<li>B <code>httpd</code></li>
<li>C <code>inetd</code></li>
<li>D <code>lpd</code></li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>1、 Service就是指常驻内存大一些程序，且可以提供一些系统或是网络功能。提供service的那个程序就成为daemon。Daemon和service可以视为等同，不必刻意去区分。</p>
<h3 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h3><p>2、 Daemon可以分为两类，一类是可独立启动的，成为stand alone；另一类是通过一支super daemon来统一管理的服务。</p>
<p>3、 Stand alone类型的daemon能够自动启动，常驻内存，对请求响应较快，如httpd、vsftpd等。<br>4、 Super daemon统一管理的是用户有请求，super daemon就唤醒响应daemon，如果用户请求结束，就kill掉该daemon。优点不用常驻内存，缺点装到内存需要时间。如telnet。这个super daemon早期是inetd，后来被xinetd取代。<br>这里说的是网络的daemon应该指的是network daemon，netd表示network的守护进程，netd主要负责一些网络的相关配置，操作，管理和查询功能的实现</p>
<p>关于netd的资料找到的很少，以下是唯一找到的一片文章介绍的 <a href="http://gaozhipeng.me/posts/netd-learn1/" target="_blank">http://gaozhipeng.me/posts/netd-learn1/</a> </pre></p>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><blockquote>
<p><a href="https://zh.wikipedia.org/zh-cn/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">https://zh.wikipedia.org/zh-cn/守护进程</a><br>在一个多任务的电脑操作系统中，守护进程（英语：daemon，&#x2F;ˈdiːmən&#x2F;或&#x2F;ˈdeɪmən&#x2F;）是一种在后台执行的电脑程序。此类程序会被以进程的形式初始化。守护进程程序的名称通常以字母“d”结尾：例如，syslogd就是指管理系统日志的守护进程。<br>通常，守护进程没有任何存在的父进程（即PPID&#x3D;1），且在UNIX系统进程层级中直接位于init之下。守护进程程序通常通过如下方法使自己成为守护进程：对一个子进程运行fork，然后使其父进程立即终止，使得这个子进程能在init下运行。这种方法通常被称为“脱壳”。<br>系统通常在启动时一同引导守护进程。守护进程为对网络请求，硬件活动等进行响应，或其他通过某些任务对其他应用程序的请求进行回应提供支持。守护进程也能够对硬件进行配置（如在某些Linux系统上的devfsd），运行计划任务（例如cron），以及运行其他任务。<br>在DOS环境中，此类应用程序被称为驻留程序（TSR）。在Windows系统中，由称为Windows服务的应用程序来履行守护进程的职责。<br>在原本的Mac OS系统中，此类应用程序被称为“extensions”。而作为Unix-like的Mac OS X有守护进程。（在Mac OS X中也有“服务”，但他们与Windows中类似的程序在概念上完全不相同。）<br><a href="http://c.biancheng.net/view/5935.html">http://c.biancheng.net/view/5935.html</a></p>
</blockquote>
<blockquote>
<p><a href="https://baike.baidu.com/item/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">https://baike.baidu.com/item/守护进程</a><br>按照服务类型分为如下几个。<br>系统守护进程：syslogd、login、crond、at等。<br>网络守护进程：sendmail、httpd、xinetd、等。<br>独立启动的守护进程：httpd、named、xinetd等。<br>被动守护进程（由xinetd启动）：telnet、finger、ktalk等。</p>
</blockquote>
<h1 id="考点8-Linux多线程编程pthread库函数"><a href="#考点8-Linux多线程编程pthread库函数" class="headerlink" title="考点8:Linux多线程编程pthread库函数"></a>考点8:Linux多线程编程pthread库函数</h1><p>下述是Linux下多线程编程常用的pthread库提供的函数名和意义,说法正确的有？</p>
<ul>
<li>A <code>pthread_create</code> 创建一个线程</li>
<li>B <code>pthread_join</code>用来等待一个线程的结束</li>
<li>C <code>pthread_mutex_init</code> 初始化一个线程互斥锁</li>
<li>D <code>pthread_exit</code>结束一个线程</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>


<h1 id="考点9-Nginx配置文件nginx-conf"><a href="#考点9-Nginx配置文件nginx-conf" class="headerlink" title="考点9:Nginx配置文件nginx.conf"></a>考点9:Nginx配置文件nginx.conf</h1><p>下列有关Nginx配置文件nginx.conf的叙述正确的是()</p>
<ul>
<li>A <code>nginx</code>进程数设置为<code>CPU</code>总核心数最佳</li>
<li>B 虚拟主机配置多个域名时,各域名间应用逗号隔开</li>
<li>C <code>sendfile on;</code>表示为开启高效文件传输模式,对于执行下载操作等相关应用时,应设置为<code>on</code></li>
<li>D 设置工作模式与连接数上限时,应考虑单个进程最大连接数(最大连接数&#x3D;连接数*进程数)</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details>

<blockquote>
<p>参考网络上的一篇总结。  Nginx配置文件nginx.conf中文详解<br>详见：<a href="%3Ehttp://www.2cto.com/os/201212/176520.html">&gt;http://www.2cto.com/os/201212/176520.html</a><br>A. 进程数设置为CPU总核心数最佳。  (正确)<br>B. 配置虚拟主机，多个域名时，用 <strong>空格</strong> 分隔。 (错误)<br>C. 设定http服务器中 sendfile on;   #开启高效文件传输模式<br>    普通应用设置为on； 用于进行下载等应用磁盘IO重负载应用，设置为<strong>off</strong>，以平衡磁盘与网络I&#x2F;O处理速度，降低系统的负载。(错误)<br>D. 工作模式与连接数上限 ：（最大连接数 &#x3D; 连接数 * 进程数）(正确) </p>
</blockquote>
<h1 id="考点10-DNS服务主配置文件有哪些"><a href="#考点10-DNS服务主配置文件有哪些" class="headerlink" title="考点10:DNS服务主配置文件有哪些"></a>考点10:DNS服务主配置文件有哪些</h1><p>下列不是dns服务主配置文件的是(      )。</p>
<ul>
<li>A <code>named.conf</code></li>
<li>B <code>dns.conf</code></li>
<li>C <code>name.conf</code></li>
<li>D <code>named.local</code></li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details>

]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Linux</category>
        <category>2021年04月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年04月12日Linux专项练习1</title>
    <url>/exam//b9682126/</url>
    <content><![CDATA[<h1 id="考点1-常见Linux命令"><a href="#考点1-常见Linux命令" class="headerlink" title="考点1:常见Linux命令"></a>考点1:常见Linux命令</h1><p>以下不属于Linux系统命令的是:</p>
<ul>
<li>A <code>kill</code></li>
<li>B <code>ifconfig</code></li>
<li>C <code>mv</code></li>
<li>D <code>remove</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>Linux没有remove命令，但是有rm</p>
<h1 id="考点2-八进制权限"><a href="#考点2-八进制权限" class="headerlink" title="考点2:八进制权限"></a>考点2:八进制权限</h1><p>linux系统中某文件的组外成员的权限为只读;所有者有全部权限;组内的权限为读与写,则该文件的权限为:</p>
<ul>
<li>A 753</li>
<li>B 763</li>
<li>C 754</li>
<li>D 764</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<h1 id="考点3-unix授权命令"><a href="#考点3-unix授权命令" class="headerlink" title="考点3:unix授权命令"></a>考点3:unix授权命令</h1><p>在unix系统下执行chmod(“&#x2F;usr&#x2F;test&#x2F;sample”,0753)之后该文件sample的访问权限为</p>
<ul>
<li>A 拥有者可读写执行,同组用户可写可执行,其他用户可读可执行</li>
<li>B 拥有者可读写执行,同组用户可读写,其他用户可读可执行</li>
<li>C 拥有者可读写执行,同组用户可读可执行,其他用户可写可执行</li>
<li>D 拥有者可读写执行,同组用户可读可执行,其他用户可读写</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h1 id="考点4-Linux终止前台进程"><a href="#考点4-Linux终止前台进程" class="headerlink" title="考点4:Linux终止前台进程"></a>考点4:Linux终止前台进程</h1><p>终止一个前台进程可能用到的命令和操作是？</p>
<ul>
<li>A <code>kill</code></li>
<li>B <code>ctrl+C</code></li>
<li>C <code>shut down</code></li>
<li>D <code>halt</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="Linux如何终止前台进程"><a href="#Linux如何终止前台进程" class="headerlink" title="Linux如何终止前台进程"></a>Linux如何终止前台进程</h3><p>终止一个前台进程用<br>ctrl+C；</p>
<h3 id="Linux如何终止后台进程"><a href="#Linux如何终止后台进程" class="headerlink" title="Linux如何终止后台进程"></a>Linux如何终止后台进程</h3><p>终止一个后台进程：<br>1、使用kill命令；<br>2、使用fg命令将后台进程变为前台进程，然后ctrl+C。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">kill</td>
<td align="left">无参数表示向进程输入关闭的指令</td>
</tr>
<tr>
<td align="left">Ctrl+C</td>
<td align="left">关闭当前（前台）进程</td>
</tr>
<tr>
<td align="left">Chrl+Z</td>
<td align="left">暂停当前（前台）进程</td>
</tr>
<tr>
<td align="left">shutdown</td>
<td align="left">关机</td>
</tr>
<tr>
<td align="left">halt</td>
<td align="left">就是调用shutdown -h(立即关机)</td>
</tr>
</tbody></table>
<h1 id="考点5-Linux内核子系统"><a href="#考点5-Linux内核子系统" class="headerlink" title="考点5:Linux内核子系统"></a>考点5:Linux内核子系统</h1><p>内核不包括的子系统是 。</p>
<ul>
<li>A 进程管理系统</li>
<li>B 内存管理系统</li>
<li>C <code>I/O</code>管理系统</li>
<li>D 硬件管理系统</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>内核分为 <strong>进程管理系统 、 内存管理系统 、 I&#x2F;O管理系统 和文件管理系统</strong>等四个子系统。<br>硬件管理系统一听就不切实际阿 因为内核是一串指令。</p>
<h1 id="考点6-Linux查看系统负载命令"><a href="#考点6-Linux查看系统负载命令" class="headerlink" title="考点6:Linux查看系统负载命令"></a>考点6:Linux查看系统负载命令</h1><p>下面有关linux查看系统负载的命令,说法错误的是？</p>
<ul>
<li>A <code>uptime</code>命令主要用于获取主机运行时间和查询<code>linux</code>系统负载等信息</li>
<li>B <code>vmstat</code>命令可以查看查看<code>cpu</code>负载</li>
<li>C <code>sar</code>命令可以查看网络接口信息</li>
<li>D <code>free</code>命令可以查看磁盘负载情况</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# uptime</span><br><span class="line"> 01:17:27 up 2 days, 13:36,  1 user,  load average: 8.92, 8.93, 9.28</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vmstat</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 3  0      0 124912 116352 1516588    0    0    34    27   31   21 15  5 79  0  0</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>
<h3 id="vmstat帮助文档"><a href="#vmstat帮助文档" class="headerlink" title="vmstat帮助文档"></a>vmstat帮助文档</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vmstat --help</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"> vmstat [options] [delay [count]]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"> -a, --active           active/inactive memory</span><br><span class="line"> -f, --forks            number of forks since boot</span><br><span class="line"> -m, --slabs            slabinfo</span><br><span class="line"> -n, --one-header       do not redisplay header</span><br><span class="line"> -s, --stats            event counter statistics</span><br><span class="line"> -d, --disk             disk statistics</span><br><span class="line"> -D, --disk-sum         summarize disk statistics</span><br><span class="line"> -p, --partition &lt;dev&gt;  partition specific statistics</span><br><span class="line"> -S, --unit &lt;char&gt;      define display unit</span><br><span class="line"> -w, --wide             wide output</span><br><span class="line"> -t, --timestamp        show timestamp</span><br><span class="line"></span><br><span class="line"> -h, --help     display this help and exit</span><br><span class="line"> -V, --version  output version information and exit</span><br><span class="line"></span><br><span class="line">For more details see vmstat(8).</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>
<h3 id="uptime帮助文档"><a href="#uptime帮助文档" class="headerlink" title="uptime帮助文档"></a>uptime帮助文档</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# uptime --help</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"> uptime [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"> -p, --pretty   show uptime in pretty format</span><br><span class="line"> -h, --help     display this help and exit</span><br><span class="line"> -s, --since    system up since</span><br><span class="line"> -V, --version  output version information and exit</span><br><span class="line"></span><br><span class="line">For more details see uptime(1).</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>
<h3 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        3686064     1917344      154528        1508     1614192     1733323</span><br><span class="line">Swap:             0           0           0</span><br><span class="line">[root@localhost ~]# free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           3.5G        1.8G        151M        1.5M        1.5G        1.7G</span><br><span class="line">Swap:            0B          0B          0B</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>
<p>free描述的是内存使用情况，不是磁盘负载。<br>free查看内存使用情况，并非磁盘。磁盘可以使用df命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           3.5G        1.8G         92M        1.5M        1.6G        1.6G</span><br><span class="line">Swap:            0B          0B          0B</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>
<p>可以看到当前Linux的内存有3.5G,已经使用了1.8G内存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# df -h</span><br><span class="line">文件系统                                容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/block/bootdevice/by-name/userdata   55G   14G   41G   26% /</span><br><span class="line">tmpfs                                   1.8G  368K  1.8G    1% /dev</span><br><span class="line">tmpfs                                   1.8G     0  1.8G    0% /dev/shm</span><br><span class="line">/data/media                              55G   14G   41G   26% /mnt/files</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>
<p>可以看到磁盘容量为55G，已用14G，有41G可以用。</p>
<h1 id="考点7-z-string-短路与-短路或"><a href="#考点7-z-string-短路与-短路或" class="headerlink" title="考点7:[-z string] 短路与 短路或"></a>考点7:[-z string] 短路与 短路或</h1><p>命令:<code>[-z&quot;&quot;]&amp;&amp;echo 0 ||echo 1</code>的输出是什么</p>
<ul>
<li>A 1</li>
<li>B 0</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="z-STRING-命令-n-string-命令"><a href="#z-STRING-命令-n-string-命令" class="headerlink" title="[-z STRING]命令[-n string]命令"></a>[-z STRING]命令[-n string]命令</h3><p><code>[-z STRING]</code> “STRING” 的长度为零则为真<br><code>[-z &quot;&quot;]</code>长度为零，返回1，故执行&amp;&amp;后面的语句 echo 0显示“0”,返回1，故不执行echo 1 最终结果为0 </p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>[-z string]</code></td>
<td align="left">“<code>string</code>”的长度为零则为真。我的理解是<code>[-z string]</code>就是<code>[-zero string]</code></td>
</tr>
<tr>
<td align="left"><code>[-n string] or [string]</code></td>
<td align="left">“<code>string</code>”的长度为非零，则为真。<code>[-n string]</code>就是<code>[non-zero string]</code></td>
</tr>
</tbody></table>
<h1 id="考点8-Redhat9安装方式"><a href="#考点8-Redhat9安装方式" class="headerlink" title="考点8:Redhat9安装方式"></a>考点8:Redhat9安装方式</h1><p>Redhat9 所支持的安装方式有()</p>
<ul>
<li>A 从本地硬盘驱动器进行安装</li>
<li>B 通过<code>Telnet</code>进行网络安装</li>
<li>C 通过<code>NFS</code>进行网络安装</li>
<li>D 通过<code>HTTP</code>进行网络安装</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details>

<p><strong>没用过红帽好伐，所以百度鸟解了一哈🤣</strong><br>从安装启动方式可以分为:软盘启动 光盘启动 U盘启动(红帽9还支持制作安装启动软盘的,只是软盘现在基本见不到了) 从软件安装来源可以分为:光盘、硬盘、nfs服务器、ftp服务器、http服务器<br>最简单的方式就是光盘引导，光盘安装。<br>其他安装方式还有KickStart无人值守安装等。</p>
<h1 id="考点9-批量删除当前目录下的文件"><a href="#考点9-批量删除当前目录下的文件" class="headerlink" title="考点9:批量删除当前目录下的文件"></a>考点9:批量删除当前目录下的文件</h1><p>批量删除当前目录下后缀名为.c的文件。如a.c、b.c。</p>
<ul>
<li>A rm *.c</li>
<li>B find . -name “*.c” -maxdepth 1 | xargs rm</li>
<li>C find . -name “*.c” | xargs rm</li>
<li>D 以上都不正确</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AB</details>

<p>xargs是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。它能够捕获一个命令的输出，然后传递给另外一个命令，当你尝试用rm 由于题目中是说删除当前目录下后缀名为.c的文件，故需要加上-maxdepth 1，表示是当前目录，不包括其子目录。</p>
<p><code>find . -name &quot;*.c&quot; -maxdepth 1</code>表示找到.(当前目录下)名字为以“.c”为后缀的文件，-maxdepth 1表示目录深度为1，也就是寻找当前目录 </p>
<h1 id="考点10-查看Linux主机的默认路由"><a href="#考点10-查看Linux主机的默认路由" class="headerlink" title="考点10:查看Linux主机的默认路由"></a>考点10:查看Linux主机的默认路由</h1><p>下面那些命令可以用来查看Linux主机的默认路由()</p>
<ul>
<li>A <code>route</code></li>
<li>B <code>ifconfig</code></li>
<li>C <code>ping</code></li>
<li>D <code>netstat</code></li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details>

<p>直接route命令就可以显示默认路由，netstat命令需要加一个参数-route</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">young@young-Lenovo-G470:~$ route</span><br><span class="line">内核 IP 路由表</span><br><span class="line">目标 网关 子网掩码 标志 跃点 引用 使用 接口</span><br><span class="line">default 172.28.234.1 0.0.0.0 UG 0 0 0 wlan0</span><br><span class="line">172.28.234.0 * 255.255.254.0 U 9 0 0 wlan0</span><br><span class="line">young@young-Lenovo-G470:~$ netstat -route</span><br><span class="line">内核 IP 路由表</span><br><span class="line">目标 网关 子网掩码 标志 跃点 引用 使用 接口</span><br><span class="line">default 172.28.234.1 0.0.0.0 UG 0 0 0 wlan0</span><br><span class="line">172.28.234.0 * 255.255.254.0 U 9 0 0 wlan0</span><br><span class="line">young@young-Lenovo-G470:~$</span><br></pre></td></tr></table></figure>

<p>route命令用来显示目前本机路由表的内容，并且还可以针对路由表中的记录来进行相应的添加、删除或修改等操作。<br>ifconfig命令用来来检测和设置本机的网络接口。<br>ping命令用来检测两部主机之间的传输信道是否畅通，或远程主机是否正常<br>netstat命令用来查看主机的连接状态 </p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Linux</category>
        <category>2021年04月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年04月12日Linux专项练习2</title>
    <url>/exam//f050cb01/</url>
    <content><![CDATA[<h1 id="考点1-vi-末行模式相关命令"><a href="#考点1-vi-末行模式相关命令" class="headerlink" title="考点1:vi 末行模式相关命令"></a>考点1:vi 末行模式相关命令</h1><p>你使用命令”vi&#x2F;etc&#x2F;inittab”查看该文件的内容,你不小心改动了一些内容,为了防止系统出为,你不想保存所修改的内容,你应该如何操作:</p>
<ul>
<li>A 在末行模式下,键入<code>:wq</code></li>
<li>B 在末行模式下,键入<code>:q!</code></li>
<li>C 在末行模式下,键入<code>:x!</code></li>
<li>D 在编辑模式下,键入”ESC”键直接退出vi</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>


<table>
<thead>
<tr>
<th align="left">vi末行模式命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">:wq</td>
<td align="left">强制性写入文件并退出。即使文件没有被修改也强制写入，并更新文件的修改时间。</td>
</tr>
<tr>
<td align="left">:q！</td>
<td align="left">直接强制退出</td>
</tr>
<tr>
<td align="left">:x！</td>
<td align="left">写入文件并退出。仅当文件被修改时才写入，并更新文件修改时间，否则不会更新文件修改时间。</td>
</tr>
</tbody></table>
<p>在编辑模式下，键入”ESC”键不退出vi 直接进入命令模式</p>
<h1 id="考点2-Linux默认的Shell"><a href="#考点2-Linux默认的Shell" class="headerlink" title="考点2:Linux默认的Shell"></a>考点2:Linux默认的Shell</h1><p>shell不仅仅是用户命令解释器,同时一种强大的编程语言,linux缺省的shell是什么</p>
<ul>
<li>A <code>bash</code></li>
<li>B <code>ruby</code></li>
<li>C <code>PHP</code></li>
<li>D <code>perl</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<h1 id="考点3-如何退出交互式Shell"><a href="#考点3-如何退出交互式Shell" class="headerlink" title="考点3:如何退出交互式Shell"></a>考点3:如何退出交互式Shell</h1><p>退出交互式的shell,应键入(    )</p>
<ul>
<li>A <code>Esc</code></li>
<li>B <code>q</code></li>
<li>C <code>exit</code></li>
<li>D <code>quit</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<ul>
<li>esc，在vi的插入模式或者底行命令模式下进入命令模式 </li>
<li>q，用来退出 man 手册查看命令或者配置文件的状态，或者more、less等命令查看文件的状态 </li>
<li>exit，一般用于退出会话式程序或者交互式命令行，如ssh远程连接，切换 shell（Linux中） </li>
<li>quit，一般用于图形界面的退出</li>
</ul>
<p>以上的exit和quit仅是个人总结，非权威，python中的exit()和quit()都可以用来退出python的交互式shell</p>
<h1 id="考点4-Linux查找字符串grep"><a href="#考点4-Linux查找字符串grep" class="headerlink" title="考点4:Linux查找字符串grep"></a>考点4:Linux查找字符串grep</h1><p>Linux系统中在给定文件中查找与设定条件相符字符串的命令为？</p>
<ul>
<li>A <code>grep</code></li>
<li>B <code>gzip</code></li>
<li>C <code>find</code></li>
<li>D <code>sort</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>grep：查找文件内的内容<br>gzip：压缩文件，文件经压缩后会增加.gz扩展名<br>find：在指定目录下查找文件<br>sort：排序</p>
<h1 id="考点5-Linux任务计划"><a href="#考点5-Linux任务计划" class="headerlink" title="考点5:Linux任务计划"></a>考点5:Linux任务计划</h1><p>假如你想计划让系统自动在每个月的第一天早上4点钟执行一个维护工作,以下哪个cron是正确的？</p>
<ul>
<li>A <code>00 4 1 1-12 * /maintenance.pl</code></li>
<li>B <code>4 1 * * ~/maintenance.pl</code></li>
<li>C <code>0 4 31 /1 * * ~/maintenance.pl</code></li>
<li>D <code>1 4 00 ~/maintenance.pl</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h3 id="Linux计划任务格式"><a href="#Linux计划任务格式" class="headerlink" title="Linux计划任务格式"></a>Linux计划任务格式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分 时 日 月 周  命令/脚本 </span><br></pre></td></tr></table></figure>
<p>上面的周，1表示星期天，…6表示星期六，0，表示星期天</p>
<h3 id="如何查看任务计划表"><a href="#如何查看任务计划表" class="headerlink" title="如何查看任务计划表"></a>如何查看任务计划表</h3><p>你们可以打开 &#x2F;etc&#x2F;crontab 里面就是任务计划表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/crontab</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]&amp;#35; cat /etc/crontab</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line"></span><br><span class="line">&amp;#35; For details see man 4 crontabs</span><br><span class="line"></span><br><span class="line">&amp;#35; Example of job definition:</span><br><span class="line">&amp;#35; .---------------- minute (0 - 59)</span><br><span class="line">&amp;#35; |  .------------- hour (0 - 23)</span><br><span class="line">&amp;#35; |  |  .---------- day of month (1 - 31)</span><br><span class="line">&amp;#35; |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class="line">&amp;#35; |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="line">&amp;#35; |  |  |  |  |</span><br><span class="line">&amp;#35; *  *  *  *  * user-name  command to be executed</span><br><span class="line"></span><br><span class="line">[root@localhost ~]&amp;#35; </span><br></pre></td></tr></table></figure>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>每天04:00 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 4 * * * 要执行的命令 </span><br></pre></td></tr></table></figure>
<p>周二和周五18:00 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 18 * * 2,5 要执行的命令 </span><br></pre></td></tr></table></figure>
<p>1月到3月份， 周二和周五18:00 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 18 * 1-3 2,5 要执行的命令 </span><br></pre></td></tr></table></figure>
<p>周一到周五17:30发广播，然后17:45分关机<br>写两条计划任务，不是只能写一条 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">30 17 * * 1-5 /usr/bin/wall &lt; /root/msg </span><br><span class="line">45 17 * * 1-5 /sbin/shutdown -h now </span><br></pre></td></tr></table></figure>
<p>中午12点到14点，每两分钟(偶数) </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*/2 12-14 * * * 命令 </span><br></pre></td></tr></table></figure>


<h1 id="考点6-导致进程从用户态切换到内核态的情况"><a href="#考点6-导致进程从用户态切换到内核态的情况" class="headerlink" title="考点6:导致进程从用户态切换到内核态的情况"></a>考点6:导致进程从用户态切换到内核态的情况</h1><p>下列选项中,会导致用户进程从用户态切换到内核的操作是?<br>I. 整数除以零<br>II. sin( )函数调用<br>III. read系统调用</p>
<ul>
<li>A 仅 I、II</li>
<li>B 仅 I、III</li>
<li>C 仅 II 、III</li>
<li>D I、II和III</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="用户态切换到内核态的3种方式"><a href="#用户态切换到内核态的3种方式" class="headerlink" title="用户态切换到内核态的3种方式"></a>用户态切换到内核态的3种方式</h3><p>a. 系统调用<br>b. 异常<br>c. 外围设备的中断</p>
<h1 id="考点7-Linux统计重复行uniq-按行排序sort-查看文件头head"><a href="#考点7-Linux统计重复行uniq-按行排序sort-查看文件头head" class="headerlink" title="考点7:Linux统计重复行uniq 按行排序sort 查看文件头head"></a>考点7:Linux统计重复行uniq 按行排序sort 查看文件头head</h1><p>有一个文件ip.txt,每行一条ip记录,共若干行,已排好序,下面哪个命令可以实现”统计出现次数最多的前3个ip及其次数”？( )</p>
<ul>
<li>A uniq -c ip.txt</li>
<li>B uniq -c ip.txt | sort -nr | head -n 3</li>
<li>C cat ip.txt | count -n | sort -rn | head -n 3</li>
<li>D cat ip.txt | count -n</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>



<p><code>uniq</code>命令：报告或删去重复行，加上<code>-n</code>参数可以统计重复行出现的次数（放在每行开头）。<br><code>sort</code>命令：对文本按行进行排序，<code>-n</code>参数表示根据数字大小排序；<code>-r</code>，对应英文单词是reverse，意思是反转排序结果，<code>sort</code>默认是从小到大排序，加上这个参数可以实现从大到小排序。<br><code>head</code>命令：取文件的前一部分（默认输出前10行）。加<code>-n [数字]</code>可以指定到底是前几行。<br>把这三个命令的作用都搞懂，再加上一点 <em>Linux管道符</em> 的知识，这道题目也就很容易解决了。最好是自己动手在命令行下实践几次，加深印象，容易记牢。</p>
<h1 id="考点8-授权-修改属主-修改属组"><a href="#考点8-授权-修改属主-修改属组" class="headerlink" title="考点8:授权 修改属主 修改属组"></a>考点8:授权 修改属主 修改属组</h1><p>软件项目存储于&#x2F;ftproot,允许apache用户修改所有程序,设置访问权限的指令？</p>
<ul>
<li>A <code>chmod 777 /ftproot</code></li>
<li>B <code>chgrp apache /frproot</code></li>
<li>C <code>chown apache /ftproot</code></li>
<li>D <code>chmod apache /ftproot</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>chmod +权限 +文件或目录<br>chown +属主.属组+文件或目录<br>chgrp +属组 +目录<br>就本题目而言，设置目录的权限可以这样： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 /ftproot</span><br></pre></td></tr></table></figure>
<p>但是这样做的话所有的用户都可以操作该目录，不是个很好的解决方案。</p>
<p>也可以直接设置目录的属主为apache： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown apache /ftproot</span><br></pre></td></tr></table></figure>
<p>然后再加上权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 7xx /ftproot</span><br></pre></td></tr></table></figure>
<p>把文件夹的属主改成了apache也不代表apache用户能修改所有程序，因为文件所有者权限有可能不可写。</p>
<blockquote>
<p>这个题目有问题，如果<code>/ftproot</code>是个目录，这样的话，<code>chmod 777 -r /ftproot</code>才能修改该目录下的所有程序。</p>
</blockquote>
<h1 id="考点9-makefile"><a href="#考点9-makefile" class="headerlink" title="考点9:makefile"></a>考点9:makefile</h1><p>下列关于makefile描述正确的有？</p>
<ul>
<li>A <code>makefile</code>文件保存了编译器和连接器的参数选项</li>
<li>B 主要包含了五个东西:显式规则、隐晦规则、变量定义、文件指示和注释</li>
<li>C 默认的情况下,<code>make</code>命令会在当前目录下按顺序找寻文件名为”<code>GNUmakefile</code>“、”<code>makefile</code>“、”<code>Makefile</code>“的文件, 找到了解释这个文件</li>
<li>D 在<code>Makefile</code>不可以使用<code>include</code>关键字把别的<code>Makefile</code>包含进来</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>


<p>makefile文件保存了编译器和连接器的参数选项,还表述了所有源文件之间的关系(源代码文件需要的特定的包含文件,可执行文件要求包含的目标文件模块及库等).创建程序(make程序)首先读取makefile文件,然后再激活编译器,汇编器,资源编译器和连接器以便产生最后的输出,最后输出并生成的通常是可执行文件.创建程序利用内置的推理规则来激活编译器,以便通过对特定CPP文件的编译来产生特定的OBJ文件.<br>Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。<br>1、显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。<br>2、隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。<br>3、变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。<br>4、文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。<br>5、注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C&#x2F;C++中的“&#x2F;&#x2F;”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“#”。<br>默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用 “GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。<br>在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include &amp;lt;filename&amp;gt;; </span><br></pre></td></tr></table></figure>
<p>filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）</p>
<h1 id="考点10-硬链接"><a href="#考点10-硬链接" class="headerlink" title="考点10:硬链接"></a>考点10:硬链接</h1><p>在Linux系统,关于硬链接的描述正确的是()</p>
<ul>
<li>A 跨文件系统</li>
<li>B 不可以跨文件系统</li>
<li>C 为链接文件创建新的i节点</li>
<li>D 链接文件的i节点与被链接文件的i节点相同</li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BD</details>

<h3 id="链接分硬链接和符号链接"><a href="#链接分硬链接和符号链接" class="headerlink" title="链接分硬链接和符号链接"></a>链接分硬链接和符号链接</h3><ul>
<li><p>符号链接可以建立对于文件和目录的链接。</p>
</li>
<li><p>符号链接可以跨文件系统，即可以跨磁盘分区。</p>
</li>
<li><p>符号链接的文件类型位是l，链接文件具有新的i节点。</p>
</li>
<li><p>硬链接不可以跨文件系统。它只能建立对文件的链接，</p>
</li>
<li><p>硬链接的文件类型位是－，且硬链接文件的i节点同被链接文件的i节点相同。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Linux</category>
        <category>2021年04月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年04月12日Linux专项练习3</title>
    <url>/exam//5766400a/</url>
    <content><![CDATA[<h1 id="考点1-find查找更改时间比一个文件新但比另一个文件旧的文件"><a href="#考点1-find查找更改时间比一个文件新但比另一个文件旧的文件" class="headerlink" title="考点1:find查找更改时间比一个文件新但比另一个文件旧的文件"></a>考点1:find查找更改时间比一个文件新但比另一个文件旧的文件</h1><p><code>find . -newer file1 \! \( -newer file2 \)</code>命令的意思是？</p>
<ul>
<li>A 查找更改时间比文件<code>file1</code>新但比文件<code>file2</code>旧的文件</li>
<li>B 查找更改时间比文件<code>file1</code>旧但比文件<code>file2</code>新的文件</li>
<li>C 查找更改时间比文件<code>file1</code>旧且比文件<code>file2</code>旧的文件</li>
<li>D 查找更改时间比文件<code>file1</code>新且比文件<code>file2</code>新的文件</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost exam]# ls -ltr --full-time</span><br><span class="line">总用量 3640</span><br><span class="line">-rw-r--r--.   1 root root     422 2021-03-19 21:12:12.566962591 +0800 StartWriting.bat</span><br><span class="line">drwxr-xr-x.   2 root root    4096 2021-03-19 21:12:12.566962591 +0800 scaffolds</span><br><span class="line">-rw-r--r--.   1 root root     817 2021-03-19 21:12:12.566962591 +0800 package.json</span><br><span class="line">-rw-r--r--.   1 root root     376 2021-03-19 21:12:12.566962591 +0800 HexoSTest.bat</span><br><span class="line">-rw-r--r--.   1 root root     576 2021-03-19 21:12:12.566962591 +0800 HexoD.bat</span><br><span class="line">-rw-r--r--.   1 root root     158 2021-03-19 21:12:12.566962591 +0800 FM.properties</span><br><span class="line">-rw-r--r--.   1 root root    3093 2021-03-19 21:12:12.566962591 +0800 _config.yml</span><br><span class="line">drwxr-xr-x.   3 root root    4096 2021-03-19 21:12:12.636962591 +0800 themes</span><br><span class="line">drwxr-xr-x.   9 root root    4096 2021-03-19 21:12:12.636962591 +0800 source</span><br><span class="line">-rwxr--r--.   1 root root     174 2021-03-19 21:16:37.816962490 +0800 hexos.sh</span><br><span class="line">drwxr-xr-x. 308 root root    8192 2021-03-19 21:19:12.036962431 +0800 node_modules</span><br><span class="line">-rw-r--r--.   1 root root  170424 2021-03-19 21:19:12.746962431 +0800 package-lock.json</span><br><span class="line">-rw-r--r--.   1 root root 3498022 2021-03-22 20:29:10.927984900 +0800 db.json</span><br><span class="line">-rw-r--r--.   1 root root     431 2021-03-22 20:52:44.997984360 +0800 HexoS.bat</span><br><span class="line">[root@localhost exam]# find . -maxdepth 1 -newer StartWriting.bat \! \( -newer HexoS.bat \)</span><br><span class="line">./HexoS.bat</span><br><span class="line">./source</span><br><span class="line">./themes</span><br><span class="line">./hexos.sh</span><br><span class="line">./node_modules</span><br><span class="line">./db.json</span><br><span class="line">./package-lock.json</span><br><span class="line">[root@localhost exam]# </span><br></pre></td></tr></table></figure>

<h1 id="考点2-x2F-etc-x2F-passwd中用户组ID与etc-x2F-group中的用户组ID不匹配导致用户无法登录的问题"><a href="#考点2-x2F-etc-x2F-passwd中用户组ID与etc-x2F-group中的用户组ID不匹配导致用户无法登录的问题" class="headerlink" title="考点2:&#x2F;etc&#x2F;passwd中用户组ID与etc&#x2F;group中的用户组ID不匹配导致用户无法登录的问题"></a>考点2:&#x2F;etc&#x2F;passwd中用户组ID与etc&#x2F;group中的用户组ID不匹配导致用户无法登录的问题</h1><p>你通过编辑&#x2F;etc&#x2F;group文件来改变了sales group的GID,所有的组员都能成功的进行的转换,除了Jack,他甚至都无法登陆,其原因是什么？</p>
<ul>
<li>A <code>Jack</code>忘记了<code>group</code>密码</li>
<li>B <code>Jack</code>需要再次被加入到<code>group</code></li>
<li>C 在<code>/etc/passwd</code>里指明了<code>Jack</code>的<code>GID</code></li>
<li>D <code>Jack</code>的账号需要被删除然后新建</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<ul>
<li>&#x2F;etc&#x2F;group是用户组信息文件，里面定义了<strong>用户组的ID</strong>, </li>
<li>&#x2F;etc&#x2F;passwd是用户基本信息文件，里面定义了<strong>用户的ID</strong>，<strong>用户组的ID</strong>等相关信息。</li>
</ul>
<p>所以因为两个文件中都定义了用户组的信息，所以两个文件应该都要改过来，否则会导致用户找不到所属组 </p>
<h1 id="考点3-硬链接和符号连接"><a href="#考点3-硬链接和符号连接" class="headerlink" title="考点3:硬链接和符号连接"></a>考点3:硬链接和符号连接</h1><p>下列关于链接描述,错误的是 。</p>
<ul>
<li>A 硬链接就是让链接文件的i节点号指向被链接文件的i节点</li>
<li>B 硬链接和符号连接都是产生一个新的i节点</li>
<li>C 链接分为硬链接和符号链接</li>
<li>D 硬连接不能链接目录文件</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>（1）软连接可以跨文件系统，硬连接不可以<br>（2）硬连接不管有多少个，都指向的是同一个I节点，会把结点连接数增加，只要结点的连接数不是0，文件就一直存在不管你删除的是源文件还是连接的文件。只要有一个存在文件就存在。当你修改源文件或者连接文件任何一个的时候，其他的文件都会做同步的修改。软链接不直接使用i节点号作为文件指针,<br>而是使用文件路径名作为指针。所以删除连接文件对源文件无影响，但是删除源文件，连接文件就会找不到要指向的文件。软链接有自己的inode, 并在磁盘上有一小片空间存放路径名。<br>（3）软连接可以对一个不存在的文件名进行连接 。<br>（4）软连接可以对目录进行连接。</p>
<p>硬连接不管有多少个，都指向的是同一个I节点，<br>只有符号链接才产生新的inode节点。<br><img data-src="https://uploadfiles.nowcoder.com/images/20190328/3472441_1553739357281_F960C6C562BF518E7DC94B8CA23A374F"><br>硬连接不能连接文件目录，软连接才可以。<br>硬连接不会产生新节点，硬连接指向同一节点inode。</p>
<p>Inode是UNIX中一种数据结构，包含了与文件系统中各个文件相关的一些重要信息，在文件系统创建时，同时会创建大量的inode。它用作数据索引的标识符，系统找到文件对应的inode，通过inode 号获取inode信息，再找到文件数据锁在的block读取。<br>硬链接，文件名和inode号对应，也可能多个文件名<b>指向同一个inode号</b>。硬链接实现不同的文件名访问同一个文件，对文件内容的修改会影响到所有的文件名，但删除一个文件名不影响其他文件名的访问。<br>软链接，也可以通过不同文件名访问同一块数据，但是<b>文件名的inode是不一样的</b>。A是B的软链接，A的内容存放的是B的路径名。<br><b>最后在回顾下硬软链接的不同：</b><br>本质不同：硬链接是指向同一个文件，软链接指向的不是同一个文件。<br>删除时：硬链接不受影响，软链接失效<br>创建链接时：创建硬链接链接数加1，创建软链接连接数不变<br><b>是否可以跨分区：硬链接不可以跨分区，软链接可以跨分区</b><br><b>目录是否可以创建链接：硬链接不可以对目录创建，软链接可以对目录创建</b><br>硬链接的inode号相同，软链接inode号不同 </p>
<h1 id="考点4-vi编辑器全部替换"><a href="#考点4-vi编辑器全部替换" class="headerlink" title="考点4:vi编辑器全部替换"></a>考点4:vi编辑器全部替换</h1><p>Vi编辑器中,怎样将字符AAA全部替换成yyy? </p>
<ul>
<li>A <code>p/AAA/yyy/</code></li>
<li>B <code>s/AAA/yyy/g</code></li>
<li>C <code>i/AAA/yyy/</code></li>
<li>D <code>p/AAA/yyy/h</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>全局替换命令为：<code>:s/源字符串/目的字符串/g</code></p>
<table>
<thead>
<tr>
<th align="left">vi末行模式命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x2F;pattern</td>
<td align="left">从光标开始处向文件尾搜索pattern</td>
</tr>
<tr>
<td align="left">?pattern</td>
<td align="left">从光标开始处向文件首搜索pattern</td>
</tr>
<tr>
<td align="left">n</td>
<td align="left">同一方向重复上一次搜索命令</td>
</tr>
<tr>
<td align="left">N</td>
<td align="left">在反方向上重复上一次搜索命令</td>
</tr>
<tr>
<td align="left">:s&#x2F;p1&#x2F;p2&#x2F;g</td>
<td align="left">将当前行中所有p1均用p2替代</td>
</tr>
<tr>
<td align="left">:n1,n2s&#x2F;p1&#x2F;p2&#x2F;g</td>
<td align="left">将第n1至n2行中所有p1均用p2替代</td>
</tr>
<tr>
<td align="left">:g&#x2F;p1&#x2F;s&#x2F;&#x2F;p2&#x2F;g</td>
<td align="left">将文件中所有p1均用p2替换</td>
</tr>
</tbody></table>
<img data-src="https://uploadfiles.nowcoder.com/images/20171115/8121647_1510750596579_185EADA507DBD588DFD475182F61A7B4">


<h1 id="考点5-recv方法"><a href="#考点5-recv方法" class="headerlink" title="考点5:recv方法"></a>考点5:recv方法</h1><p>调用recv(int sockfd, void *buf, size_t len, int flags)的过程中,一共进行了几次内存复制操作？</p>
<ul>
<li>A 1</li>
<li>B 2</li>
<li>C 3</li>
<li>D 4</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>内核从对端接受数据，放在socket的缓存中，然后复制到应用层的buffer，所以一共两个buffer。<br>recv 接受对端socket数据，经过两次系统调用，首先在内核中将数据拷贝到自己的协议栈；然后recv返回将数据从内核缓冲区拷贝到用户buffer中。 内核从对端接受数据，放在socket的缓存中，然后复制到应用层的buffer，所以一共两个buffer。</p>
<h1 id="考点6-Linux卸载设备umount"><a href="#考点6-Linux卸载设备umount" class="headerlink" title="考点6:Linux卸载设备umount"></a>考点6:Linux卸载设备umount</h1><p>将光盘&#x2F;dev&#x2F;hdc卸载的命令是?</p>
<ul>
<li>A <code>umount /mnt/cdrom /dev/hdc</code></li>
<li>B <code>mount /dev/hdc</code></li>
<li>C <code>umount /dev/hdc</code></li>
<li>D <code>mount /mnt/cdrom /dev/hdc</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>题干没有说明，事先是把&#x2F;dev&#x2F;hdc挂载到&#x2F;mnt&#x2F;cdrom下。</p>
<p>挂载设备使用mount，<br>卸载设备使用umount，有三种方式，通过设备名，挂载点或者设备名和挂载点 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">umount /dev/hdc</span><br><span class="line">umount /mnt/cdrom</span><br><span class="line">umount /mnt/cdrom /dev/hdc</span><br></pre></td></tr></table></figure>

<h1 id="考点7-Linux多线程编程-pthread库-函数名和意义"><a href="#考点7-Linux多线程编程-pthread库-函数名和意义" class="headerlink" title="考点7:Linux多线程编程 pthread库 函数名和意义"></a>考点7:Linux多线程编程 pthread库 函数名和意义</h1><p>下述是Linux下多线程编程常用的pthread库提供的函数名和意义,说法正确的有？</p>
<ul>
<li>A <code>pthread_create</code> 创建一个线程</li>
<li>B <code>pthread_join</code> 用来等待一个线程的结束</li>
<li>C <code>pthread_mutex_init</code> 初始化一个线程互斥锁</li>
<li>D <code>pthread_exit</code> 结束一个线程</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>

<h1 id="考点8-chmod授权"><a href="#考点8-chmod授权" class="headerlink" title="考点8:chmod授权"></a>考点8:chmod授权</h1><p>文件aaa的访问权限为rw-r–r–,现要增加所有用户的执行权限和同组用户的写权限,下列哪些命令是正确的？</p>
<ul>
<li>A <code>chmod a+x , g+w aaa</code></li>
<li>B <code>chmod 764 aaa</code></li>
<li>C <code>chmod 775 aaa</code></li>
<li>D <code>chmod o+x , g+w aaa</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>


<h1 id="考点9-与用户管理相关的配置文件"><a href="#考点9-与用户管理相关的配置文件" class="headerlink" title="考点9:与用户管理相关的配置文件"></a>考点9:与用户管理相关的配置文件</h1><p>Linux系统上,下面哪些文件是与用户管理相关的配置文件()</p>
<ul>
<li>A <code>/etc/passwd</code></li>
<li>B <code>/etc/shadow</code></li>
<li>C <code>/etc/group</code></li>
<li>D <code>/etc/password</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<p>&#x2F;etc&#x2F;passwd     存放用户的UID name 密码过期时间 修改时间等等<br>&#x2F;etc&#x2F;shadow     存放用户的密码密文<br>&#x2F;etc&#x2F;group      存放用户的所属组情况<br>&#x2F;etc&#x2F;password    是错误的，linux没有D 这个文件</p>
<h1 id="考点10-Linux多种复制文件方法"><a href="#考点10-Linux多种复制文件方法" class="headerlink" title="考点10:Linux多种复制文件方法"></a>考点10:Linux多种复制文件方法</h1><p>将文件file1复制为file2可以用下面哪些命令()</p>
<ul>
<li>A <code>cp file1 file2</code></li>
<li>B <code>cat file1 &gt;file2</code></li>
<li>C <code>cat &lt; file1 &gt;file2</code></li>
<li>D <code>dd if=file1 of=file2</code></li>
<li>E <code>cat file1 | cat &gt;file2</code></li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCDE</details>

<h3 id="Linux复制cp命令"><a href="#Linux复制cp命令" class="headerlink" title="Linux复制cp命令"></a>Linux复制cp命令</h3><ul>
<li><code>cp命令</code>：cp指令用于复制文件或目录。 <ul>
<li>将文件file1复制成文件file2命令如下：cp file1 file2</li>
</ul>
</li>
</ul>
<h3 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h3><ul>
<li><code>cat命令</code>：cat命令是linux下的一个文本输出命令，通常是用于观看某个文件的内容的。 <ul>
<li>一次显示整个文件命令如下： cat filename</li>
</ul>
</li>
</ul>
<p>输入输出重定向</p>
<ul>
<li><code>&gt;</code>: linux中的数据流重导向：输出导向，覆盖导向的文件内容。 </li>
<li><code>&lt;</code>: linux中的数据流重导向：输入导向，理解为原本由键盘输入改为文本输入 </li>
<li><code>|</code>：管道命令操作符，处理经由前面一个指令传出的正确输出信息，然后，传递给下一个命令，作为标准的输入</li>
</ul>
<h3 id="dd命令"><a href="#dd命令" class="headerlink" title="dd命令"></a>dd命令</h3><ul>
<li><code>dd命令</code>: 作用是用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。 <ul>
<li>参数：<ul>
<li>if  输入文件（或设备名称）</li>
<li>of  输出文件（或设备名称）</li>
</ul>
</li>
<li>将文件file1拷贝到文件file2中命令如下：<ul>
<li>dd if&#x3D;file1 of&#x3D;file2</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Linux</category>
        <category>2021年04月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年04月17日Linux专项联系1</title>
    <url>/exam//15ad9369/</url>
    <content><![CDATA[<h1 id="考点1-DHCP分配固定IP地址"><a href="#考点1-DHCP分配固定IP地址" class="headerlink" title="考点1:DHCP分配固定IP地址"></a>考点1:DHCP分配固定IP地址</h1><p>在dhcpd.conf中用于向某个客户主机分配固定IP地址的参数是 (   )</p>
<ul>
<li>A <code>server-name</code></li>
<li>B <code>fixed-address</code></li>
<li>C <code>filename</code></li>
<li>D <code>hardware</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>fixed是固定的意思 address是地址的意思</p>
<h1 id="考点2-切换超级用户"><a href="#考点2-切换超级用户" class="headerlink" title="考点2:切换超级用户"></a>考点2:切换超级用户</h1><p>linux中哪个命令可以将普通用户转换成超级用户？()</p>
<ul>
<li>A <code>super</code></li>
<li>B <code>passwd</code></li>
<li>C <code>tar</code></li>
<li>D <code>su</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<h1 id="考点3-路由设置-route-add-net-目的网络-gw-网关地址"><a href="#考点3-路由设置-route-add-net-目的网络-gw-网关地址" class="headerlink" title="考点3:路由设置:route add -net 目的网络 gw 网关地址"></a>考点3:路由设置:route add -net 目的网络 gw 网关地址</h1><p>局域网的网络地址192.168.1.0&#x2F;24,局域网络连接其它网络的网关地址是192.168.1.1。主机192.168.1.20访问172.16.1.0&#x2F;24网络时,其路由设置正确的是？</p>
<ul>
<li>A <code>route add</code> –<code>net 192.168.1.0 gw 192.168.1.1 netmask 255.255.255.0 metric 1</code></li>
<li>B <code>route add</code> –<code>net 172.16.1.0 gw 192.168.1.1 netmask 255.255.255.0 metric 1</code></li>
<li>C <code>route add</code> –<code>net 172.16.1.0 gw 172.16.1.1 netmask 255.255.255.0 metric 1</code></li>
<li>D <code>route add default 192.168.1.0 netmask 172.168.1.1 metric 1</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>-net 后面跟的是目标网络，gw就是gateway（网关入口）就是你从哪个网关去到那个目标网络。明白这两项这题就能选了。</p>
<h1 id="考点4-UNIX在退出系统账户后继续运行进程"><a href="#考点4-UNIX在退出系统账户后继续运行进程" class="headerlink" title="考点4:UNIX在退出系统账户后继续运行进程"></a>考点4:UNIX在退出系统账户后继续运行进程</h1><p>在退出unix系统账户之后还需要继续运行某个进程,那么可用()</p>
<ul>
<li>A <code>awk</code></li>
<li>B <code>sed</code></li>
<li>C <code>crontab</code></li>
<li>D <code>nohup</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户&#x2F;关闭终端之后继续运行相应的进程。nohup就是不挂起的意思<br>awk 对数据分析的</p>
<p>sed  编辑文件的</p>
<p>crontab<br>用于设置周期性被执行的指令</p>
<p> nohup</p>
<p>在注销后使用<br>nohup<br> 命令运行后台中的程序。</p>
<h1 id="考点5-vi编辑器命令模式复制当前行快捷键"><a href="#考点5-vi编辑器命令模式复制当前行快捷键" class="headerlink" title="考点5:vi编辑器命令模式复制当前行快捷键"></a>考点5:vi编辑器命令模式复制当前行快捷键</h1><p>在命令行下使用 vi 编辑一个文件时, 如何复制当前行？(最佳选项)</p>
<ul>
<li>A <code>cc</code></li>
<li>B <code>dd</code></li>
<li>C <code>yy</code></li>
<li>D <code>Ctrl + c</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>cc 多数unix通过此调用它们的C编译程序<br>dd  删除光标所在的一整行<br>yy 复制光标所在的一整行<br>p 将已复制的数据在光标的下一行粘贴<br>P 将已复制的数据在光标的上一行粘贴</p>
<p>yy复制当前行 nyy复制从当前行开始的n行。 pp是对应的粘贴操作，与yy对应，</p>
<h1 id="考点6-Linux环境变量配置文件"><a href="#考点6-Linux环境变量配置文件" class="headerlink" title="考点6:Linux环境变量配置文件"></a>考点6:Linux环境变量配置文件</h1><p>使用shell时,默认的环境变量放在哪里？</p>
<ul>
<li>A ~&#x2F;.<code>bash_profile</code></li>
<li>B ~&#x2F;.<code>bash</code></li>
<li>C <code>/etc/profile.d</code></li>
<li>D ~&#96;&#x2F;bash&#96;</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>&#x2F;etc&#x2F;profile:<br>此文件为系统的为每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从&#x2F;etc&#x2F;profile.d目录的配置文件中搜集shell的设置.</p>
<p>&#x2F;etc&#x2F;bashrc<br>:为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.</p>
<p>~&#x2F;.bash_profile<br>:每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.</p>
<p>~&#x2F;.bashrc<br>:该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取.</p>
<p>~&#x2F;.bash_logout :<br>当每次退出系统(退出bash shell)时,执行该文件. </p>
<p>.bash_profile、.bashrc、和.bash_logout</p>
<p>上面这三个文件是bash shell的用户环境配置文件，位于用户的主目录下。</p>
<p>.bash_profile是最重要的一个配置文件，它在用户每次登录系统时被读取，里面的所有<br>命令都会被bash执行。.profile(由Bourne Shell和Korn Shell使用)和.login(由C Shell使用)两个文件是.bash_profile的同义词，目的是为了兼容其它Shell。<br>在Debian中使用.profile文件代替.bash_profile文件。</p>
<p>.bashrc<br>文件会在bash shell调用另一个bash<br>shell时读取，也就是在shell中再键入bash命令启动一个新shell时就会去读该文件。这样可有效分离登录和子shell所需的环境。但一般 来说都会在.bash_profile里调用.bashrc脚本以便统一配置用户环境。</p>
<p>.bash_logout<br>在退出shell时被读取。所以我们可把一些清理工作的命令放到这文件中。</p>
<p>登录Linux时，首先启动 &#x2F;etc&#x2F;profile 文件，然后再启动用户目录下的 <del>&#x2F;.bash_profile、<br>~&#x2F;.bash_login或<br>~&#x2F;.profile文件中的其中一个(根据不同的linux操作系统的不同，命名不一样)，执行的顺序为：</del>&#x2F;.bash_profile、<br>~&#x2F;.bash_login、 ~&#x2F;.profile。</p>
<p>如果 ~&#x2F;.bash_profile文件存在的话，一般还会执行 ~&#x2F;.bashrc文件。</p>
<h1 id="考点7-Linux可执行文件开头的特征字符"><a href="#考点7-Linux可执行文件开头的特征字符" class="headerlink" title="考点7:Linux可执行文件开头的特征字符"></a>考点7:Linux可执行文件开头的特征字符</h1><p>Linux的可执行文件开头的特征字符串是什么</p>
<ul>
<li>A <code>PE</code></li>
<li>B <code>MZ</code></li>
<li>C <code>ELF</code></li>
<li>D <code>LNX</code></li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>Executable Linkable File 可执行可链接文件<br>可移植可执行文件（Portable Executable，PE）是一种用于可执行、目标文件和动态链接库的文件格式，主要用于Windows，<br>而使用于Linux和多数Unix系统中的是可执行与可链接格式（ELF），Mac OS中则主要使用Mach-O；</p>
<h1 id="考点8-x2F-etc-x2F-sysctl-conf开启流量转发功能的参数"><a href="#考点8-x2F-etc-x2F-sysctl-conf开启流量转发功能的参数" class="headerlink" title="考点8:&#x2F;etc&#x2F;sysctl.conf开启流量转发功能的参数"></a>考点8:&#x2F;etc&#x2F;sysctl.conf开启流量转发功能的参数</h1><p>修改&#x2F;etc&#x2F;sysctl.conf如下哪项参数可以开启Linux流量转发功能()</p>
<ul>
<li>A <code>net.ipv4.conf.all.rp_filter = 0</code></li>
<li>B <code>net.ipv4.conf.default.rp_filter = 0</code></li>
<li>C <code>net.ipv4.ip_forward = 1</code></li>
<li>D <code>net.ipv4.conf.all.rp_filter = 1</code></li>
<li>E <code>net.ipv4.conf.default.rp_filter = 1</code></li>
<li>F <code>net.ipv4.ip_forward = 0</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>可以通过命令：cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward查看，1为开启Linux流量转发，0为禁止使用。<br>rp_filter参数有三个值，0、1、2，具体含义：</p>
<p>0：不开启源地址校验。</p>
<p>1：开启严格的反向路径校验。对每个进来的数据包，校验其反向路径是否是最佳路径。如果反向路径不是最佳路径，则直接丢弃该数据包。</p>
<p>2：开启松散的反向路径校验。对每个进来的数据包，校验其源地址是否可达，即反向路径是否能通（通过任意网口），如果反向路径不同，则直接丢弃该数据包。</p>
<h1 id="考点9-线程"><a href="#考点9-线程" class="headerlink" title="考点9:线程"></a>考点9:线程</h1><p>有关线程说法正确的是( )</p>
<ul>
<li>A 线程是程序的多个顺序的流动态执行</li>
<li>B 线程有自己独立的地址空间</li>
<li>C 线程不能够独立执行,必须依存在应用程序中,由应用程序提供多个线程执行控制</li>
<li>D 线程是系统进行资源分配和调度的一个独立单位</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

<p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是<strong>操作系统进行资源分配和调度的一个独立单位</strong>；</p>
<p>线程是进程的一个实体，一个进程中包含多个线程。是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位</p>
<p>进程有独立的地址空间，线程没有。<br><strong>线程是共享进程的地址空间</strong>，因此B错误</p>
<p><strong>进程是操作系统进行资源分配和调度的一个独立单位</strong>，而<strong>线程只是CPU调度和分派的基本单位</strong>，因此D错误</p>
<p>进程有独立的地址空间，线程没有。线程是共享进程的地址空间</p>
<h1 id="考点10-Linux创建文件的命令"><a href="#考点10-Linux创建文件的命令" class="headerlink" title="考点10:Linux创建文件的命令"></a>考点10:Linux创建文件的命令</h1><p>linux 创建文件的命令有()</p>
<ul>
<li>A <code>ls</code></li>
<li>B <code>touch</code></li>
<li>C <code>cat</code></li>
<li>D <code>vi/vim</code></li>
<li>E <code>&gt;</code></li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BDE</details>

<p>touch filename 新建文件<br>将几个文件合并为一个文件 —–cat file1 file2 &gt; file</p>
<p>vi&#x2F;vim filename 表示用vi或vim打开文件，如果不存在该文件则新建文</p>
<p>ls -查看当前目录下的文件<br>touch filename 新建文件<br>cat : 三个功能：<br>  1.一次显示整个文件：cat filename<br>  2.创建新文件，不能 编辑已有文件：cat &gt; filename<br>  3.将几个文件合并为一个文件：cat file1 file2 &gt; file<br><code>vi/vim filename</code>表示用vi或vim打开文件，如果不存在该文件则新建文件<br><code>&gt;</code> 是定向输出到文件，如果文件不存在，就创建文件；如果文件存在，就将其清空；<br><code>&gt;</code> firename 将空装入文件firename，如果没有会自动创建</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Linux</category>
        <category>2021年04月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年04月18日Linux专项练习1</title>
    <url>/exam//fe4a753b/</url>
    <content><![CDATA[<h1 id="考点1-Linux文件权限"><a href="#考点1-Linux文件权限" class="headerlink" title="考点1:Linux文件权限"></a>考点1:Linux文件权限</h1><p>在linux文件系统权限中(rwx),只读权限对应的数值为()</p>
<ul>
<li>A 4</li>
<li>B 2</li>
<li>C 1</li>
<li>D 选项均不正确</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>“4&#x3D;r,2&#x3D;w,1&#x3D;x”<br>r 代表读，w 代表写，x 代表执行，<br>如果可读，权限是二进制的100，十进制是4；<br>如果可写，权限是二进制的010，十进制是2；<br>如果可运行，权限是二进制的001，十进制是1</p>
<h1 id="考点2-cp-f命令"><a href="#考点2-cp-f命令" class="headerlink" title="考点2:cp -f命令"></a>考点2:cp -f命令</h1><p>cp拷贝命令的-f参数含义为?</p>
<ul>
<li>A 拷贝目录</li>
<li>B 递归处理</li>
<li>C 显示执行过程</li>
<li>D 强制进行拷贝</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>-r ：recursive，递归处理<br>-v ：verbose，显示详细过程<br>-f ：force，强制执行，多用于覆盖拷贝。无论目的目录是否有同名文件，强制复制</p>
<p>cp：将一个或多个源文件或者目录复制到指定的文件或目录。<br>选项：<br>-a：与”-dpR”相同<br>-d：当复制符号链接时，把目标文件或目录也建立为符号链接，并指向与源文件或目录连接的原始文件或目录<br>-f：强行复制文件或目录，不论是否存在<br>-i：覆盖既有文件前先询问用户<br>-l：对源文件建立硬链接，而非复制文件<br>-p：保留源文件或目录的属性<br>-R&#x2F;r：递归处理指定目录与子目录<br>-s：对源文件建立符号链接，而非复制文件<br>-u：只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在才复制文件<br>-S：在备份文件时，用指定的后缀“SUFFIX”代替文件默认后缀<br>-b：覆盖已经存在的文件目标前将目标文件备份<br>-v：详细显示命令执行的操作</p>
<p>举个栗子：<br>将文件jieni复制到usr&#x2F;tmp下，并改名为pika<br>cp jieni &#x2F;usr&#x2F;tmp&#x2F;pika</p>
<p>将目标&#x2F;usr&#x2F;jieni下所有文件复制到&#x2F;usr&#x2F;pika<br>cp &#x2F;usr&#x2F;jieni &#x2F;usr&#x2F;pika</p>
<p>交互式方式（询问）将目录&#x2F;usr&#x2F;jieni中a开头的所有.c文件复制到&#x2F;usr&#x2F;pika中<br>cp -i &#x2F;usr&#x2F;jieni a*.c &#x2F;usr&#x2F;pika</p>
<h1 id="考点3-Vsftpd配置"><a href="#考点3-Vsftpd配置" class="headerlink" title="考点3:Vsftpd配置"></a>考点3:Vsftpd配置</h1><p>Vsftpd 配置本地用户传输速率的参数？</p>
<ul>
<li>A <code>Local _max_rate</code></li>
<li>B <code>anon _max_rate</code></li>
<li>C <code>user _max_rate</code></li>
<li>D <code>max_user</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>vsftpd 是“very secure FTP daemon”的缩写，安全性是它的一个最大的特点。<br>local_max_rate&#x3D;0 实体用户的传输速度限制，单位为bytes&#x2F;second， 0 为不限制。</p>
<h3 id="Vsftpd-配置"><a href="#Vsftpd-配置" class="headerlink" title="Vsftpd 配置"></a>Vsftpd 配置</h3><h4 id="local-max-rate-x3D-0："><a href="#local-max-rate-x3D-0：" class="headerlink" title="local_max_rate&#x3D;0："></a>local_max_rate&#x3D;0：</h4><p>本地用户使用的最大传输速度，单位为B&#x2F;s，0 表示不限制速度。预设值为0。</p>
<h4 id="anon-max-rate-x3D-0"><a href="#anon-max-rate-x3D-0" class="headerlink" title="anon_max_rate&#x3D;0"></a>anon_max_rate&#x3D;0</h4><p>：<br>设置匿名登入者使用的最大传输速度，单位为B&#x2F;s，0 表示不限制速度。默认值为0。</p>
<h1 id="考点4-Linux命令返回直含义"><a href="#考点4-Linux命令返回直含义" class="headerlink" title="考点4:Linux命令返回直含义"></a>考点4:Linux命令返回直含义</h1><p>linux命令执行成功后会返回</p>
<ul>
<li>A 0</li>
<li>B 1</li>
<li>C 2</li>
<li>D -1</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5:"></a>考点5:</h1><p>你在一台Windows 2000 Server 上部署了几个web 站点,这些Web 站点都已启用了日志。你用一个第三方的报表工具来分析web站点产生的日志文件,你发现所有从上午7:00到午夜的数据都被包含在第二天的日志文件中。你希望这些数据包含在当天的日志文件中,你该怎么做？</p>
<ul>
<li>A 确保日志类型被设置为<code>W3C</code></li>
<li>B 在<code>web</code>站点的日志属性中修改日志翻转属性</li>
<li>C 在<code>web</code>服务器的时间属性中修改时间区域设置</li>
<li>D 在<code>web</code>服务器上配置时间服务器使用<code>LocalSystem</code>账户</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>


<h1 id="考点6-UNIX系统代码段和数据段分开的目的"><a href="#考点6-UNIX系统代码段和数据段分开的目的" class="headerlink" title="考点6:UNIX系统代码段和数据段分开的目的"></a>考点6:UNIX系统代码段和数据段分开的目的</h1><p>关于UNIX系统代码段和数据段分开的目的,错误的说法有()。</p>
<ul>
<li>A 可共享正文</li>
<li>B 可共享数据</li>
<li>C 可重入</li>
<li>D 可保护代码为只读</li>
<li>E 方便编程</li>
<li>F 更好支持内存回收策略</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: E</details>
1）防止程序指令被修改，设置代码段权限为只读，设置数据段权限为可读写  

<p>2）代码段和数据段分开有利于提高程序的局部性，现代CPU缓存一般设计为数据缓存和指令缓存分离，指令和数据分开存放可以提高CPU缓存命中率。</p>
<p>3）共享指令，当系统运行多个程序的副本时，它们指令时一样的，因此内存只需保存一份程序的指令代码。每个副本进程的数据区是进程私有，可以节省内存。<br>1）代码段：代码段是用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。<br>2）数据段：数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配的变量和全局变量。<br>3）BSS段：BSS段包含了程序中未初始化的全局变量，在内存中 bss段全部置零。<br>4）堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）<br>它的物理内存空间是由程序申请的，并由程序负责释放。<br>5）栈：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存&#x2F;恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。<br>实际上,在Linux系统下并没有强调分段,每个进程缺省情况下“数据段”，“堆栈段”和“代码段”都使用等价的段描述,映射到相同的线性地址空间,除非你个别设置LDT.</p>
<h1 id="考点7-dvm进程和Linux进程"><a href="#考点7-dvm进程和Linux进程" class="headerlink" title="考点7:dvm进程和Linux进程"></a>考点7:dvm进程和Linux进程</h1><p>下面关于andriod dvm的进程和Linux的进程,应用程序的进程说法正确的是</p>
<ul>
<li>A <code>DVM</code>指<code>dalivk</code>的虚拟机,每一个<code>Andriod</code>应用程序都在它自己的进程中运行,都拥有一个独立的<code>Dalivk</code>虚拟机实例,而每一个<code>DVM</code>不一定都是在<code>Linux</code>中的一个进程,所以说不是一个概念</li>
<li>B <code>DVM</code>指<code>dalivk</code>的虚拟机,每一个<code>Andriod</code>应用系统程序都在它自己的进程中运行,不一定拥有一个独立的<code>Dalivk</code>虚拟机实例,而每一个<code>DVM</code>都是在<code>Linux</code>中的一个进程,所以说可以认为是同一个概念</li>
<li>C <code>DVM</code>指<code>dalivk</code>的虚拟机,每一个<code>Andriod</code>应用系统程序都在它自己的进程中运行,不一定拥有一个独立的<code>Dalivk</code>虚拟机实例,而每一个<code>DVM</code>不一定都是在<code>Linux</code>中的一个进程,所以说不是一个概念</li>
<li>D <code>DVM</code>指<code>dalivk</code>的虚拟机,每一个<code>Andriod</code>应用程序都在它自己的进程中运行,都拥有一个独立的<code>Dalivk</code>虚拟机实例,而每一个<code>DVM</code>都是在<code>Linux</code>中的一个进程,所以说可以认为是同一个概念</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>Android系统用的就是Linux的内核，DVM可以理解成在Linux上跑的程序，每个应用程序运行时，都会启动一个DVM实例，也就是一个Linux的进程，因此DVM进程和Linux进程实际上是一回事。</p>
<h1 id="考点8-线程"><a href="#考点8-线程" class="headerlink" title="考点8:线程"></a>考点8:线程</h1><p>下面说法哪个正确的:</p>
<ul>
<li>A 各个线程拥有相同的堆栈</li>
<li>B i++是线程安全的,不需要同步</li>
<li>C <code>x=y</code>是线程安全的,不需要同步</li>
<li>D 对进程来说,其虚拟内存的大小不受物理内存大小的限制</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>线程有自己的栈，但没有堆所以A错。普通整数的一般赋值、增量和减量语句会产生多条机器指令，操作均不具有原子性，需要同步，BC错。虚拟存储器具有请求调入和置换功能，所以虚拟内存的大小不受物理内存大小的限制。D对。</p>
<h1 id="考点9-进程通讯方式"><a href="#考点9-进程通讯方式" class="headerlink" title="考点9:进程通讯方式"></a>考点9:进程通讯方式</h1><p>进程之间通信都有哪些方式？</p>
<ul>
<li>A 共享内存</li>
<li>B 消息传递</li>
<li>C 系统管道</li>
<li>D 临界区</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Linux</category>
        <category>2021年04月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年04月18日Linux专项练习2</title>
    <url>/exam//b7729f1c/</url>
    <content><![CDATA[<h1 id="考点1-vi保存并退出"><a href="#考点1-vi保存并退出" class="headerlink" title="考点1:vi保存并退出"></a>考点1:vi保存并退出</h1><p>在Linux系统的vi编辑器中,如果不保存对文件进行的修改,应使用(  )命令强制退出vi编辑器</p>
<ul>
<li>A :q</li>
<li>B :<code>wq</code></li>
<li>C :q!</li>
<li>D :!q</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h1 id="考点2-文件操作的唯一依据"><a href="#考点2-文件操作的唯一依据" class="headerlink" title="考点2:文件操作的唯一依据"></a>考点2:文件操作的唯一依据</h1><p>文件操作的唯一依据是？</p>
<ul>
<li>A 文件名</li>
<li>B 文件句柄</li>
<li>C 物理地址</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>在文件I&#x2F;O中，要从一个文件读取数据，应用程序首先要调用操作系统函数并传送文件名，并选一个到该文件的路径来打开文件。该函数取回一个顺序号，即文件句柄（file handle），该文件句柄对于打开的文件是唯一的识别依据。要从文件中读取一块数据，应用程序需要调用函数ReadFile，并将文件句柄在内存中的地址和要拷贝的字节数传送给操作系统。当完成任务后，再通过调用系统函数来关闭该文件。</p>
<p>文件句柄应该是windows的叫法，linux叫文件描述符。</p>
<h1 id="考点3-Linux查看物理内存的大小"><a href="#考点3-Linux查看物理内存的大小" class="headerlink" title="考点3:Linux查看物理内存的大小"></a>考点3:Linux查看物理内存的大小</h1><p>在 linux 下,如何查看物理内存的大小？ ()</p>
<ul>
<li>A <code>cat /dev/mem</code></li>
<li>B <code>cat /proc/meminfo</code></li>
<li>C <code>mem</code></li>
<li>D <code>ps -ef</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>方式一：free<br>直观的展示linux系统内存使用及交换区的容量大小等<br>方式二：top<br>动态实时查看系统中每一个进程的资源使用情况<br>方式三：cat &#x2F;proc&#x2F;meminfo<br>方式四：gnome-system-monitor 一个显示最近一段时间内的CPU、内存、交换区及网络使用情况的视图工具。<br>方式五：ps aux –sort -rss<br>各个线程的资源使用情况<br>方式六：vmstat -s<br>vmstat命令显示实时的和平均的统计，覆盖CPU、内存、I&#x2F;O等内容。</p>
<h1 id="考点4-sed命令"><a href="#考点4-sed命令" class="headerlink" title="考点4:sed命令"></a>考点4:sed命令</h1><p>以下哪些命令可以打印文件(demo.log)中包含ERP的行到标准输出()</p>
<ul>
<li>A <code>sed</code> ‘<code>/ERR/a</code>&#39; <code>demo.log</code></li>
<li>B <code>sed</code> ‘<code>/ERP/p</code>‘ <code>demo.log</code></li>
<li>C <code>sed</code> ‘<code>/ERP/d</code>‘ <code>demo.log</code></li>
<li>D <code>sed -n</code> ‘<code>/ERP/p</code>‘ <code>demo.log</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>sed命令用于行的新增&#x2F;删除, 行的替换&#x2F;显示, 搜寻并替换, 直接修改文件。<br>-n：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到屏幕上。但如果加上 -n<br>参数后，则只有经过 sed 特殊处理的那一行才会被列出来。<br>p：打印，将某个选择的数据印出来。通常 p 会与参数 sed -n 一起用<br>d:删除<br>a：新增<br>sed是非交互式的编辑器。它不会修改文件，除非使用shell重定向来保存结果。默认情况下，所有的输出行都被打印到屏幕上</p>
<p>sed编辑器逐行处理文件（或输入），并将结果发送到屏幕。具体过程如下：首先sed把当前正在处理的行保存在一个临时缓存区中（也称为模式空间），然后处理临时缓冲区中的行，完成后把该行发送到屏幕上。sed每处理完一行就将其从临时缓冲区删除，然后将下一行读入，进行处理和显示。处理完输入文件的最后一行后，sed便结束运行。sed把每一行都存在临时缓冲区中，对这个副本进行编辑，所以不会修改原文件。</p>
<p>然后回到本题中，</p>
<p> -n 取消默认的输出，从而重定向为ERP输出</p>
<p>-p 打印行</p>
<p>最后是filename文件名<br>打印文件（demo.log）中包含ERP的行到标准输出。<br>sed -n ‘&#x2F;ERP&#x2F;p’ demo.log<br>sed是非交互式的编辑器。它不会修改文件，除非使用shell重定向来保存结果。<br>-n：使用安静(silent)模式。默认情况下，所有的输出行都被打印到屏幕上。<br>-p：打印，将某个选择的数据印出来。通常 p 会与参数 sed -n 一起用。<br>-d：删除<br>-a：新增</p>
<p>Vi编辑器中,怎样将字符AAA全部替换成yyy?<br>s&#x2F;AAA&#x2F;yyy&#x2F;g<br>s：取代，通常 s 动作可以搭配正规表示式。例如 1,20s&#x2F;old&#x2F;new&#x2F;g！<br>g：是行内进行全局替换。</p>
<p>示例：<br>sed ‘s&#x2F;aaa&#x2F;bbb&#x2F;‘  filea   将filea中的第一个aaa替换为bbb；<br>sed ‘s&#x2F;aaa&#x2F;bbb&#x2F;g’  filea  将filea中的所有的aaa替换为bbb。</p>
<h1 id="考点5-死锁的必要条件"><a href="#考点5-死锁的必要条件" class="headerlink" title="考点5:死锁的必要条件"></a>考点5:死锁的必要条件</h1><p>下面哪些是死锁发生的必要条件？</p>
<ul>
<li>A 互斥条件</li>
<li>B 请求和保持</li>
<li>C 不可剥夺</li>
<li>D 循环等待</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>

<p>产生死锁的四个必要条件：<br>（1） 互斥条件：一个资源每次只能被一个进程使用。<br>（2） 占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3）不可强行占有:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。<br>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p>
<h1 id="考点6-移位运算-十六进制数-幂运算"><a href="#考点6-移位运算-十六进制数-幂运算" class="headerlink" title="考点6:移位运算 十六进制数 幂运算"></a>考点6:移位运算 十六进制数 幂运算</h1><p>下列表达式值相同的是哪几项()</p>
<ul>
<li>A 1<code>&lt;&lt;3</code></li>
<li>B 0<code>x0F</code> &amp; 0<code>x08</code></li>
<li>C 2^3(^是幂运算)</li>
<li>D 3^2(^是幂运算)</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<p>A. 1左移3位  即1000<br>B. 0000 1111 &amp; 0000 1000  即0000 1000<br>C. 2^3   即8  即1000<br>D. 3^2   即9  即1001<br> ABC值相同</p>
<h1 id="考点7-vi保存并退出方法"><a href="#考点7-vi保存并退出方法" class="headerlink" title="考点7:vi保存并退出方法"></a>考点7:vi保存并退出方法</h1><p>在Linux系统下,你用vi编辑器对文本文件test.txt进行了修改,想保存对该文件所做的修改并正常退出vi编辑器,可以(   )。</p>
<ul>
<li>A 在命令模式下执行<code>ZZ</code>命令</li>
<li>B 在命令模式下执行<code>WQ</code>命令</li>
<li>C 在末行模式下执行:q!</li>
<li>D 在末行模式下执行:<code>wq</code></li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details>


<h1 id="考点8-shell系统调用-ls系统调用"><a href="#考点8-shell系统调用-ls系统调用" class="headerlink" title="考点8:shell系统调用 ls系统调用"></a>考点8:shell系统调用 ls系统调用</h1><p>Linux执行ls,会引起哪些系统调用()</p>
<ul>
<li>A <code>nmap</code></li>
<li>B <code>read</code></li>
<li>C <code>execve</code></li>
<li>D <code>fork</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details>

<p>任何shell都会执行 exec 和 fork<br>而    ls会执行read<br>三个加起来</p>
<h1 id="考点9-firmware分析相关命令"><a href="#考点9-firmware分析相关命令" class="headerlink" title="考点9:firmware分析相关命令"></a>考点9:firmware分析相关命令</h1><p>下面哪些命令和工具对 firmware 分析有帮助？</p>
<ul>
<li>A <code>binwalk</code></li>
<li>B <code>file</code></li>
<li>C <code>firmware-mod-kit</code></li>
<li>D <code>netstat</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<p>Binwalk是用于搜索给定二进制镜像文件以获取嵌入的文件和代码的工具，具体来说，它被设计用于识别嵌入固件镜像内的文件和代码。<br>file命令用来探测给定文件的类型，file命令对文件的检查分为文件系统、魔法幻数检查和语言检查3个过程。<br>firmware-mod-kit工具的功能和binwalk工具的类似，其实firmware-mod-kit工具在功能上有调用binwalk工具提供的功能以及其他的固件解包工具的整合。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Linux</category>
        <category>2021年04月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年04月18日Linux专项练习3</title>
    <url>/exam//c075af8a/</url>
    <content><![CDATA[<h1 id="考点1-八进制文件权限"><a href="#考点1-八进制文件权限" class="headerlink" title="考点1:八进制文件权限"></a>考点1:八进制文件权限</h1><p>在Linux中,file.sh文件的权限为<code>-rw-r--r-x</code>,其对应权限用数值形式表示为()</p>
<ul>
<li>A 775</li>
<li>B 745</li>
<li>C 645</li>
<li>D 643</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>Linux权限中，第一个指是否是目录，后面根据rwx形式对拥有者，所属组，其他分别授权，-rw-r–r-x即为110,100,101，转换成十进制就是645</p>
<h1 id="考点2-具有c语言功能的过滤器"><a href="#考点2-具有c语言功能的过滤器" class="headerlink" title="考点2:具有c语言功能的过滤器"></a>考点2:具有c语言功能的过滤器</h1><p>具有很多C语言的功能,又称过滤器的是？</p>
<ul>
<li>A <code>Csh</code></li>
<li>B <code>tcsh</code></li>
<li>C <code>awk</code></li>
<li>D <code>sed</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>sed awk grep ,linux文本处理三剑客<br>csh:调用 C shell。<br>Tcsh是csh的增强版，并且完全兼容csh。它不但具有csh的全部功能，还具有命令行编辑、拼写校正、可编程字符集、历史纪录、作业控制等功能，以及C语言风格的语法结构。<br>AWK是一种优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一,AWK 提供了极其强大的功能：可以进行样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。<br>sed:Stream EDitor</p>
<h1 id="考点3-shell编程赋值语句"><a href="#考点3-shell编程赋值语句" class="headerlink" title="考点3:shell编程赋值语句"></a>考点3:shell编程赋值语句</h1><p>在bash中,下列哪些语句是赋值语句？()</p>
<ul>
<li>A <code>a$=&quot;test&quot;</code></li>
<li>B <code>$a$=&quot;test&quot;</code></li>
<li>C <code>a=&quot;test&quot;</code></li>
<li>D <code>$a=&quot;test&quot;</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>bash中有两个内置的命令declare 和 typeset 可用于创建变量。除了使用内置命令来创建和设置变量外，还可以直接赋值，格式为：变量名&#x3D;变量值<br> 注意：变量名前面不应加美元“$”符号。（和PHP不同）<br> 等号“&#x3D;”前后不可以有空格。<br> Shell中不需要显式的语法来声明变量。<br> 变量名不可以直接和其他字符相连，如果想相连，必须用括号： echo “this is $(he)llo!”</p>
<h1 id="考点4-gcc生成调试信息"><a href="#考点4-gcc生成调试信息" class="headerlink" title="考点4:gcc生成调试信息"></a>考点4:gcc生成调试信息</h1><p>若基于Linux操作系统所开发的ARM应用程序源文件名为test.c,那么要生成该程序代码的调试信息,编译时使用的GCC命令正确的是?</p>
<ul>
<li>A <code>arm-linux-gcc -c -o test.o test.c</code></li>
<li>B <code>arm-linux-gcc -S -o test.o test.c</code></li>
<li>C <code>arm-linux-gcc -o test test.c</code></li>
<li>D <code>arm-linux-gcc -g -o test test.c</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>-o参数用于指定输出的文本，如果不指定输出文件则默认输出.out文件<br>-c参数将对源程序test.c进行预处理、编译、汇编操作，生成test.o文件<br>-S参数将对源程序test.c进行预处理、编译，生成test.s文件<br>-g选项，加入GDB能够使用的调试信息,使用GDB调试时比较方便</p>
<h1 id="考点5-useradd创建用户时不指定用户主目录"><a href="#考点5-useradd创建用户时不指定用户主目录" class="headerlink" title="考点5:useradd创建用户时不指定用户主目录"></a>考点5:useradd创建用户时不指定用户主目录</h1><p>创建用户时不指定用户主目录的参数(      )</p>
<ul>
<li>A <code>useradd -o</code></li>
<li>B <code>useradd -m</code></li>
<li>C <code>useradd -M</code></li>
<li>D <code>useradd -d</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h1 id="考点6-POSIX线程同步方式"><a href="#考点6-POSIX线程同步方式" class="headerlink" title="考点6:POSIX线程同步方式"></a>考点6:POSIX线程同步方式</h1><p>POSIX线程同步方式包括:(      )</p>
<ul>
<li>A <code>POSIX</code>信号量</li>
<li>B 互斥锁</li>
<li>C 条件变量</li>
<li>D 临界区</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<p>临界区指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个线程访问的特性。当有线程进入临界区段时，其他线程或是进程必须等待（例如：bounded waiting 等待法），有一些同步的机制必须在临界区段的进入点与离开点实现，以确保这些共用资源是被互斥获得使用，例如：semaphore。只能被单一线程访问的设备，例如：打印机。</p>
<p>首先说POSIX：可移植操作系统接口，就是定义了一些操作系统该为程序提供的接口标准。<br>再然后说线程同步方式：</p>
<ul>
<li>互斥锁</li>
<li>条件变量</li>
<li>读写锁</li>
<li>信号</li>
<li></li>
</ul>
<h1 id="考点7-subnet命令"><a href="#考点7-subnet命令" class="headerlink" title="考点7:subnet命令"></a>考点7:subnet命令</h1><p>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subnet 166.173.197.131 netmask 255.255.255.192&#123;</span><br><span class="line">range 166.173.197.10 166.173.197.107;</span><br><span class="line">default-lease-time 600;</span><br><span class="line">max-lease-time 7200;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表示？()</p>
<ul>
<li>A 向166.173.197.10网络分配从166.173.197.133到166.173.197.255</li>
<li>B 一个两小时的最大租用时间</li>
<li>C 指定了一个十分钟的缺省租用时间</li>
<li>D 网络地址166.173.197.0</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<h1 id="考点8-subnet命令"><a href="#考点8-subnet命令" class="headerlink" title="考点8:subnet命令"></a>考点8:subnet命令</h1><p>Linux 系统中DHCP 服务器的服务程序是dhcpd,配置文件是dhcpd.conf,如果在该配置文件中包括如下配置内容:<br>Subnet 192.168.2.0 netmask 255.255.255.0 {<br>range 192.168.2.100 192.168.2.200 ;<br>}<br>关于以上配置内容,说法正确的是( )多选</p>
<ul>
<li>A 对子网”192.168.2.0&#x2F;16”中的主机进行动态地址分配</li>
<li>B 对子网”192.168.2.0&#x2F;24”中的主机进行动态地址分配</li>
<li>C 在子网中用于动态分配的<code>IP</code> 地址数量为100 个</li>
<li>D 在子网中用于动态分配的<code>IP</code> 地址数量为101 个</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BD</details>

<p>A类的默认子网掩码 255.0.0.0<br>B类的默认子网掩码 255.255.0.0<br>C类的默认子网掩码 255.255.255.0</p>
<p>16位是B类，B类IP地址的前面6位表示网络地址，后16位表示主机地址，B类IP地址前面开头的数字范围是128—191</p>
<p>24位是C类，标准的C类地址的确是24位的子网掩码，但是为了更好的饿使用IP地址，采用了一种技术叫VLSM的。<br>题目的前面开头是192，所以是C类地址，所以24位表示主机地址。所以是／24</p>
<h1 id="考点9-vsftpd服务流量控制的参数"><a href="#考点9-vsftpd服务流量控制的参数" class="headerlink" title="考点9:vsftpd服务流量控制的参数"></a>考点9:vsftpd服务流量控制的参数</h1><p>vsftpd服务流量控制的参数( )</p>
<ul>
<li>A <code>system_max_rate</code></li>
<li>B <code>local_max_rate</code></li>
<li>C <code>anon_max_rate</code></li>
<li>D <code>guest_max_rate</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<p>访问速率设置：<br>anon_max_rate&#x3D;0<br>设置匿名登入者使用的最大传输速度，单位为B&#x2F;s，0 表示不限制速度。默认值为0。<br>local_max_rate&#x3D;0<br>本地用户使用的最大传输速度，单位为B&#x2F;s，0 表示不限制速度。预设值为0</p>
<p>vsftpd 是“very secure FTP daemon”的缩写，安全性是它的一个最大的特点。vsftpd 是一个 UNIX 类操作系统上运行的服务器的名字，它可以运行在诸如 Linux、BSD、Solaris、 HP-UNIX等系统上面，是一个完全免费的、开放源代码的ftp服务器软件，支持很多其他的 FTP 服务器所不支持的特征。比如：非常高的安全性需求、带宽限制、良好的可伸缩性、可创建虚拟用户、支持IPv6、速率高等。<br>anon_max_rate:匿名访问最大传输速率，anon是anonymous(匿名的)的缩写</p>
<h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10:"></a>考点10:</h1><p>邮件服务器为每个用户限制磁盘存储空间上限,执行<code>checkquota -cug /var/mail</code>指令后, 在&#x2F;var&#x2F;mail目录自动创建的配置文件是(      )</p>
<ul>
<li>A <code>quota.user</code></li>
<li>B <code>aquota.user</code></li>
<li>C <code>aquota.group</code></li>
<li>D <code>quota.group</code></li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<p>aquota.group与aqouta.user分别是组以及用户磁盘配额需要的配置文件。<br>如果没有这两个文件，则磁盘配额是不会生效的。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Linux</category>
        <category>2021年04月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年04月18日Linux专项练习4</title>
    <url>/exam//8e2081b4/</url>
    <content><![CDATA[<h1 id="考点1-vi打开文件"><a href="#考点1-vi打开文件" class="headerlink" title="考点1:vi打开文件"></a>考点1:vi打开文件</h1><p>有一台系统为Linux的计算机,在其当前目录下有一个名为test的文本文件,管理员小张要用vi编辑器打开该文档以查看其中的内容,应使用()命令.</p>
<ul>
<li>A <code>opentest</code></li>
<li>B <code>vi read test</code></li>
<li>C <code>vi test</code></li>
<li>D <code>open vi</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h1 id="考点2-shell编程if语句"><a href="#考点2-shell编程if语句" class="headerlink" title="考点2:shell编程if语句"></a>考点2:shell编程if语句</h1><p><code>if [ $2 -a $2 = &quot;test&quot; ]</code>中 -a是什么意思 </p>
<ul>
<li>A 大于</li>
<li>B 减</li>
<li>C 全部</li>
<li>D 并且</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>-a 是shell中的布尔运算符，表示与运算</p>
<h1 id="考点3-shell脚本变量含义"><a href="#考点3-shell脚本变量含义" class="headerlink" title="考点3:shell脚本变量含义"></a>考点3:shell脚本变量含义</h1><p>在RHEL5统中,”run.sh”是Shell执行脚本,在执行<code>./run.sh file1 file2 file3</code>命令的过程中,变量$1的值为(   )</p>
<ul>
<li>A <code>run.sh</code></li>
<li>B <code>file1</code></li>
<li>C <code>file2</code></li>
<li>D <code>file3</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">linux中shell变量$#,$@,$0,$1,$2的含义解释: </span><br><span class="line">变量说明: </span><br><span class="line">$$ </span><br><span class="line">Shell本身的PID（ProcessID） </span><br><span class="line">$! </span><br><span class="line">Shell最后运行的后台Process的PID </span><br><span class="line">$? </span><br><span class="line">最后运行的命令的结束代码（返回值） </span><br><span class="line">$- </span><br><span class="line">使用Set命令设定的Flag一览 </span><br><span class="line">$* </span><br><span class="line">所有参数列表。如&quot;$*&quot;用「&quot;」括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。 </span><br><span class="line">$@ </span><br><span class="line">所有参数列表。如&quot;$@&quot;用「&quot;」括起来的情况、以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。 </span><br><span class="line">$# </span><br><span class="line">添加到Shell的参数个数 </span><br><span class="line">$0 </span><br><span class="line">Shell本身的文件名 </span><br><span class="line">$1～$n </span><br><span class="line">添加到Shell的各参数值。$1是第1参数、$2是第2参数…</span><br></pre></td></tr></table></figure>

<h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4:"></a>考点4:</h1><p>采用多路复用I&#x2F;O监听3个套接字的数据时,如果套接字描述符分别是:5,17,19,则<br>select(int maxfd,struct fd_set* rdset,NULL,NULL)<br>中的maxfd应取为()</p>
<ul>
<li>A 4</li>
<li>B 20</li>
<li>C 5</li>
<li>D 9</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>Maxfd是三个套接字描述符中最大数字加上1</p>
<h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5:"></a>考点5:</h1><p>具有很多C语言的功能,又称过滤器的是？</p>
<ul>
<li>A <code>Csh</code></li>
<li>B <code>tcsh</code></li>
<li>C <code>awk</code></li>
<li>D <code>sed</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6:"></a>考点6:</h1><p>在OSI模型中,HTTP协议工作在第()层,交换机工作在第()层。</p>
<ul>
<li>A 7&#x2F;1</li>
<li>B 7&#x2F;2</li>
<li>C 6&#x2F;3</li>
<li>D 6&#x2F;2</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p><a href="https://m.nowcoder.com/questions?tagId=43719192&amp;type=1&amp;source=intelli&amp;pos=1">https://m.nowcoder.com/questions?tagId=43719192&amp;type=1&amp;source=intelli&amp;pos=1</a></p>
<h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7:"></a>考点7:</h1><p>查看TCP连接的命令是什么？</p>
<ul>
<li>A <code>tcpdump</code></li>
<li>B <code>top</code></li>
<li>C <code>netstat</code></li>
<li>D <code>ifconfig</code></li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>netstat -at    #列出所有tcp端口<br>netstat -lt    #只列出所有监听 tcp 端口<br>netstat -st    #显示TCP端口的统计信息</p>
<p>ifconfig是linux中用于显示或配置网络设备(网络接口卡)的命令，英文全称是network interfaces<br>configuring。配置网卡的IP地址语法例:ifconfig eth0 192.168.0.1 netmask<br>255.255.255.0.ifconfig可设置网络设备的状态，或是显示当前的设置。</p>
<p>tcpdump是网络监控工具<br>tcpdump：<br>将网络中传送的数据包完全截获下来以供分析。<br>它支持针对网络层、协议、主机、网络或端口的过滤；并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</p>
<h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8:"></a>考点8:</h1><p>在重新启动Linux系统的同时把内存中的信息写入硬盘,应使用()命令实现</p>
<ul>
<li>A #<code>shutdown -r now</code></li>
<li>B #<code>halt</code></li>
<li>C #<code>reboot</code></li>
<li>D #<code>init3</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>在linux命令中reboot是重新启动，shutdown -r<br>now是立即停止然后重新启动，都说他们两个是一样的，其实是有一定的区别的。<br>shutdown命令可以安全地关闭或重启Linux系统，它在系统关闭之前给系统上的所有登录用户提示一条警告信息。该命令还允许用户指定一个时间参数，可以是一个精确的时间，也可以是从现在开始的一个时间段。<br>精确时间的格式是hh:mm，表示小时和分钟，时间段由+ 和分钟数表示。系统执行该命令后会自动进行数据同步的工作。<br>该命令的一般格式: shutdown [选项] [时间] [警告信息]<br>命令中各选项的含义为:</p>
<ul>
<li>k 并不真正关机而只是发出警告信息给所有用户</li>
<li>r 关机后立即重新启动</li>
<li>h 关机后不重新启动</li>
<li>f 快速关机重启动时跳过fsck</li>
<li>n 快速关机不经过init 程序</li>
<li>c 取消一个已经运行的shutdown<br>需要特别说明的是该命令只能由超级用户使用。<br>例1，系统在十分钟后关机并且马上重新启动: # shutdown –r +10<br>例2，系统马上关机并且不重新启动:# shutdown –h now<br>halt是最简单的关机命令，其实际上是调用shutdown</li>
</ul>
<p>-h命令。halt执行时，杀死应用进程，文件系统写操作完成后就会停止内核。<br>halt命令的部分参数如下：<br>[-f] 没有调用shutdown而强制关机或重启<br>[-i] 关机或重新启动之前，关掉所有的网络接口<br>[-p] 关机时调用poweroff，此选项为缺省选项<br>reboot的工作过程与halt类似，其作用是重新启动，而halt是关机。其参数也与halt类似。reboot命令重启动系统时是删除所有的进程，而不是平稳地终止它们。因此，使用reboot命令可以快速地关闭系统，但如果还有其它用户在该系统上工作时，就会引起数据的丢失。所以使用reboot命令的场合主要是在单用户模式。<br>init是所有进程的祖先，其进程号始终为1。init用于切换系统的运行级别，切换的工作是立即完成的。init<br>0命令用于立即将系统运行级别切换为0，即关机；init 6命令用于将系统运行级别切换为6，即重新启动</p>
<p>shutdown：  这个命令会通知系统内的各个进程，并通知关闭一些服务。<br>shutdown -h now 立刻关机                      常用<br>shutdown -h 20:25 指定关机的时间<br>shutdown -h +10  10分钟后关机<br>shutdown -r now 系统立刻重启<br>shutdown -r +30 ‘the system will reboot’  显示题是信息给所有在线用户<br>shutdown -k now ‘system will reboot’  仅仅发出要重新启动的信息，而不会关机或者重启</p>
<p>reboot ： 删除所有进程，不平稳终止。 ‘sync；sync；sync；reboot’  </p>
<p>halt： 不理会目前系统状态，执行硬件关机。</p>
<p>init： 用于切换系统的运行级别，切换的工作是立即完成的。<br>init 0 关机<br>init 3 命令行模式<br>Init5 含有图形界面<br>init 4重启</p>
<p>理论上reboot适合于单用户的时候也是对的<br>init0 &#x3D; 关机<br>init6&#x3D; 重启</p>
<h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9:"></a>考点9:</h1><p>Linux的可执行文件开头的特征字符串是什么</p>
<ul>
<li>A <code>PE</code></li>
<li>B <code>MZ</code></li>
<li>C <code>ELF</code></li>
<li>D <code>LNX</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>Executable Linkable File 可执行可链接文件</p>
<p>vi编辑器里面如何删除最后一行？<br>A<br>G;d<br>B<br>G;dd<br>C<br>A;dd<br>D<br>A;d<br>正确答案: B</p>
<p>gg到顶部；G &#x3D; shift + g到底部。</p>
<p>vi编辑器一般模式下：<br>G：光标移到最后一行<br>dd：删除一行<br>shift+G 到底部，dd删除行</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Linux</category>
        <category>2021年04月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年04月18日Linux专项练习5</title>
    <url>/exam//f927b122/</url>
    <content><![CDATA[<h1 id="考点1-Linux开发者"><a href="#考点1-Linux开发者" class="headerlink" title="考点1:Linux开发者"></a>考点1:Linux开发者</h1><p>Linux 最早是由一位名叫( )的计算机爱好者开放。</p>
<ul>
<li>A <code>Richard Petersen</code></li>
<li>B <code>Linus Torvalds</code></li>
<li>C <code>Rob Pike</code></li>
<li>D <code>Linus Sarwar</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>李纳斯·脱袜子</p>
<h1 id="考点2-Linux-pagefault"><a href="#考点2-Linux-pagefault" class="headerlink" title="考点2:Linux pagefault"></a>考点2:Linux pagefault</h1><p>Linux什么情况下回发生page fault;</p>
<ul>
<li>A 系统可用内存不够时</li>
<li>B 所需访问虚拟内存未被装载</li>
<li>C 当开始进行<code>swap</code>交换时</li>
<li>D 当进程被挂起时</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>影响一个应用程序性能的因素有很多，这次说说page fault。</p>
<ol>
<li>为什么会存在page fault问题？<br>计算机的物理内存（看看你的内存条）有限，一般现在都是几个GB的容量了，BTW，我的笔记本有8GB，:-)。<br>但应用程序的需求是无限的，操作系统为了解决这个矛盾，使用了虚拟内存的设计。简单的描述就是，给应用程序<br>一个与物理内存无关的虚拟地址空间，并提供一套映射机制，将虚拟地址映射到物理内存。当然应用程序是不知道<br>有这个映射机制存在的，他唯一需要做的就是尽情的使用自己的虚拟地址空间。操作系统提供的映射机制是<br>运行时动态进行虚拟地址和物理地址之间的映射的，当一个虚拟地址没有对应的物理内存时候，<br>映射机制就分配物理内存，构建映射表，满足应用程序的需求，这个过程就叫page fault。<br>与直接访问物理内存不同，page fault过程大部分是由软件完成的，消耗时间比较久，所以是影响性能的一个关键指标。<br>Linux把page fault又进一步分为minor page fault和major page<br>fault。前面提到的分配物理内存，构建映射表过程可以看做是<br>minor page fault。major page<br>fault是由swap机制引入的，对于swap情况，地址映射好了后，还需要从外部存储读取数据，这个<br>过程涉及到IO操作，耗时更久。</li>
<li>如何查看应用程序的page fault指标呢？<br>1） 可以使用time命令：<br>  比如我想看看svm-train的情况（模型训练很耗资源）\time svm-train<br>age_train_equal.txt（前面的斜杠表示不使用shell的内嵌time命令）<br>输出是：7.68user 0.02system 0:07.71elapsed 99%CPU (0avgtext+0avgdata<br>42768maxresident)k<br>       0inputs+6696outputs (0major+15445minor)pagefaults<br>0swaps<br>可以看到只有minor page fault，没有major。<br>time命令的实现是用到了Linux提供的rusage机制。Linux的wait API可以返回一个应用程序的运行过程的资源消耗情况。<br>如果你想在自己的代码中获取资源利用情况，可以使用libc的getrusage函数，这个函数也是内核的API。<br>2） proc文件系统<br>Linux系统下的&#x2F;proc&#x2F;PID&#x2F;stat文件，也提供了相关统计数据。<br>转自： <a href="http://www.cnblogs.com/cornsea/archive/2012/12/17/2821429.html">http://www.cnblogs.com/cornsea/archive/2012/12/17/2821429.html</a></li>
</ol>
<h1 id="考点3-Linux文件去重并排序"><a href="#考点3-Linux文件去重并排序" class="headerlink" title="考点3:Linux文件去重并排序"></a>考点3:Linux文件去重并排序</h1><p>以下哪个命令可实现文件去重并排序:</p>
<ul>
<li>A <code>uniq demo.txt</code></li>
<li>B <code>sort demo.txt</code></li>
<li>C <code>uniq demo.txt|sort</code></li>
<li>D <code>sort demo.txt|uniq</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<h1 id="考点4-自定义DNS解析"><a href="#考点4-自定义DNS解析" class="headerlink" title="考点4:自定义DNS解析"></a>考点4:自定义DNS解析</h1><p>当内网内没有条件建立dns服务器,又不想用IP访问网站,应配置什么文件</p>
<ul>
<li>A <code>hosts</code></li>
<li>B <code>sysconfig</code></li>
<li>C <code>network</code></li>
<li>D <code>hostname</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>hosts文件是Linux系统上一个负责ip地址与域名快速解析的文件，以ascii格式保存在&#x2F;etc&#x2F;目录下。hosts文件包含了ip地址与主机名之间的映射，还包括主机的别名。在没有域名解析服务器的情况下，系统上的所有网络程序都通过查询该文件来解析对应于某个主机名的ip地址，否则就需要使用dns服务程序来解决。通过可以将常用的域名和ip地址映射加入到hosts文件中，实现快速方便的访问。</p>
<p>hosts文件在&#x2F;etc&#x2F;hosts下。<br>既然看到&#x2F;etc&#x2F;了，兄弟萌一起来回顾下&#x2F;etc&#x2F;目录下的一些文件的作用吧！！！<br>&#x2F;etc&#x2F;resolv.conf 是DNS配置文件。在网卡配置文件中进行配置，默认情况下 网卡配置文件DNS优先于&#x2F;etc&#x2F;resolv.conf。<br>&#x2F;etc&#x2F;hostname 在Centos 7，配置主机名，查看修改。<br>&#x2F;etc&#x2F;hosts ip与域名对应关系 ，解析域名（主机名），用&#x2F;etc&#x2F;hosts搭建网站的测试环境 (虚拟机)。不同服务器之间相互访问。<br>&#x2F;etc&#x2F;gateways 设置路由器<br>&#x2F;etc&#x2F;fstab file system table ：文件系统挂载表，开机的时候设备与入口对应关系 开机自动挂载列表。<br>&#x2F;etc&#x2F;rc.local 开机自启<br>&#x2F;etc&#x2F;inittab（centos 6）运行级别的配置文件<br>&#x2F;etc&#x2F;profile 环境变量配置文件<br>&#x2F;etc&#x2F;bashrc 命令别名<br>&#x2F;etc&#x2F;motd 文件中的内容 会在用户登录系统之后显示出来<br>&#x2F;etc&#x2F;issue &#x2F;etc&#x2F;issue.net 文件中的内容 会在用户登录系统之前显示出来</p>
<h1 id="考点5-tar解压缩到指定目录：tar-xvzf-压缩包-C-目的目录"><a href="#考点5-tar解压缩到指定目录：tar-xvzf-压缩包-C-目的目录" class="headerlink" title="考点5:tar解压缩到指定目录：tar -xvzf 压缩包 -C 目的目录"></a>考点5:tar解压缩到指定目录：tar -xvzf 压缩包 -C 目的目录</h1><p>为了将当前目录下的归档文件myftp. tgz解压缩到&#x2F;tmp目录下,用户可以使用命令</p>
<ul>
<li>A <code>tar xvzf myftp. tgz</code> –<code>C /tmp</code></li>
<li>B <code>tar  xvzf  myftp. tgz</code> –<code>R /tmp</code></li>
<li>C <code>tar vzf myftp. tgz</code> –<code>X /tmp</code></li>
<li>D <code>tar xvzf myftp. tgz /tmp</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>tar命令中<br>-x：extract files from an archive即从归档文件中释放文件；<br>-v：verbosely list files processed即详细列出要处理的文件；<br>-z：filter the archive through gzip即通过gzip解压文件；<br>-f：use archive file or device ARCHIVE即使用档案文件或设备；<br>通常情况下解压.tar.gz和.tgz等格式的归档文件就可以直接使用tar xvzf；<br>因为要解压到指定目录下，所以还应在待解压文件名后加上-C（change to directory）参数</p>
<p>tar 配合压缩解压缩常用用法</p>
<h3 id="tar压缩"><a href="#tar压缩" class="headerlink" title="tar压缩"></a>tar压缩</h3><p>tar -cvzf 打包文件名 打包文件集</p>
<h3 id="tar解压缩"><a href="#tar解压缩" class="headerlink" title="tar解压缩"></a>tar解压缩</h3><p>tar -xvzf 需要解包的文件名 -C 解压路径.</p>
<p>x解压<br>z表示gz压缩文件<br>v显示过程<br>f指定的文件</p>
<p>-C指定位置</p>
<p>-c: 建立新的备份文件<br>-t:列出备份文件的内容<br>-x:从备份文件中还原文件<br>-z:通过gzip指令处理备份文件<br>-v:显示指令执行过程<br>-f:指定压缩或解压文件</p>
<pre>
touch a.c  
&#35; 压缩 a.c文件为test.tar.gz a.c
tar -czvf test.tar.gz a.c   
&#35; 列出压缩文件内容
tar -tzvf test.tar.gz
&#35; 解压文件
tar -xzvf test.tar.gz

-C（change to directory）参数
</pre>


<h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6:"></a>考点6:</h1><p>设定linux系统默认为字符模式,需要修改的配置文件是( )</p>
<ul>
<li>A <code>/etc/fstab</code></li>
<li>B <code>/etc/inittab</code></li>
<li>C <code>/etc/boot</code></li>
<li>D <code>/etc/inittab.conf</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>etc&#x2F;inittab 最后一行是运行等级，我的是centos6.5，默认是5，即图形化界面，将5修改为3后，则默认的启动模式将由图形化界面变为纯字符的命令行模式。两者之间也可以通过键盘组合键来转换，ctrl+alt+F2切换到纯字符，alt+F2切换成图形化界面。</p>
<p>把id:5:initdefault中5修改3， </p>
<h3 id="Linux下有7个运行级别"><a href="#Linux下有7个运行级别" class="headerlink" title="Linux下有7个运行级别"></a>Linux下有7个运行级别</h3><p>0系统停机模式，系统默认运行级别不能设置为0，否则不能正常启动，机器关闭。<br>1单用户模式，root权限，用于系统维护，禁止远程登陆，就像Windows下的安全模式登录。<br>2多用户模式，没有NFS网络支持。<br>3完整的多用户文本模式，有NFS，登陆后进入控制台命令行模式。<br>4系统未使用，保留一般不用，在一些特殊情况下可以用它来做一些事情。例如在笔记本电脑的电池用尽时，可以切换到这个模式来做一些设置。 5图形化模式，登陆后进入图形GUI模式，X Window系统。<br>6重启模式，默认运行级别不能设为6，否则不能正常启动。运行init 6机器就会重启。</p>
<h1 id="考点7-chmod修改文件权限"><a href="#考点7-chmod修改文件权限" class="headerlink" title="考点7:chmod修改文件权限"></a>考点7:chmod修改文件权限</h1><p>文件目录data当前权限为<code>rwx------</code>,只需要增加用户组可读可执行权限,但不允许写操作,具体方法为:</p>
<ul>
<li>A <code>chmod +050 data</code></li>
<li>B <code>chmod +040 data</code></li>
<li>C <code>chmod +005 data</code></li>
<li>D <code>chmod +004 data</code></li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>对目录来说只有（r）权限是无法进入的，还要赋予执行权限（x）</p>
<h1 id="考点8-chmod修改文件权限"><a href="#考点8-chmod修改文件权限" class="headerlink" title="考点8:chmod修改文件权限"></a>考点8:chmod修改文件权限</h1><p>文件exer1的访问权限为<code>rw-r--r--</code> ,现要增加所有用户的执行权限和同组用户的写权限,下列命令正确的是</p>
<ul>
<li>A <code>chmod a+x,g+w exer1</code></li>
<li>B <code>chmod 775 exer1</code></li>
<li>C <code>chmod o+x exer1</code></li>
<li>D <code>chmod g+w exer1</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AB</details>

<p>u-g-o：表示用户-用户组-其他用户。<br>a : 表示所有 用户，<br>x : 执行权限，r：读权限，w：写权限。<br>A： a+x &#x3D; 增加所有用户的执行权限；g+w &#x3D; 同组用户的写权限，正确；<br>B：由于文件exer1 刚开始的访问权限为<br>rw-  r–  r–，<br>所有用户加上执行权限变为：rwx   r-x  r-x<br>同组用户加上写权限变为：rwx rwx r-x &#x3D; 775（4-2-1表示r-w-x）。正确。</p>
<h1 id="考点9-删除非目录的方法"><a href="#考点9-删除非目录的方法" class="headerlink" title="考点9:删除非目录的方法"></a>考点9:删除非目录的方法</h1><p>Linux的非root用户,在自己的目录中,不可以删除非空目录dirs的方法是:</p>
<ul>
<li>A <code>rm dir dirs</code></li>
<li>B <code>rm -r dirs</code></li>
<li>C <code>mv dirs /dev/null</code></li>
<li>D <code>destroy dirs</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details>

]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Linux</category>
        <category>2021年04月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年03月22日Linux专项练习1</title>
    <url>/exam//551d2e1a/</url>
    <content><![CDATA[<h1 id="考点1-cat-n"><a href="#考点1-cat-n" class="headerlink" title="考点1:cat -n"></a>考点1:cat -n</h1><p><code>cat -n file1 file2</code>命令的意思是？</p>
<ul>
<li>A 只会把文件<code>file1</code>的内容输出到屏幕上。</li>
<li>B 把文件<code>file1</code>和<code>file2</code>连在一起,然后输出到屏幕上。</li>
<li>C 创建文件<code>file1</code>和<code>file2</code></li>
<li>D 把<code>file2</code>的内容输出到<code>file1</code>中并保存</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>参数-n 或 –number 表示显示行号，行号从1开始</p>
<p>上述命令即将file1和file2的文件内容连在一起然后输出到屏幕，并打印行号，file1和file2文件内容不变 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat --help</span><br><span class="line">用法：cat [选项]... [文件]...</span><br><span class="line">将[文件]或标准输入组合输出到标准输出。</span><br><span class="line"></span><br><span class="line">  -A, --show-all           等于-vET</span><br><span class="line">  -b, --number-nonblank    对非空输出行编号</span><br><span class="line">  -e                       等于-vE</span><br><span class="line">  -E, --show-ends          在每行结束处显示&quot;$&quot;</span><br><span class="line">  -n, --number             对输出的所有行编号</span><br><span class="line">  -s, --squeeze-blank      不输出多行空行</span><br><span class="line">  -t                       与-vT 等价</span><br><span class="line">  -T, --show-tabs          将跳格字符显示为^I</span><br><span class="line">  -u                       (被忽略)</span><br><span class="line">  -v, --show-nonprinting   使用^ 和M- 引用，除了LFD和 TAB 之外</span><br><span class="line">      --help        显示此帮助信息并退出</span><br><span class="line">      --version        显示版本信息并退出</span><br><span class="line"></span><br><span class="line">如果没有指定文件，或者文件为&quot;-&quot;，则从标准输入读取。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">  cat f - g  先输出f 的内容，然后输出标准输入的内容，最后输出g 的内容。</span><br><span class="line">  cat        将标准输入的内容复制到标准输出。</span><br><span class="line"></span><br><span class="line">GNU coreutils online help: &lt;http://www.gnu.org/software/coreutils/&gt;</span><br><span class="line">请向&lt;http://translationproject.org/team/zh_CN.html&gt; 报告cat 的翻译错误</span><br><span class="line">要获取完整文档，请运行：info coreutils &#x27;cat invocation&#x27;</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>

<h1 id="考点2-自由软件的定义"><a href="#考点2-自由软件的定义" class="headerlink" title="考点2:自由软件的定义"></a>考点2:自由软件的定义</h1><p>说 Linux 是一种”自由软件”的主要理由是 ____________ 。</p>
<ul>
<li>A <code>Linux</code>的源代码是公开的</li>
<li>B <code>Linux</code>是多用户、多任务的操作系统</li>
<li>C <code>Linux</code>具有可移植性</li>
<li>D <code>Linux</code>属于<code>GPL</code>软件</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<h1 id="考点3-多路复用IO监听-套接字描述符-select方法的第一个参数maxfd的取值"><a href="#考点3-多路复用IO监听-套接字描述符-select方法的第一个参数maxfd的取值" class="headerlink" title="考点3:多路复用IO监听 套接字描述符 select方法的第一个参数maxfd的取值"></a>考点3:多路复用IO监听 套接字描述符 select方法的第一个参数maxfd的取值</h1><p>采用多路复用I&#x2F;O监听3个套接字的数据时,如果套接字描述符分别是:5,17,19,则<br>select(int maxfd,struct fd_set* rdset,NULL,NULL)<br>中的maxfd应取为()</p>
<ul>
<li>A 4</li>
<li>B 20</li>
<li>C 5</li>
<li>D 9</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>Maxfd表示要监视的文件描述符的范围，一般取监视的描述符数的最大值+1</p>
<h1 id="考点4-文件权限"><a href="#考点4-文件权限" class="headerlink" title="考点4:文件权限"></a>考点4:文件权限</h1><p>某文件的组外成员的权限为只读;所有者有全部权限;组内的权限为读与写,则该文件的权限为__ _ ___ 。</p>
<ul>
<li>A ４６７</li>
<li>B ６７４</li>
<li>C ４７６</li>
<li>D ７６４</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h3 id="文件权限ugo"><a href="#文件权限ugo" class="headerlink" title="文件权限ugo"></a>文件权限ugo</h3><p>u-g-o：用户-组内用户-其他用户</p>
<p>r-w-x：用4-2-1表示。</p>
<p>所有者u有全部权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rwx = 7</span><br></pre></td></tr></table></figure>
<p>组内g的权限为读与写:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rw- = 6</span><br></pre></td></tr></table></figure>
<p>组外成员o的权限为只读：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">r-- = 4</span><br></pre></td></tr></table></figure>

<p>如：<code>-r-xr-x--x为551</code>。<br>最前面的-表示文件类型，</p>
<ul>
<li>如果是文件用-表示，</li>
<li>如果是文件夹用d表示，</li>
<li>如果是链接文件用l表示。</li>
</ul>
<h1 id="考点5-显示当前目录的命令"><a href="#考点5-显示当前目录的命令" class="headerlink" title="考点5:显示当前目录的命令"></a>考点5:显示当前目录的命令</h1><p>用什么命令来显示当前目录？</p>
<ul>
<li>A <code>echo $(pwd)</code></li>
<li>B <code>echo pwd</code></li>
<li>C <code>$pwd</code></li>
<li>D <code>pwd | echo</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>考对于命令替换、echo、环境变量、管道的理解。</p>
<p>A. 将命令替换<code>$()</code>内的的<code>pwd</code>命令执行后，输出结果给到<code>echo</code>，再由<code>echo</code>输出。等效于直接执行命令<code>pwd</code>。<br>B. echo后面的普通字符会被直接默认当做字符串输出。<br>C. 一般来说系统里是不存在<code>$pwd</code>这个环境变量的，而有<code>$PWD</code>、<code>$OLDPWD</code>，这俩环境变量分别是用来打印当前、上一次工作目录的。一般在shell脚本编写里也会使用环境变量<code>$PWD</code>来代替命令<code>$(pwd)</code>获取当前工作目录。<br>D. 由于存在管道符，所以<code>pwd</code>命令的输出传递给了管道后的输入，但<code>echo</code>无法接收该输入，所以就相当于把<code>pwd</code>的结果丢弃了，然后执行<code>echo</code>，就输出为空了。如果想要把通过管道后的输入作为参数传递给<code>echo</code>，则需要加上<code>xargs</code>。像这样<code>pwd | xargs echo</code></p>
<h1 id="考点6-bash环境的用户文件"><a href="#考点6-bash环境的用户文件" class="headerlink" title="考点6:bash环境的用户文件"></a>考点6:bash环境的用户文件</h1><p>定义bash环境的用户文件是？</p>
<ul>
<li>A bash &amp;.bashrc</li>
<li>B bash &amp; bash_profile</li>
<li>C bashrc &amp;.bash_profile</li>
<li>D bashrc &amp;.bash_conf</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<table>
<thead>
<tr>
<th align="left">文件</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>~/.bash_profile</code></td>
<td align="left">每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.此文件类似于&#x2F;etc&#x2F;profile，也是需要需要重启才会生效，&#x2F;etc&#x2F;profile对所有用户生效，~&#x2F;.bash_profile只对当前用户生效。</td>
</tr>
<tr>
<td align="left"><code>~/.bashrc</code></td>
<td align="left">该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.（每个用户都有一个.bashrc文件，在用户目录下）此文件类似于&#x2F;etc&#x2F;bashrc，不需要重启生效，重新打开一个bash即可生效， &#x2F;etc&#x2F;bashrc对所有用户新打开的bash都生效，但~&#x2F;.bashrc只对当前用户新打开的bash生效。</td>
</tr>
</tbody></table>
<h1 id="考点7-死锁的必要条件"><a href="#考点7-死锁的必要条件" class="headerlink" title="考点7:死锁的必要条件"></a>考点7:死锁的必要条件</h1><p>下面哪些是死锁的必要条件？</p>
<ul>
<li>A 互斥</li>
<li>B 请求保持</li>
<li>C 不可剥夺</li>
<li>D 环路</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>

<h3 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h3><p>（1） 互斥条件：一个资源每次只能被一个进程使用。<br>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3） 不剥夺条件：进程已获得的资源，在使用完之前，不能强行剥夺。<br>（4） 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<h1 id="考点8-查看Linux系统状态的命令"><a href="#考点8-查看Linux系统状态的命令" class="headerlink" title="考点8:查看Linux系统状态的命令"></a>考点8:查看Linux系统状态的命令</h1><p>如何查看当前Linux系统的状态,如CPU使用,内存使用,负载情况,下列描述正确的是？</p>
<ul>
<li>A 可以使用<code>top</code>命令分析<code>CPU</code>使用,内存使用,负载等情况</li>
<li>B 可以使用<code>free</code>查看内存整体的使用情况</li>
<li>C 可以使用<code>cat /proc/meminfo</code>查看内存更详细的情况</li>
<li>D 以上描述都不正确</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<p>top命令：<br>Linux下常用的性能分析工具。能够实时显示系统中各个进程对资源的占用状况。<br>free命令：<br>可以显示Linux系统中空闲的、已用的物理内存及swap内存，及被内核使用的buffer。<br>df命令：<br>用于显示当前在Linux系统上的文件系统的磁盘使用情况的统计信息。</p>
<h1 id="考点9-DHCP-获取服务器分配的IP地址的命令"><a href="#考点9-DHCP-获取服务器分配的IP地址的命令" class="headerlink" title="考点9:DHCP 获取服务器分配的IP地址的命令"></a>考点9:DHCP 获取服务器分配的IP地址的命令</h1><p>Linux系统中,已经将DHCP服务器架设好,客户端的网络接口eth0,可以通过( )命令获得服务器分配的IP地址。多选</p>
<ul>
<li>A <code>dhclient</code></li>
<li>B <code>ifdown eth0;ifup eth0</code></li>
<li>C <code>ifconfig</code></li>
<li>D <code>service network stop;service network start</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>

]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Linux</category>
        <category>2021年03月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年03月23日Linux专项练习4</title>
    <url>/exam//7a1aced2/</url>
    <content><![CDATA[<h1 id="考点1-如何修改文件权限"><a href="#考点1-如何修改文件权限" class="headerlink" title="考点1:如何修改文件权限"></a>考点1:如何修改文件权限</h1><p>怎样更改一个文件的权限设置？</p>
<ul>
<li>A <code>chmod</code></li>
<li>B <code>file</code></li>
<li>C <code>attrib</code></li>
<li>D <code>change</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>chmod 是change &amp;nbsp;mode of file 的缩写，改变文件的的读写权限。</p>
<h1 id="考点2-hardware-filename-fixed-address-server-name命令"><a href="#考点2-hardware-filename-fixed-address-server-name命令" class="headerlink" title="考点2:hardware filename fixed-address server-name命令"></a>考点2:hardware filename fixed-address server-name命令</h1><p>在dhcpd.conf中用于向某个客户主机分配固定IP地址的参数是 (   )</p>
<ul>
<li>A <code>server-name</code></li>
<li>B <code>fixed-address</code></li>
<li>C <code>filename</code></li>
<li>D <code>hardware</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="hardware语句"><a href="#hardware语句" class="headerlink" title="hardware语句"></a>hardware语句</h3><p>语法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hardware hardware-type hardware-address; </span><br></pre></td></tr></table></figure>
<p>指明物理硬件接口类型和硬件地址。硬件地址由6个8位组构成，每个8位组以“：”隔开。如00：00：E8：1B：54：97</p>
<h3 id="server-name-语句"><a href="#server-name-语句" class="headerlink" title="server-name 语句"></a>server-name 语句</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server-name <span class="string">&quot;name&quot;</span>; </span><br></pre></td></tr></table></figure>
<p>用于告诉客户服务器的名字。</p>
<h3 id="fixed-address-语句"><a href="#fixed-address-语句" class="headerlink" title="fixed-address 语句"></a>fixed-address 语句</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fixed-address address [, address ... ]; </span><br></pre></td></tr></table></figure>
<p>fixed-address 语句用于指定一个或多个IP地址给一个DHCP客户。只能出现在host声明里。</p>
<h1 id="考点3-ls-df-du-fine命令"><a href="#考点3-ls-df-du-fine命令" class="headerlink" title="考点3:ls df du fine命令"></a>考点3:ls df du fine命令</h1><p>下列哪个命令可以看到文件的大小？(不添加参数的情况下)</p>
<ul>
<li>A <code>ls</code></li>
<li>B <code>df</code></li>
<li>C <code>du</code></li>
<li>D <code>find</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>A：ls是list的缩写，用来显示当前目录下面文件的信息；如果要查看文件的大小则需要加上-al参数<br>B：df是disk free的缩写，用来显示文件系统中不同磁盘的使用情况；<br>C：du是disk usage的缩写，显示当前目录或者当前文件的占用的块大小；<br>D：find命令作用在目录下，用来查找指定目录或者当前目录下的文件。</p>
<h2 id="ls-l查看文件大小"><a href="#ls-l查看文件大小" class="headerlink" title="ls -l查看文件大小"></a>ls -l查看文件大小</h2><p>参考资料：<a href="https://www.cnblogs.com/sparkdev/p/7476005.html">https://www.cnblogs.com/sparkdev/p/7476005.html</a><br>ls -al命令输出的第5列就是该文件或目录的大小（以字节为单位显示的文件大小）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ls -l exam/</span><br><span class="line">总用量 3640</span><br><span class="line">-rw-r--r--.   1 root root    3093 3月  19 21:12 _config.yml</span><br><span class="line">-rw-r--r--.   1 root root 3498022 3月  22 20:29 db.json</span><br><span class="line">-rw-r--r--.   1 root root     158 3月  19 21:12 FM.properties</span><br><span class="line">-rw-r--r--.   1 root root     576 3月  19 21:12 HexoD.bat</span><br><span class="line">-rw-r--r--.   1 root root     431 3月  22 20:52 HexoS.bat</span><br><span class="line">-rwxr--r--.   1 root root     174 3月  19 21:16 hexos.sh</span><br><span class="line">-rw-r--r--.   1 root root     376 3月  19 21:12 HexoSTest.bat</span><br><span class="line">drwxr-xr-x. 308 root root    8192 3月  19 21:19 node_modules</span><br><span class="line">-rw-r--r--.   1 root root     817 3月  19 21:12 package.json</span><br><span class="line">-rw-r--r--.   1 root root  170424 3月  19 21:19 package-lock.json</span><br><span class="line">drwxr-xr-x.   2 root root    4096 3月  19 21:12 scaffolds</span><br><span class="line">drwxr-xr-x.   9 root root    4096 3月  19 21:12 source</span><br><span class="line">-rw-r--r--.   1 root root     422 3月  19 21:12 StartWriting.bat</span><br><span class="line">drwxr-xr-x.   3 root root    4096 3月  19 21:12 themes</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>
<h3 id="ls-lh"><a href="#ls-lh" class="headerlink" title="ls -lh"></a>ls -lh</h3><p>在 Linux 命令中，涉及到文件大小的地方，一般默认是以字节为单位显示的。这样可读性就不是很好。所以有了 -h 选项！这个选项的全称是 –human-readable(给人读的)。也就是以 K, M, G 等单位来显示文件的大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ls -lh exam/</span><br><span class="line">总用量 3.6M</span><br><span class="line">-rw-r--r--.   1 root root 3.1K 3月  19 21:12 _config.yml</span><br><span class="line">-rw-r--r--.   1 root root 3.4M 3月  22 20:29 db.json</span><br><span class="line">-rw-r--r--.   1 root root  158 3月  19 21:12 FM.properties</span><br><span class="line">-rw-r--r--.   1 root root  576 3月  19 21:12 HexoD.bat</span><br><span class="line">-rw-r--r--.   1 root root  431 3月  22 20:52 HexoS.bat</span><br><span class="line">-rwxr--r--.   1 root root  174 3月  19 21:16 hexos.sh</span><br><span class="line">-rw-r--r--.   1 root root  376 3月  19 21:12 HexoSTest.bat</span><br><span class="line">drwxr-xr-x. 308 root root 8.0K 3月  19 21:19 node_modules</span><br><span class="line">-rw-r--r--.   1 root root  817 3月  19 21:12 package.json</span><br><span class="line">-rw-r--r--.   1 root root 167K 3月  19 21:19 package-lock.json</span><br><span class="line">drwxr-xr-x.   2 root root 4.0K 3月  19 21:12 scaffolds</span><br><span class="line">drwxr-xr-x.   9 root root 4.0K 3月  19 21:12 source</span><br><span class="line">-rw-r--r--.   1 root root  422 3月  19 21:12 StartWriting.bat</span><br><span class="line">drwxr-xr-x.   3 root root 4.0K 3月  19 21:12 themes</span><br><span class="line">[root@localhost ~]# </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="考点4-Linux命令返回值"><a href="#考点4-Linux命令返回值" class="headerlink" title="考点4:Linux命令返回值"></a>考点4:Linux命令返回值</h1><p>linux命令执行成功后会返回</p>
<ul>
<li>A 0</li>
<li>B 1</li>
<li>C 2</li>
<li>D -1</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h3 id="Linux命令返回值"><a href="#Linux命令返回值" class="headerlink" title="Linux命令返回值"></a>Linux命令返回值</h3><p>参考资料：<br><a href="https://blog.csdn.net/cy413026/article/details/104172448">https://blog.csdn.net/cy413026/article/details/104172448</a><br>Linux错误代码及其含义：<a href="https://blog.csdn.net/u013457167/article/details/79196306">https://blog.csdn.net/u013457167/article/details/79196306</a></p>
<p>在shell终端中，你所输入的一切命令其实都有返回值，而这个返回值默认保存在变量<code>$?</code>中，举例看一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line"> </span><br><span class="line">grup_pwd=`cat /etc/grub.conf | grep -v ^# | grep password 2&gt; /dev/null`</span><br><span class="line"> </span><br><span class="line">if [ $? -eq 0 ];then</span><br><span class="line">   echo &quot;  [ √ ] 已设置grub密码,符合要求&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;  [ X ] 没有设置grub密码，不符合要求,建议设置grub密码&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h3 id="Linux错误码含义"><a href="#Linux错误码含义" class="headerlink" title="Linux错误码含义"></a>Linux错误码含义</h3><p>Linux错误代码及其含义：<a href="https://blog.csdn.net/u013457167/article/details/79196306">https://blog.csdn.net/u013457167/article/details/79196306</a></p>
<h1 id="考点5-查看文件命令cat-more-tail"><a href="#考点5-查看文件命令cat-more-tail" class="headerlink" title="考点5:查看文件命令cat more tail"></a>考点5:查看文件命令cat more tail</h1><p>为了查看不断更新的日志文件,可以使用的指令是()</p>
<ul>
<li>A <code>cat -n</code></li>
<li>B <code>vi</code></li>
<li>C <code>more</code></li>
<li>D <code>tail -f</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>linux 下tail用于查看档案的结尾，-f 参数是follow的意思，当文件增长时，输出后续添加的数据。所以使用使用tail命令的-f选项可以方便的查阅正在改变的日志文件。<br>Linux tail 命令：<a href="https://www.runoob.com/linux/linux-comm-tail.html">https://www.runoob.com/linux/linux-comm-tail.html</a></p>
<h1 id="考点5-vi编辑器的三种模式"><a href="#考点5-vi编辑器的三种模式" class="headerlink" title="考点5:vi编辑器的三种模式"></a>考点5:vi编辑器的三种模式</h1><p>在RHEL5系统中,在vi编辑器环境中的任意时刻,选择”ESC”键后,编辑器将进入(  )模式</p>
<ul>
<li>A 命令</li>
<li>B 输入</li>
<li>C 末行</li>
<li>D 文本</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>
  
<p>vim编辑器可以分为三种模式：<br>1.命令模式：控制屏幕光标的移动，进行文本的删除，复制等文字编辑工作，不使用【del】和【backspace】键，以及进入插入模式或者回到底行模式；<br>2.插入模式：只有在插入模式下，才可以输入文字，按【esc】可以回到命令模式，vim编辑器一打开是不可以输入的，因为刚打开时候处于命令模式;<br>3.底行模式：保存文件或者退出vim，也可以设置编辑环境和一些编译工作。<br><img data-src="https://uploadfiles.nowcoder.com/images/20180619/3431580_1529372993152_25A1FCC1486B869925E23FECFEBADC61"></p>
<h1 id="考点6-useradd命令"><a href="#考点6-useradd命令" class="headerlink" title="考点6:useradd命令"></a>考点6:useradd命令</h1><p>创建用户时不指定用户主目录的参数(      )</p>
<ul>
<li>A <code>useradd -o</code></li>
<li>B <code>useradd -m</code></li>
<li>C <code>useradd -M</code></li>
<li>D <code>useradd -d</code></li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<table>
<thead>
<tr>
<th align="left">useradd参数</th>
<th align="left">全称</th>
<th align="left">释义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-b</td>
<td align="left">base-dir BASE_DIR</td>
<td align="left">新账户的主目录的基目录</td>
</tr>
<tr>
<td align="left">-c</td>
<td align="left">comment COMMENT</td>
<td align="left">新账户的 GECOS 字段</td>
</tr>
<tr>
<td align="left">-d</td>
<td align="left">home-dir HOME_DIR</td>
<td align="left">新账户的主目录</td>
</tr>
<tr>
<td align="left">-D</td>
<td align="left">defaults</td>
<td align="left">显示或更改默认的 useradd 配置</td>
</tr>
<tr>
<td align="left">-e</td>
<td align="left">expiredate EXPIRE_DATE</td>
<td align="left">新账户的过期日期</td>
</tr>
<tr>
<td align="left">-f</td>
<td align="left">inactive INACTIVE</td>
<td align="left">新账户的密码不活动期</td>
</tr>
<tr>
<td align="left">-g</td>
<td align="left">gid GROUP</td>
<td align="left">新账户主组的名称或 ID</td>
</tr>
<tr>
<td align="left">-G</td>
<td align="left">groups GROUPS</td>
<td align="left">新账户的附加组列表</td>
</tr>
<tr>
<td align="left">-h</td>
<td align="left">help</td>
<td align="left">显示此帮助信息并推出</td>
</tr>
<tr>
<td align="left">-k</td>
<td align="left">skel SKEL_DIR</td>
<td align="left">使用此目录作为骨架目录</td>
</tr>
<tr>
<td align="left">-K</td>
<td align="left">key KEY&#x3D;VALUE</td>
<td align="left">不使用 &#x2F;etc&#x2F;login.defs 中的默认值</td>
</tr>
<tr>
<td align="left">-l</td>
<td align="left">no-log-init</td>
<td align="left">不要将此用户添加到最近登录和登录失败数据库</td>
</tr>
<tr>
<td align="left">-m</td>
<td align="left">create-home</td>
<td align="left">创建用户的主目录</td>
</tr>
<tr>
<td align="left">-M</td>
<td align="left">no-create-home</td>
<td align="left">不创建用户的主目录</td>
</tr>
<tr>
<td align="left">-N</td>
<td align="left">no-user-group</td>
<td align="left">不创建同名的组</td>
</tr>
<tr>
<td align="left">-o</td>
<td align="left">non-unique</td>
<td align="left">允许使用重复的 UID 创建用户</td>
</tr>
<tr>
<td align="left">-p</td>
<td align="left">password PASSWORD</td>
<td align="left">加密后的新账户密码</td>
</tr>
<tr>
<td align="left">-r</td>
<td align="left">system</td>
<td align="left">创建一个系统账户</td>
</tr>
<tr>
<td align="left">-s</td>
<td align="left">shell SHELL</td>
<td align="left">新账户的登录 shell</td>
</tr>
<tr>
<td align="left">-u</td>
<td align="left">uid UID</td>
<td align="left">新账户的用户 ID</td>
</tr>
<tr>
<td align="left">-U</td>
<td align="left">user-group</td>
<td align="left">创建与用户同名的组</td>
</tr>
<tr>
<td align="left">-Z</td>
<td align="left">selinux-user SEUSER</td>
<td align="left">为 SELinux 用户映射使用指定 SEUSER</td>
</tr>
</tbody></table>
<h1 id="考点7-多进程同时操作一个文件"><a href="#考点7-多进程同时操作一个文件" class="headerlink" title="考点7:多进程同时操作一个文件"></a>考点7:多进程同时操作一个文件</h1><p>Linux下两个进程可以同时打开同一个文件,这时如下描述错误的是:</p>
<ul>
<li>A 两个进程中分别产生生成两个独立的<code>fd</code></li>
<li>B 两个进程可以任意对文件进行读写操作,操作系统并不保证写的原子性</li>
<li>C 进程可以通过系统调用对文件加锁,从而实现对文件内容的保护</li>
<li>D 任何一个进程删除该文件时,另外一个进程会立即出现读写失败</li>
<li>E 两个进程可以分别读取文件的不同部分而不会相互影响</li>
<li>F 一个进程对文件长度和内容的修改另外一个进程可以立即感知</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>一般删除都是文件索引，如果两个文件同时打开同一个文件，一个线程执行删除操作，只要另一个线程不退出，就可以继续对该文件进行操作，一旦退出才找不到该文件的索引节点而报错。</p>
<p>内核中，对应于每个进程都有一个文件描述符表，表示这个进程打开的所有文件。文件描述表中每一项都是一个指针，指向一个用于描述打开的文件的数据块———file对象，file对象中描述了文件的打开模式，读写位置等重要信息，当进程打开一个文件时，内核就会创建一个新的file对象。需要注意的是，file对象不是专属于某个进程的，不同进程的文件描述符表中的指针可以指向相同的file对象，从而共享这个打开的文件。file对象有引用计数，记录了引用这个对象的文件描述符个数，只有当引用计数为0时，内核才销毁file对象，因此某个进程关闭文件，不影响与之共享同一个file对象的进程.<br><a href="http://www.cnblogs.com/zhaoyl/archive/2012/05/15/2502010.html">http://www.cnblogs.com/zhaoyl/archive/2012/05/15/2502010.html</a><br><a href="http://blog.chinaunix.net/uid-26548237-id-3046664.html">http://blog.chinaunix.net/uid-26548237-id-3046664.html</a></p>
<h1 id="考点8-TCP握手-分手"><a href="#考点8-TCP握手-分手" class="headerlink" title="考点8:TCP握手 分手"></a>考点8:TCP握手 分手</h1><p>TCP的握手与分手,可能出现的情形有()。</p>
<ul>
<li>A 握手需要3次通信</li>
<li>B 分手需要进行4次通信</li>
<li>C <code>FIN</code>和<code>ACK</code> 在同一包里</li>
<li>D <code>ACK</code> 和<code>SYN</code> 在同一包里</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>

<p>知识盲区：后续再解析<br><a href="https://m.nowcoder.com/questions?tagId=42507626&type=1&source=intelli&pos=6">https://m.nowcoder.com/questions?tagId=42507626&type=1&source=intelli&pos=6</a></p>
<h1 id="考点9-Linux日志文件"><a href="#考点9-Linux日志文件" class="headerlink" title="考点9:Linux日志文件"></a>考点9:Linux日志文件</h1><p>以下说法正确的是()</p>
<ul>
<li>A <code>linux</code>系统中的<code>/var/log/lastlog</code>日志记录了所有用户最后登录的记录,可以用<code>lastlog</code>命令查看</li>
<li>B <code>linux</code>系统中的<code>/var/log/last</code>日志可以用<code>last</code>命令查看</li>
<li>C <code>/var/log/wtmp</code>日志记录了登录过本系统的用户信息,可以用<code>tail -f</code>命令查看</li>
<li>D <code>/var/run/utmp</code>日志记录了正在登录本系统中的用户信息,可以用<code>last -f</code>命令查看</li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details>

<p>B. 执行last指令时，它会读取位于&#x2F;var&#x2F;log&#x2F;wtmp的文件，并把该给文件的内容记录的登录系统的用户名单全部显示出来。<br>C. wtmp是二进制文件，他们不能被诸如tail命令剪贴或合并，需要使用who、w、users、last和ac来使用这两个文件包含的信息。</p>
<p><strong>&#x2F;var&#x2F;log&#x2F;lastlog</strong>:记录系统中所有用户最后一次的登录时间的曰志。这个文件也是二进制文件.不能直接用Vi 查看。而要使用lastlog命令查看<br><strong>&#x2F;var&#x2F;log&#x2F;wtmp</strong> :永久记录所有用户的登陆、注销信息，同时记录系统的后动、重启、关机事件。同样，这个文件也是二进制文件.不能直接用Vi查看，而要使用<strong>last命令</strong>查看.<br><strong>&#x2F;var&#x2F;log&#x2F;utmp</strong>:记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息。同样，这个文件不能直接用Vi查看，而要使用w、who、users等命令查看 </p>
<p><strong>&#x2F;var&#x2F;log&#x2F;wtmp</strong>是一个二进制文件，记录每个用户的登录次数和持续时间等信息，使用”last -f”查看，如”last -f &#x2F;var&#x2F;log&#x2F;wtmp”;<br><strong>&#x2F;var&#x2F;run&#x2F;utmp</strong>是一个二进制文件，保存当前在本系统中的用户信息，使用”last -f”查看，如”last -f &#x2F;var&#x2F;run&#x2F;utmp”;<br>  </p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://linux.cn/article-10096-1.html">https://linux.cn/article-10096-1.html</a></p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Linux</category>
        <category>2021年03月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年03月22日Linux专项练习3</title>
    <url>/exam//f3563fb1/</url>
    <content><![CDATA[<h1 id="考点1-Linux添加用户命令"><a href="#考点1-Linux添加用户命令" class="headerlink" title="考点1:Linux添加用户命令"></a>考点1:Linux添加用户命令</h1><p>增加一个用户的命令是什么</p>
<ul>
<li>A <code>useradd</code></li>
<li>B <code>usermod</code></li>
<li>C <code>groupadd</code></li>
<li>D <code>userdel</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<ul>
<li>useradd 增加用户</li>
<li>usermod 修改用户账号信息</li>
<li>groupadd 添加组账号</li>
<li>userdel 删除用户</li>
</ul>
<h1 id="考点2-查看线程信息的gdb"><a href="#考点2-查看线程信息的gdb" class="headerlink" title="考点2:查看线程信息的gdb"></a>考点2:查看线程信息的gdb</h1><p>写出完成gdb查看线程信息功能的gdb命令。</p>
<ul>
<li>A <code>bt</code></li>
<li>B <code>info thread</code></li>
<li>C <code>set scheduler-locking off</code></li>
<li>D <code>info break</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="backtrace-bt"><a href="#backtrace-bt" class="headerlink" title="backtrace bt"></a>backtrace bt</h3><p>打印当前的函数调用栈的所有信息。</p>
<h3 id="info-threads"><a href="#info-threads" class="headerlink" title="info threads"></a>info threads</h3><p>显示当前可调试的所有线程，每个线程会有一个GDB为其分配的ID，后面操作线程的时候会用到这个ID。前面有*的是当前调试的线程。</p>
<h3 id="set-scheduler-locking"><a href="#set-scheduler-locking" class="headerlink" title="set scheduler-locking"></a>set scheduler-locking</h3><p>线程调试显示线程状态,off 不锁定任何线程</p>
<h3 id="info-break"><a href="#info-break" class="headerlink" title="info break"></a>info break</h3><p>可列出所有断点信息，info break 后也可设置要查看的break num</p>
<h1 id="考点3-Linux查看CPU占用"><a href="#考点3-Linux查看CPU占用" class="headerlink" title="考点3:Linux查看CPU占用"></a>考点3:Linux查看CPU占用</h1><p>linux查看cpu占用的命令是什么？</p>
<ul>
<li>A <code>top</code></li>
<li>B <code>netstat</code></li>
<li>C <code>free</code></li>
<li>D <code>df</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">top</td>
<td align="left">查看CPU占用、</td>
</tr>
<tr>
<td align="left">netstat</td>
<td align="left">显示网络连接、路由表、网络接口信息、</td>
</tr>
<tr>
<td align="left">free</td>
<td align="left">查看内存使用情况、</td>
</tr>
<tr>
<td align="left">df</td>
<td align="left">检查文件系统的磁盘空间的占用情况</td>
</tr>
</tbody></table>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# top</span><br><span class="line">top - 14:55:48 up 1 day,  7:53,  1 user,  load average: 5.39, 5.48, 5.66</span><br><span class="line">Tasks: 459 total,   5 running, 454 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  2.9 us, 10.5 sy,  0.0 ni, 86.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  3686064 total,   210728 free,  1495188 used,  1980148 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.  2154167 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                  </span><br><span class="line">  459 aid_med+  20   0  105704  25716   8812 S  28.6  0.7 525:05.08 mediaserver                                                                                              </span><br><span class="line">18389 root      20   0  112596   2364   1372 R  23.8  0.1   0:00.13 top                                                                                                      </span><br><span class="line">  271 root      rt   0       0      0      0 S   4.8  0.0  20:48.85 cfinteractive                                                                                            </span><br><span class="line"> 3100 root      19  -1       0      0      0 S   4.8  0.0  11:05.56 VosRXThread                                                                                              </span><br><span class="line">    1 root      20   0    1256   1000    396 S   0.0  0.0   1:29.37 init                                                                                                     </span><br><span class="line">    2 root      -2   0       0      0      0 S   0.0  0.0   0:00.25 kthreadd                                                                                                 </span><br><span class="line">    3 root      20   0       0      0      0 S   0.0  0.0   2:26.66 ksoftirqd/0                                                                                              </span><br><span class="line">    6 root      20   0       0      0      0 S   0.0  0.0   0:00.10 kworker/u16:0                                                                                            </span><br><span class="line">    7 root      20   0       0      0      0 S   0.0  0.0   3:14.78 rcu_preempt                                                                                              </span><br><span class="line">    8 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcu_bh                                                                                                   </span><br><span class="line">    9 root      20   0       0      0      0 S   0.0  0.0   0:00.68 rcu_sched                                                                                                </span><br><span class="line">   10 root      rt   0       0      0      0 S   0.0  0.0   0:24.56 migration/0                                                                                              </span><br><span class="line">   11 root      rt   0       0      0      0 S   0.0  0.0   0:18.06 migration/1                                                                                              </span><br><span class="line">   12 root      20   0       0      0      0 S   0.0  0.0   1:50.00 ksoftirqd/1                                                                                              </span><br><span class="line">   15 root      rt   0       0      0      0 S   0.0  0.0   0:14.80 migration/2                                                                                              </span><br><span class="line">   16 root      20   0       0      0      0 S   0.0  0.0   1:36.11 ksoftirqd/2                                                                                              </span><br><span class="line">   19 root      rt   0       0      0      0 S   0.0  0.0   0:13.23 migration/3                                                                                              </span><br><span class="line">   20 root      20   0       0      0      0 S   0.0  0.0   1:26.22 ksoftirqd/3                                                                                              </span><br><span class="line">   22 root       0 -20       0      0      0 S   0.0  0.0   0:15.00 kworker/3:0H                                                                                             </span><br><span class="line">   23 root      rt   0       0      0      0 S   0.0  0.0   0:04.04 migration/4                                                                                              </span><br><span class="line">   24 root      20   0       0      0      0 S   0.0  0.0   0:03.91 ksoftirqd/4                                                                                              </span><br><span class="line">   26 root       0 -20       0      0      0 S   0.0  0.0   0:00.15 kworker/4:0H                                                                                             </span><br><span class="line">   27 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 khelper                                                                                                  </span><br><span class="line">   28 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 netns                                                                                                    </span><br><span class="line">   29 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 wakelock_printk                                                                                          </span><br><span class="line">   30 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 perf                                                                                                     </span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>

<h1 id="考点4-x2F-etc目录下各个文件的作用"><a href="#考点4-x2F-etc目录下各个文件的作用" class="headerlink" title="考点4:&#x2F;etc目录下各个文件的作用"></a>考点4:&#x2F;etc目录下各个文件的作用</h1><p>下列文件中,包含了主机名到IP地址的映射关系的文件是: 。</p>
<ul>
<li>A <code>/etc/HOSTNAME</code></li>
<li>B <code>/etc/hosts</code></li>
<li>C <code>/etc/resolv.conf</code></li>
<li>D <code>/etc/networks</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="x2F-etc-x2F-目录下的文件的作用"><a href="#x2F-etc-x2F-目录下的文件的作用" class="headerlink" title="&#x2F;etc&#x2F;目录下的文件的作用"></a>&#x2F;etc&#x2F;目录下的文件的作用</h3><table>
<thead>
<tr>
<th align="left">&#x2F;etc&#x2F;文件</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>/etc/resolv.conf</code></td>
<td align="left">是<code>DNS</code>配置文件。在网卡配置文件中进行配置，默认情况下 网卡配置文件<code>DNS</code>优先于<code>/etc/resolv.conf</code>。</td>
</tr>
<tr>
<td align="left"><code>/etc/hostname</code></td>
<td align="left">在<code>Centos 7</code>，配置主机名，查看修改。</td>
</tr>
<tr>
<td align="left"><code>/etc/hosts</code></td>
<td align="left"><code>ip</code>与域名对应关系 ，解析域名（主机名），用<code>/etc/hosts</code>搭建网站的测试环境 (虚拟机)。不同服务器之间相互访问。</td>
</tr>
<tr>
<td align="left"><code>/etc/fstab</code></td>
<td align="left"><code>file system table</code> ：文件系统挂载表，开机的时候设备与入口对应关系 开机自动挂载列表。</td>
</tr>
<tr>
<td align="left"><code>/etc/rc.local</code></td>
<td align="left">开机自启</td>
</tr>
<tr>
<td align="left"><code>/etc/inittab</code>（<code>centos 6</code>）</td>
<td align="left">运行级别的配置文件</td>
</tr>
<tr>
<td align="left"><code>/etc/profile</code></td>
<td align="left">环境变量配置文件</td>
</tr>
<tr>
<td align="left"><code>/etc/bashrc</code></td>
<td align="left">命令别名</td>
</tr>
<tr>
<td align="left"><code>/etc/motd</code></td>
<td align="left">文件中的内容 会在用户登录系统之后显示出来</td>
</tr>
<tr>
<td align="left"><code>/etc/issue /etc/issue.net</code></td>
<td align="left">文件中的内容 会在用户登录系统之前显示出来</td>
</tr>
</tbody></table>
<h1 id="考点5-Linux系统调用"><a href="#考点5-Linux系统调用" class="headerlink" title="考点5:Linux系统调用"></a>考点5:Linux系统调用</h1><p>linux的系统调用是指</p>
<ul>
<li>A 由内核发起的调用</li>
<li>B <code>glibc</code>函数库里的函数</li>
<li>C 由系统管理员运行的程序</li>
<li>D 是用户进程调用内核功能的接口</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h3 id="什么是系统调用"><a href="#什么是系统调用" class="headerlink" title="什么是系统调用"></a>什么是系统调用</h3><p>系统调用是指内核提供的，功能十分强大的一系列函数。这些系统调用是在内核中实现的，再通过一定的方式把系统调用给用户，一般通过门（gate）陷入（trap）实现。系统调用是用户程序和内核交互的接口。</p>
<h3 id="5个系统调用"><a href="#5个系统调用" class="headerlink" title="5个系统调用"></a>5个系统调用</h3><ul>
<li>open,</li>
<li>write,</li>
<li>read,</li>
<li>close,</li>
<li>ioctl</li>
</ul>
<h1 id="考点6-top-free-x2F-proc-x2F-meminfo"><a href="#考点6-top-free-x2F-proc-x2F-meminfo" class="headerlink" title="考点6:top free &#x2F;proc&#x2F;meminfo"></a>考点6:top free &#x2F;proc&#x2F;meminfo</h1><p>如何查看当前Linux系统的状态,如CPU使用,内存使用,负载情况,下列描述正确的是？</p>
<ul>
<li>A 可以使用<code>top</code>命令分析<code>CPU</code>使用,内存使用,负载等情况</li>
<li>B 可以使用<code>free</code>查看内存整体的使用情况</li>
<li>C 可以使用<code>cat /proc/meminfo</code>查看内存更详细的情况</li>
<li>D 以上描述都不正确</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>

<h3 id="分析CPU使用-内存使用-负载情况-top"><a href="#分析CPU使用-内存使用-负载情况-top" class="headerlink" title="分析CPU使用 内存使用 负载情况 top"></a>分析CPU使用 内存使用 负载情况 top</h3><p>见上述的top</p>
<h3 id="查看内存整体使用情况-free-h"><a href="#查看内存整体使用情况-free-h" class="headerlink" title="查看内存整体使用情况 free -h"></a>查看内存整体使用情况 free -h</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           3.5G        1.4G        202M        2.8M        1.9G        2.1G</span><br><span class="line">Swap:            0B          0B          0B</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>
<h3 id="查看内存详细信息-cat-x2F-proc-x2F-meminfo"><a href="#查看内存详细信息-cat-x2F-proc-x2F-meminfo" class="headerlink" title="查看内存详细信息 cat &#x2F;proc&#x2F;meminfo"></a>查看内存详细信息 cat &#x2F;proc&#x2F;meminfo</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat /proc/meminfo</span><br><span class="line">MemTotal:        3686064 kB</span><br><span class="line">MemFree:          204972 kB</span><br><span class="line">Buffers:          117712 kB</span><br><span class="line">Cached:          1803660 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">Active:          1754532 kB</span><br><span class="line">Inactive:        1109552 kB</span><br><span class="line">Active(anon):     949128 kB</span><br><span class="line">Inactive(anon):     2440 kB</span><br><span class="line">Active(file):     805404 kB</span><br><span class="line">Inactive(file):  1107112 kB</span><br><span class="line">Unevictable:        5956 kB</span><br><span class="line">Mlocked:               0 kB</span><br><span class="line">SwapTotal:             0 kB</span><br><span class="line">SwapFree:              0 kB</span><br><span class="line">Dirty:                 0 kB</span><br><span class="line">Writeback:            84 kB</span><br><span class="line">AnonPages:        948680 kB</span><br><span class="line">Mapped:           467008 kB</span><br><span class="line">Shmem:              2820 kB</span><br><span class="line">Slab:             150864 kB</span><br><span class="line">SReclaimable:      64912 kB</span><br><span class="line">SUnreclaim:        85952 kB</span><br><span class="line">KernelStack:       38384 kB</span><br><span class="line">PageTables:        35820 kB</span><br><span class="line">NFS_Unstable:          0 kB</span><br><span class="line">Bounce:                0 kB</span><br><span class="line">WritebackTmp:          0 kB</span><br><span class="line">CommitLimit:     1843032 kB</span><br><span class="line">Committed_AS:   86691356 kB</span><br><span class="line">VmallocTotal:   251658176 kB</span><br><span class="line">VmallocUsed:      189540 kB</span><br><span class="line">VmallocChunk:   251341732 kB</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>
<h1 id="考点7-哪些是子进程从父进程继承得到的"><a href="#考点7-哪些是子进程从父进程继承得到的" class="headerlink" title="考点7:哪些是子进程从父进程继承得到的"></a>考点7:哪些是子进程从父进程继承得到的</h1><p>在Linux上,对于多进程,子进程继承了父进程的下列哪些？</p>
<ul>
<li>A 进程地址空间</li>
<li>B 共享内存</li>
<li>C 信号掩码</li>
<li>D 已打开的文件描述符</li>
<li>E 以上都不是</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details>

<p>参考：</p>
<ul>
<li><a href="http://blog.csdn.net/xiaojun111111/article/details/51764389">http://blog.csdn.net/xiaojun111111/article/details/51764389</a></li>
<li><a href="http://blog.csdn.net/ygm_linux/article/details/50683877">http://blog.csdn.net/ygm_linux&#x2F;article&#x2F;details&#x2F;50683877</a></li>
</ul>
<h3 id="子进程继承父进程"><a href="#子进程继承父进程" class="headerlink" title="子进程继承父进程"></a>子进程继承父进程</h3><ul>
<li>用户号UIDs和用户组号GIDs；</li>
<li>环境Environment；</li>
<li>堆栈；</li>
<li>共享内存；</li>
<li>打开文件的描述符；</li>
<li>执行时关闭（Close-on-exec）标志；</li>
<li>信号（Signal）控制设定；</li>
<li>进程组号；</li>
<li>当前工作目录；</li>
<li>根目录；</li>
<li>文件方式创建屏蔽字；</li>
<li>资源限制；</li>
<li>控制终端；</li>
</ul>
<h3 id="子进程独有"><a href="#子进程独有" class="headerlink" title="子进程独有"></a>子进程独有</h3><ul>
<li>进程号PID；</li>
<li>不同的父进程号；</li>
<li>自己的文件描述符和目录流的拷贝；</li>
<li>子进程不继承父进程的进程正文（text），数据和其他锁定内存（memory locks）；</li>
<li>不继承异步输入和输出；</li>
</ul>
<p>父进程和子进程拥有独立的地址空间和PID参数。</p>
<p>子进程从父进程继承了用户号和用户组号，用户信息，目录信息，环境（表），打开的文件描述符，堆栈，（共享）内存等。<br>经过fork()以后，父进程和子进程拥有相同内容的代码段、数据段和用户堆栈，就像父进程把自己克隆了一遍。事实上，父进程只复制了自己的PCB块。而代码段，数据段和用户堆栈内存空间并没有复制一份，而是与子进程共享。只有当子进程在运行中出现写操作时，才会产生中断，并为子进程分配内存空间。由于父进程的PCB和子进程的一样，所以在PCB中断中所记录的父进程占有的资源，也是与子进程共享使用的。这里的“共享”一词意味着“竞争”</p>
<h1 id="考点8-Linux主机负载相关命令"><a href="#考点8-Linux主机负载相关命令" class="headerlink" title="考点8:Linux主机负载相关命令"></a>考点8:Linux主机负载相关命令</h1><p>以下哪些命令可以获取linux主机的负载相关指标</p>
<ul>
<li>A <code>uptime</code></li>
<li>B <code>top</code></li>
<li>C <code>ls</code></li>
<li>D <code>sar</code></li>
<li>E <code>crontab</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>


<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">uptime命令</td>
<td align="left">能够打印系统总共运行了多长时间和系统的平均负载。可以显示的信息显示依次为：现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载。</td>
</tr>
<tr>
<td align="left">top命令</td>
<td align="left">是用来监控 Linux 系统状况，比如cpu、内存的使用。</td>
</tr>
<tr>
<td align="left">ls命令</td>
<td align="left">用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。</td>
</tr>
<tr>
<td align="left">sar命令</td>
<td align="left">（System ActivityReporter系统活动情况报告）是目前Linux上最为全面的系统性能分析工具之一，可以从多方面对系统的活动进行报告，包括：文件的读写情况、系统调用的使用情况、磁盘I&#x2F;O、CPU效率、内存使用状况、进程活动及IPC有关的活动等。</td>
</tr>
<tr>
<td align="left">crontab</td>
<td align="left">是用来定期执行程序的命令。crond 命令每分钟会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# uptime</span><br><span class="line"> 15:23:59 up 1 day,  8:21,  1 user,  load average: 5.45, 5.51, 5.51</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>

<h1 id="考点9-Linux交换分区"><a href="#考点9-Linux交换分区" class="headerlink" title="考点9:Linux交换分区"></a>考点9:Linux交换分区</h1><p>关于Linux交换分区的说法正确是(      )</p>
<ul>
<li>A 安装<code>Linux</code>系统时必须划分交换分区</li>
<li>B 交换分区的作用是虚拟内存空间</li>
<li>C 交换分区的数据存取速度比物理内存慢</li>
<li>D 计算机内存为8<code>GB</code>,则交换分区的大小通常设置为16<code>GB</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details>

<p>交换分区一般设置内存的2倍</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Linux</category>
        <category>2021年03月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年03月31日Linux专项练习1</title>
    <url>/exam//d5fcd365/</url>
    <content><![CDATA[<h1 id="考点1-Linux修改权限命令-chmod命令"><a href="#考点1-Linux修改权限命令-chmod命令" class="headerlink" title="考点1:Linux修改权限命令_chmod命令"></a>考点1:Linux修改权限命令_chmod命令</h1><p>Linux下,为某个脚本赋予可执行权限()</p>
<ul>
<li>A <code>chmod +x filename.sh</code></li>
<li>B <code>chown +x filename.sh</code></li>
<li>C <code>chmod +r filename.sh</code></li>
<li>D <code>chown +r filename.sh</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>chmod命令修改权限 +x表示增加执行权限，+r表示增加读取权限，+w表示增加写权限<br>chown将指定文件的拥有者改为指定的用户或组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">total 3766</span><br><span class="line">-rwxr-xr-x 1 lan 197609     183  3月 19 21:32 hexos.sh*</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rwx</span><br><span class="line">111</span><br><span class="line">421</span><br></pre></td></tr></table></figure>

<h1 id="考点2-UNIX目录结构"><a href="#考点2-UNIX目录结构" class="headerlink" title="考点2:UNIX目录结构"></a>考点2:UNIX目录结构</h1><p>在UNIX系统中,目录结构采用( )</p>
<ul>
<li>A 单级目录结构</li>
<li>B 二级目录结构</li>
<li>C 单纯树形目录结构</li>
<li>D 带链接树形目录结构</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>带链接树形目录结构又称非循环图目录结构,它是指访问一文件(或目录)可以有多条路径。一般常说UNIX的文件系统是树形结构，其实是指带链接的树形结构，而不是纯树形目录结构。 </p>
<h1 id="考点3-Linux的-Z文件的解压缩命令"><a href="#考点3-Linux的-Z文件的解压缩命令" class="headerlink" title="考点3:Linux的.Z文件的解压缩命令"></a>考点3:Linux的.Z文件的解压缩命令</h1><p>一个文件名字为rr.Z,可以用来解压缩的命令是？</p>
<ul>
<li>A <code>tar</code></li>
<li>B <code>gzip</code></li>
<li>C <code>compress</code></li>
<li>D <code>uncompress</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>tar</code></td>
<td align="left">操作<code>.tar</code>的命令</td>
</tr>
<tr>
<td align="left"><code>gzip</code></td>
<td align="left">压缩<code>.gz</code>压缩包的命令</td>
</tr>
<tr>
<td align="left"><code>compress</code></td>
<td align="left">压缩.Z文件</td>
</tr>
<tr>
<td align="left"><code>uncompress</code></td>
<td align="left">解压缩.Z文件</td>
</tr>
</tbody></table>
<h1 id="考点4-记录已经加载的文件系统的文件"><a href="#考点4-记录已经加载的文件系统的文件" class="headerlink" title="考点4:记录已经加载的文件系统的文件"></a>考点4:记录已经加载的文件系统的文件</h1><p>系统当前已经加载的所有文件系统在_________文件中得到反映。</p>
<ul>
<li>A <code>/usr/sbin/cfdisk</code></li>
<li>B <code>/sbin/fdisk</code></li>
<li>C <code>/etc/mtab</code></li>
<li>D <code>/etc/fstab</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<table>
<thead>
<tr>
<th align="left">&#x2F;etc&#x2F;文件</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>/etc/mtab</code></td>
<td align="left">记载的是现在系统已经装载的文件系统，包括操作系统建立的虚拟文件等；而&#x2F;etc&#x2F;fstab是系统准备装载的</td>
</tr>
<tr>
<td align="left"><code>/etc/fstab</code></td>
<td align="left">记录了计算机上硬盘分区的相关信息，启动Linux的时候，检查分区的fsck命令，和挂载分区的mount命令，都需要fstab中的信息，来正确的检查和挂载硬盘。</td>
</tr>
</tbody></table>
<h1 id="考点5-Linux列举当前目录"><a href="#考点5-Linux列举当前目录" class="headerlink" title="考点5:Linux列举当前目录"></a>考点5:Linux列举当前目录</h1><p>在linux中,列举当前目录下文件的是哪个命令______。</p>
<ul>
<li>A <code>ps</code></li>
<li>B <code>cd</code></li>
<li>C <code>mv</code></li>
<li>D <code>ls</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ps</td>
<td align="left">查看运行中的进程</td>
</tr>
<tr>
<td align="left">cd</td>
<td align="left">进入某个目录</td>
</tr>
<tr>
<td align="left">mv</td>
<td align="left">移动文件或者文件夹</td>
</tr>
<tr>
<td align="left">ls</td>
<td align="left">list的缩写，列出某个目录下的文件或者文件夹</td>
</tr>
</tbody></table>
<h1 id="考点6-Linux查看文件命令"><a href="#考点6-Linux查看文件命令" class="headerlink" title="考点6:Linux查看文件命令"></a>考点6:Linux查看文件命令</h1><p>在Linux下查看文件有多种方法,若希望在查看文件内容过程中,可以按空格实现翻页,应使用(      )命令</p>
<ul>
<li>A <code>cat</code></li>
<li>B <code>more</code></li>
<li>C <code>less</code></li>
<li>D <code>head</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<ul>
<li>cat：由第一行开始显示文件所有内容； </li>
<li>tac：从最后一行开始显示文件的所有内容，<ul>
<li>注意 tac 与cat 写法正好相反；</li>
</ul>
</li>
<li>more：一页一页的显示文件内容，只能向后翻页； </li>
<li>less：也是一页一页显示文件内容，但是可以通过键盘上的【pagedown】，【pageup】控制向后，向前翻页； </li>
<li>head：显示一个文件的前几行； </li>
<li>tail：显示一个文件的后几行；</li>
</ul>
<h1 id="考点7-Linux查看CPU-Swap分区-硬盘信息命令"><a href="#考点7-Linux查看CPU-Swap分区-硬盘信息命令" class="headerlink" title="考点7:Linux查看CPU Swap分区 硬盘信息命令"></a>考点7:Linux查看CPU Swap分区 硬盘信息命令</h1><p>如何在命令行查看一台linux机器的CPU、SWAP分区信息、硬盘信息?</p>
<ul>
<li>A <code>cat /proc/cpuinfo</code></li>
<li>B <code>du</code></li>
<li>C <code>cat /proc/swaps</code></li>
<li>D <code>df -lh</code></li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details>

<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>cat /proc/cpuinfo</code></td>
<td align="left">查看一台<code>linux</code>机器的<code>CPU</code>信息</td>
</tr>
<tr>
<td align="left"><code>cat /proc/swaps</code></td>
<td align="left">查看<code>SWAP</code>分区信息</td>
</tr>
<tr>
<td align="left"><code>du</code></td>
<td align="left">查看该目录占用文件系统数据块的情况</td>
</tr>
<tr>
<td align="left"><code>df -lh</code></td>
<td align="left">查看硬盘信息</td>
</tr>
</tbody></table>
<h3 id="cat-x2F-proc-x2F-cpuinfo查看CPU信息"><a href="#cat-x2F-proc-x2F-cpuinfo查看CPU信息" class="headerlink" title="cat &#x2F;proc&#x2F;cpuinfo查看CPU信息"></a>cat &#x2F;proc&#x2F;cpuinfo查看CPU信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat /proc/cpuinfo </span><br><span class="line">Processor    : AArch64 Processor rev 4 (aarch64)</span><br><span class="line">processor    : 0</span><br><span class="line">processor    : 1</span><br><span class="line">processor    : 2</span><br><span class="line">processor    : 3</span><br><span class="line">processor    : 4</span><br><span class="line">processor    : 5</span><br><span class="line">processor    : 6</span><br><span class="line">processor    : 7</span><br><span class="line">Features    : fp asimd evtstrm aes pmull sha1 sha2 crc32 </span><br><span class="line">CPU implementer    : 0x41</span><br><span class="line">CPU architecture: 8</span><br><span class="line">CPU variant    : 0x0</span><br><span class="line">CPU part    : 0xd03</span><br><span class="line">CPU revision    : 4</span><br><span class="line"></span><br><span class="line">Hardware    : Qualcomm Technologies, Inc MSM8976</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>
<h3 id="cat-x2F-proc-x2F-swaps查看swap分区信息"><a href="#cat-x2F-proc-x2F-swaps查看swap分区信息" class="headerlink" title="cat &#x2F;proc&#x2F;swaps查看swap分区信息"></a>cat &#x2F;proc&#x2F;swaps查看swap分区信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat /proc/swaps</span><br><span class="line">Filename                Type        Size    Used    Priority</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>

<h3 id="du查看文件或目录占用大小"><a href="#du查看文件或目录占用大小" class="headerlink" title="du查看文件或目录占用大小"></a>du查看文件或目录占用大小</h3><p>查看当前目录下各个文件或目录的占用大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# du -h -d 1</span><br><span class="line">8.0K    ./.pki</span><br><span class="line">20K    ./.ssh</span><br><span class="line">2.6M    ./.nvm</span><br><span class="line">12K    ./.config</span><br><span class="line">42M    ./.npm</span><br><span class="line">104K    ./C_Test</span><br><span class="line">12K    ./Shell_Test</span><br><span class="line">8.0K    ./Linux_Test</span><br><span class="line">45M    .</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>
<h3 id="df-h查看磁盘空间占用情况"><a href="#df-h查看磁盘空间占用情况" class="headerlink" title="df -h查看磁盘空间占用情况"></a>df -h查看磁盘空间占用情况</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# df -h</span><br><span class="line">文件系统                                容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/block/bootdevice/by-name/userdata   55G   15G   40G   28% /</span><br><span class="line">tmpfs                                   1.8G  364K  1.8G    1% /dev</span><br><span class="line">tmpfs                                   1.8G     0  1.8G    0% /dev/shm</span><br><span class="line">/data/media                              55G   15G   40G   28% /mnt/files</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>
<h3 id="free-h查看内存占用情况"><a href="#free-h查看内存占用情况" class="headerlink" title="free -h查看内存占用情况"></a>free -h查看内存占用情况</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           3.5G        1.8G         64M        8.7M        1.6G        1.6G</span><br><span class="line">Swap:            0B          0B          0B</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>
<h1 id="考点8-日志文件系统有哪些"><a href="#考点8-日志文件系统有哪些" class="headerlink" title="考点8:日志文件系统有哪些"></a>考点8:日志文件系统有哪些</h1><p>以下哪个是日志文件系统()</p>
<ul>
<li>A <code>ext2</code></li>
<li>B <code>fat32</code></li>
<li>C <code>ntfs</code></li>
<li>D <code>ext3</code></li>
<li>E <code>ext4</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: CDE</details>

<h3 id="日志文件系统"><a href="#日志文件系统" class="headerlink" title="日志文件系统"></a>日志文件系统</h3><p>日志文件系统（英语：Journaling file system）是一种文件系统。在发生变化时，它先把相关的信息写入一个被称为日志的区域，然后再把变化写入主文件系统。在文件系统发生故障（如内核崩溃或突然停电）时，日志文件系统更容易保持一致性，并且可以较快恢复。</p>
<h3 id="常见的日志文件系统"><a href="#常见的日志文件系统" class="headerlink" title="常见的日志文件系统"></a>常见的日志文件系统</h3><table>
<thead>
<tr>
<th align="left">文件系统</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">JFS</td>
<td align="left">IBM的 Journaled File System, 最早的日志文件系统。</td>
</tr>
<tr>
<td align="left">Ext4&#x2F;Ext3文件系统</td>
<td align="left">由Ext2文件系统演化而成的日志文件系统，广泛用于Linux系统。</td>
</tr>
<tr>
<td align="left">XFS文件系统</td>
<td align="left">广泛用于Linux系统，取代了Ext4。</td>
</tr>
<tr>
<td align="left">ReiserFS</td>
<td align="left">用B+树作为数据结构的日志文件系统，在处理小文件时有较好的性能。</td>
</tr>
<tr>
<td align="left">Btrfs</td>
<td align="left">用B树作为数据结构，被认为是下一代Linux文件系统。</td>
</tr>
<tr>
<td align="left">NTFS</td>
<td align="left">微软的NTFS也是日志文件系统，也是Windows下最常用的文件系统。</td>
</tr>
<tr>
<td align="left">HFS+</td>
<td align="left">苹果公司发展的OS X操作系统下主要使用的文件系统。</td>
</tr>
</tbody></table>
<h1 id="考点9-系统调用"><a href="#考点9-系统调用" class="headerlink" title="考点9:系统调用"></a>考点9:系统调用</h1><p>Linux执行ls,会引起哪些系统调用()</p>
<ul>
<li>A <code>nmap</code></li>
<li>B <code>read</code></li>
<li>C <code>execve</code></li>
<li>D <code>fork</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details>

<p>任何shell都会执行exec和fork，而ls会执行read。<br>三个加起来就是read,execve,fork</p>
<h1 id="考点10-Linux2-6默认支持的文件系统"><a href="#考点10-Linux2-6默认支持的文件系统" class="headerlink" title="考点10:Linux2.6默认支持的文件系统"></a>考点10:Linux2.6默认支持的文件系统</h1><p>linux 2.6.* 内核默认支持的文件系统有哪些？</p>
<ul>
<li>A <code>ext3</code></li>
<li>B <code>ext2</code></li>
<li>C <code>ext4</code></li>
<li>D <code>xfs</code></li>
<li>E <code>ufs</code></li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>

<p>背答案算了</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Linux</category>
        <category>2021年03月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年03月31日Linux专项联系2</title>
    <url>/exam//7b887ccd/</url>
    <content><![CDATA[<h1 id="考点1-输入输出重定向"><a href="#考点1-输入输出重定向" class="headerlink" title="考点1:输入输出重定向"></a>考点1:输入输出重定向</h1><p>在RHEL5系统中,小王希望将他执行的ls命令的输出结果保存在当前目录下文件output.ls中,以供日后进行分析和使用,但要求不覆盖原文件的内容,他应该使用的命令是(  )</p>
<ul>
<li>A <code>ls&gt;output.ls</code></li>
<li>B <code>ls&gt;&gt;output.ls</code></li>
<li>C <code>ls&lt;&lt;output.ls</code></li>
<li>D <code>ls—output.ls</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>&gt;  输出重定向到一个文件或设备 <strong>覆盖原来的文件</strong><br>&gt;!  输出重定向到一个文件或设备 <strong>强制覆盖原来的文件</strong><br>&gt;&gt;  输出重定向到一个文件或设备 <strong>追加原来的文件</strong><br>&lt;  输入重定向到一个程序 </p>
<ul> <li>command &gt; file:将输出重定向到 file。 </li><li>command &lt; file:将输入重定向到 file。 </li><li>command &gt;&gt; file:将输出以追加的方式重定向到 file。 </li><li>n &gt; file:将文件描述符为 n 的文件重定向到 file。 </li><li>n &gt;&gt; file:将文件描述符为 n 的文件以追加的方式重定向到 file。 </li><li>n &gt;&amp; m:将输出文件 m 和 n 合并。 </li><li>n &lt;&amp; m:将输入文件 m 和 n 合并。 </li><li>&lt;&lt; tag:将开始标记 tag 和结束标记 tag 之间的内容作为输入。 </li></ul>

<h1 id="考点2-Linux目录结构"><a href="#考点2-Linux目录结构" class="headerlink" title="考点2:Linux目录结构"></a>考点2:Linux目录结构</h1><p>Linux文件系统的文件都按其作用分门别类地放在相关的目录中,对于外部设备文件,一般应将其放在()目录中</p>
<ul>
<li>A <code>/bin</code></li>
<li>B <code>/etc</code></li>
<li>C <code>/dev</code></li>
<li>D <code>/lib</code></li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p> &#x2F;bin  二进制执行文件，也就是命令文件<br> &#x2F;etc 下存放的是配置文件<br> &#x2F;dev 存放是时外部设备文件，硬盘，usb等<br> &#x2F;lib 存放的是库文件 </p>
<p>&#x2F;bin 二进制可执行命令<br>&#x2F;dev 设备特殊文件<br>&#x2F;etc 系统管理和配置文件<br>&#x2F;etc&#x2F;rc.d 启动的配置文件和脚本<br>&#x2F;home 用户主目录的基点，比如用户user的主目录就是&#x2F;home&#x2F;user，可以用~user表示<br>&#x2F;lib 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件<br>&#x2F;sbin 超级管理命令，这里存放的是系统管理员使用的管理程序<br>&#x2F;tmp 公共的临时文件存储点<br>&#x2F;root 系统管理员的主目录<br>&#x2F;mnt 系统提供这个目录是让用户临时挂载其他的文件系统<br>&#x2F;lost+found这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）<br>&#x2F;proc 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。<br>&#x2F;var 某些大文件的溢出区，比方说各种服务的日志文件<br>&#x2F;usr 最庞大的目录，要用到的应用程序和文件几乎都在这个目录，其中包含：<br>&#x2F;usr&#x2F;x11R6 存放x window的目录<br>&#x2F;usr&#x2F;bin 众多的应用程序<br>&#x2F;usr&#x2F;sbin 超级用户的一些管理程序<br>&#x2F;usr&#x2F;doc linux文档<br>&#x2F;usr&#x2F;include linux下开发和编译应用程序所需要的头文件<br>&#x2F;usr&#x2F;lib 常用的动态链接库和软件包的配置文件<br>&#x2F;usr&#x2F;man 帮助文档<br>&#x2F;usr&#x2F;src 源代码，linux内核的源代码就放在&#x2F;usr&#x2F;src&#x2F;linux里<br>&#x2F;usr&#x2F;local&#x2F;bin 本地增加的命令</p>
<p>&#x2F;dev   是device的简写，英文原意是device 设备。</p>
<h1 id="考点3-常用端口号-WWW和FTP端口号"><a href="#考点3-常用端口号-WWW和FTP端口号" class="headerlink" title="考点3:常用端口号 WWW和FTP端口号"></a>考点3:常用端口号 WWW和FTP端口号</h1><p>下面对www 和ftp的端口描述正确的是</p>
<ul>
<li>A 20 21</li>
<li>B 80 20</li>
<li>C 80 21</li>
<li>D 80,20 21</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h3 id="FTP端口"><a href="#FTP端口" class="headerlink" title="FTP端口"></a>FTP端口</h3><p>FTP服务器有两个端口，其中<strong>21端口用于连接</strong>，<strong>20端口用于传输数据</strong><br>进行FTP文件传输中，客户端首先连接到FTP服务器的21端口，进行用户的认证，认证成功后，要传输文件时，服务器会开一个端口为20来进行传输数据文件。<br>也就是说，<strong>端口20才是真正传输所用到的端口，端口21只用于FTP的登陆认证</strong>。我们平常下载文件时，会遇到下载到99%时，文件不完成，不能成功的下载。其实是因为文件下载完毕后，还要在21端口再行进行用户认证，而下载文件的时间如果过长，客户机与服务器的21端口的连接会被服务器认为是超时连接而中断掉，就是这个原因。解决方法就是设置21端口的响应时间。</p>
<p>www 80<br>ftp(主动模式20数据端口，用于传输-服务端传输文件  被动模式21控制端口,认证-客户端认证用户)  ftp协议由ftp服务器和ftp客户端构成,是基于tcp的两个端口：20,21<br>tftp协议基于udp端口 tcp传输层协议 ftp应用层协议 </p>
<h3 id="其他常用端口"><a href="#其他常用端口" class="headerlink" title="其他常用端口"></a>其他常用端口</h3><ul>
<li>SSH：22</li>
<li>Telnet：23 </li>
<li>SMTP：25 </li>
<li>POP3：110. S</li>
<li>NMP：161 </li>
<li>DNS服务：53  </li>
<li>HTTP(www)：80(默认端口) </li>
<li>HTTPS：443(在http的基础上ssl加密)</li>
</ul>
<h1 id="考点4-Linux查看磁盘挂载状态命令"><a href="#考点4-Linux查看磁盘挂载状态命令" class="headerlink" title="考点4:Linux查看磁盘挂载状态命令"></a>考点4:Linux查看磁盘挂载状态命令</h1><p>linux下查看磁盘挂载状态的命令式？</p>
<ul>
<li>A <code>rpm</code></li>
<li>B <code>mount</code></li>
<li>C <code>netstat</code></li>
<li>D <code>df</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>安装命令：rpm -ivh<br>卸载命令: rpm -e [package name]<br>查看挂载状态: mount<br>查看磁盘情况: df<br>查看端口:netstat –anlp<br>.tar.gz的安装:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar –zxvf tar.gz </span><br><span class="line">./configure </span><br><span class="line">Make </span><br><span class="line">Make install</span><br></pre></td></tr></table></figure>

<h1 id="考点5-vi强制保存退出参数"><a href="#考点5-vi强制保存退出参数" class="headerlink" title="考点5:vi强制保存退出参数"></a>考点5:vi强制保存退出参数</h1><p>某配置文件针对所有用户的访问权限是只读,vi编辑器强制存盘退出的指令是(      )</p>
<ul>
<li>A <code>:wq</code></li>
<li>B <code>ZZ</code></li>
<li>C <code>:q!</code></li>
<li>D <code>:wq!</code></li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<table>
<thead>
<tr>
<th align="left">vim的退出编辑命令</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">:q</td>
<td align="left">不保存退出</td>
</tr>
<tr>
<td align="left">:q!</td>
<td align="left">不保存强制退出</td>
</tr>
<tr>
<td align="left">:wq</td>
<td align="left">写入文件并退出</td>
</tr>
<tr>
<td align="left">:wq!</td>
<td align="left"><strong>强制写入并退出（只有当操作者是文件所有者才可行）</strong></td>
</tr>
<tr>
<td align="left">:x</td>
<td align="left">文件有变动时等同于 :wq，文件无变动时等同与 :q</td>
</tr>
<tr>
<td align="left">ZZ</td>
<td align="left">等同于:x</td>
</tr>
</tbody></table>
<h1 id="考点7-Linux的ifconfig命令"><a href="#考点7-Linux的ifconfig命令" class="headerlink" title="考点7:Linux的ifconfig命令"></a>考点7:Linux的ifconfig命令</h1><p>下列提法中,不属于ifconfig命令作用范围的是 。</p>
<ul>
<li>A 配置本地回环地址</li>
<li>B 配置网卡的<code>IP</code>地址</li>
<li>C 激活网络适配器</li>
<li>D 加载网卡到内核中</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<h3 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h3><p>1.作用<br>ifconfig用于查看和更改网络接口的地址和参数，包括IP地址、网络掩码、广播地址，使用权限是超级用户。<br>2.格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig -interface [options] address</span><br></pre></td></tr></table></figure>
<p>3.主要参数如下</p>
<ul>
<li>interface：指定的网络接口名，如eth0和eth1。 </li>
<li>options:<ul>
<li>up：激活指定的网络接口卡。</li>
<li>down：关闭指定的网络接口。 </li>
<li>broadcast address：设置接口的广播地址。 </li>
<li>pointopoint：启用点对点方式。 </li>
<li>address：设置指定接口设备的IP地址。 </li>
<li>netmask address：设置接口的子网掩码。</li>
</ul>
</li>
</ul>
<h1 id="考点8-Linux进程-clone和fork的区别"><a href="#考点8-Linux进程-clone和fork的区别" class="headerlink" title="考点8:Linux进程 clone和fork的区别"></a>考点8:Linux进程 clone和fork的区别</h1><p>下列关于 clone 和 fork 的区别描述正确的有？</p>
<ul>
<li>A <code>clone</code>和<code>fork</code>最大不同在于<code>fork</code>不再复制父进程的栈空间,而是自己创建一个新的。</li>
<li>B <code>clone</code>和<code>fork</code>最大不同在于<code>clone</code>不再复制父进程的栈空间,而是自己创建一个新的。</li>
<li>C <code>clone</code>是<code>fork</code>的升级版本,不仅可以创建进程或者线程,还可以指定创建新的命名空间(<code>namespace</code>)、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等</li>
<li>D <code>fork</code>是<code>clone</code>的升级版本,不仅可以创建进程或者线程,还可以指定创建新的命名空间(<code>namespace</code>)、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<p>fork()<br>函数复制时将父进程的所以资源都通过复制数据结构进行了复制，然后传递给子进程，所以fork()函数不带参数；<br>clone()<br>函数则是将部分父进程的资源的数据结构进行复制，复制哪些资源是可选择的，这个可以通过参数设定，所以clone()<br>函数带参数，没有复制的资源可以通过指针共享给子进程</p>
<p>fork()是全部复制<br>vfork()是共享内存<br><strong>clone()是可以将父进程资源有选择地复制给子进程</strong>，而没有复制的数据结构则通过指针的复制让子进程共享，具体要复制哪些资源给子进程，由参数列表中的clone_flags来决定。另外，clone()返回的是子进程的pid。 </p>
<p>fork是复制进程，创建一个新的进程，不带参数<br>clone是可选的复制父进程资源，可以通过参数控制复制的内容 </p>
<h1 id="考点9-存储用户创建用户目录的系统用户默认文件的文件"><a href="#考点9-存储用户创建用户目录的系统用户默认文件的文件" class="headerlink" title="考点9:存储用户创建用户目录的系统用户默认文件的文件"></a>考点9:存储用户创建用户目录的系统用户默认文件的文件</h1><p>在Linux系统中, 哪个文件你可以存储用于创建用户目录的系统用户默认文件？ </p>
<ul>
<li>A <code>/usr/tmp</code></li>
<li>B <code>/etc/default</code></li>
<li>C <code>/etc/skel</code></li>
<li>D <code>/etc/users</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>Linux下的&#x2F;etc&#x2F;skel目录往往不被人注意，其实此目录在新建用户时还是很有用的，灵活运用此目录可以节约一定的配置时间。<br>skel是skeleton的缩写，意为骨骼、框架。故此目录的作用是在建立新用户时，用于初始化用户根目录。系统会将此目录下的所有文件、目录都复制到新建用户的根目录，并且将用户属主与用户组调整为与此根目录相同。所以可将用户配置文件预置到&#x2F;etc&#x2F;skel目录下，比如说.bashrc、.profile与.vimrc等。<br>注：<br>1.如果在新建用户时，没有自动建立用户根目录，则无法调用到此框架目录。<br>2.如果不想以默认的&#x2F;etc&#x2F;skel目录作为框架目录，可以在运行useradd命令时指定新的框架目录。例如：<br>sudo useradd -d &#x2F;home&#x2F;chen -m -k<br> &#x2F;etc&#x2F;my_skel chen<br>上述命令将新建用户chen，设置用户根目录为&#x2F;home&#x2F;chen，并且此目录会自动建立；同时指定框架目录为&#x2F;etc&#x2F;my_skel。<br>3.如果不想在每次新建用户时，都重新指定新的框架目录，可以通过修改&#x2F;etc&#x2F;default&#x2F;useradd配置文件来改变默认的框架目录，方法如下：<br>查找SKEL变量的定义，如果此变量的定义已被注释掉，可以取消注释，然后修改其值：<br>SKEL&#x3D;&#x2F;etc&#x2F;my_skel</p>
<h1 id="考点10-Linux可以查看系统启动时间的命令"><a href="#考点10-Linux可以查看系统启动时间的命令" class="headerlink" title="考点10:Linux可以查看系统启动时间的命令"></a>考点10:Linux可以查看系统启动时间的命令</h1><p>以下哪些命令可以查看当前系统的启动时间()</p>
<ul>
<li>A <code>w</code></li>
<li>B <code>top</code></li>
<li>C <code>ps</code></li>
<li>D <code>uptime</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>


<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ps</td>
<td align="left">查看当前系统中的进程</td>
</tr>
<tr>
<td align="left">who -b</td>
<td align="left">查看当前系统的启动时间</td>
</tr>
<tr>
<td align="left">last reboot</td>
<td align="left">查看当前系统的启动时间</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">查看当前系统的启动时间</td>
</tr>
<tr>
<td align="left">top</td>
<td align="left">查看当前系统的启动时间</td>
</tr>
<tr>
<td align="left">uptime</td>
<td align="left">查看当前系统的启动时间</td>
</tr>
</tbody></table>
<h1 id="考点11-可以查看Linux系统负载的命令"><a href="#考点11-可以查看Linux系统负载的命令" class="headerlink" title="考点11:可以查看Linux系统负载的命令"></a>考点11:可以查看Linux系统负载的命令</h1><p>关于Linux系统的负载(Load),以下表述正确的是______。</p>
<ul>
<li>A 通过就绪和运行的进程数来反映</li>
<li>B 可以通过<code>TOP</code>命令查看</li>
<li>C 可以通过<code>uptime</code>查看</li>
<li>D <code>Load:2.5,1.3,1.1</code>表示系统的负载压力在逐渐减少</li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Linux</category>
        <category>2021年03月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月22日 SQL专项练习</title>
    <url>/exam//b514bef7/</url>
    <content><![CDATA[<h1 id="考点1-数据库分类"><a href="#考点1-数据库分类" class="headerlink" title="考点1:数据库分类"></a>考点1:数据库分类</h1><p>MySQL是一种（ ）数据库管理系统。</p>
<ul>
<li>A 层次型</li>
<li>B 联盟链</li>
<li>C 关系型</li>
<li>D 对象型</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>层次型数据库管理系统是紧随网状数据库而出现的。现实世界中很多事物是按层次组织起来的。层次数据模型的提出，首先是为了模拟这种按层次组织起来的事物。<br><strong>最著名最典型的层次数据库系统是IBM公司的IMS</strong>（Information Management System）</p>
<p>MySQL就是一种普通的关系型数据库，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库中。</p>
<p>比较流行的数据库模型有三种，分别为层次式数据库、网状数据库和关系型数据库。而在当今的互联网中，最常见的数据库模型主要是两种，即SQL关系型数据库和NoSQL非关系型数据库。关系型数据库的代表包括Oracle, Sql Server, Mysql。</p>
<h1 id="考点2-分组查询语句"><a href="#考点2-分组查询语句" class="headerlink" title="考点2:分组查询语句"></a>考点2:分组查询语句</h1><p>SQL中属于分组查询的语句是？（）</p>
<ul>
<li>A Where</li>
<li>B 联盟链</li>
<li>C Group By</li>
<li>D Having</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h2 id="区块链分类"><a href="#区块链分类" class="headerlink" title="区块链分类"></a>区块链分类</h2><p>区块链大致可以分为公有链（Public Blockchain）、私有链（Private Blockchain）以及联盟链（Consortium Blockchain）三大类。<br>因此，联盟链属于区块链的一种。</p>
<h2 id="SQL各语句的作用"><a href="#SQL各语句的作用" class="headerlink" title="SQL各语句的作用"></a>SQL各语句的作用</h2><ul>
<li>where筛选、</li>
<li>group by分组、</li>
<li>having与group by连用，用于筛选。</li>
</ul>
<h1 id="考点3-group-by-having"><a href="#考点3-group-by-having" class="headerlink" title="考点3:group by having"></a>考点3:group by having</h1><p>若要“查询选修了3门以上课程的学生的学号”，则正确的SQL语句是( )</p>
<ul>
<li>A <code>SELECT S# FROM SC GROUP BY S# WHERE COUNT(*)&gt; 3</code></li>
<li>B <code>SELECT S# FROM SC GROUP BY S# HAVING COUNT(*)&gt; 3</code></li>
<li>C <code>SELECT S# FROM SC ORDER BY S# WHERE COUNT(*)&gt; 3</code></li>
<li>D <code>SELECT S# FROM SC ORDER BY S# HAVING COUNT(*)&gt; 3</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p><code>count(*)</code>计算了有多少行，由于group by学号，则<code>count(*)</code>计算了每个学号有多少行</p>
<h2 id="order-by排序"><a href="#order-by排序" class="headerlink" title="order by排序"></a>order by排序</h2><p>1.order by 从英文里理解就是行的排序方式，默认的为升序。 order by 后面必须列出排序的字段名，可以是多个字段名。</p>
<h2 id="group-by必须搭配聚合函数使用"><a href="#group-by必须搭配聚合函数使用" class="headerlink" title="group by必须搭配聚合函数使用"></a>group by必须搭配聚合函数使用</h2><p>2.group by 从英文里理解就是分组。必须有“聚合函数”来配合才能使用，使用时至少需要一个分组标志字段。<br>注意：聚合函数是—sum()、count()、avg()等都是“聚合函数”</p>
<h2 id="having子句"><a href="#having子句" class="headerlink" title="having子句"></a>having子句</h2><p><strong>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用</strong>。<br><strong>HAVING 子句可以让我们筛选分组后的各组数据</strong>。<br>SQL HAVING语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name, aggregate_function(column_name)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name operator <span class="keyword">value</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column_name</span><br><span class="line"><span class="keyword">HAVING</span> aggregate_function(column_name) operator <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure>


<p>执行顺序 where-&gt;group by-&gt;聚合-&gt;having,<br>where无论如何不能拿到聚合</p>
<h2 id="where-聚合函数-having的执行顺序"><a href="#where-聚合函数-having的执行顺序" class="headerlink" title="where 聚合函数 having的执行顺序"></a>where 聚合函数 having的执行顺序</h2><p>where、聚合函数、having 在from后面的执行顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">where&gt;聚合函数(sum,min,max,avg,count)&gt;having</span><br></pre></td></tr></table></figure>
<p>若须引入聚合函数来对group by结果进行过滤 则只能用having。</p>
<p>HAVING语句通常与GROUP BY语句联合使用，用来过滤由GROUP BY语句返回的记录集。</p>
<p>HAVING语句的存在弥补了WHERE关键字不能与聚合函数联合使用的不足。</p>
<p>1、where 后不能跟聚合函数，因为where执行顺序先于聚合函数。<br>2、where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，条件中不能包含聚组函数，使用where条件显示特定的行。<br>3、having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。<br><a href="https://blog.csdn.net/qq_35269216/article/details/90812872" target="_blank">https://blog.csdn.net/qq_35269216&#x2F;article&#x2F;details&#x2F;90812872</a></p>
<h2 id="SQL-HAVING-子句"><a href="#SQL-HAVING-子句" class="headerlink" title="SQL HAVING 子句"></a>SQL HAVING 子句</h2><p><a href="https://www.w3cschool.cn/sql/bxfh1oza.html">https://www.w3cschool.cn/sql/bxfh1oza.html</a></p>
<p><code>HAVING</code>​ 子句使你能够指定过滤条件，从而控制查询结果中哪些组可以出现在最终结果里面。</p>
<p><code>WHERE</code>​子句对被选择的列施加条件，而 ​<code>HAVING</code>​子句则对 ​<code>GROUP BY</code>​ 子句所产生的组施加条件。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>下面可以看到 ​<code>HAVING</code>​ 子句在 ​<code>SEL ECT </code>​查询中的位置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>;</span><br></pre></td></tr></table></figure>
<p><strong>在<code>SELECT</code>​查询中，​<code>HAVING</code>​子句必须紧随<code>GROUP BY</code>​子句，并出现在<code>ORDER BY</code>​子句（如果有的话）之前。</strong></p>
<p>带有 ​<code>HAVING</code>​ 子句的 ​<code>SELECT</code>​ 语句的语法如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2</span><br><span class="line"><span class="keyword">FROM</span> table1, table2</span><br><span class="line"><span class="keyword">WHERE</span> [ conditions ]</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1, column2</span><br><span class="line"><span class="keyword">HAVING</span> [ conditions ]</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column1, column2;</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>考虑 ​<code>CUSTOMERS</code>​ 表，表中的记录如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+----------+-----+-----------+----------+</span><br><span class="line">| ID | NAME     | AGE | ADDRESS   | SALARY   |</span><br><span class="line">+----+----------+-----+-----------+----------+</span><br><span class="line">|  1 | Ramesh   |  32 | Ahmedabad |  2000.00 |</span><br><span class="line">|  2 | Khilan   |  25 | Delhi     |  1500.00 |</span><br><span class="line">|  3 | kaushik  |  23 | Kota      |  2000.00 |</span><br><span class="line">|  4 | Chaitali |  25 | Mumbai    |  6500.00 |</span><br><span class="line">|  5 | Hardik   |  27 | Bhopal    |  8500.00 |</span><br><span class="line">|  6 | Komal    |  22 | MP        |  4500.00 |</span><br><span class="line">|  7 | Muffy    |  24 | Indore    | 10000.00 |</span><br><span class="line">+----+----------+-----+-----------+----------+</span><br></pre></td></tr></table></figure>

<p>下面是一个有关 ​<code>HAVING</code>​ 子句使用的实例，该实例将会筛选出出现次数大于或等于 2 的所有记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SQL</span> <span class="operator">&gt;</span> <span class="keyword">SELECT</span> ID, NAME, AGE, ADDRESS, SALARY</span><br><span class="line"><span class="keyword">FROM</span> CUSTOMERS</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> age</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(age) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>其执行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+----------+-----+---------+---------+</span><br><span class="line">| ID | NAME     | AGE | ADDRESS | SALARY  |</span><br><span class="line">+----+----------+-----+---------+---------+</span><br><span class="line">|  2 | Khilan   |  25 | Delhi   | 1500.00 |</span><br><span class="line">|  4 | Chaitali |  25 | Mumbai  | 6500.00 |</span><br><span class="line">+----+----------+-----+---------+---------+;</span><br></pre></td></tr></table></figure>

<h1 id="考点4-多对多"><a href="#考点4-多对多" class="headerlink" title="考点4:多对多"></a>考点4:多对多</h1><p>某学院包含多个专业如计算机科学、信息管理、软件工程、网络工程。每个专业每年都招收一个班级的学生。在招生过程中就已明确规定，一个学生只能就读于该学院的一个班级，但是一个班级可以招收不超过60个学生。那么，学生和班级之间是________的关系。</p>
<ul>
<li>A 一对多</li>
<li>B 多对多</li>
<li>C 一对一</li>
<li>D 多对一</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<ul>
<li>多个学生在一个班级，限定条件：一个学生只能在一个班级，所以多对一</li>
<li>如果限定条件改变：一个学生可以读不同的班级，那么就是多对多</li>
</ul>
<h1 id="考点5-SQL-Server-datediff函数-getdate函数"><a href="#考点5-SQL-Server-datediff函数-getdate函数" class="headerlink" title="考点5:SQL Server datediff函数 getdate函数"></a>考点5:SQL Server datediff函数 getdate函数</h1><p>请取出 BORROW表中日期(RDATE字段)为当天的所有记录？(RDATE字段为datetime型，包含日期与时间)。SQL语句实现正确的是：（      ）</p>
<ul>
<li>A <code>select * from BORROW where datediff(dd,RDATE,getdate())=0</code></li>
<li>B <code>select * from BORROW where RDATE=getdate()</code></li>
<li>C <code>select * from BORROW where RDATE-getdate()=0</code></li>
<li>D <code>select * from BORROW where RDATE&gt;getdate()</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h2 id="SQL-Server-DATEDIFF-函数"><a href="#SQL-Server-DATEDIFF-函数" class="headerlink" title="SQL Server DATEDIFF() 函数"></a>SQL Server DATEDIFF() 函数</h2><p><a href="https://www.w3cschool.cn/mysql/func-datediff.html">https://www.w3cschool.cn/mysql/func-datediff.html</a></p>
<h2 id="MySQL-DATEDIFF-函数"><a href="#MySQL-DATEDIFF-函数" class="headerlink" title="MySQL DATEDIFF() 函数"></a>MySQL DATEDIFF() 函数</h2><p><a href="https://www.w3cschool.cn/mysql/func-datediff-mysql.html">https://www.w3cschool.cn/mysql/func-datediff-mysql.html</a></p>
<h3 id="定义和用法"><a href="#定义和用法" class="headerlink" title="定义和用法"></a>定义和用法</h3><p>DATEDIFF() 函数返回两个日期之间的天数。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DATEDIFF(date1,date2);</span><br></pre></td></tr></table></figure>
<p>date1 和 date2 参数是合法的日期或日期&#x2F;时间表达式。</p>
<p>注释：只有值的日期部分参与计算。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面是 SELECT 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATEDIFF(<span class="string">&#x27;2008-11-30&#x27;</span>,<span class="string">&#x27;2008-11-29&#x27;</span>) <span class="keyword">AS</span> DiffDate;</span><br></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT DATEDIFF(&#x27;2008-11-30&#x27;,&#x27;2008-11-29&#x27;) AS DiffDate;</span><br><span class="line">+----------+</span><br><span class="line">| DiffDate |</span><br><span class="line">+----------+</span><br><span class="line">|        1 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.16 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br></pre></td></tr></table></figure>

<h2 id="SQL-Server-getdate函数"><a href="#SQL-Server-getdate函数" class="headerlink" title="SQL Server getdate函数"></a>SQL Server getdate函数</h2><p><a href="https://www.w3cschool.cn/mysql/func-getdate.html">https://www.w3cschool.cn/mysql/func-getdate.html</a></p>
<p>getdate()得出的是当前日期+时间(精确到毫秒) RDATE也是datetime型，与getdate无法准确比较 故用datediff(dd, date1, date2)&#x3D;0，datepart以日为单位，比较rdate和当前的日期，使之相隔0天即为当天。</p>
<h2 id="SQL-Server-和-MySQL-中的-Date-函数"><a href="#SQL-Server-和-MySQL-中的-Date-函数" class="headerlink" title="SQL Server 和 MySQL 中的 Date 函数"></a>SQL Server 和 MySQL 中的 Date 函数</h2><p><a href="https://www.w3cschool.cn/sql/zh6t9fpu.html">https://www.w3cschool.cn/sql/zh6t9fpu.html</a></p>
<h1 id="考点6-select-case条件语句"><a href="#考点6-select-case条件语句" class="headerlink" title="考点6:select case条件语句"></a>考点6:select case条件语句</h1><p>积分result表中有A B C D四列，要求：<br>1）当A列值大于等于B列时，选择A列否则选择B列<br>2）当C列值大于等于D列时，选择C列否则选择D列<br>用SQL语句实现正确的是：（      ）</p>
<ul>
<li>A <code>select ( when A&gt;=B then A else B ) MAX_AB, ( when C&gt;=D then C else D ) MAX_CD from result</code></li>
<li>B <code>select (case when A&gt;=B then A else B ) MAX_AB, (case when C&gt;=D then C else D ) MAX_CD from result</code></li>
<li>C <code>select (case when A&gt;=B then A else B end) MAX_AB, (case when C&gt;=D then C else D end) MAX_CD from result</code></li>
<li>D <code>select case when A&gt;=B then A else B end MAX_AB, case when C&gt;=D then C else D end MAX_CD from result</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<h2 id="SQL-查询：SELECT-CASE-条件赋值"><a href="#SQL-查询：SELECT-CASE-条件赋值" class="headerlink" title="SQL 查询：SELECT CASE 条件赋值"></a>SQL 查询：SELECT CASE 条件赋值</h2><p><a href="https://www.cnblogs.com/richardzhu/p/3571670.html">https://www.cnblogs.com/richardzhu/p/3571670.html</a><br><a href="https://zhuanlan.zhihu.com/p/63333847">https://zhuanlan.zhihu.com/p/63333847</a><br><a href="https://segmentfault.com/a/1190000020877471">https://segmentfault.com/a/1190000020877471</a><br><a href="https://www.gairuo.com/p/sql-select-case-when-then">https://www.gairuo.com/p/sql-select-case-when-then</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> c_1,</span><br><span class="line">    <span class="keyword">CASE</span></span><br><span class="line">        <span class="keyword">WHEN</span> condition1 <span class="keyword">THEN</span> result1</span><br><span class="line">        <span class="keyword">WHEN</span> condition2 <span class="keyword">THEN</span> result2</span><br><span class="line">        <span class="keyword">WHEN</span> conditionN <span class="keyword">THEN</span> resultN</span><br><span class="line">        <span class="keyword">ELSE</span> result_else</span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">as</span> c_name</span><br><span class="line"><span class="keyword">from</span> tab_name;</span><br></pre></td></tr></table></figure>
<h2 id="MySQL-CASE语句"><a href="#MySQL-CASE语句" class="headerlink" title="MySQL CASE语句"></a>MySQL CASE语句</h2><p><a href="https://www.yiibai.com/mysql/case-statement.html">https://www.yiibai.com/mysql/case-statement.html</a><br><a href="https://www.yiibai.com/mysql/case-function.html">https://www.yiibai.com/mysql/case-function.html</a><br><a href="https://www.yiibai.com/plsql/plsql_searched_case.html">https://www.yiibai.com/plsql/plsql_searched_case.html</a></p>
<p><img data-src="https://www.yiibai.com/uploads/images/2018/12/19/091847_96033.jpg" alt="这里有一张图片"></p>
<h1 id="考点7-多变联查"><a href="#考点7-多变联查" class="headerlink" title="考点7:多变联查"></a>考点7:多变联查</h1><p>运动会比赛信息的数据库，有如下三个表：<br>运动员ATHLETE（运动员编号 Ano，姓名Aname，性别Asex，所属系名 Adep）， 项目 ITEM （项目编号Ino，名称Iname，比赛地点Ilocation）， 成绩SCORE （运动员编号Ano，项目编号Ino，积分Score）。<br>写出目前总积分最高的系名及其积分，SQL语句实现正确的是：（      ）</p>
<ul>
<li><p>A </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Adep,<span class="built_in">SUM</span>(Score) </span><br><span class="line"><span class="keyword">FROM</span> ATHLETE,SCORE</span><br><span class="line"><span class="keyword">WHERE</span> ATHLETE.Ano<span class="operator">=</span>SCORE.Ano <span class="keyword">GROUP</span> <span class="keyword">BY</span> Adep <span class="keyword">HAVING</span> <span class="built_in">SUM</span>(Score)<span class="operator">&gt;=</span><span class="keyword">ANY</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(Score) <span class="keyword">FROM</span> ATHLETE,SCORE</span><br><span class="line"><span class="keyword">WHERE</span> ATHLETE.Ano<span class="operator">=</span>SCORE.Ano <span class="keyword">GROUP</span> <span class="keyword">BY</span> Adep);</span><br></pre></td></tr></table></figure>
</li>
<li><p>B</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Adep,<span class="built_in">SUM</span>(Score) <span class="keyword">FROM</span> ATHLETE,SCORE</span><br><span class="line"><span class="keyword">WHERE</span> ATHLETE.Ano<span class="operator">=</span>SCORE.Ano <span class="keyword">GROUP</span> <span class="keyword">BY</span> Adep <span class="keyword">HAVING</span> <span class="built_in">SUM</span>(Score)<span class="operator">&gt;=</span><span class="keyword">SOME</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(Score) <span class="keyword">FROM</span> ATHLETE,SCORE <span class="keyword">WHERE</span> ATHLETE.Ano<span class="operator">=</span>SCORE.Ano <span class="keyword">GROUP</span> <span class="keyword">BY</span> Adep);</span><br></pre></td></tr></table></figure></li>
<li><p>C</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Adep,<span class="built_in">SUM</span>(Score) <span class="keyword">FROM</span> ATHLETE,SCORE <span class="keyword">WHERE</span> ATHLETE.Ano<span class="operator">=</span>SCORE.Ano <span class="keyword">GROUP</span> <span class="keyword">BY</span> Adep <span class="keyword">HAVING</span> <span class="built_in">SUM</span>(Score) <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(Score) <span class="keyword">FROM</span> ATHLETE,SCORE <span class="keyword">WHERE</span> ATHLETE.Ano<span class="operator">=</span>SCORE.Ano <span class="keyword">GROUP</span> <span class="keyword">BY</span> Adep);</span><br></pre></td></tr></table></figure></li>
<li><p>D</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Adep,<span class="built_in">SUM</span>(Score) <span class="keyword">FROM</span> ATHLETE,SCORE <span class="keyword">WHERE</span> ATHLETE.Ano<span class="operator">=</span>SCORE.Ano <span class="keyword">GROUP</span> <span class="keyword">BY</span> Adep <span class="keyword">HAVING</span> <span class="built_in">SUM</span>(Score)<span class="operator">&gt;=</span><span class="keyword">ALL</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(Score) <span class="keyword">FROM</span> ATHLETE,SCORE <span class="keyword">WHERE</span> ATHLETE.Ano<span class="operator">=</span>SCORE.Ano <span class="keyword">GROUP</span> <span class="keyword">BY</span> Adep);</span><br></pre></td></tr></table></figure></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h1 id="考点8-最可能导致sql注入的字符"><a href="#考点8-最可能导致sql注入的字符" class="headerlink" title="考点8:最可能导致sql注入的字符"></a>考点8:最可能导致sql注入的字符</h1><p>下面哪些字符最可能会导致sql注入?</p>
<ul>
<li>A <code>&#39;</code>（单引号）</li>
<li>B <code>/</code></li>
<li>C <code>&quot;</code>(双引号)</li>
<li>D <code>$</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>防止SQL注入，需要注意以下几个要点：</p>
<ul>
<li>永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对<strong>单引号</strong>和**双”-“**进行转换等。</li>
<li>永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。</li>
<li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</li>
<li>不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。</li>
<li>应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装</li>
<li>sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。</li>
</ul>
<h1 id="考点9-多表联查"><a href="#考点9-多表联查" class="headerlink" title="考点9:多表联查"></a>考点9:多表联查</h1><p>雇员表EMP 结构如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(  雇员编号 EMPNO ,   姓名 ENAME ,</span><br><span class="line">工作岗位 JOB ,  管理员编号 MGR ,</span><br><span class="line">受雇时间 HIREDATE ,  工资 SAL ,</span><br><span class="line">奖金 COMM ,  部门编号 DEPTNO );</span><br></pre></td></tr></table></figure>
<p>下列操作语句正确的是：（      ）</p>
<ul>
<li>A 显示在10和30部门工作并且工资大于5500元的雇员的姓名和工资，列标题显示为Employee和Monthly Salary 语句：<code>SELECT ENAME EMPLOYEE ,SAL “MONTHLY SALARY” FROM EMP WHERE DEPTNO IN(10,30)AND SAL&gt;5500;</code></li>
<li>B 显示受雇时间在2010年1月1日和2012年12月31日之间的雇员的姓名、工资、及受雇时间，并以受雇时间升序排列。 语句：<code>SELECT ENAME,SAL,HIREDATE FROM EMP WHERE HIREDATE BETWEEN ‘2010-01-01’ AND ‘2012-12-31’ ORDER BY HIREDATE;</code></li>
<li>C 显示奖金比工资多10％以上的雇员的姓名、工资及奖金。 语句：<code>SELECT ENAME,SAL ,COMM FROM EMP WHERE COMM&gt;SAL*1.1;</code></li>
<li>D 查询没有奖金且工资低于6500并工作岗位是经理、普通员工、销售员的所有员工信息。 语句：<code>SELECT * FROM EMP WHERE SAL&lt;6500 AND COMM IS NULL AND JOB IN (‘经理’,‘普通员工’,‘销售员’);</code></li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>C选项 where子句中不能使用<code>*</code></p>
<h1 id="考点10-delete和truncate的区别"><a href="#考点10-delete和truncate的区别" class="headerlink" title="考点10:delete和truncate的区别"></a>考点10:delete和truncate的区别</h1><p>下面有关sql 语句中 delete truncate的说法正确的是？（）</p>
<ul>
<li>A 论清理表数据的速度，truncate一般比delete更快</li>
<li>B truncate命令可以用来删除部分数据。</li>
<li>C truncate只删除表的数据不删除表的结构</li>
<li>D delete能够回收高水位</li>
</ul>
<details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

<p>1、处理效率：<code>drop&gt;trustcate&gt;delete</code><br>2、drop删除整个表；trustcate删除全部记录，但不删除表；delete删除部分记录<br>3、delete不影响所用extent，高水线保持原位置不动；trustcate会将高水线复位。</p>
<p>truncate之所以快是因为，truncate不删除数据，只是将当前表重新映射一段存储空间，并把旧空间标记为可用，并未覆盖数据。</p>
<p>oracle数据库中高水位的概念，通俗的讲就是将存储空间想象成水库，插入数据水位线就会上升，但是删除操作并不会造成最高水位线下降。 </p>
<p>执行truncate语句需要拥有表的drop权限，从逻辑上讲，truncate table类似于delete删除所有行的语句或drop table然后再create table语句的组合。为了实现高性能，它绕过了删除数据的DML方法，因此，它不能回滚。尽管truncate table与delete相似，但它被分类为DDL语句而不是DML语句</p>
<h2 id="MySQL-truncate-table语句"><a href="#MySQL-truncate-table语句" class="headerlink" title="MySQL truncate table语句"></a>MySQL truncate table语句</h2><p><a href="https://www.yiibai.com/mysql/truncate-table.html">https://www.yiibai.com/mysql/truncate-table.html</a></p>
<h2 id="SQL-Truncate-Table"><a href="#SQL-Truncate-Table" class="headerlink" title="SQL Truncate Table"></a>SQL Truncate Table</h2><p><a href="https://www.yiibai.com/sql/sql-truncate-table.html">https://www.yiibai.com/sql/sql-truncate-table.html</a></p>
<ol start="2">
<li>SQL TRUNCATE TABLE与DELETE逻辑上，TRUNCATE TABLE语句和不带WHERE子句的DELETE语句提供了从表中删除所有数据的相同效果。 但是，它们确实存在一些差别：</li>
</ol>
<p>使用DELETE语句时，数据库系统会记录操作。 通过一些努力，可以回滚已删除的数据。 但是，当使用TRUNCATE TABLE语句时，除非在尚未提交的事务中使用它，否则无法回滚。<br>要从外键约束引用的表中删除数据，不能使用TRUNCATE TABLE语句。 在这种情况下，必须使用DELETE语句。<br>如果表具有与之关联的触发器，则TRUNCATE TABLE语句不会触发delete触发器。<br>执行TRUNCATE TABLE语句后，某些数据库系统会将自动增量列(或标识，序列等)的值重置为其起始值。 DELETE语句不是这种情况。带有WHERE子句的DELETE语句从表中删除部分数据，而TRUNCATE TABLE语句始终从表中删除所有数据。&#x2F;&#x2F;原文出自【易百教程】，商业转载请联系作者获得授权，非商业请保留原文链接：<a href="https://www.yiibai.com/sql/sql-truncate-table.html">https://www.yiibai.com/sql/sql-truncate-table.html</a></p>
<h3 id="2-SQL-TRUNCATE-TABLE与DELETE"><a href="#2-SQL-TRUNCATE-TABLE与DELETE" class="headerlink" title="2. SQL TRUNCATE TABLE与DELETE"></a>2. SQL TRUNCATE TABLE与DELETE</h3><p>逻辑上，<code>TRUNCATE TABLE</code>语句和不带<code>WHERE</code>子句的<code>DELETE</code>语句提供了从表中删除所有数据的相同效果。 但是，它们确实存在一些差别：</p>
<ul>
<li>使用<code>DELETE</code>语句时，数据库系统会记录操作。 通过一些努力，可以回滚已删除的数据。 但是，当使用<code>TRUNCATE TABLE</code>语句时，除非在尚未提交的事务中使用它，否则无法回滚。</li>
<li>要从外键约束引用的表中删除数据，不能使用<code>TRUNCATE TABLE</code>语句。 在这种情况下，必须使用<code>DELETE</code>语句。</li>
<li>如果表具有与之关联的触发器，则<code>TRUNCATE TABLE</code>语句不会触发<code>delete</code>触发器。</li>
<li>执行<code>TRUNCATE TABLE</code>语句后，某些数据库系统会将自动增量列(或标识，序列等)的值重置为其起始值。 <code>DELETE</code>语句不是这种情况。</li>
<li>带有<code>WHERE</code>子句的<code>DELETE</code>语句从表中删除部分数据，而<code>TRUNCATE TABLE</code>语句始终从表中删除所有数据。</li>
</ul>
<h2 id="MYSQL中TRUNCATE和DELETE的区别"><a href="#MYSQL中TRUNCATE和DELETE的区别" class="headerlink" title="MYSQL中TRUNCATE和DELETE的区别"></a>MYSQL中TRUNCATE和DELETE的区别</h2><p><a href="https://www.jianshu.com/p/ddc5b65e63af">https://www.jianshu.com/p/ddc5b65e63af</a></p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月02日 java</title>
    <url>/exam//2dad217f/</url>
    <content><![CDATA[<h1 id="考点1-switch-case穿透-没有break的switch-case语句"><a href="#考点1-switch-case穿透-没有break的switch-case语句" class="headerlink" title="考点1:switch-case穿透 没有break的switch-case语句"></a>考点1:switch-case穿透 没有break的switch-case语句</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        result = result + <span class="string">&quot;him &quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        result = result + <span class="string">&quot;her &quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        result = result + <span class="string">&quot;it &quot;</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        result = result + <span class="string">&quot;me &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>
<p>请给出最终输出内容。</p>
<ul>
<li>A <code>it me</code></li>
<li>B <code>him her it me</code></li>
<li>C <code>him her</code></li>
<li>D <code>me</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>没有break，会产生穿透，从满足条件的case开始执行到底</p>
<h1 id="考点2-java常用包"><a href="#考点2-java常用包" class="headerlink" title="考点2:java常用包"></a>考点2:java常用包</h1><p>下面有关JDK中的包和他们的基本功能,描述错误的是？</p>
<ul>
<li>A <code>java.awt</code>: 包含构成抽象窗口工具集的多个类,用来构建和管理应用程序的图形用户界面</li>
<li>B <code>java.io</code>:　 包含提供多种输出输入功能的类</li>
<li>C <code>java.lang</code>: 包含执行与网络有关的类,如<code>URL,SCOKET,SEVERSOCKET</code></li>
<li>D <code>java.util</code>:　 包含一些实用性的类</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>


<ol>
<li><strong>java.awt：</strong>提供了绘图和图像类，主要用于编写GUI程序，包括按钮、标签等常用组件以及相应的事件类。</li>
<li><strong>java.lang：</strong>java的语言包，是核心包，默认导入到用户程序，包中有object类，数据类型包装类，数学类，字符串类，系统和运行时类，操作类，线程类，错误和异常处理类，过程类。</li>
<li><strong>java.io：</strong>包含提供多种输出输入功能的类。</li>
<li><strong>java.net：</strong> 包含执行与网络有关的类，如URL，SCOKET，SEVERSOCKET等。</li>
<li><strong>java.applet：</strong>包含java小应用程序的类。</li>
<li><strong>java.util：</strong>包含集合框架、遗留的 collection 类、事件模型、日期和时间设施、国际化和各种实用工具类（字符串标记生成器、随机数生成器和位数组、日期Date类、堆栈Stack类、向量Vector类等）。集合类、时间处理模式、日期时间工具等各类常用工具包。</li>
<li><strong>java.sql：</strong>提供使用 JavaTM 编程语言访问并处理存储在数据源（通常是一个关系数据库）中的数据的 API。</li>
</ol>
<p>java.lang——包含一些Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能。<br>java.net——包含执行与网络相关的操作的类和接口。<br>java.io——包含提供多种输入&#x2F;输出功能的类。<br>java.util——包含一些实用性工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。<br>java.text——包含了一些java格式化相关的类<br>java.sql——包含了java进行JDBC数据库编程的相关类&#x2F;接口<br>java.awt——包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。</p>
<h1 id="考点3-运算符"><a href="#考点3-运算符" class="headerlink" title="考点3:运算符"></a>考点3:运算符</h1><p>Java中只有整型才能使用的运算符为？</p>
<ul>
<li>A <code>*</code></li>
<li>B <code>/</code></li>
<li>C <code>%</code></li>
<li>D <code>+</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>答案：C<br>ABD选项的操作符都可用于float和double<br>只有%取余操作，只适用于整型</p>
<p>运算对象为整型的运算符：<code>%</code>取余<code>~</code>取反，<code>&amp;</code>按位与， <code>|</code>按位或，<code>^</code>按位异或.</p>
<p>C不对，<code>%</code>可以应用于<code>doube</code>，并非整型才能用。感觉这道题没有正确答案</p>
<p>这题有问题吧，java中浮点数也可以用<code>%</code>，只不过由于精度问题，结果常会不准确。 </p>
<h3 id="取余如何实现"><a href="#取余如何实现" class="headerlink" title="取余如何实现"></a>取余如何实现</h3><p><strong>java取余就是用被除数一直减去除数，直到差小于除数为止，这也正是余数的定义</strong>。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>%<span class="number">3.0</span>;</span><br><span class="line">System.out.println(a); <span class="comment">//输出：1.0</span></span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">8.3</span>%<span class="number">3.2</span>;</span><br><span class="line">System.out.println(b); <span class="comment">//输出：1.9000000000000004</span></span><br><span class="line"><span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span> - <span class="number">3.0</span>;</span><br><span class="line">System.out.println(c); <span class="comment">//输出：7.0</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">8.3</span> - <span class="number">3.2</span>;</span><br><span class="line">System.out.println(d); <span class="comment">//输出：5.1000000000000005</span></span><br><span class="line">d -= <span class="number">3.2</span>;</span><br><span class="line">System.out.println(d); <span class="comment">//输出：1.9000000000000004</span></span><br></pre></td></tr></table></figure>
<p>可以看出，在求余时的减法过程中，就已经丢失精度了，所以最后的结果当然不准确。</p>
<h1 id="考点4-循环"><a href="#考点4-循环" class="headerlink" title="考点4:循环"></a>考点4:循环</h1><p>以下代码的循环次数是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(--i);</span><br><span class="line">            --i;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i != <span class="number">0</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 0</li>
<li>B 1</li>
<li>C 7</li>
<li>D 无限次</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>


<p>执行1次，5<br>执行2次，3<br>执行3次，1<br>执行4次，-1<br>永远执行不到0</p>
<p>每一次循环都会减二，7每次减2都是成奇数。永远执行不到0。 </p>
<h1 id="考点5-异常处理"><a href="#考点5-异常处理" class="headerlink" title="考点5:异常处理"></a>考点5:异常处理</h1><p>在异常处理中,以下描述不正确的有</p>
<ul>
<li>A <code>try</code>块不可以省略</li>
<li>B 可以使用多重<code>catch</code>块</li>
<li>C <code>finally</code>块可以省略</li>
<li>D <code>catch</code>块和<code>finally</code>块可以同时省略</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<p>选D 假如try中有异常抛出，则会去执行catch块，再去执行finally块；假如没有catch 块，可以直接执行finally<br>块。catch和finally不能同时都省略。</p>
<figure class="highlight java"><figcaption><span>G:\dev2\idea_workspace\MyJavaTools\RunableTools\src\base\TestCatchFinally.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> base;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCatchFinally</span> &#123;</span><br><span class="line">    <span class="comment">// 自定义异常</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testThrowInCatch();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        testExitInCatch();</span><br><span class="line">        System.out.println(<span class="string">&quot;main end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在catch语句中抛出异常的情况</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MyException 自定义异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testThrowInCatch</span><span class="params">()</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 除零异常</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch-1...&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally-1...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在catch块中直接终止当前运行的Java虚拟机的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testExitInCatch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch-2...&quot;</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally-2...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">catch-1...</span><br><span class="line">finally-1...</span><br><span class="line">catch-2...</span><br></pre></td></tr></table></figure>
<p>可以看到</p>
<ul>
<li>finally块一定会执行，</li>
<li>只有在catch块中调用System.exit()结束了虚拟机，finally才不会执行。</li>
</ul>
<h1 id="考点6-接口修饰符"><a href="#考点6-接口修饰符" class="headerlink" title="考点6:接口修饰符"></a>考点6:接口修饰符</h1><p>能用来修饰interface的有()</p>
<ul>
<li>A <code>private</code></li>
<li>B <code>public</code></li>
<li>C <code>protected</code></li>
<li>D <code>static</code></li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>定义非内部java接口可以使用public和package修饰，这一点可以在Eclipse创建接口时查看：</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/09/20210903005053.png" alt="image-20210903005053027"></p>
<h3 id="package权限的接口"><a href="#package权限的接口" class="headerlink" title="package权限的接口"></a>package权限的接口</h3><p>所以的package权限，就是什么都不写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> interfacetest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="public修饰的接口"><a href="#public修饰的接口" class="headerlink" title="public修饰的接口"></a>public修饰的接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> interfacetest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内部接口没有限制"><a href="#内部接口没有限制" class="headerlink" title="内部接口没有限制"></a>内部接口没有限制</h3><p>内部接口与类的成员变量一样，如下的代码是没有错误的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> interfacetest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="comment">// 私有内部接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">interface</span> <span class="title class_">C1</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类权限内部接口</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">interface</span> <span class="title class_">C2</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包权限内部接口</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">C3</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共权限内部接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">C4</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">interface</span> <span class="title class_">C5</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现内部接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C1Impl</span> <span class="keyword">implements</span> <span class="title class_">C1</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="考点7-调动线程的start方法才会启动线程"><a href="#考点7-调动线程的start方法才会启动线程" class="headerlink" title="考点7:调动线程的start方法才会启动线程"></a>考点7:调动线程的start方法才会启动线程</h1><p>以下程序运行的结果为 (   )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System. out .print( <span class="string">&quot;run&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Example example= <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">        example.run();</span><br><span class="line">        System. out .print( <span class="string">&quot;main&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>A <code>run main</code></li>
<li>B <code>main run</code></li>
<li>C <code>main</code></li>
<li>D <code>run</code></li>
<li>E 不能确定</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>


<p>调用<code>example.run()</code>，并没有创建新线程，只有main线程由上而下执行，<code>Thread.sleep(1000)</code>只是让main线程休眠了1000ms；最终打印出了run main</p>
<p>调用<code>example.start()</code>，创建了一个新线程，运行到<code>Thread.sleep(1000)</code>,该线程休眠了1000ms；main线程先打印main，新创建的线程结束休眠后，打印run，最终打印出了main run</p>
<h1 id="考点8-多态-向上转型-类的加载顺序-运行时表现子类特性"><a href="#考点8-多态-向上转型-类的加载顺序-运行时表现子类特性" class="headerlink" title="考点8:多态 向上转型 类的加载顺序 运行时表现子类特性"></a>考点8:多态 向上转型 类的加载顺序 运行时表现子类特性</h1><p>下面代码的输出是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">baseName</span> <span class="operator">=</span> <span class="string">&quot;base&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span> &#123;</span><br><span class="line">        callName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(baseName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">baseName</span> <span class="operator">=</span> <span class="string">&quot;sub&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callName</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(baseName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A <code>null</code></li>
<li>B <code>sub</code></li>
<li>C <code>base</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p><code>new Sub();</code>在创造派生类的过程中首先创建基类对象，然后才能创建派生类。<br>创建基类即默认调用<code>Base()</code>方法，在方法中调用<code>callName()</code>方法，由于派生类中存在此方法，则被调用的<code>callName</code>（）方法是派生类中的方法，此时派生类还未构造，所以变量<code>baseName</code>的值为<code>null</code></p>
<p><strong>本题与内部类无关系，去掉内部类后代码如上，</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">baseName</span> <span class="operator">=</span> <span class="string">&quot;base&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span> &#123;</span><br><span class="line">        callName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(baseName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">baseName</span> <span class="operator">=</span> <span class="string">&quot;sub&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(baseName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编译时表现为父类特性，运行时表现为子类特性"><a href="#编译时表现为父类特性，运行时表现为子类特性" class="headerlink" title="编译时表现为父类特性，运行时表现为子类特性"></a>编译时表现为父类特性，运行时表现为子类特性</h3><p>执行Base b &#x3D; new Sub();时由于多态 b编译时表现为Base类特性，运行时表现为Sub类特性，<br>Base b &#x3D; new Sub()；不管是哪种状态都会调用Base构造器执行callName()方法；<br>执行方法时，由于多台表现为子类特性，所以会先在子类是否有callName()；如果有就执行，没有再去父类寻找</p>
<p>现在，子类有这个方法，所以执行子类重写的方法。而此时子类尚未初始化（执行完父类构造器后才会开始执行子类构造器），</p>
<p><strong>优先执行子类重写的方法</strong></p>
<h3 id="向上转型加载顺序"><a href="#向上转型加载顺序" class="headerlink" title="向上转型加载顺序"></a>向上转型加载顺序</h3><p>本题考查知识点是多态(上转型)以及类的先后加载顺序<br>上转型 类似 Father father &#x3D; new Son();<br>1:父类中的静态代码块<br>2:子类中的静态代码块<br>3:父类中构造方法<br>4:子类当中的构造方法</p>
<p>下面来简单分析一下加载顺序<br>当执行到Base b &#x3D;newSub()时，本题的加载顺序是:<br>加载父类Base类中的构造方法Base()进而调用callName()(因为子类把父类的这个方法给覆盖了,所以此方法执行的是子类中的)<br>因为子类中的baseName变量还没进行初始化,故为null</p>
<p>解题要点：</p>
<p> 1、静态内部类是不依赖于外部类的，静态内部类中只能访问外部类的静态成员（变量和方法），此处的内部类没有意义，静态非静态，只是在构造内部类对象时写法不同，但程序执行没有差异；</p>
<p> 2、继承关系类的加载顺序（不考虑静态属性和静态代码的情况下）：初始化父类的非静态成员属性或非静态代码块–&gt;执行父类的构造函数–&gt;初始化子类的非静态成员属性或非静态代码块–&gt;执行子类的构造函数；本题中首先执行父类的 private String baseName &#x3D; “base”;，然后执行父类的构造函数；执行过程中调用callName()方法；</p>
<p> 3、多态：父类引用指向子类对象，父类引用b指向了子类对象new<br> Sub();多态中，实际执行时如果子类重写了父类的方法，则执行子类的方法；</p>
<p> 4、根据多态的原则，再执行父类的构造方法中调用callName方法，实际调用的是子类的callName方法，子类的callName方法输出的是属性baseName的值，可是这时子类的baseName属性还没有被初始化，因为此时仍处在父类构造函数执行过程中。</p>
<h3 id="多态-编译看左-运行看右"><a href="#多态-编译看左-运行看右" class="headerlink" title="多态 编译看左 运行看右"></a>多态 编译看左 运行看右</h3><p><code>Base b = new Sub()</code>，因为是多态，遵循着<strong>编译看左运行看右</strong>，所以首先调用Base的构造方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Base</span> <span class="params">()</span> &#123;callName();&#125;</span><br></pre></td></tr></table></figure>
<p>调试一下就可以很清楚的看到执行步骤，当执行父类的callName方法时，直接跳到子类的输出 System.out.println(baseName)，此时子类还没有初始化，所以是null</p>
<h1 id="考点9-线程安全的集合"><a href="#考点9-线程安全的集合" class="headerlink" title="考点9:线程安全的集合"></a>考点9:线程安全的集合</h1><p>线程安全的map在JDK 1.5及其更高版本环境 有哪几种方法可以实现?</p>
<ul>
<li>A <code>Map map = new HashMap()</code></li>
<li>B <code>Map map = new TreeMap()</code></li>
<li>C <code>Map map = new ConcurrentHashMap();</code></li>
<li>D <code>Map map = Collections.synchronizedMap(new HashMap());</code></li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: CD</details>


<p>答案 ： C D</p>
<ol>
<li>HashMap,TreeMap 未进行同步考虑，是线程不安全的。</li>
<li>HashTable 和 ConcurrentHashMap 都是线程安全的。区别在于他们对加锁的范围不同，HashTable<br>对整张Hash表进行加锁，而ConcurrentHashMap将Hash表分为16桶(segment)，每次只对需要的桶进行加锁。</li>
<li>Collections 类提供了synchronizedXxx()方法，可以将指定的集合包装成线程同步的集合。比如，<br>List  list &#x3D; Collections.synchronizedList(new ArrayList());<br>Set  set &#x3D; Collections.synchronizedSet(new HashSet());</li>
</ol>
<h3 id="Hashtable线程安全效率低"><a href="#Hashtable线程安全效率低" class="headerlink" title="Hashtable线程安全效率低"></a>Hashtable线程安全效率低</h3><p>HashMap不是线程安全的； Hashtable线程安全，但效率低，因为是Hashtable是使用synchronized的，所有线程竞争同一把锁； </p>
<h3 id="ConcurrentHashMap线程安全效率高"><a href="#ConcurrentHashMap线程安全效率高" class="headerlink" title="ConcurrentHashMap线程安全效率高"></a>ConcurrentHashMap线程安全效率高</h3><p>ConcurrentHashMap不仅线程安全而且效率高，因为它包含一个segment数组，将数据分段存储，给每一段数据配一把锁，也就是所谓的<strong>锁分段技术</strong> </p>
<h3 id="为什么HashMap不是线程安全的？"><a href="#为什么HashMap不是线程安全的？" class="headerlink" title="为什么HashMap不是线程安全的？"></a>为什么HashMap不是线程安全的？</h3><p>1、如果多个线程同时使用put方法添加元素，而且假设正好存在两个put的key发生了碰撞(根据hash值计算的bucket一样)，那么根据HashMap的实现，这两个key会添加到数组的同一个位置，这样最终就会发生其中一个线程的put的数据被覆盖。<br>2、如果多个线程同时检测到元素个数超过 <code>数组大小*loadFactor</code>，这样就会发生多个线程同时对Node数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给table，也就是说其他线程的都会丢失，并且各自线程put的数据也丢失。 </p>
<p>hashMap实现线程安全： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、</span></span><br><span class="line">Hashtable&lt;String, String&gt; hashtable =<span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//2、</span></span><br><span class="line">Map&lt;String, String&gt; synchronizedHashMap = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;());</span><br><span class="line"><span class="comment">//3、</span></span><br><span class="line">ConcurrentHashMap&lt;String, String&gt; concurrentHashMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h1 id="考点10-CMS垃圾回收器"><a href="#考点10-CMS垃圾回收器" class="headerlink" title="考点10:CMS垃圾回收器"></a>考点10:CMS垃圾回收器</h1><p>CMS垃圾回收器在那些阶段是没用用户线程参与的</p>
<ul>
<li>A 初始标记</li>
<li>B 并发标记</li>
<li>C 重新标记</li>
<li>D 并发清理</li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>CMS全称<strong>Concurrent Mark Sweep</strong>，是一款并发的、使用<strong>标记-清除</strong>算法的垃圾回收器，以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器，对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。 </p>
<p>CMS的基础算法是：<strong>标记—清除</strong>。<br>它的过程可以分为以下6个步骤：</p>
<ol>
<li><strong>初始标记</strong>(STW initial mark)</li>
<li><strong>并发标记</strong>(Concurrent marking)</li>
<li><strong>并发预清理</strong>(Concurrent precleaning)</li>
<li><strong>重新标记</strong>(STW remark)</li>
<li><strong>并发清理</strong>(Concurrent sweeping)</li>
<li><strong>并发重置</strong>(Concurrent reset)</li>
</ol>
<img data-src="https://uploadfiles.nowcoder.com/images/20200502/9374535_1588428365082_2D3DED829E7D27716B630299E48DDD87">

<ol>
<li><strong>初始标记：</strong>在这个阶段，需要虚拟机停顿正在执行的任务，官方的叫法STW(Stop The Word)。这个过程从垃圾回收的”根对象”开始，只扫描到能够和”根对象”直接关联的对象，并作标记。所以<strong>这个过程虽然暂停了整个JVM，但是很快就完成了</strong>。</li>
<li><strong>并发标记：</strong>这个阶段紧随初始标记阶段，在初始标记的基础上继续向下追溯标记。并发标记阶段，<strong>应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿</strong>。</li>
<li><strong>并发预清理</strong>：并发预清理阶段仍然是并发的。在这个阶段，虚拟机查找在执行并发标记阶段新进入老年代的对象(可能会有一些对象从新生代晋升到老年代， 或者有一些对象被分配到老年代)。通过重新扫描，减少下一个阶段”重新标记”的工作，因为下一个阶段会Stop The World。</li>
<li><strong>重新标记</strong>：这个阶段会暂停虚拟机，收集器线程扫描在CMS堆中剩余的对象。扫描从”根对象”开始向下追溯，并处理对象关联。</li>
<li><strong>并发清理：</strong>清理垃圾对象，<strong>这个阶段收集器线程和应用程序线程并发执行</strong>。</li>
<li><strong>并发重置：</strong>这个阶段，重置CMS收集器的数据结构，等待下一次垃圾回收。</li>
</ol>
<p>CMS不会整理、压缩堆空间，这样就带来一个问题：经过CMS收集的堆会产生空间碎片，CMS不对堆空间整理压缩节约了垃圾回收的停顿时间，但也带来的堆空间的浪费。  为了解决堆空间浪费问题，CMS回收器不再采用简单的指针指向一块可用堆空 间来为下次对象分配使用。；而是把一些未分配的空间汇总成一个列表，当JVM分配对象空间的时候，会搜索这个列表找到足够大的空间来hold住这个对象。<br>从上面的图可以看到，为了让应用程序不停顿，CMS线程和应用程序线程并发执行，这样就需要有更多的CPU，单纯靠线程切 换是不靠谱的。并且，重新标记阶段，为空保证STW快速完成，也要用到更多的甚至所有的CPU资源。  </p>
<p>B.并发标记 和 D.并发清理 这两个阶段是有用户线程参与的，所以答案选A和C。</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年09月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年09月05日 java1</title>
    <url>/exam//a1973542/</url>
    <content><![CDATA[<h1 id="考点1-子类能访问父类的那些成员"><a href="#考点1-子类能访问父类的那些成员" class="headerlink" title="考点1:子类能访问父类的那些成员"></a>考点1:子类能访问父类的那些成员</h1><p>C#、JAVA)扩展方法能访问被扩展对象的public成员</p>
<ul>
<li>A 能</li>
<li>B 不能</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p><strong>翻译一下，子类方法是否能够访问父类中的public成员。</strong></p>
<h1 id="考点2-构造方法"><a href="#考点2-构造方法" class="headerlink" title="考点2:构造方法"></a>考点2:构造方法</h1><p>以下有关构造方法的说法,正确的是:()</p>
<ul>
<li>A 一个类的构造方法可以有多个</li>
<li>B 构造方法在类定义时被调用</li>
<li>C 构造方法只能由对象中的其他方法调用</li>
<li>D 构造方法可以和类同名,也可以和类名不同</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>A 一个类有多个构造方法便是重载的表现。<strong>重载参数列表不同</strong>。所以A是正确的。<br>B 构造方法是在对象<strong>创建时</strong>就被调用，用于初始化。<br>C 构造方法是给与之对应的对象进行初始化，初始化的动作只执行一次。<br>D 构造方法必须与所在类的名称同名。</p>
<p>B、构造器在对象被实例化的时候调用<br>C、构造方法不能由对象中的其他方法调用。都是new出来或者利用了反射。<br>D、构造方法必须与类同名，且没有返回值（不同于void）。</p>
<h1 id="考点3-线程执行体run-启动线程start"><a href="#考点3-线程执行体run-启动线程start" class="headerlink" title="考点3:线程执行体run() 启动线程start()"></a>考点3:线程执行体run() 启动线程start()</h1><p>以下哪个方法用于定义线程的执行体？</p>
<ul>
<li>A <code>start()</code></li>
<li>B <code>init()</code></li>
<li>C <code>run()</code></li>
<li>D <code>synchronized()</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>run()用于定义线程执行体，<br>start()用于启动线程</p>
<h1 id="考点4-重载"><a href="#考点4-重载" class="headerlink" title="考点4:重载"></a>考点4:重载</h1><p>对于同一类中的两个方法 , 在判断它们是不是重载方法时 , 肯定不考虑( )</p>
<ul>
<li>A 参数个数</li>
<li>B 参数类型</li>
<li>C 返回值类型</li>
<li>D 参数顺序</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>方法重写的注意事项：<br>构造方法不能被重写，不要问为什么？因为构造方法名必须和类名相同<br>private修饰的成员方法不能被重写<br><strong>static修饰的方法不能被重写</strong><br><strong>final修饰的方法不能被重写</strong><br>当子类重写了父类中的方法后，子类对象调用该方法时调用的是子类重写后的方法</p>
<h3 id="子类的实例方法不能重写父类的静态方法"><a href="#子类的实例方法不能重写父类的静态方法" class="headerlink" title="子类的实例方法不能重写父类的静态方法"></a>子类的实例方法不能重写父类的静态方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> extendstest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">	<span class="comment">// 父类中的static方法</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Static method in parent class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 父类中的非static方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nonStaticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Non static method in parent class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 父类中的final方法</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">finalMethod</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Final method in parent class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">	<span class="comment">// 子类可以重写父类的protected 非static方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nonStaticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>.nonStaticMethod();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 子类无法重写父类的static方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Static method in parent class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">finalMethod</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Final method in son class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类的staticMethod方法报错如下:</p>
<pre>
Multiple markers at this line
    - <mark>This instance method cannot override the static method from Father</mark>
    - overrides extendstest.Father.canYouSeeStatic
    - The method canYouSeeStatic() of type Son must override or implement a supertype method
</pre>

<p><strong>意思是子类的实例方法不能重写父类的静态方法</strong></p>
<p>给子类中的staticMethod加上static修饰符：</p>
<pre>
    // 子类无法重写父类的static方法
    @Override
    public <mark>static</mark> void staticMethod() {
        System.out.println("Static method in parent class");
    }
</pre>

<p>还是不可以重写，报错如下：</p>
<pre>
The method staticMethod() of type Son must override or implement a supertype method
</pre>

<p>子类的finalMethod方法报错如下：</p>
<pre>
Multiple markers at this line
    - <mark>Cannot override the final method from Parent</mark>
    - overrides extendstest.Parent.finalMethod
</pre>

<h3 id="可以定义与父类同名的Static方法"><a href="#可以定义与父类同名的Static方法" class="headerlink" title="可以定义与父类同名的Static方法"></a>可以定义与父类同名的Static方法</h3><p>去掉子类的staticMethod()方法上面的<code>@Override</code>，则不会报错。<br>这不是重写，无法实现多态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> extendstest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">	<span class="comment">// 父类中的static方法</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Static method in parent class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 父类中的非static方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nonStaticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Non static method in parent class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 父类中的final方法</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">finalMethod</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Final method in parent class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Parent</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">		<span class="comment">// 调用的还是父类的静态方法，不能实现多态</span></span><br><span class="line">		parent.staticMethod();</span><br><span class="line">		<span class="comment">// 调用的是子类的方法，多态</span></span><br><span class="line">		parent.nonStaticMethod();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">	<span class="comment">// 子类可以重写父类的protected 非static方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nonStaticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Static method in Son class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 子类无法重写父类的static方法</span></span><br><span class="line">	<span class="comment">// @Override</span></span><br><span class="line">	<span class="comment">// 子类可以定义与父类相同的静态方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Static method in Son class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Static method in parent class</span><br><span class="line">Static method in Son class</span><br></pre></td></tr></table></figure>
<h3 id="重写描述的是子类实例方法和父类实例方法的关系"><a href="#重写描述的是子类实例方法和父类实例方法的关系" class="headerlink" title="重写描述的是子类实例方法和父类实例方法的关系"></a>重写描述的是子类实例方法和父类实例方法的关系</h3><p>static定义的方法时类方法，通过类名调用。<br>上面的<code>parent.staticMethod();</code>调用实际上还是<code>类名.staticMethod();</code><br>也就是<code>Parent.staticMethod();</code>.所以不会去调用Son类中的同名方法。<br>如果非要调用子类的同名静态方法的话，需要改成:<code>Son.staticMethod()</code>。</p>
<h3 id="static方法如何实现”多态”"><a href="#static方法如何实现”多态”" class="headerlink" title="static方法如何实现”多态”"></a>static方法如何实现”多态”</h3><p>使用子类来调用覆盖的static方法，如果子类中有该静态方法，则执行子类的静态方法。<br>如果子类没有该静态方法，则去父类中查找静态方法，如果有则执行父类的静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> extendstest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// 父类中的static方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in parent class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类中的非static方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nonStaticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Non static method in parent class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类中的final方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">finalMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Final method in parent class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        <span class="type">Parent</span> <span class="variable">parent</span> <span class="operator">=</span> son;</span><br><span class="line">        <span class="comment">// 调用的还是父类的静态方法，不能实现多态</span></span><br><span class="line">        parent.staticMethod();</span><br><span class="line">        <span class="comment">// 调用的是子类的方法，多态</span></span><br><span class="line">        parent.nonStaticMethod();</span><br><span class="line">        <span class="comment">// 调用子类的静态方法，如果子类定义了该静态方法，</span></span><br><span class="line">        <span class="comment">// 则调用子类的，如果没有则去父类中查找</span></span><br><span class="line">        <span class="comment">// son.staticMethod();</span></span><br><span class="line">        Son.staticMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// 子类可以重写父类的protected 非static方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nonStaticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in Son class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类无法重写父类的static方法</span></span><br><span class="line">    <span class="comment">// @Override</span></span><br><span class="line">    <span class="comment">// 子类可以定义与父类相同的静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in Son class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Static method in parent class</span><br><span class="line">Static method in Son class</span><br><span class="line">Static method in Son class</span><br></pre></td></tr></table></figure>
<p>此时Son类中重写了父类的静态方法，调用的是重写后的。<br>如果把Son类中的staticMethod方法注释掉。：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> extendstest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// 父类中的static方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in parent class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类中的非static方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nonStaticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Non static method in parent class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类中的final方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">finalMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Final method in parent class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        <span class="type">Parent</span> <span class="variable">parent</span> <span class="operator">=</span> son;</span><br><span class="line">        <span class="comment">// 调用的还是父类的静态方法，不能实现多态</span></span><br><span class="line">        parent.staticMethod();</span><br><span class="line">        <span class="comment">// 调用的是子类的方法，多态</span></span><br><span class="line">        parent.nonStaticMethod();</span><br><span class="line">        <span class="comment">// 调用子类的静态方法，如果子类定义了该静态方法，</span></span><br><span class="line">        <span class="comment">// 则调用子类的，如果没有则去父类中查找</span></span><br><span class="line">        <span class="comment">// son.staticMethod();</span></span><br><span class="line">        Son.staticMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// 子类可以重写父类的protected 非static方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nonStaticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in Son class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    // 子类无法重写父类的static方法</span></span><br><span class="line"><span class="comment">//    // @Override</span></span><br><span class="line"><span class="comment">//    // 子类可以定义与父类相同的静态方法</span></span><br><span class="line"><span class="comment">//    public static void staticMethod() &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;Static method in Son class&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Static method in parent class</span><br><span class="line">Static method in Son class</span><br><span class="line">Static method in parent class</span><br></pre></td></tr></table></figure>
<p>可以看到，此时调用了从父类继承得到的静态方法。</p>
<h3 id="static方法可以被继承-可以被覆盖-不能被重写"><a href="#static方法可以被继承-可以被覆盖-不能被重写" class="headerlink" title="static方法可以被继承 可以被覆盖 不能被重写"></a>static方法可以被继承 可以被覆盖 不能被重写</h3><p><strong>重写，说的是根据<code>运行时</code>的对象类型来决定调用哪个方法</strong>，而不是编译时类型。</p>
<p>因为无法使用<code>@Override</code>修饰，所以不是重写。</p>
<p>对于静态方法，我们不应该尝试去重写，而且调用时应该以类进行调用，而不是对象进行调用。</p>
<h3 id="问-static方法可以被重写吗？"><a href="#问-static方法可以被重写吗？" class="headerlink" title="问 static方法可以被重写吗？"></a>问 static方法可以被重写吗？</h3><p>答，static方法可以被子类继承，子类可以覆盖继承到的static方法。但是这不叫重写。<br>因为如果你在同名的static方法上写上@Override注解，编译器会报错。</p>
<p>重写是为了实现多态，多态是<strong>在运行的时候</strong>根据对象的类型来调用方法的。<br>如果使用了静态方法，那么在<strong>编译期间</strong>，就知道调用的是那个静态方法了，这不符合多态的定义。</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/df43f5500ea3">https://www.jianshu.com/p/df43f5500ea3</a><br>静态方法从程序开始运行后就已经分配了内存，也就是说已经写死了。所有引用到该方法的对象（父类的对象也好子类的对象也好）所指向的都是同一块内存中的数据，也就是该静态方法。<strong>子类中如果定义了相同名称的静态方法，并不会重写，而应该是在内存中又分配了一块给子类的静态方法，没有重写这一说</strong>。</p>
</blockquote>
<h1 id="考点5-不懂的点：JVM"><a href="#考点5-不懂的点：JVM" class="headerlink" title="考点5:不懂的点：JVM"></a>考点5:不懂的点：JVM</h1><p>off-heap是指那种内存()</p>
<ul>
<li>A <code>JVM GC</code>能管理的内存</li>
<li>B <code>JVM</code>进程管理的内存</li>
<li>C 在<code>JVM</code>老年代内存区</li>
<li>D 在<code>JVM</code>新生代内存</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h3><p>off-heap叫做堆外内存，将你的对象从堆中脱离出来序列化，然后存储在一大块内存中，这就像它存储到磁盘上一样，但它仍然在RAM中。<br>对象在这种状态下不能直接使用，它们必须首先反序列化，也不受垃圾收集。<br>序列化和反序列化将会影响部分性能（所以可以考虑使用FST-serialization）使用堆外内存能够降低GC导致的暂停。<br>堆外内存不受垃圾收集器管理，也不属于老年代，新生代。</p>
<p><strong>堆外内存意味着把内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机）</strong>。<strong>不属于老年代和新生代。</strong></p>
<p><strong>JVM GC回收堆和方法区，排除法选择 B</strong></p>
<p>这样做的结果就是能保持一个较小的堆，以减少垃圾收集对应用的影响。</p>
<p>使用堆外内存能够降低GC导致的暂停。</p>
<p>堆外内存，它和内存池一样，也能缩短垃圾回收时间，但是它适用的对象和内存池完全相反。<br>内存池往往适用于生命期较短的可变对象，而生命期中等或较长的对象，正是堆外内存要解决的。</p>
<h4 id="堆外内存的特点"><a href="#堆外内存的特点" class="headerlink" title="堆外内存的特点"></a>堆外内存的特点</h4><p><a href="https://blog.csdn.net/universe_ant/article/details/52145450">https://blog.csdn.net/universe_ant/article/details/52145450</a><br>堆外内存有以下特点：</p>
<ul>
<li>对于大内存有良好的伸缩性</li>
<li>对垃圾回收停顿的改善可以明显感觉到</li>
<li>在进程间可以共享，减少虚拟机间的复制</li>
</ul>
<p>当然堆外内存也有它自己的问题，</p>
<ul>
<li>最大的问题就是你的数据结构变得不那么直观，如果数据结构比较复杂，就要对它进行串行化（serialization），而串行化本身也会影响性能。</li>
<li>另一个问题是由于你可以使用更大的内存，你可能开始担心虚拟内存（即硬盘）的速度对你的影响了。</li>
</ul>
<h3 id="1）程序计数器"><a href="#1）程序计数器" class="headerlink" title="1）程序计数器"></a>1）程序计数器</h3><p>几乎不占有内存。用于取下一条执行的指令。</p>
<h3 id="2）堆"><a href="#2）堆" class="headerlink" title="2）堆"></a>2）堆</h3><p>所有通过new创建的对象的内存都在堆中分配，其大小可以通过-Xmx和-Xms来控制。<br>堆被划分为新生代和旧生代，<br>新生代又被进一步划分为Eden和Survivor区，最后Survivor由FromSpace和ToSpace组成，结构图如下所示：</p>
<p>新生代。新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中，新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例旧生代。用于存放新生代中经过多次垃圾回收仍然存活的对象。</p>
<img data-src="https://uploadfiles.nowcoder.com/images/20191224/337184788_1577191659133_DB86032511CDC329D42FB2BB8831615C">

<h3 id="3）栈"><a href="#3）栈" class="headerlink" title="3）栈"></a>3）栈</h3><p>每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果。</p>
<h3 id="4）本地方法栈"><a href="#4）本地方法栈" class="headerlink" title="4）本地方法栈"></a>4）本地方法栈</h3><p>用于支持native方法的执行，存储了每个native方法调用的状态</p>
<h3 id="5）方法区"><a href="#5）方法区" class="headerlink" title="5）方法区"></a>5）方法区</h3><p>存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。<br>JVM用永久代（PermanetGeneration）来存放方法区，（在JDK的HotSpot虚拟机中，可以认为方法区就是永久代，但是在其他类型的虚拟机中，没有永久代的概念，有关信息可以看周志明的书）可通过-XX:PermSize和-XX:MaxPermSize来指定最小值和最大值。</p>
<h1 id="考点6-异常处理机制"><a href="#考点6-异常处理机制" class="headerlink" title="考点6:异常处理机制"></a>考点6:异常处理机制</h1><p>java关于异常处理机制的叙述哪些正确</p>
<ul>
<li>A <code>catch</code>部分捕捉到异常情况时,才会执行<code>finally</code>部分</li>
<li>B 当<code>try</code>区段的程序发生异常时,才会执行<code>catch</code>区段的程序</li>
<li>C 在<code>try</code>区段不论程序是否发生异常及捕获到异常,都会执行<code>finally</code>部分</li>
<li>D 以上都是</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<h3 id="finally不执行情况"><a href="#finally不执行情况" class="headerlink" title="finally不执行情况"></a>finally不执行情况</h3><p>try块执行时，finally表示总是执行。但是</p>
<ol>
<li>在try中调用System.exit(0)，强制退出了程序，finally块不执行。</li>
<li>在进入try块前，出现了异常，此时try没有执行，finally块不执行。</li>
</ol>
<h1 id="考点7-面向对象三大特性"><a href="#考点7-面向对象三大特性" class="headerlink" title="考点7:面向对象三大特性"></a>考点7:面向对象三大特性</h1><p>面向对象的程序设计语言具有()等共同特性。</p>
<ul>
<li>A 封装性</li>
<li>B 多态性</li>
<li>C 简单性</li>
<li>D 复杂性</li>
<li>E 继承性</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABE</details>

<h3 id="面向对象OOP三大特性："><a href="#面向对象OOP三大特性：" class="headerlink" title="面向对象OOP三大特性："></a>面向对象OOP三大特性：</h3><ul>
<li>继承</li>
<li>封装</li>
<li>多态</li>
</ul>
<p>准确来说，基于对象和面向对象是有区别的。<br><strong>基于对象是封装和继承</strong>。<br><strong>面向对象是封装、继承和多态</strong>。<br>详见 <a href="https://blog.csdn.net/jiaruitao777/article/details/99098027" target="_blank">https://blog.csdn.net/jiaruitao777/article/details/99098027</a></p>
<h1 id="考点8-IO流-字符流字节流"><a href="#考点8-IO流-字符流字节流" class="headerlink" title="考点8:IO流 字符流字节流"></a>考点8:IO流 字符流字节流</h1><p>下面哪个流类不属于面向字符的流()</p>
<ul>
<li>A <code>BufferedWriter</code></li>
<li>B <code>FileInputStream</code></li>
<li>C <code>ObjectInputStream</code></li>
<li>D <code>InputStreamReader</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<p>既然是字符流，那么一般是reader和writer结尾。<br>Stream结尾的是字节，Reader结尾的是字符</p>
<p>面向字符的输入流类都是Reader的子类，<img data-src="https://uploadfiles.nowcoder.com/images/20190603/652334996_1559537222061_12B6233B6EA3C9956865918F5E9B7240"></p>
<p>面向字符的输出流都是类 Writer 的子类<img data-src="https://uploadfiles.nowcoder.com/images/20190603/652334996_1559537178275_256EC3581646F19915DBB5C9F4D80330"></p>
<img data-src="https://uploadfiles.nowcoder.com/images/20200805/643412545_1596634989327_DEF638F8839D3C558612E08DC0A11BFF">



<h1 id="考点9-堆存放对象-栈存放程序"><a href="#考点9-堆存放对象-栈存放程序" class="headerlink" title="考点9:堆存放对象 栈存放程序"></a>考点9:堆存放对象 栈存放程序</h1><p>程序中常采用变量表示数据,变量具有名、地址、值、作用域、生存期等属性。关于变量的叙述,()是正确的。</p>
<ul>
<li>A 根据作用域规则,在函数中定义的变量只能在函数中引用</li>
<li>B 在函数中定义的变量,其生存期为整个程序执行期间</li>
<li>C 在函数中定义的变量不能与其所在函数的形参同名</li>
<li>D 在函数中定义的变量,其存储单元在内存的栈区</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details>

<p>这里主要说明D为什么是对的</p>
<p>首先说明栈内存和堆内存里存放的是什么</p>
<ul>
<li>栈内存中存放函数中定义的一些基本类型的变量和对象的引用变量；</li>
<li><strong>堆内存中存放new创建的</strong>对象和数组。</li>
</ul>
<p>简单的来说，<strong>堆主要是用来存放对象的，栈主要是用来执行程序的</strong></p>
<p>这么做是因为</p>
<ul>
<li>栈的存取速度快，栈数据可以共享，但是栈中的数据大小和生存期必须确定，缺乏灵活性中存放一些基本类型的对象和对象句柄</li>
<li>堆是操作系统分配给自己内存，由于从操作系统管理的内存分配，所以再分配和销毁时都需要占用时间，因此用堆的效率非常低，但是优点在于编译器不需要指导从堆里分配多少存储控件，也不需要知道存储的数据要再堆里停留多长事件，因此用堆保存数据时会得到更大的灵活性</li>
</ul>
<p>参考链接：<a href="https://blog.csdn.net/wangbo1998/article/details/80379016">https://blog.csdn.net/wangbo1998/article/details/80379016</a></p>
<p>D选项不太严谨，如果定义的是引用类型变量，且没有通过逃逸分析，则可能会被分配到堆中，逃逸分析是jdk1.8默认开启的</p>
<p>D选项我给大家说明一下，我觉得题出的不严谨，如果方法中有引用类型的变量，那么存储是在堆中，引用在栈中</p>
<h1 id="考点10-身份证号的正则表达式"><a href="#考点10-身份证号的正则表达式" class="headerlink" title="考点10:身份证号的正则表达式"></a>考点10:身份证号的正则表达式</h1><p><strong>多选题</strong><br>关于身份证号,以下正确的正则表达式为(      )</p>
<ul>
<li>A <code>isIDCard=/^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$/;</code></li>
<li>B <code>isIDCard=/^[1-9]\d&#123;7&#125;((9\d)|(1[0-2]))(([0|1|2]\d)|3[9-1])\d&#123;3&#125;$/;</code></li>
<li>C <code>isIDCard=/^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;4&#125;$/;</code></li>
<li>D <code>isIDCard=/^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((9\d)|(1[9-2]))(([0|1|2]\d)|3[9-1])\d&#123;4&#125;$/;</code></li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

<h3 id="身份证构成"><a href="#身份证构成" class="headerlink" title="身份证构成"></a>身份证构成</h3><p>15位身份证的构成：六位出生地区码+六位出身日期码+三位顺序码<br>18位身份证的构成：六位出生地区码+八位出生日期码+三位顺序码+一位校验码</p>
<p>A选项<br><strong>^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$</strong></p>
<ul>
<li><code>[1-9]\d&#123;7&#125;</code>，有8位，其中前六位是地址码，后两位是年份，00~99年。</li>
<li><code>((0\d)|(1[0-2]))</code>,有两位，表示月份，第一个括号范围位00<del>09，第二个括号的范围位10</del>12，综合得到00~12，符合月份的定义。</li>
<li><code>(([0|1|2]\d)|3[0-1])</code>,有两位，表示日期，第一个括号的范围位00<del>09或者10</del>19或者20<del>29，第2个括号的范围位30</del>31，综合得到00~31，符合月份的定义。这个其实也不严谨，例如2月份，只有28天，或29天。</li>
<li><code>\d&#123;3&#125;</code>有三位，表示顺序码</li>
</ul>
<p>B选项<br><strong>^[1-9]\d{7}((9\d)|(1[0-2]))(([0|1|2]\d)|3[9-1])\d{3}$</strong></p>
<ul>
<li><code>[1-9]\d&#123;7&#125;</code>，有8位，其中前六位是地址码，后两位是年份，00~99年。</li>
<li><code>((9\d)|(1[0-2]))</code>，有两位，表示月份，第一个括号的范围位90~99，一年只有12个月份，没有90月份，更没有99月份，B选项排除。</li>
</ul>
<p>C选项的<br><strong>^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$</strong></p>
<ul>
<li><code>[1-9]\d&#123;5&#125;</code>这六位，表示六位出生地码，<ul>
<li><strong>^<mark>[1-9]\d{5}</mark>[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$</strong></li>
</ul>
</li>
<li><code>[1-9]\d&#123;3&#125;</code>这四位，表示年<ul>
<li><strong>^[1-9]\d{5}<mark>[1-9]\d{3}</mark>((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$</strong></li>
</ul>
</li>
<li><code>((0\d)|(1[0-2]))</code>这两位表示，月份，从第一个括号匹配<code>00~09</code>。第二个括号匹配<code>10~12</code>。<ul>
<li><strong>^[1-9]\d{5}[1-9]\d{3}<mark>((0\d)|(1[0-2]))</mark>(([0|1|2]\d)|3[0-1])\d{4}$</strong></li>
<li>所以月份共计匹配范围：<code>00~12</code>符合月份00~12的定义。</li>
</ul>
</li>
<li><code>(([0|1|2]\d)|3[0-1])</code>这两位表示日期，第一个括号匹配00<del>09,10</del>19,20<del>29。第二个括号匹配30</del>31。<ul>
<li><strong>^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))<mark>(([0|1|2]\d)|3[0-1])</mark>\d{4}$</strong></li>
<li>所以日期总计匹配范围：00~31,符合日期的定义。</li>
</ul>
</li>
<li><code>\d&#123;4&#125;</code>,表示匹配三位顺序吗+一位校验码。校验码有字母，这里显然不能完全匹配，勉强认为校验码都是数字吧。<ul>
<li><strong>^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])<mark>\d{4}</mark>$</strong></li>
</ul>
</li>
</ul>
<p>D选项<br><strong>^[1-9]\d{5}[1-9]\d{3}((9\d)|(1[9-2]))(([0|1|2]\d)|3[9-1])\d{4}$</strong></p>
<ul>
<li><code>[1-9]\d&#123;5&#125;</code>,六位地址码</li>
<li><code>[1-9]\d&#123;3&#125;</code>,四位年，1000~9999</li>
<li><code>((9\d)|(1[9-2]))</code>,表示月份，<code>9\d</code>的范围位<code>90~99</code>,一年最多有12个月，没有90个月，更没有99个月。所以D选项错误。</li>
</ul>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Java</category>
        <category>2021年09月</category>
      </categories>
  </entry>
  <entry>
    <title>2021年03月22日Linux专项练习2</title>
    <url>/exam//84510f27/</url>
    <content><![CDATA[<h1 id="考点1-Linux八进制文件权限"><a href="#考点1-Linux八进制文件权限" class="headerlink" title="考点1:Linux八进制文件权限"></a>考点1:Linux八进制文件权限</h1><p> 权限为765的文件,下列哪个是正确的权限位标记()?</p>
<ul>
<li>A <code>-rw-rw-r-x</code></li>
<li>B <code>-rw-r-xr-r</code></li>
<li>C <code>-rwxrw-r-x</code></li>
<li>D <code>-rwxr-xrwx</code></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>首先在 rwx 中r&#x3D;4，w&#x3D;2，x&#x3D;1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7=4+2+1</span><br><span class="line">6=4+2</span><br><span class="line">5=4+1</span><br></pre></td></tr></table></figure>
<p>因此是<code>rwxrw-r-x</code>，选C<br>至于最前面那位，如果是文件夹的话为d，否则为-</p>
<h1 id="考点2-ls-al"><a href="#考点2-ls-al" class="headerlink" title="考点2:ls -al"></a>考点2:ls -al</h1><p>用ls –al 命令列出下面的文件列表,哪个文件是符号连接文件？</p>
<ul>
<li>A -rw-rw-rw- 2 hel-s users 56 Sep 09 11:05 hello</li>
<li>B -rwxrwxrwx 2 hel-s users 56 Sep 09 11:05 goodbye</li>
<li>C drwxr–r– 1 hel users 1024 Sep 10 08:10 zhang</li>
<li>D lrwxr–r– 1 hel users 2024 Sep 12 08:12 cheng &gt; peng.yan1</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h3 id="ls-l第一列含义"><a href="#ls-l第一列含义" class="headerlink" title="ls -l第一列含义"></a>ls -l第一列含义</h3><p>ls -l的第一列的</p>
<ul>
<li>第1个字符表示文件的类型，<ul>
<li><code>-</code> 表示文件；</li>
<li><code>d</code> 表示目录directory；</li>
<li><code>l</code> 表示软链接link。软链接 类似于快捷方式，当源文件丢失时，软链接也失败。</li>
</ul>
</li>
<li>第2，3，4个字符是文件所属主的权限，</li>
<li>第5，6，7个字符是，所属组的权限，、</li>
<li>第8，9，10个字符是其他用户的权限</li>
</ul>
<p>软链接就类似windows的快捷方式，删掉源文件快捷方式就不能用了。 而硬链接源文件和新文件是同等地位的，删了源文件，用新文件依旧可以访问，只是有一个记录链接数的参数会减一。</p>
<h1 id="考点3-Linux路由设置"><a href="#考点3-Linux路由设置" class="headerlink" title="考点3:Linux路由设置"></a>考点3:Linux路由设置</h1><p>局域网的网络地址192.168.1.0&#x2F;24,局域网络连接其它网络的网关地址是192.168.1.1。主机192.168.1.20访问172.16.1.0&#x2F;24网络时,其路由设置正确的是？</p>
<ul>
<li>A route add –net 192.168.1.0 gw 192.168.1.1 netmask 255.255.255.0 metric 1</li>
<li>B route add –net 172.16.1.0 gw 192.168.1.1 netmask 255.255.255.0 metric 1</li>
<li>C route add –net 172.16.1.0 gw 172.16.1.1 netmask 255.255.255.0 metric 1</li>
<li>D route add default 192.168.1.0 netmask 172.168.1.1 metric 1</li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<p>-net 后面跟的是目标网络，gw就是gateway（网关入口）就是你从哪个网关去到那个目标网络。</p>
<h1 id="考点4-Linux环境变量"><a href="#考点4-Linux环境变量" class="headerlink" title="考点4:Linux环境变量"></a>考点4:Linux环境变量</h1><p>以下哪个环境变量表示当前路径 () 。</p>
<ul>
<li>A <code>PATH</code></li>
<li>B <code>PWD</code></li>
<li>C <code>HOME</code></li>
<li>D <code>ROOT</code></li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h3><p>命令pwd是print working directory的缩写，打印当前工作目录</p>
<h3 id="PWD环境变量"><a href="#PWD环境变量" class="headerlink" title="PWD环境变量"></a>PWD环境变量</h3><p>大写的PWD代表环境变量，小写的pwd是shell命令输出当前工作目录。</p>
<h4 id="查看PWD环境变量"><a href="#查看PWD环境变量" class="headerlink" title="查看PWD环境变量:"></a>查看PWD环境变量:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $PWD</span><br></pre></td></tr></table></figure>
<h3 id="PWD和OLDPWD环境变量"><a href="#PWD和OLDPWD环境变量" class="headerlink" title="PWD和OLDPWD环境变量"></a>PWD和OLDPWD环境变量</h3><p><code>PWD</code>记录当前的目录路径，当利用<code>cd</code>命令切换当前目录时，系统自动更新<code>PWD</code>的值，<br><code>OLDPWD</code>记录旧的工作目录，即用户所处的前一个目录。</p>
<h3 id="env命令"><a href="#env命令" class="headerlink" title="env命令"></a>env命令</h3><p>查看系统中所有环境变量可以使用env命令,可以看到PWD的值会随着工作目录变化而变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# env</span><br><span class="line">NVM_RC_VERSION=</span><br><span class="line">HOSTNAME=localhost</span><br><span class="line">NVM_CD_FLAGS=</span><br><span class="line">TERM=xterm</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">HISTSIZE=1000</span><br><span class="line">SSH_CLIENT=192.168.1.4 5694 22</span><br><span class="line">SSH_TTY=/dev/pts/5</span><br><span class="line">NVM_DIR=/root/.nvm</span><br><span class="line">JRE_HOME=/opt/java/jdk1.8.0_281/jre</span><br><span class="line">USER=root</span><br><span class="line">LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:</span><br><span class="line">MAIL=/var/spool/mail/root</span><br><span class="line">PATH=/opt/java/jdk1.8.0_281/bin:/opt/java/jdk1.8.0_281/jre/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/usr/local/git/bin:/root/bin</span><br><span class="line">PWD=/root</span><br><span class="line">JAVA_HOME=/opt/java/jdk1.8.0_281</span><br><span class="line">LANG=zh_CN.UTF-8</span><br><span class="line">HISTCONTROL=ignoredups</span><br><span class="line">SHLVL=1</span><br><span class="line">HOME=/root</span><br><span class="line">LOGNAME=root</span><br><span class="line">CLASSPATH=.:JAVA_HOME/lib:JRE_HOME/lib:</span><br><span class="line">SSH_CONNECTION=192.168.1.4 5694 192.168.1.3 22</span><br><span class="line">LESSOPEN=||/usr/bin/lesspipe.sh %s</span><br><span class="line">_=/usr/bin/env</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>
<h3 id="PATH环境变量"><a href="#PATH环境变量" class="headerlink" title="PATH环境变量"></a>PATH环境变量</h3><p><code>PATH</code>是<code>Linux</code>中一个极为重要的环境变量，它用于帮助<code>Shell</code>找到用户输入的命令。用户所输入的每个命令实际上是一个源代码文件，计算机执行这个文件里的代码以实现这个命令的功能，这些源代码文件称为可执行文件。可执行文件存在于各种各样的目录下，<code>PATH</code>就记录了一系列的目录列表，<code>Shell</code>为每个输入命令搜索<code>PATH</code>中的目录列表。</p>
<h3 id="HOME环境变量"><a href="#HOME环境变量" class="headerlink" title="HOME环境变量"></a>HOME环境变量</h3><p><code>HOME</code>记录当前用户的目录，由<code>/etc/passwd</code>的倒数第2个域决定，<code>HOME</code>目录用于保存用户自己的文件。</p>
<pre>
[root@localhost ~]&#35; cat /etc/passwd|grep root
root:x:0:0:root:<mark>/root</mark>:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
[root@localhost ~]&#35; 
</pre>

<h1 id="考点5-grep命令"><a href="#考点5-grep命令" class="headerlink" title="考点5:grep命令"></a>考点5:grep命令</h1><p>在Linux系统中, 为找到文件try_grep含有以a字母为行开头的内容, 可以使用命令？</p>
<ul>
<li>A grep -E #$ try_grep</li>
<li>B grep -E #a try_grep</li>
<li>C grep -E ^$ try_grep</li>
<li>D grep -E ^a try_grep</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details>

<h3 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h3><p><code>-E</code>参数：表示使用扩展的正则表达式</p>
<p><code>^</code>：开始行<br><code>$</code>: 结束行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep  -E  ^a  try_grep #匹配以a开头的行</span><br><span class="line">grep  -E  a$  try_grep #匹配以a结束的行</span><br></pre></td></tr></table></figure>

<h1 id="考点6-tar解压参数"><a href="#考点6-tar解压参数" class="headerlink" title="考点6:tar解压参数"></a>考点6:tar解压参数</h1><p>tar命令用于解压的参数是？</p>
<ul>
<li>A -v</li>
<li>B -x</li>
<li>C -c</li>
<li>D -f</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="tar参数"><a href="#tar参数" class="headerlink" title="tar参数"></a>tar参数</h3><p>主要参数：</p>
<ul>
<li>c：创建新的档案文件。如果用户想备份一个目录或是一些文件，就要选择这个选项。相当于<strong>打包</strong>。 </li>
<li>x：从档案文件中释放文件。相当于<strong>拆包</strong>。</li>
</ul>
<p>辅助参数：</p>
<ul>
<li>z：是否同时具有 gzip 的属性？亦即是否需要用gzip 压缩或解压？ 一般格式为xx.tar.gz或xx. tgz </li>
<li>j：是否同时具有 bzip2 的属性？亦即是否需要用bzip2 压缩或解压？一般格式为xx.tar.bz2   </li>
<li>v：压缩的过程中显示文件！这个常用 </li>
<li>f：使用档名，请留意，在 f 之后要立即接档名喔！不要再加其他参数！ </li>
<li>p：使用原文件的原来属性（属性不会依据使用者而变） </li>
<li>–exclude FILE：在压缩的过程中，不要将 FILE 打包！</li>
</ul>
<h1 id="考点7-软链接硬链接"><a href="#考点7-软链接硬链接" class="headerlink" title="考点7:软链接硬链接"></a>考点7:软链接硬链接</h1><p>Linux中包括两种链接:硬链接(Hard Link)和软链接(Soft Link),下列说法正确的是()</p>
<ul>
<li>A 软链接可以跨文件系统进行连接,硬链接不可以</li>
<li>B 当删除原文件的时候软链接文件仍然存在,且指向的内容不变</li>
<li>C 硬链接被删除,磁盘上的数据文件会同时被删除</li>
<li>D 硬链接会重新建立一个<code>inode</code>,软链接不会</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<h3 id="什么是链接"><a href="#什么是链接" class="headerlink" title="什么是链接"></a>什么是链接</h3><p>链接操作实际上是给系统中已有的某个文件指定另外一个可用于访问它的名称。对于这个新的文件名，我们可以为之指定不同的</p>
<h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>硬链接只能引用同一文件系统中的文件。<br>它引用的是文件在文件系统中的物理索引(也称为 inode)。<br>当您移动或删除原始文件时，硬链接不会被破坏，因为它所引用的是文件的物理数据而不是文件在文件结构中的位置。<br>硬链接的文件不需要用户有访问原始文件的权限，也不会显示原始文件的位置，这样有助于文件的安全。<br>如果您删除的文件有相应的硬链接，那么这个文件依然会保留，直到所有对它的引用都被删除。</p>
<h3 id="软链接（符号链接）"><a href="#软链接（符号链接）" class="headerlink" title="软链接（符号链接）"></a>软链接（符号链接）</h3><p>软链接，其实就是新建立一个文件，这个文件就是专门用来指向别的文件的（那就和windows 下的快捷方式的那个文件有很接近的意味）。<br>软链接产生的是一个新的文件，但这个文件的作用就是专门指向某个文件的，删了这个软链接文件，那就等于不需要这个连接，和原来的存在的实体原文件没有任何关系，<br>但删除原来的文件，则相应的软链接不可用（cat那个软链接文件，则提示“没有该文件或目录“）。</p>
<h3 id="硬链接与软链接的区别"><a href="#硬链接与软链接的区别" class="headerlink" title="硬链接与软链接的区别"></a>硬链接与软链接的区别</h3><h4 id="硬链接不会创建inode-不可跨越文件系统"><a href="#硬链接不会创建inode-不可跨越文件系统" class="headerlink" title="硬链接不会创建inode 不可跨越文件系统"></a>硬链接不会创建inode 不可跨越文件系统</h4><p>硬链接是不会建立inode的，他只是在文件原来的inode link count域再增加1而已，也因此硬链接是不可以跨越文件系统的。</p>
<h4 id="软链接会重新创建inode"><a href="#软链接会重新创建inode" class="headerlink" title="软链接会重新创建inode"></a>软链接会重新创建inode</h4><p>相反都是软链接会重新建立一个inode，当然inode的结构跟其他的不一样，他只是一个指明源文件的字符串信息。一旦删除源文件，那么软链接将变得毫无意义。</p>
<h4 id="删除硬链接的时候-文件可能不会被删除"><a href="#删除硬链接的时候-文件可能不会被删除" class="headerlink" title="删除硬链接的时候 文件可能不会被删除"></a>删除硬链接的时候 文件可能不会被删除</h4><p>而硬链接删除的时候，系统调用会检查inode link count的数值，如果他大于等于1，那么inode不会被回收。因此文件的内容不会被删除。</p>
<h4 id="硬链接的链接文件和源文件是同一个文件"><a href="#硬链接的链接文件和源文件是同一个文件" class="headerlink" title="硬链接的链接文件和源文件是同一个文件"></a>硬链接的链接文件和源文件是同一个文件</h4><p>硬链接实际上是为文件建一个别名，链接文件和原文件实际上是同一个文件。</p>
<p>可以通过ls -i来查看一下，这两个文件的inode号是同一个，说明它们是同一个文件；</p>
<p>而软链接建立的是一个指向，即链接文件内的内容是指向原文件的指针，它们是两个文件。</p>
<h4 id="软链接可以跨文件系统"><a href="#软链接可以跨文件系统" class="headerlink" title="软链接可以跨文件系统"></a>软链接可以跨文件系统</h4><p>软链接可以跨文件系统，硬链接不可以；</p>
<h4 id="硬链接的文件必须存在-软链接可以对不存在的文件进行链接"><a href="#硬链接的文件必须存在-软链接可以对不存在的文件进行链接" class="headerlink" title="硬链接的文件必须存在 软链接可以对不存在的文件进行链接"></a>硬链接的文件必须存在 软链接可以对不存在的文件进行链接</h4><p>软链接可以对一个不存在的文件名(filename)进行链接（当然此时如果你vi这个软链接文件，linux会自动新建一个文件名为filename的文件）,<br>硬链接不可以（其文件必须存在，inode必须存在）；</p>
<h4 id="软链接可以对目录进行链接-硬链接不可以"><a href="#软链接可以对目录进行链接-硬链接不可以" class="headerlink" title="软链接可以对目录进行链接 硬链接不可以"></a>软链接可以对目录进行链接 硬链接不可以</h4><p>软链接可以对目录进行连接，硬链接不可以。</p>
<h3 id="如何创建链接"><a href="#如何创建链接" class="headerlink" title="如何创建链接"></a>如何创建链接</h3><p>两种链接都可以通过命令ln 来创建。</p>
<h4 id="创建硬链接ln"><a href="#创建硬链接ln" class="headerlink" title="创建硬链接ln"></a>创建硬链接ln</h4><p><code>ln</code>默认创建的是硬链接。</p>
<h4 id="创建软链接ls-s"><a href="#创建软链接ls-s" class="headerlink" title="创建软链接ls -s"></a>创建软链接ls -s</h4><p>使用<code>ln -s</code>可以创建软链接。</p>
<h1 id="考点8-环境变量"><a href="#考点8-环境变量" class="headerlink" title="考点8:环境变量"></a>考点8:环境变量</h1><p>在RHEL5系统中,下面关于shell环境变量配置文件的描述,正确的是(  )</p>
<ul>
<li>A 用户登录系统时,<code>bash</code>首先执行<code>/etc/profile</code>配置文件和<code>/etc/profile.d/</code>目录下的配置文件,这些配置文件对所有用户都有效</li>
<li>B 用户登录系统时,<code>bash</code>首先执行<code>.bash_profile</code>文件和<code>.bashrc</code>文件,这些配置文件对所有用户都有效</li>
<li>C 用户主目录下的.<code>bashrc</code>设置为每次登录时执行,而<code>.bash_profile</code>则为每次打开新的终端时执行</li>
<li>D 执行用户主目录下的环境变量配置文件时,不可以重复设置用户登录时配置文件中已经设置的选项</li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p><a href="https://www.jianshu.com/p/6d32b166f47d">https://www.jianshu.com/p/6d32b166f47d</a></p>
<h3 id="x2F-ect-x2F-profile"><a href="#x2F-ect-x2F-profile" class="headerlink" title="&#x2F;ect&#x2F;profile"></a>&#x2F;ect&#x2F;profile</h3><p>此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从<code>/etc/profile.d</code>目录的配置文件中搜集shell的设置.</p>
<h3 id="x2F-etc-x2F-bashrc"><a href="#x2F-etc-x2F-bashrc" class="headerlink" title="&#x2F;etc&#x2F;bashrc"></a>&#x2F;etc&#x2F;bashrc</h3><p>为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.</p>
<h3 id="x2F-bash-profile"><a href="#x2F-bash-profile" class="headerlink" title="~&#x2F;.bash_profile"></a>~&#x2F;.bash_profile</h3><p>每个用户都可使用该文件输入<br>专用于 自己使用的shell信息,<strong>当用户登录时,该文件仅仅执行一次</strong>!默认情况下,他设置一些环境变量,执行~&#x2F;.bashrc文件.</p>
<h3 id="x2F-bashrc"><a href="#x2F-bashrc" class="headerlink" title="~&#x2F;.bashrc"></a>~&#x2F;.bashrc</h3><p>该文件包含专用于用户的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取.</p>
<h3 id="x2F-bash-logout"><a href="#x2F-bash-logout" class="headerlink" title="~&#x2F;.bash_logout"></a>~&#x2F;.bash_logout</h3><blockquote>
<p><a href="https://blog.csdn.net/wackycrazy/article/details/47998747">https://blog.csdn.net/wackycrazy/article/details/47998747</a><br>&#x2F;etc&#x2F;profile 文件中设定的环境变量，运行的命令或脚本，针对所有用户有效<br>&#x2F;etc&#x2F;bashrc 文件中设定的本地变量，定义的别名，针对所有启动的shell程序的用户有效<br>这两个配置文件是全局的。<br>~&#x2F;.bash_profile 作用跟&#x2F;etc&#x2F;profile是一样的，只不过针对的是某一个用户<br>~&#x2F;.bashrc的作用跟&#x2F;etc&#x2F;bashrc也是一样的，只不过针对的也是某一个用户</p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/ithomer/article/details/6322892">https://blog.csdn.net/ithomer/article/details/6322892</a><br>（1） &#x2F;etc&#x2F;profile： 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行. 并从&#x2F;etc&#x2F;profile.d目录的配置文件中搜集shell的设置。<br>（2） &#x2F;etc&#x2F;bashrc: 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取（即每次新开一个终端，都会执行bashrc）。<br>（3） <del>&#x2F;.bash_profile: 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次。默认情况下,设置一些环境变量,执行用户的.bashrc文件。<br>（4） ~&#x2F;.bashrc: 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。<br>（5） ~&#x2F;.bash_logout: 当每次退出系统(退出bash shell)时,执行该文件. 另外,&#x2F;etc&#x2F;profile中设定的变量(全局)的可以作用于任何用户,而</del>&#x2F;.bashrc等中设定的变量(局部)只能继承 &#x2F;etc&#x2F;profile中的变量,他们是”父子”关系。<br>（6） <del>&#x2F;.bash_profile: 是交互式、login 方式进入 bash 运行的</del>&#x2F;.bashrc 是交互式 non-login 方式进入 bash 运行的通常二者设置大致相同，所以通常前者会调用后者。</p>
</blockquote>
<blockquote>
<p><a href="https://www.linuxprobe.com/diff-bashrcprofile.html">https://www.linuxprobe.com/diff-bashrcprofile.html</a><br>profile<br>其实看名字就能了解大概了, profile 是某个用户唯一的用来设置环境变量的地方, 因为用户可以有多个 shell 比如 bash, sh, zsh 之类的, 但像环境变量这种其实只需要在统一的一个地方初始化就可以了, 而这就是 profile.<br>bashrc<br>bashrc 也是看名字就知道, 是专门用来给 bash 做初始化的比如用来初始化 bash 的设置, bash 的代码补全, bash 的别名, bash 的颜色. 以此类推也就还会有 shrc, zshrc 这样的文件存在了, 只是 bash 太常用了而已.<br>期望的执行顺序</p>
</blockquote>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/25944849">https://zhuanlan.zhihu.com/p/25944849</a><br><del>&#x2F;.bashrc<br>该文件存储的是专属于个人bash shell的信息，当登录时以及每次打开一个新的shell时,执行这个文件。在这个文件里可以自定义用户专属的个人信息。<br>相关文件的读取顺序<br>在刚登录Linux时，首先启动 &#x2F;etc&#x2F;profile 文件，然后再启动用户目录下的 ~&#x2F;.bash_profile、 ~&#x2F;.bash_login或 ~&#x2F;.profile文件中的其中一个，执行的顺序为：</del>&#x2F;.bash_profile、 ~&#x2F;.bash_login、 ~&#x2F;.profile。如果 ~&#x2F;.bash_profile文件存在的话，一般还会执行 ~&#x2F;.bashrc文件。</p>
</blockquote>
<blockquote>
<p><a href="http://blog.itpub.net/27040306/viewspace-732343/">http://blog.itpub.net/27040306/viewspace-732343/</a><br>&#x2F;etc&#x2F;profile、&#x2F;etc&#x2F;bashrc、<del>&#x2F;.bash_profile、</del>&#x2F;.bashrc很容易混淆，他们之间有什么区别？它们的作用到底是什么？<br>&#x2F;etc&#x2F;profile: 用来设置系统环境参数，比如$PATH. 这里面的环境变量是对系统内所有用户生效的。<br>&#x2F;etc&#x2F;bashrc:  这个文件设置系统bash shell相关的东西，对系统内所有用户生效。只要用户运行bash命令，那么这里面的东西就在起作用。<br><del>&#x2F;.bash_profile: 用来设置一些环境变量，功能和&#x2F;etc&#x2F;profile 类似，但是这个是针对用户来设定的，也就是说，你在&#x2F;home&#x2F;user1&#x2F;.bash_profile 中设定了环境变量，那么这个环境变量只针对 user1 这个用户生效.<br>~&#x2F;.bashrc: 作用类似于&#x2F;etc&#x2F;bashrc, 只是针对用户自己而言，不对其他用户生效。<br>另外&#x2F;etc&#x2F;profile中设定的变量(全局)的可以作用于任何用户,而</del>&#x2F;.bashrc等中设定的变量(局部)只能继承&#x2F;etc&#x2F;profile中的变量,他们是”父子”关系.<br>~&#x2F;.bash_profile 是交互式、login 方式进入 bash 运行的，意思是只有用户登录时才会生效。<br>~&#x2F;.bashrc 是交互式 non-login 方式进入 bash 运行的，用户不一定登录，只要以该用户身份运行命令行就会读取该文件。</p>
</blockquote>
<p><a href="https://cloud.tencent.com/developer/article/1148535">https://cloud.tencent.com/developer/article/1148535</a></p>
<blockquote>
<p>&#x2F;etc&#x2F;profile<br>为系统的每个用户设置环境信息和启动程序，当用户第一次登录时，该文件被执行，其配置对所有登录的用户都有效。当被修改时，必须重启才会生效。英文描述：”System wide environment and startup programs, for login setup.”<br>&#x2F;etc&#x2F;environment<br>系统的环境变量，&#x2F;etc&#x2F;profile是所有用户的环境变量，前者与登录用户无关，后者与登录用户有关，当同一变量在两个文件里有冲突时，以用户环境为准。<br>&#x2F;etc&#x2F;bashrc<br>为每个运行 bash shell 的用户执行该文件，当 bash shell 打开时，该文件被执行，其配置对所有使用bash的用户打开的每个bash都有效。当被修改后，不用重启只需要打开一个新的 bash 即可生效。英文描述：”System wide functions and aliases.”<br><del>&#x2F;.bash_profile<br>为当前用户设置专属的环境信息和启动程序，当用户登录时该文件执行一次。默认情况下，它用于设置环境变量，并执行当前用户的 .bashrc 文件。理念类似于 &#x2F;etc&#x2F;profile，只不过只对当前用户有效，也需要重启才能生效。(注意：Centos7系统命名为.bash_profile，其他系统可能是.bash_login或.profile。)<br>~&#x2F;.bashrc<br>为当前用户设置专属的 bash 信息，当每次打开新的shell时，该文件被执行。理念类似于&#x2F;etc&#x2F;bashrc，只不过只对当前用户有效，不需要重启只需要打开新的shell即可生效。<br>~&#x2F;.bash_logout<br>为当前用户，每次退出bash shell时执行该文件，可以把一些清理工作的命令放进这个文件。<br>&#x2F;etc&#x2F;profile.d&#x2F;<br>此文件夹里是除&#x2F;etc&#x2F;profile之外其他的”application-specific startup files”。英文描述为”The &#x2F;etc&#x2F;profile file sets the environment variables at startup of the Bash shell. The &#x2F;etc&#x2F;profile.d directory contains other scripts that contain application-specific startup files, which are also executed at startup time by the shell.” 同时，这些文件”are loaded via &#x2F;etc&#x2F;profile which makes them a part of the bash “profile” in the same way anyway.” 因此可以简单的理解为是&#x2F;etc&#x2F;profile的一部分，只不过按类别或功能拆分成若干个文件进行配置了（方便维护和理解）。<br>注意事项<br>以上需要重启才能生效的文件，其实可以通过source xxx暂时生效。<br> 文件的执行顺序为：当登录Linux时，首先启动&#x2F;etc&#x2F;environment和&#x2F;etc&#x2F;profile，然后启动当前用户目录下的&#x2F;.bash_profile，执行此文件时一般会调用&#x2F;.bashrc文件，而执行&#x2F;.bashrc时一般会调用&#x2F;etc&#x2F;bashrc，最后退出shell时，执行&#x2F;.bash_logout。简单来说顺序为：<br>  （登录时）&#x2F;etc&#x2F;environment –&gt; &#x2F;etc&#x2F;profile(以及&#x2F;etc&#x2F;profile.d&#x2F;里的文件) –&gt; ~&#x2F;.bash_profile –&gt; （打开shell时）</del>&#x2F;.bashrc –&gt; &#x2F;etc&#x2F;bashrc –&gt; （退出shell时）~&#x2F;.bash_logout</p>
</blockquote>
<h1 id="考点9-shell脚本参数"><a href="#考点9-shell脚本参数" class="headerlink" title="考点9:shell脚本参数"></a>考点9:shell脚本参数</h1><p>如果参数列表个数为1则执行<code>$&lt;1</code> , 如果参数列表个数为2则执行<code>$&lt;2&lt;$</code> ,其他情况则……,补充下面的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Case (  ) in</span><br><span class="line"><span class="meta prompt_">1&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">   $&lt;1</span></span><br><span class="line"><span class="meta prompt_">2&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">   $&lt;2&lt;<span class="variable">$1</span></span></span><br><span class="line">Default &gt; </span><br><span class="line">   echo ……</span><br></pre></td></tr></table></figure>
<ul>
<li>A $$</li>
<li>B $#</li>
<li>C $@</li>
<li>D $*</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>
 
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>$#</code></td>
<td align="left">是传给脚本的参数个数</td>
</tr>
<tr>
<td align="left"><code>$0</code></td>
<td align="left">是脚本本身的名字</td>
</tr>
<tr>
<td align="left"><code>$1</code></td>
<td align="left">是传递给该shell脚本的第一个参数</td>
</tr>
<tr>
<td align="left"><code>$2</code></td>
<td align="left">是传递给该shell脚本的第二个参数</td>
</tr>
<tr>
<td align="left"><code>$@</code></td>
<td align="left">是传给脚本的所有参数的列表</td>
</tr>
<tr>
<td align="left"><code>$*</code></td>
<td align="left">是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个</td>
</tr>
<tr>
<td align="left"><code>$$</code></td>
<td align="left">是脚本运行的当前进程ID号</td>
</tr>
<tr>
<td align="left"><code>$?</code></td>
<td align="left">是显示最后命令的退出状态，0表示没有错误，其他表示有错误</td>
</tr>
</tbody></table>
<h1 id="考点10-进程间通讯方式"><a href="#考点10-进程间通讯方式" class="headerlink" title="考点10:进程间通讯方式"></a>考点10:进程间通讯方式</h1><p>进程间通讯方式有哪些？</p>
<ul>
<li>A 管道</li>
<li>B 消息队列</li>
<li>C 共享内存</li>
<li>D 文件和记录锁定</li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details>

<h3 id="UNIX的通信方式"><a href="#UNIX的通信方式" class="headerlink" title="UNIX的通信方式"></a>UNIX的通信方式</h3><h4 id="1-文件和记录锁定"><a href="#1-文件和记录锁定" class="headerlink" title="1 文件和记录锁定"></a>1 文件和记录锁定</h4><p>为避免两个进程间同时要求访问同一共享资源而引起访问和操作的混乱，在进程对共享资源进行访问前必须对其进行锁定，该进程访问完后再释放。这是UNIX为共享资源提供的互斥性保障。</p>
<h4 id="2-管道"><a href="#2-管道" class="headerlink" title="2 管道"></a>2 管道</h4><p>管道一般用于两个不同进程之间的通信。当一个进程创建一个管道，并调用fork创建自己的一个子进程后，父进程关闭读管道端，子进程关闭写管道端，这样 提供了两个进程之间数据流动的一种方式。</p>
<h4 id="3-FIFO"><a href="#3-FIFO" class="headerlink" title="3 FIFO"></a>3 FIFO</h4><p>FIFO是一种先进先出的队列。它类似于一个管道，只允许数据的单向流动。每个FIFO都有一个名字，允许不相关的进程访问同一个FIFO。因此也成为命名管。</p>
<h4 id="4-消息队列"><a href="#4-消息队列" class="headerlink" title="4 消息队列"></a>4 消息队列</h4><p>UNIX下不同进程之间可实现共享资源的一种机制；UNIX允许不同进程将格式化的数据流以消息形式发送给任意进程。对消息队列具有操作权限的进程都可以使用msget完成对消息队列的操作控制。通过使用消息类型，进程可以按任何顺序读消息，或为消息安排优先级顺序。</p>
<h4 id="5-信号灯"><a href="#5-信号灯" class="headerlink" title="5 信号灯"></a>5 信号灯</h4><p>作为进程间通讯的一种方法，它不是用于交换大批数据，而用于多进程之间的同步（协调对共享存储段的存取）。</p>
<h4 id="6-共享内存"><a href="#6-共享内存" class="headerlink" title="6 共享内存"></a>6 共享内存</h4><p>通过信号灯实现存储共享（类似“红灯停、绿灯行”）</p>
]]></content>
      <categories>
        <category>牛客网</category>
        <category>专项练习</category>
        <category>Linux</category>
        <category>2021年03月</category>
      </categories>
  </entry>
</search>
