<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/exam/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/exam/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/exam/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/exam/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_Sly-yzHYmALHXzjFpPWsodMrjBSphw7bfRbMUH80Qc">
  <meta name="msvalidate.01" content="B1CFD346B8DEBBFE0C983C2AF8955531">
  <meta name="baidu-site-verification" content="vkMTwK56xr">

<link rel="stylesheet" href="/exam/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lanlan2017.github.io","root":"/exam/","images":"/exam/images","scheme":"Gemini","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/exam/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/exam/js/config.js"></script>
<meta name="description" content="考点1:子类能访问父类的那些成员C#、JAVA)扩展方法能访问被扩展对象的public成员  A 能 B 不能  解析显示答案&#x2F;隐藏答案正确答案: A  翻译一下，子类方法是否能够访问父类中的public成员。 考点2:构造方法以下有关构造方法的说法,正确的是:()  A 一个类的构造方法可以有多个 B 构造方法在类定义时被调用 C 构造方法只能由对象中的其他方法调用 D 构造方法可以和类同名,也">
<meta property="og:type" content="article">
<meta property="og:title" content="2021年09月05日 java1">
<meta property="og:url" content="https://lanlan2017.github.io/exam/a1973542/index.html">
<meta property="og:site_name" content="蓝蓝站点">
<meta property="og:description" content="考点1:子类能访问父类的那些成员C#、JAVA)扩展方法能访问被扩展对象的public成员  A 能 B 不能  解析显示答案&#x2F;隐藏答案正确答案: A  翻译一下，子类方法是否能够访问父类中的public成员。 考点2:构造方法以下有关构造方法的说法,正确的是:()  A 一个类的构造方法可以有多个 B 构造方法在类定义时被调用 C 构造方法只能由对象中的其他方法调用 D 构造方法可以和类同名,也">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20191224/337184788_1577191659133_DB86032511CDC329D42FB2BB8831615C">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20190603/652334996_1559537222061_12B6233B6EA3C9956865918F5E9B7240">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20190603/652334996_1559537178275_256EC3581646F19915DBB5C9F4D80330">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20200805/643412545_1596634989327_DEF638F8839D3C558612E08DC0A11BFF">
<meta property="article:published_time" content="2021-09-05T02:11:35.000Z">
<meta property="article:modified_time" content="2021-12-31T07:27:40.000Z">
<meta property="article:author" content="蓝蓝">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://uploadfiles.nowcoder.com/images/20191224/337184788_1577191659133_DB86032511CDC329D42FB2BB8831615C">


<link rel="canonical" href="https://lanlan2017.github.io/exam/a1973542/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://lanlan2017.github.io/exam/a1973542/","path":"/a1973542/","title":"2021年09月05日 java1"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>2021年09月05日 java1 | 蓝蓝站点</title>
  

  <script src="/exam/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?dadeb188eb14ccde0b25a19230c429b5"></script>


<link rel="dns-prefetch" href="https://waline-test-mzjszagu6-lanlan2017.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/exam/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/exam/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">蓝蓝站点</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">笔试题汇总</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/exam/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-dir"><a href="/exam/dir/" rel="section"><i class="fa fa-sitemap fa-fw"></i>目录</a></li>
        <li class="menu-item menu-item-categories"><a href="/exam/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/exam/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-tags"><a href="/exam/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%80%83%E7%82%B91-%E5%AD%90%E7%B1%BB%E8%83%BD%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%9A%84%E9%82%A3%E4%BA%9B%E6%88%90%E5%91%98"><span class="nav-number">1.</span> <span class="nav-text">考点1:子类能访问父类的那些成员</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90"><span class="nav-number">1.1.</span> <span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%80%83%E7%82%B92-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">考点2:构造方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-1"><span class="nav-number">2.1.</span> <span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%80%83%E7%82%B93-%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E4%BD%93run-%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8Bstart"><span class="nav-number">3.</span> <span class="nav-text">考点3:线程执行体run() 启动线程start()</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-2"><span class="nav-number">3.1.</span> <span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%80%83%E7%82%B94-%E9%87%8D%E8%BD%BD"><span class="nav-number">4.</span> <span class="nav-text">考点4:重载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-3"><span class="nav-number">4.1.</span> <span class="nav-text">解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E9%87%8D%E5%86%99%E7%88%B6%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">4.1.1.</span> <span class="nav-text">子类的实例方法不能重写父类的静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%88%B6%E7%B1%BB%E5%90%8C%E5%90%8D%E7%9A%84Static%E6%96%B9%E6%B3%95"><span class="nav-number">4.1.2.</span> <span class="nav-text">可以定义与父类同名的Static方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E6%8F%8F%E8%BF%B0%E7%9A%84%E6%98%AF%E5%AD%90%E7%B1%BB%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%92%8C%E7%88%B6%E7%B1%BB%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">4.1.3.</span> <span class="nav-text">重写描述的是子类实例方法和父类实例方法的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E2%80%9D%E5%A4%9A%E6%80%81%E2%80%9D"><span class="nav-number">4.1.4.</span> <span class="nav-text">static方法如何实现”多态”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF-%E5%8F%AF%E4%BB%A5%E8%A2%AB%E8%A6%86%E7%9B%96-%E4%B8%8D%E8%83%BD%E8%A2%AB%E9%87%8D%E5%86%99"><span class="nav-number">4.1.5.</span> <span class="nav-text">static方法可以被继承 可以被覆盖 不能被重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE-static%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99%E5%90%97%EF%BC%9F"><span class="nav-number">4.1.6.</span> <span class="nav-text">问 static方法可以被重写吗？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%80%83%E7%82%B95-%E4%B8%8D%E6%87%82%E7%9A%84%E7%82%B9%EF%BC%9AJVM"><span class="nav-number">5.</span> <span class="nav-text">考点5:不懂的点：JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-4"><span class="nav-number">5.1.</span> <span class="nav-text">解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98"><span class="nav-number">5.1.1.</span> <span class="nav-text">堆外内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">堆外内存的特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">5.1.2.</span> <span class="nav-text">1）程序计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E5%A0%86"><span class="nav-number">5.1.3.</span> <span class="nav-text">2）堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E6%A0%88"><span class="nav-number">5.1.4.</span> <span class="nav-text">3）栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-number">5.1.5.</span> <span class="nav-text">4）本地方法栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%EF%BC%89%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">5.1.6.</span> <span class="nav-text">5）方法区</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%80%83%E7%82%B96-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">6.</span> <span class="nav-text">考点6:异常处理机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-5"><span class="nav-number">6.1.</span> <span class="nav-text">解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#finally%E4%B8%8D%E6%89%A7%E8%A1%8C%E6%83%85%E5%86%B5"><span class="nav-number">6.1.1.</span> <span class="nav-text">finally不执行情况</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%80%83%E7%82%B97-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">7.</span> <span class="nav-text">考点7:面向对象三大特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-6"><span class="nav-number">7.1.</span> <span class="nav-text">解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1OOP%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="nav-number">7.1.1.</span> <span class="nav-text">面向对象OOP三大特性：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%80%83%E7%82%B98-IO%E6%B5%81-%E5%AD%97%E7%AC%A6%E6%B5%81%E5%AD%97%E8%8A%82%E6%B5%81"><span class="nav-number">8.</span> <span class="nav-text">考点8:IO流 字符流字节流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-7"><span class="nav-number">8.1.</span> <span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%80%83%E7%82%B99-%E5%A0%86%E5%AD%98%E6%94%BE%E5%AF%B9%E8%B1%A1-%E6%A0%88%E5%AD%98%E6%94%BE%E7%A8%8B%E5%BA%8F"><span class="nav-number">9.</span> <span class="nav-text">考点9:堆存放对象 栈存放程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-8"><span class="nav-number">9.1.</span> <span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%80%83%E7%82%B910-%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">10.</span> <span class="nav-text">考点10:身份证号的正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-9"><span class="nav-number">10.1.</span> <span class="nav-text">解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%9E%84%E6%88%90"><span class="nav-number">10.1.1.</span> <span class="nav-text">身份证构成</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="蓝蓝"
      src="/exam/images/avatar.png">
  <p class="site-author-name" itemprop="name">蓝蓝</p>
  <div class="site-description" itemprop="description">汇总一些做过的笔试题</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/exam/archives/">
          <span class="site-state-item-count">148</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/exam/categories/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/todo/" title="todo → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;todo&#x2F;"><i class="fa fa-check-square fa-fw"></i>todo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/links/" title="links → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;links&#x2F;"><i class="fa fa-link fa-fw"></i>links</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/exam/a1973542/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/exam/images/avatar.png">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="汇总一些做过的笔试题">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          2021年09月05日 java1
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-05 10:11:35" itemprop="dateCreated datePublished" datetime="2021-09-05T10:11:35+08:00">2021-09-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-31 15:27:40" itemprop="dateModified" datetime="2021-12-31T15:27:40+08:00">2021-12-31</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">牛客网</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">专项练习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/exam/categories/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/Java/2021%E5%B9%B409%E6%9C%88/" itemprop="url" rel="index"><span itemprop="name">2021年09月</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/exam/a1973542/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/exam/a1973542/" data-xid="/exam/a1973542/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="考点1-子类能访问父类的那些成员"><a href="#考点1-子类能访问父类的那些成员" class="headerlink" title="考点1:子类能访问父类的那些成员"></a>考点1:子类能访问父类的那些成员</h1><p>C#、JAVA)扩展方法能访问被扩展对象的public成员</p>
<ul>
<li>A 能</li>
<li>B 不能</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p><strong>翻译一下，子类方法是否能够访问父类中的public成员。</strong></p>
<h1 id="考点2-构造方法"><a href="#考点2-构造方法" class="headerlink" title="考点2:构造方法"></a>考点2:构造方法</h1><p>以下有关构造方法的说法,正确的是:()</p>
<ul>
<li>A 一个类的构造方法可以有多个</li>
<li>B 构造方法在类定义时被调用</li>
<li>C 构造方法只能由对象中的其他方法调用</li>
<li>D 构造方法可以和类同名,也可以和类名不同</li>
</ul>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>

<p>A 一个类有多个构造方法便是重载的表现。<strong>重载参数列表不同</strong>。所以A是正确的。<br>B 构造方法是在对象<strong>创建时</strong>就被调用，用于初始化。<br>C 构造方法是给与之对应的对象进行初始化，初始化的动作只执行一次。<br>D 构造方法必须与所在类的名称同名。</p>
<p>B、构造器在对象被实例化的时候调用<br>C、构造方法不能由对象中的其他方法调用。都是new出来或者利用了反射。<br>D、构造方法必须与类同名，且没有返回值（不同于void）。</p>
<h1 id="考点3-线程执行体run-启动线程start"><a href="#考点3-线程执行体run-启动线程start" class="headerlink" title="考点3:线程执行体run() 启动线程start()"></a>考点3:线程执行体run() 启动线程start()</h1><p>以下哪个方法用于定义线程的执行体？</p>
<ul>
<li>A <code>start()</code></li>
<li>B <code>init()</code></li>
<li>C <code>run()</code></li>
<li>D <code>synchronized()</code></li>
</ul>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>run()用于定义线程执行体，<br>start()用于启动线程</p>
<h1 id="考点4-重载"><a href="#考点4-重载" class="headerlink" title="考点4:重载"></a>考点4:重载</h1><p>对于同一类中的两个方法 , 在判断它们是不是重载方法时 , 肯定不考虑( )</p>
<ul>
<li>A 参数个数</li>
<li>B 参数类型</li>
<li>C 返回值类型</li>
<li>D 参数顺序</li>
</ul>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>

<p>方法重写的注意事项：<br>构造方法不能被重写，不要问为什么？因为构造方法名必须和类名相同<br>private修饰的成员方法不能被重写<br><strong>static修饰的方法不能被重写</strong><br><strong>final修饰的方法不能被重写</strong><br>当子类重写了父类中的方法后，子类对象调用该方法时调用的是子类重写后的方法</p>
<h3 id="子类的实例方法不能重写父类的静态方法"><a href="#子类的实例方法不能重写父类的静态方法" class="headerlink" title="子类的实例方法不能重写父类的静态方法"></a>子类的实例方法不能重写父类的静态方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extendstest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 父类中的static方法</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Static method in parent class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 父类中的非static方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Non static method in parent class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 父类中的final方法</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finalMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Final method in parent class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 子类可以重写父类的protected 非static方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.nonStaticMethod();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 子类无法重写父类的static方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Static method in parent class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finalMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Final method in son class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类的staticMethod方法报错如下:</p>
<pre>
Multiple markers at this line
    - <mark>This instance method cannot override the static method from Father</mark>
    - overrides extendstest.Father.canYouSeeStatic
    - The method canYouSeeStatic() of type Son must override or implement a supertype method
</pre>

<p><strong>意思是子类的实例方法不能重写父类的静态方法</strong></p>
<p>给子类中的staticMethod加上static修饰符：</p>
<pre>
    // 子类无法重写父类的static方法
    @Override
    public <mark>static</mark> void staticMethod() {
        System.out.println("Static method in parent class");
    }
</pre>

<p>还是不可以重写，报错如下：</p>
<pre>
The method staticMethod() of type Son must override or implement a supertype method
</pre>

<p>子类的finalMethod方法报错如下：</p>
<pre>
Multiple markers at this line
    - <mark>Cannot override the final method from Parent</mark>
    - overrides extendstest.Parent.finalMethod
</pre>

<h3 id="可以定义与父类同名的Static方法"><a href="#可以定义与父类同名的Static方法" class="headerlink" title="可以定义与父类同名的Static方法"></a>可以定义与父类同名的Static方法</h3><p>去掉子类的staticMethod()方法上面的<code>@Override</code>，则不会报错。<br>这不是重写，无法实现多态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extendstest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 父类中的static方法</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Static method in parent class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 父类中的非static方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Non static method in parent class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 父类中的final方法</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finalMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Final method in parent class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Parent parent = <span class="keyword">new</span> Son();</span><br><span class="line">		<span class="comment">// 调用的还是父类的静态方法，不能实现多态</span></span><br><span class="line">		parent.staticMethod();</span><br><span class="line">		<span class="comment">// 调用的是子类的方法，多态</span></span><br><span class="line">		parent.nonStaticMethod();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 子类可以重写父类的protected 非static方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Static method in Son class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 子类无法重写父类的static方法</span></span><br><span class="line">	<span class="comment">// @Override</span></span><br><span class="line">	<span class="comment">// 子类可以定义与父类相同的静态方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Static method in Son class&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Static method in parent class</span><br><span class="line">Static method in Son class</span><br></pre></td></tr></table></figure>
<h3 id="重写描述的是子类实例方法和父类实例方法的关系"><a href="#重写描述的是子类实例方法和父类实例方法的关系" class="headerlink" title="重写描述的是子类实例方法和父类实例方法的关系"></a>重写描述的是子类实例方法和父类实例方法的关系</h3><p>static定义的方法时类方法，通过类名调用。<br>上面的<code>parent.staticMethod();</code>调用实际上还是<code>类名.staticMethod();</code><br>也就是<code>Parent.staticMethod();</code>.所以不会去调用Son类中的同名方法。<br>如果非要调用子类的同名静态方法的话，需要改成:<code>Son.staticMethod()</code>。</p>
<h3 id="static方法如何实现”多态”"><a href="#static方法如何实现”多态”" class="headerlink" title="static方法如何实现”多态”"></a>static方法如何实现”多态”</h3><p>使用子类来调用覆盖的static方法，如果子类中有该静态方法，则执行子类的静态方法。<br>如果子类没有该静态方法，则去父类中查找静态方法，如果有则执行父类的静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extendstest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 父类中的static方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in parent class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类中的非static方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Non static method in parent class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类中的final方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finalMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Final method in parent class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        Parent parent = son;</span><br><span class="line">        <span class="comment">// 调用的还是父类的静态方法，不能实现多态</span></span><br><span class="line">        parent.staticMethod();</span><br><span class="line">        <span class="comment">// 调用的是子类的方法，多态</span></span><br><span class="line">        parent.nonStaticMethod();</span><br><span class="line">        <span class="comment">// 调用子类的静态方法，如果子类定义了该静态方法，</span></span><br><span class="line">        <span class="comment">// 则调用子类的，如果没有则去父类中查找</span></span><br><span class="line">        <span class="comment">// son.staticMethod();</span></span><br><span class="line">        Son.staticMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子类可以重写父类的protected 非static方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in Son class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类无法重写父类的static方法</span></span><br><span class="line">    <span class="comment">// @Override</span></span><br><span class="line">    <span class="comment">// 子类可以定义与父类相同的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in Son class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Static method in parent class</span><br><span class="line">Static method in Son class</span><br><span class="line">Static method in Son class</span><br></pre></td></tr></table></figure>
<p>此时Son类中重写了父类的静态方法，调用的是重写后的。<br>如果把Son类中的staticMethod方法注释掉。：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extendstest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 父类中的static方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in parent class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类中的非static方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Non static method in parent class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类中的final方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finalMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Final method in parent class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        Parent parent = son;</span><br><span class="line">        <span class="comment">// 调用的还是父类的静态方法，不能实现多态</span></span><br><span class="line">        parent.staticMethod();</span><br><span class="line">        <span class="comment">// 调用的是子类的方法，多态</span></span><br><span class="line">        parent.nonStaticMethod();</span><br><span class="line">        <span class="comment">// 调用子类的静态方法，如果子类定义了该静态方法，</span></span><br><span class="line">        <span class="comment">// 则调用子类的，如果没有则去父类中查找</span></span><br><span class="line">        <span class="comment">// son.staticMethod();</span></span><br><span class="line">        Son.staticMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子类可以重写父类的protected 非static方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in Son class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    // 子类无法重写父类的static方法</span></span><br><span class="line"><span class="comment">//    // @Override</span></span><br><span class="line"><span class="comment">//    // 子类可以定义与父类相同的静态方法</span></span><br><span class="line"><span class="comment">//    public static void staticMethod() &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;Static method in Son class&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Static method in parent class</span><br><span class="line">Static method in Son class</span><br><span class="line">Static method in parent class</span><br></pre></td></tr></table></figure>
<p>可以看到，此时调用了从父类继承得到的静态方法。</p>
<h3 id="static方法可以被继承-可以被覆盖-不能被重写"><a href="#static方法可以被继承-可以被覆盖-不能被重写" class="headerlink" title="static方法可以被继承 可以被覆盖 不能被重写"></a>static方法可以被继承 可以被覆盖 不能被重写</h3><p><strong>重写，说的是根据<code>运行时</code>的对象类型来决定调用哪个方法</strong>，而不是编译时类型。</p>
<p>因为无法使用<code>@Override</code>修饰，所以不是重写。</p>
<p>对于静态方法，我们不应该尝试去重写，而且调用时应该以类进行调用，而不是对象进行调用。</p>
<h3 id="问-static方法可以被重写吗？"><a href="#问-static方法可以被重写吗？" class="headerlink" title="问 static方法可以被重写吗？"></a>问 static方法可以被重写吗？</h3><p>答，static方法可以被子类继承，子类可以覆盖继承到的static方法。但是这不叫重写。<br>因为如果你在同名的static方法上写上@Override注解，编译器会报错。</p>
<p>重写是为了实现多态，多态是<strong>在运行的时候</strong>根据对象的类型来调用方法的。<br>如果使用了静态方法，那么在<strong>编译期间</strong>，就知道调用的是那个静态方法了，这不符合多态的定义。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/df43f5500ea3">https://www.jianshu.com/p/df43f5500ea3</a><br>静态方法从程序开始运行后就已经分配了内存，也就是说已经写死了。所有引用到该方法的对象（父类的对象也好子类的对象也好）所指向的都是同一块内存中的数据，也就是该静态方法。<strong>子类中如果定义了相同名称的静态方法，并不会重写，而应该是在内存中又分配了一块给子类的静态方法，没有重写这一说</strong>。</p>
</blockquote>
<h1 id="考点5-不懂的点：JVM"><a href="#考点5-不懂的点：JVM" class="headerlink" title="考点5:不懂的点：JVM"></a>考点5:不懂的点：JVM</h1><p>off-heap是指那种内存()</p>
<ul>
<li>A <code>JVM GC</code>能管理的内存</li>
<li>B <code>JVM</code>进程管理的内存</li>
<li>C 在<code>JVM</code>老年代内存区</li>
<li>D 在<code>JVM</code>新生代内存</li>
</ul>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>

<h3 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h3><p>off-heap叫做堆外内存，将你的对象从堆中脱离出来序列化，然后存储在一大块内存中，这就像它存储到磁盘上一样，但它仍然在RAM中。<br>对象在这种状态下不能直接使用，它们必须首先反序列化，也不受垃圾收集。<br>序列化和反序列化将会影响部分性能（所以可以考虑使用FST-serialization）使用堆外内存能够降低GC导致的暂停。<br>堆外内存不受垃圾收集器管理，也不属于老年代，新生代。</p>
<p><strong>堆外内存意味着把内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机）</strong>。<strong>不属于老年代和新生代。</strong></p>
<p><strong>JVM GC回收堆和方法区，排除法选择 B</strong></p>
<p>这样做的结果就是能保持一个较小的堆，以减少垃圾收集对应用的影响。</p>
<p>使用堆外内存能够降低GC导致的暂停。</p>
<p>堆外内存，它和内存池一样，也能缩短垃圾回收时间，但是它适用的对象和内存池完全相反。<br>内存池往往适用于生命期较短的可变对象，而生命期中等或较长的对象，正是堆外内存要解决的。</p>
<h4 id="堆外内存的特点"><a href="#堆外内存的特点" class="headerlink" title="堆外内存的特点"></a>堆外内存的特点</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/universe_ant/article/details/52145450">https://blog.csdn.net/universe_ant/article/details/52145450</a><br>堆外内存有以下特点：</p>
<ul>
<li>对于大内存有良好的伸缩性</li>
<li>对垃圾回收停顿的改善可以明显感觉到</li>
<li>在进程间可以共享，减少虚拟机间的复制</li>
</ul>
<p>当然堆外内存也有它自己的问题，</p>
<ul>
<li>最大的问题就是你的数据结构变得不那么直观，如果数据结构比较复杂，就要对它进行串行化（serialization），而串行化本身也会影响性能。</li>
<li>另一个问题是由于你可以使用更大的内存，你可能开始担心虚拟内存（即硬盘）的速度对你的影响了。</li>
</ul>
<h3 id="1）程序计数器"><a href="#1）程序计数器" class="headerlink" title="1）程序计数器"></a>1）程序计数器</h3><p>几乎不占有内存。用于取下一条执行的指令。</p>
<h3 id="2）堆"><a href="#2）堆" class="headerlink" title="2）堆"></a>2）堆</h3><p>所有通过new创建的对象的内存都在堆中分配，其大小可以通过-Xmx和-Xms来控制。<br>堆被划分为新生代和旧生代，<br>新生代又被进一步划分为Eden和Survivor区，最后Survivor由FromSpace和ToSpace组成，结构图如下所示：</p>
<p>新生代。新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中，新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例旧生代。用于存放新生代中经过多次垃圾回收仍然存活的对象。</p>
<img data-src="https://uploadfiles.nowcoder.com/images/20191224/337184788_1577191659133_DB86032511CDC329D42FB2BB8831615C">

<h3 id="3）栈"><a href="#3）栈" class="headerlink" title="3）栈"></a>3）栈</h3><p>每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果。</p>
<h3 id="4）本地方法栈"><a href="#4）本地方法栈" class="headerlink" title="4）本地方法栈"></a>4）本地方法栈</h3><p>用于支持native方法的执行，存储了每个native方法调用的状态</p>
<h3 id="5）方法区"><a href="#5）方法区" class="headerlink" title="5）方法区"></a>5）方法区</h3><p>存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。<br>JVM用永久代（PermanetGeneration）来存放方法区，（在JDK的HotSpot虚拟机中，可以认为方法区就是永久代，但是在其他类型的虚拟机中，没有永久代的概念，有关信息可以看周志明的书）可通过-XX:PermSize和-XX:MaxPermSize来指定最小值和最大值。</p>
<h1 id="考点6-异常处理机制"><a href="#考点6-异常处理机制" class="headerlink" title="考点6:异常处理机制"></a>考点6:异常处理机制</h1><p>java关于异常处理机制的叙述哪些正确</p>
<ul>
<li>A <code>catch</code>部分捕捉到异常情况时,才会执行<code>finally</code>部分</li>
<li>B 当<code>try</code>区段的程序发生异常时,才会执行<code>catch</code>区段的程序</li>
<li>C 在<code>try</code>区段不论程序是否发生异常及捕获到异常,都会执行<code>finally</code>部分</li>
<li>D 以上都是</li>
</ul>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<h3 id="finally不执行情况"><a href="#finally不执行情况" class="headerlink" title="finally不执行情况"></a>finally不执行情况</h3><p>try块执行时，finally表示总是执行。但是</p>
<ol>
<li>在try中调用System.exit(0)，强制退出了程序，finally块不执行。</li>
<li>在进入try块前，出现了异常，此时try没有执行，finally块不执行。</li>
</ol>
<h1 id="考点7-面向对象三大特性"><a href="#考点7-面向对象三大特性" class="headerlink" title="考点7:面向对象三大特性"></a>考点7:面向对象三大特性</h1><p>面向对象的程序设计语言具有()等共同特性。</p>
<ul>
<li>A 封装性</li>
<li>B 多态性</li>
<li>C 简单性</li>
<li>D 复杂性</li>
<li>E 继承性</li>
</ul>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABE</details>

<h3 id="面向对象OOP三大特性："><a href="#面向对象OOP三大特性：" class="headerlink" title="面向对象OOP三大特性："></a>面向对象OOP三大特性：</h3><ul>
<li>继承</li>
<li>封装</li>
<li>多态</li>
</ul>
<p>准确来说，基于对象和面向对象是有区别的。<br><strong>基于对象是封装和继承</strong>。<br><strong>面向对象是封装、继承和多态</strong>。<br>详见 <a href="https://blog.csdn.net/jiaruitao777/article/details/99098027" target="_blank">https://blog.csdn.net/jiaruitao777/article/details/99098027</a></p>
<h1 id="考点8-IO流-字符流字节流"><a href="#考点8-IO流-字符流字节流" class="headerlink" title="考点8:IO流 字符流字节流"></a>考点8:IO流 字符流字节流</h1><p>下面哪个流类不属于面向字符的流()</p>
<ul>
<li>A <code>BufferedWriter</code></li>
<li>B <code>FileInputStream</code></li>
<li>C <code>ObjectInputStream</code></li>
<li>D <code>InputStreamReader</code></li>
</ul>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>

<p>既然是字符流，那么一般是reader和writer结尾。<br>Stream结尾的是字节，Reader结尾的是字符</p>
<p>面向字符的输入流类都是Reader的子类，<img data-src="https://uploadfiles.nowcoder.com/images/20190603/652334996_1559537222061_12B6233B6EA3C9956865918F5E9B7240"></p>
<p>面向字符的输出流都是类 Writer 的子类<img data-src="https://uploadfiles.nowcoder.com/images/20190603/652334996_1559537178275_256EC3581646F19915DBB5C9F4D80330"></p>
<img data-src="https://uploadfiles.nowcoder.com/images/20200805/643412545_1596634989327_DEF638F8839D3C558612E08DC0A11BFF">



<h1 id="考点9-堆存放对象-栈存放程序"><a href="#考点9-堆存放对象-栈存放程序" class="headerlink" title="考点9:堆存放对象 栈存放程序"></a>考点9:堆存放对象 栈存放程序</h1><p>程序中常采用变量表示数据,变量具有名、地址、值、作用域、生存期等属性。关于变量的叙述,()是正确的。</p>
<ul>
<li>A 根据作用域规则,在函数中定义的变量只能在函数中引用</li>
<li>B 在函数中定义的变量,其生存期为整个程序执行期间</li>
<li>C 在函数中定义的变量不能与其所在函数的形参同名</li>
<li>D 在函数中定义的变量,其存储单元在内存的栈区</li>
</ul>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details>

<p>这里主要说明D为什么是对的</p>
<p>首先说明栈内存和堆内存里存放的是什么</p>
<ul>
<li> 栈内存中存放函数中定义的一些基本类型的变量和对象的引用变量；</li>
<li> <strong>堆内存中存放new创建的</strong>对象和数组。</li>
</ul>
<p>简单的来说，<strong>堆主要是用来存放对象的，栈主要是用来执行程序的</strong></p>
<p>这么做是因为</p>
<ul>
<li> 栈的存取速度快，栈数据可以共享，但是栈中的数据大小和生存期必须确定，缺乏灵活性中存放一些基本类型的对象和对象句柄</li>
<li> 堆是操作系统分配给自己内存，由于从操作系统管理的内存分配，所以再分配和销毁时都需要占用时间，因此用堆的效率非常低，但是优点在于编译器不需要指导从堆里分配多少存储控件，也不需要知道存储的数据要再堆里停留多长事件，因此用堆保存数据时会得到更大的灵活性 </li>
</ul>
<p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wangbo1998/article/details/80379016">https://blog.csdn.net/wangbo1998/article/details/80379016</a></p>
<p>D选项不太严谨，如果定义的是引用类型变量，且没有通过逃逸分析，则可能会被分配到堆中，逃逸分析是jdk1.8默认开启的</p>
<p>D选项我给大家说明一下，我觉得题出的不严谨，如果方法中有引用类型的变量，那么存储是在堆中，引用在栈中</p>
<h1 id="考点10-身份证号的正则表达式"><a href="#考点10-身份证号的正则表达式" class="headerlink" title="考点10:身份证号的正则表达式"></a>考点10:身份证号的正则表达式</h1><p><strong>多选题</strong><br>关于身份证号,以下正确的正则表达式为(      )</p>
<ul>
<li>A <code>isIDCard=/^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$/;</code></li>
<li>B <code>isIDCard=/^[1-9]\d&#123;7&#125;((9\d)|(1[0-2]))(([0|1|2]\d)|3[9-1])\d&#123;3&#125;$/;</code></li>
<li>C <code>isIDCard=/^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;4&#125;$/;</code></li>
<li>D <code>isIDCard=/^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((9\d)|(1[9-2]))(([0|1|2]\d)|3[9-1])\d&#123;4&#125;$/;</code></li>
</ul>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details>

<h3 id="身份证构成"><a href="#身份证构成" class="headerlink" title="身份证构成"></a>身份证构成</h3><p>15位身份证的构成：六位出生地区码+六位出身日期码+三位顺序码<br>18位身份证的构成：六位出生地区码+八位出生日期码+三位顺序码+一位校验码</p>
<p>A选项<br><strong>^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$</strong></p>
<ul>
<li><code>[1-9]\d&#123;7&#125;</code>，有8位，其中前六位是地址码，后两位是年份，00~99年。</li>
<li><code>((0\d)|(1[0-2]))</code>,有两位，表示月份，第一个括号范围位00<del>09，第二个括号的范围位10</del>12，综合得到00~12，符合月份的定义。</li>
<li><code>(([0|1|2]\d)|3[0-1])</code>,有两位，表示日期，第一个括号的范围位00<del>09或者10</del>19或者20<del>29，第2个括号的范围位30</del>31，综合得到00~31，符合月份的定义。这个其实也不严谨，例如2月份，只有28天，或29天。</li>
<li><code>\d&#123;3&#125;</code>有三位，表示顺序码</li>
</ul>
<p>B选项<br><strong>^[1-9]\d{7}((9\d)|(1[0-2]))(([0|1|2]\d)|3[9-1])\d{3}$</strong></p>
<ul>
<li><code>[1-9]\d&#123;7&#125;</code>，有8位，其中前六位是地址码，后两位是年份，00~99年。</li>
<li><code>((9\d)|(1[0-2]))</code>，有两位，表示月份，第一个括号的范围位90~99，一年只有12个月份，没有90月份，更没有99月份，B选项排除。</li>
</ul>
<p>C选项的<br><strong>^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$</strong></p>
<ul>
<li><code>[1-9]\d&#123;5&#125;</code>这六位，表示六位出生地码，<ul>
<li><strong>^<mark>[1-9]\d{5}</mark>[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$</strong></li>
</ul>
</li>
<li><code>[1-9]\d&#123;3&#125;</code>这四位，表示年<ul>
<li><strong>^[1-9]\d{5}<mark>[1-9]\d{3}</mark>((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$</strong></li>
</ul>
</li>
<li><code>((0\d)|(1[0-2]))</code>这两位表示，月份，从第一个括号匹配<code>00~09</code>。第二个括号匹配<code>10~12</code>。<ul>
<li><strong>^[1-9]\d{5}[1-9]\d{3}<mark>((0\d)|(1[0-2]))</mark>(([0|1|2]\d)|3[0-1])\d{4}$</strong></li>
<li>所以月份共计匹配范围：<code>00~12</code>符合月份00~12的定义。</li>
</ul>
</li>
<li><code>(([0|1|2]\d)|3[0-1])</code>这两位表示日期，第一个括号匹配00<del>09,10</del>19,20<del>29。第二个括号匹配30</del>31。<ul>
<li><strong>^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))<mark>(([0|1|2]\d)|3[0-1])</mark>\d{4}$</strong></li>
<li>所以日期总计匹配范围：00~31,符合日期的定义。</li>
</ul>
</li>
<li><code>\d&#123;4&#125;</code>,表示匹配三位顺序吗+一位校验码。校验码有字母，这里显然不能完全匹配，勉强认为校验码都是数字吧。<ul>
<li><strong>^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])<mark>\d{4}</mark>$</strong></li>
</ul>
</li>
</ul>
<p>D选项<br><strong>^[1-9]\d{5}[1-9]\d{3}((9\d)|(1[9-2]))(([0|1|2]\d)|3[9-1])\d{4}$</strong></p>
<ul>
<li><code>[1-9]\d&#123;5&#125;</code>,六位地址码</li>
<li><code>[1-9]\d&#123;3&#125;</code>,四位年，1000~9999</li>
<li><code>((9\d)|(1[9-2]))</code>,表示月份，<code>9\d</code>的范围位<code>90~99</code>,一年最多有12个月，没有90个月，更没有99个月。所以D选项错误。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div></div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/exam/images/wechatpay.png" alt="蓝蓝 微信">
        <span>微信</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>蓝蓝
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://lanlan2017.github.io/exam/a1973542/" title="2021年09月05日 java1">https://lanlan2017.github.io/exam/a1973542/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/exam/5eb758f5/" rel="prev" title="2021年09月04日 java">
                  <i class="fa fa-chevron-left"></i> 2021年09月04日 java
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/exam/4f99546e/" rel="next" title="2021年09月05日 java3">
                  2021年09月05日 java3 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline-comments"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蓝蓝</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">507k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">7:41</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/exam/js/comments.js"></script><script src="/exam/js/utils.js"></script><script src="/exam/js/motion.js"></script><script src="/exam/js/next-boot.js"></script><script src="/exam/js/bookmark.js"></script><script src="/exam/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/exam/js/third-party/search/local-search.js"></script>



  <script src="/exam/js/third-party/fancybox.js"></script>

  <script src="/exam/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/exam/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://lanlan2017.github.io/exam/a1973542/"}</script>
  <script src="/exam/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":null,"enable":true,"serverURL":"https://waline-test-mzjszagu6-lanlan2017.vercel.app","placeholder":"Just go go","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/exam/a1973542/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
</body>
</html>
